<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>Chunks of Bytecode · Crafting Interpreters</title>
<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta content="width=device-width, initial-scale=1" name="viewport">
<link href="https://youhogeon-meritz.github.io/style.css" rel="stylesheet" type="text/css">
<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600" rel="stylesheet" type="text/css">
<link href="https://youhogeon-meritz.github.io/image/favicon.png" rel="icon" type="image/png">


<!-- Google analytics -->

</head>
<body id="top">
<!-- <div class="scrim"></div> -->
<nav class="wide">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<div class="contents">
<h3><a href="https://youhogeon-meritz.github.io/chunks-of-bytecode.html#top"><font papago-translate="splitted"><font papago-translate="translated">바이트코드 덩어리</font></font><small>14</small></a></h3>
<ul>
<li><a href="https://youhogeon-meritz.github.io/chunks-of-bytecode.html#bytecode"><small>14.1</small><font papago-translate="splitted"><font papago-translate="translated"> 바이트코드?</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/chunks-of-bytecode.html#getting-started"><small>14.2</small><font papago-translate="splitted"><font papago-translate="translated"> 시작하기</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/chunks-of-bytecode.html#chunks-of-instructions"><small>14.3</small><font papago-translate="splitted"><font papago-translate="translated"> 지침 덩어리</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/chunks-of-bytecode.html#disassembling-chunks"><small>14.4</small><font papago-translate="splitted"><font papago-translate="translated"> 덩어리 분해하기</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/chunks-of-bytecode.html#constants"><small>14.5</small><font papago-translate="splitted"><font papago-translate="translated"> 상수</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/chunks-of-bytecode.html#line-information"><small>14.6</small><font papago-translate="splitted"><font papago-translate="translated"> 라인 정보</font></font></a></li>
<li class="divider"></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/chunks-of-bytecode.html#challenges"><font papago-translate="translated">과제들</font></a></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/chunks-of-bytecode.html#design-note"><small><font papago-translate="translated">메모</font></small><font papago-translate="splitted"><font papago-translate="translated">언어 테스트</font></font></a></li>
</ul>
<div class="prev-next">
<a class="left" href="https://youhogeon-meritz.github.io/a-bytecode-virtual-machine.html" title="바이트코드 가상 머신" papago-attr-id="1"><font papago-translate="translated">← 이전</font></a>
<a href="https://youhogeon-meritz.github.io/a-bytecode-virtual-machine.html" title="바이트코드 가상 머신" papago-attr-id="2"><font papago-translate="translated">↑ 위로</font></a>
<a class="right" href="https://youhogeon-meritz.github.io/a-virtual-machine.html" title="가상 머신" papago-attr-id="3"><font papago-translate="translated">다음 →</font></a>
</div> </div>
</nav>
<nav class="narrow">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<a class="prev" href="https://youhogeon-meritz.github.io/a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">←</a>
<a class="next" href="https://youhogeon-meritz.github.io/a-virtual-machine.html" title="A Virtual Machine">→</a>
</nav>
<div class="page">
<div class="nav-wrapper">
<nav class="floating pinned">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<div class="expandable">
<h3><a href="https://youhogeon-meritz.github.io/chunks-of-bytecode.html#top"><font papago-translate="splitted"><font papago-translate="translated">바이트코드 덩어리</font></font><small>14</small></a></h3>
<ul>
<li><a href="https://youhogeon-meritz.github.io/chunks-of-bytecode.html#bytecode"><small>14.1</small><font papago-translate="splitted"><font papago-translate="translated"> 바이트코드?</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/chunks-of-bytecode.html#getting-started"><small>14.2</small><font papago-translate="splitted"><font papago-translate="translated"> 시작하기</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/chunks-of-bytecode.html#chunks-of-instructions"><small>14.3</small><font papago-translate="splitted"><font papago-translate="translated"> 지침 덩어리</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/chunks-of-bytecode.html#disassembling-chunks"><small>14.4</small><font papago-translate="splitted"><font papago-translate="translated"> 덩어리 분해하기</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/chunks-of-bytecode.html#constants"><small>14.5</small><font papago-translate="splitted"><font papago-translate="translated"> 상수</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/chunks-of-bytecode.html#line-information"><small>14.6</small><font papago-translate="splitted"><font papago-translate="translated"> 라인 정보</font></font></a></li>
<li class="divider"></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/chunks-of-bytecode.html#challenges">Challenges</a></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/chunks-of-bytecode.html#design-note"><small>note</small><font papago-translate="splitted"><font papago-translate="translated">언어 테스트</font></font></a></li>
</ul>
<div class="prev-next">
<a class="left" href="https://youhogeon-meritz.github.io/a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">←&nbsp;Previous</a>
<a href="https://youhogeon-meritz.github.io/a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">↑&nbsp;Up</a>
<a class="right" href="https://youhogeon-meritz.github.io/a-virtual-machine.html" title="A Virtual Machine">Next&nbsp;→</a>
</div> </div>
<a id="expand-nav">≡</a>
</nav>
</div>
<article class="chapter">
<div class="number">14</div>
<h1><font papago-translate="translated">바이트코드 덩어리</font></h1>
<blockquote>
<p><font papago-translate="translated">이론에 거의 모든 시간을 투자하고 있다는 것을 알게 되면 실용적인 것에 관심을 기울이세요. 그러면 이론이 향상될 것입니다.</font><font papago-translate="translated"> 연습에 거의 모든 시간을 할애하고 있다는 것을 알게 되면 이론적인 것에 주의를 기울이세요. 그러면 연습 실력이 향상될 것입니다.</font></p>
<p><cite>Donald Knuth</cite></p>
</blockquote>
<p><font papago-translate="translated">우리는 이미 Jlox와 함께 Lox를 완전히 구현했는데, 왜 아직 책이 끝나지 않았나요?</font><font papago-translate="translated"> 그 이유 중 하나는 Jlox가 우리를 위해 많은 일을 해주기 위해 J<span name="metal">VM</span>에 의존하기 때문입니다.</font><font papago-translate="translated"> 통역사가 금속까지 어떻게 작동하는지 이해하려면, 우리가 직접 그 조각들을 만들어야 합니다.</font></p>
<aside name="metal" style="top: 508px;">
<p><font papago-translate="translated">물론, 두 번째 인터프리터는 메모리 할당과 같은 기본 사항을 위해 C 표준 라이브러리에 의존하며, C 컴파일러는 우리가 실행 중인 기본 기계 코드의 세부 사항에서 벗어날 수 있게 해줍니다.</font><font papago-translate="translated"> 그 기계 코드는 아마도 칩의 마이크로코드 측면에서 구현되었을 것입니다.</font><font papago-translate="translated"> 그리고 C 런타임은 메모리 페이지를 배포하기 위해 운영 체제에 의존합니다.</font><font papago-translate="translated"> 하지만 이 책이 당신의 책장에 들어가려면<em> 어딘가</em>에 멈춰야 합니다.</font></p>
</aside>
<p><font papago-translate="translated">jlox가 충분하지 않은 더 근본적인 이유는 너무 느리기 때문입니다.</font><font papago-translate="translated"> 트리워크 통역사는 일부 고급 선언 언어에 적합합니다.</font><font papago-translate="translated"> 하지만 범용적이고 명령형인 언어, 심지어 L<span class="em">ox</span>와 같은 "스크립트" 언어조차도<span class="em"></span> 날지 못할 것입니다.</font><font papago-translate="translated"> 이 작은 스크립트를 보세요:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">fun</span> <span class="i">fib</span>(<span class="i">n</span>) {
  <span class="k">if</span> (<span class="i">n</span> &lt; <span class="n">2</span>) <span class="k">return</span> <span class="i">n</span>;
  <span class="k">return</span> <span class="i">fib</span>(<span class="i">n</span> - <span class="n">1</span>) + <span class="i">fib</span>(<span class="i">n</span> - <span class="n">2</span>);<span name="fib"> </span>
}

<span class="k">var</span> <span class="i">before</span> = <span class="i">clock</span>();
<span class="k">print</span> <span class="i">fib</span>(<span class="n">40</span>);
<span class="k">var</span> <span class="i">after</span> = <span class="i">clock</span>();
<span class="k">print</span> <span class="i">after</span> - <span class="i">before</span>;
</pre></div>
<aside name="fib" style="top: 763px;">
<p><font papago-translate="translated">이것은 실제로 피보나치 수를 계산하는 데 있어 코믹하게 비효율적인 방법입니다.</font><font papago-translate="translated"> 우리의 목표는<em> 통역</em>사가 얼마나 빨리 실행되는지 보는 것이지, 프로그램을 얼마나 빨리 작성할 수 있는지 보는 것이 아닙니다.</font><font papago-translate="translated"> 많은 작업을 수행하는 느린 프로그램, 즉 무득점이든 아니든 간에,<span class="em"></span><span class="em"></span> 이를 위한 좋은 시험 사례입니다.</font></p>
</aside>
<p><font papago-translate="translated">제 노트북에서는 실행하는 데 약 72초가 걸립니다.</font><font papago-translate="translated"> 동등한 C 프로그램은 0.5초 만에 끝납니다.</font><font papago-translate="translated"> 동적으로 입력된 스크립팅 언어는 수동 메모리 관리를 통해 정적으로 입력된 언어만큼 빠르지는 않겠지만<em>, 두 자릿수</em> 이상 느리게 설정할 필요는 없습니다.</font></p>
<p><font papago-translate="translated">우리는 Jlox를 프로파일러로 실행하여 핫스팟을 조정하고 조정할 수 있지만, 그것만으로도 충분합니다.</font><font papago-translate="translated"> 실행 모델인 AST를 걷는 것은 근본적으로 잘못된<span class="em"></span><span class="em"></span> 설계입니다.</font><font papago-translate="translated"> 우리가 원하는 성능에 맞게 AMC Gremlin을 SR-71 블랙버드로 연마하는 것만큼 미세하게 최적화할 수는 없습니다.</font></p>
<p><font papago-translate="translated">핵심 모델을 재고해야 합니다.</font><font papago-translate="translated"> 이 장에서는 해당 모델인 바이트코드를 소개하고 새로운 인터프리터인 clox를 시작합니다.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/chunks-of-bytecode.html#bytecode" id="bytecode"><small><font papago-translate="translated">14 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">바이트코드?</font></font></a></h2>
<p><font papago-translate="translated">공학에서는 절충안이 없는 선택지가 거의 없습니다.</font><font papago-translate="translated"> 바이트코드를 사용하는 이유를 가장 잘 이해하기 위해 몇 가지 대안과 비교해 보겠습니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/chunks-of-bytecode.html#why-not-walk-the-ast" id="why-not-walk-the-ast"><small><font papago-translate="translated">14 . 1 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">왜 AST를 걷지 않나요?</font></font></a></h3>
<p><font papago-translate="translated">기존 통역사는 몇 가지 방법이 있습니다:</font></p>
<ul>
<li>
<p><font papago-translate="translated">먼저, 우리는 이미 그것을 썼습니다.</font><font papago-translate="translated"> 완료되었습니다.</font><font papago-translate="translated"> 그리고 그것이 이루어지는 주된 이유는 이 스타일의 통역사<em>가 정말로 구현하기 쉽</em>기 때문입니다.</font><font papago-translate="translated"> 코드의 런타임 표현은 구문에 직접 매핑됩니다.</font><font papago-translate="translated"> 파서에서 런타임에 필요한 데이터 구조로 이동하는 것은 사실상 쉽습니다.</font></p>
</li>
<li>
<p><font papago-translate="translated"><em>휴대가 간편</em>합니다.</font><font papago-translate="translated"> 현재 우리의 인터프리터는 Java로 작성되었으며 Java가 지원하는 모든 플랫폼에서 실행됩니다.</font><font papago-translate="translated"> 우리는 동일한 접근 방식을 사용하여 C로 새로운 구현을 작성하고, 기본적으로 태양 아래의 모든 플랫폼에서 우리의 언어를 컴파일하고 실행할 수 있습니다.</font></p>
</li>
</ul>
<p><font papago-translate="splitted"><font papago-translate="translated">이것들이 진정한 장점입니다.</font><font papago-translate="translated"> 하지만<em> 한편으로는 메모리 효율적이지 않습니다</em>.</font><font papago-translate="translated"> 각 구문은 AST 노드가 됩니다.</font><font papago-translate="translated"> 작은 Lox 표현은 다음과 같습니다 </font></font><code translate="no">1 + 2</code><font papago-translate="splitted"><font papago-translate="translated"> 는 많은 포인터를 사이에 두고 여러 개의 객체로 변합니다:</font></font></p>
<p><span name="header"></span></p>
<aside name="header" style="top: 1934px;">
<p><font papago-translate="translated">"(헤더)" 부분은 Java 가상 머신이 메모리 관리를 지원하고 객체의 유형을 저장하는 데 사용하는 부기 정보입니다.</font><font papago-translate="translated"> 그것들도 공간을 차지합니다!</font></p>
</aside><img alt="The tree of Java objects created to represent '1 + 2'." src="https://youhogeon-meritz.github.io/image/chunks-of-bytecode/ast.png">
<p><font papago-translate="translated">각 포인터는 객체에 32비트 또는 64비트의 오버헤드를 추가합니다.</font><font papago-translate="translated"> 더 나쁜 것은 느슨하게 연결된 객체 웹에 데이터를 힙에 뿌리는 것이<span name="locality"><em> 공간적 지역성</em></span>에 나쁜 영향을 미친다는 것입니다.</font></p>
<aside name="locality" style="top: 2381px;">
<p><font papago-translate="translated">제 첫 번째 책<em>인 게임 프로그래밍 패턴</em>에서 이 정확한 문제<a href="http://gameprogrammingpatterns.com/data-locality.html">에</a> 대한<a href="http://gameprogrammingpatterns.com/data-locality.html"> 전체 챕터</a>를 작성했습니다.</font></p>
</aside>
<p><font papago-translate="translated">최신 CPU는 RAM에서 데이터를 꺼낼 수 있는 속도보다 훨씬 빠르게 처리합니다.</font><font papago-translate="translated"> 이를 보완하기 위해 칩에는 여러 계층의 캐싱이 있습니다.</font><font papago-translate="translated"> 필요한 메모리가 이미 캐시에 있는 경우 더 빠르게 로드할 수 있습니다.</font><font papago-translate="translated"> 우리는 100<em>배</em> 이상 빠르게 이야기하고 있습니다.</font></p>
<p><font papago-translate="translated">데이터가 그 캐시에 어떻게 들어가나요?</font><font papago-translate="translated"> 기계가 당신을 위해 물건을 추측적으로 채워줍니다.</font><font papago-translate="translated"> 그 휴리스틱은 꽤 간단합니다.</font><font papago-translate="translated"> CPU는 RAM에서 약간의 데이터를 읽을 때마다 인접한 바이트 묶음을 가져와 캐시에 넣습니다.</font></p>
<p><font papago-translate="translated">다음에 우리 프로그램이 캐시 라인 안에 있을 만큼 가까운 데이터를 요청하면, 우리의 CPU는 공장에서 잘 기름칠된 컨베이어 벨트처럼 작동합니다.</font><font papago-translate="translated"> 우리는<em> 이것</em>을<em> 정말</em>로 활용하고 싶습니다.</font><font papago-translate="translated"> 캐시를 효과적으로 사용하려면 메모리에서 코드를 표현하는 방식이 읽기처럼 조밀하고 순서가 정해져야 합니다.</font></p>
<p><font papago-translate="translated">이제 저 나무를 올려다 보세요.</font><font papago-translate="translated"> 그 하위 객체<span name="anywhere"><em>들은 어디에나</em></span> 있을 수 있습니다.</font><font papago-translate="translated"> 트리워커가 자식 노드에 대한 참조를 따르는 모든 단계는 캐시의 경계를 벗어나 새로운 데이터 덩어리가 RAM에서 빨아들일 때까지 CPU를 강제로 정지시킬 수 있습니다.</font><font papago-translate="translated"> 포인터 필드와 객체 헤더가 모두 있는 트리 노드<em>의 오버헤드</em>만으로도 객체가 서로 멀어지고 캐시 밖으로 밀려나는 경향이 있습니다.</font></p>
<aside name="anywhere" style="top: 2789px;">
<p><font papago-translate="translated">파서가 처음 물건을 생산할 때 우연히 순차 메모리에 할당되었다고 해도, 몇 번의 쓰레기 수거 작업을 거친 후에는 물건들이 메모리 속에서 이동할 수 있어 어디<span class="em"></span><span class="em"></span>에 있을지 알 수 없습니다.</font></p>
</aside>
<p><font papago-translate="translated">우리의 AST 워커는 인터페이스 디스패치와 방문자 패턴에 대한 다른 오버헤드도 가지고 있지만, 로컬리티 문제만으로도 더 나은 코드 표현을 정당화할 수 있습니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/chunks-of-bytecode.html#why-not-compile-to-native-code" id="why-not-compile-to-native-code"><small><font papago-translate="translated">14 . 1 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">왜 네이티브 코드로 컴파일하지 않나요?</font></font></a></h3>
<p><font papago-translate="translated"><em>정말</em> 빠르게 진행하고 싶다면, 그 모든 간접적인 요소들을 제거하고 싶을 것입니다.</font><font papago-translate="translated"> 바로 금속까지.</font><font papago-translate="translated"> 기계 코드.</font><font papago-translate="translated"> 심지어 빠르게<em> 들리기</em>도 합니다.</font><font papago-translate="translated"> <em>기계 코드.</em></font></p>
<p><font papago-translate="translated">칩이 지원하는 네이티브 명령어 세트에 직접 컴파일하는 것이 가장 빠른 언어들이 하는 일입니다.</font><font papago-translate="translated"> 엔지니어들이 실제로 기계 코드로 프로그램을<span name="hand"> 수작업으로 작성</span>하던 초기 시절부터 네이티브 코드를 타겟팅하는 것이 가장 효율적인 옵션이었습니다.</font></p>
<aside name="hand" style="top: 3293px;">
<p><font papago-translate="translated">네, 실제로 기계 코드를 수작업으로 작성했습니다.</font><font papago-translate="translated"> 펀치 카드에.</font><font papago-translate="translated"> <em>아마도 주먹</em>으로 주먹을 날린 것으로 추정됩니다.</font></p>
</aside>
<p><font papago-translate="translated">기계 코드나 조금 더 인간의 취향에 맞는 사촌 어셈블리 코드를 한 번도 작성해 본 적이 없다면, 가장 부드러운 소개를 드리겠습니다.</font><font papago-translate="translated"> 네이티브 코드는 바이너리로 직접 인코딩된 밀집된 일련의 연산입니다.</font><font papago-translate="translated"> 각 명령어의 길이는 1바이트에서 몇 바이트 사이이며, 거의 놀라울 정도로 낮은 수준입니다.</font><font papago-translate="translated"> "이 주소에서 이 레지스터로 값을 이동합니다." "이 두 레지스터의 정수를 추가합니다."</font><font papago-translate="translated"> 그런 것들.</font></p>
<p><font papago-translate="translated">CPU는 명령어를 차례대로 처리하여 각 명령어를 디코딩하고 실행합니다.</font><font papago-translate="translated"> 우리의 AST와 같은 트리 구조는 없으며, 제어 흐름은 코드의 한 지점에서 다른 지점으로 직접 이동하여 처리됩니다.</font><font papago-translate="translated"> 간접적이지 않고, 오버헤드도 없으며, 불필요하게 건너뛰거나 포인터를 쫓는 일도 없습니다.</font></p>
<p><font papago-translate="translated">번개처럼 빠르지만, 그 성능에는 대가가 따릅니다.</font><font papago-translate="translated"> 우선, 네이티브 코드로 컴파일하는 것은 쉽지 않습니다.</font><font papago-translate="translated"> 오늘날 널리 사용되는 대부분의 칩은 수십 년에 걸쳐 축적된 수많은 명령어를 가진 방대한 비잔틴 아키텍처를 가지고 있습니다.</font><font papago-translate="translated"> 정교한 레지스터 할당, 파이프라이닝, 그리고 명령 스케줄링이 필요합니다.</font></p>
<p><font papago-translate="translated"><span name="back">물론 휴대성</span>을 포기했습니다.</font><font papago-translate="translated"> 몇 년 동안 어떤 아키텍처를 마스터하는 데 시간을 투자하면 여전히 여러 인기 있는 교육 세트<em> 중 하나</em>만 배울 수 있습니다.</font><font papago-translate="translated"> 모든 언어를 익히려면 모든 명령어 세트를 배우고 각 명령어에 대해 별도의 백엔드를 작성해야 합니다.</font></p>
<aside name="back" style="top: 3773px;">
<p><font papago-translate="translated">상황이 완전히 심각하지는 않습니다.</font><font papago-translate="translated"> 잘 설계된 컴파일러를 사용하면 프론트엔드를 공유할 수 있으며, 대부분의 중간 계층 최적화는 지원하는 다양한 아키텍처를 통해 이루어집니다.</font><font papago-translate="translated"> 주로 코드 생성과 명령어 선택에 관한 몇 가지 세부 사항을 매번 새로 작성해야 합니다.</font></p>
<p><font papago-translate="translated">L<a href="https://llvm.org/">LVM</a> 프로젝트는 이 중 일부를 즉시 제공합니다.</font><font papago-translate="translated"> 컴파일러가 LLVM만의 특별한 중간 언어를 출력하면, LLVM은 이를 여러 아키텍처의 네이티브 코드로 컴파일합니다.</font></p>
</aside>
<h3><a href="https://youhogeon-meritz.github.io/chunks-of-bytecode.html#what-is-bytecode" id="what-is-bytecode"><small><font papago-translate="translated">14 . 1 . 3</font></small><font papago-translate="splitted"><font papago-translate="translated">바이트코드란 무엇인가요?</font></font></a></h3>
<p><font papago-translate="translated">그 두 가지 점을 마음속 깊이 새겨보세요.</font><font papago-translate="translated"> 한쪽 끝에 있는 트리워크 통역사는 간단하고 휴대하기 쉬우며 느립니다.</font><font papago-translate="translated"> 반면에, 네이티브 코드는 복잡하고 플랫폼에 특화되어 있지만 빠릅니다.</font><font papago-translate="translated"> 바이트코드가 가운데에 위치합니다.</font><font papago-translate="translated"> 이<span class="em"></span> 책에서는 조립 코드로 손을 더럽히지 않도록 나무를 걷는 사람의 휴대성을 유지합니다.</font><font papago-translate="translated"> 성능 향상을 얻기 위해 약간의 단순함을 희생하지만, 완전히<em></em> 네이티브로 전환하는 것만큼 빠르지는 않습니다.</font></p>
<p><font papago-translate="translated">구조적으로 바이트코드는 기계 코드와 유사합니다.</font><font papago-translate="translated"> 이진 명령어의 조밀하고 선형적인 순서입니다.</font><font papago-translate="translated"> 그것은 오버헤드를 낮게 유지하고 캐시와 잘 어울립니다.</font><font papago-translate="translated"> 하지만 실제 칩보다 훨씬 간단하고 높은 수준의 명령어 세트입니다. (많은 바이트코드 형식에서 각 명령어는 단 한 바이트 길이이므로 "바이트코드")</font></p>
<p><font papago-translate="translated">어떤 소스 언어로 네이티브 컴파일러를 작성하고 있는데, 가장 쉽게 타겟팅할 수 있는 아키텍처를 정의할 수 있는 카르테 블랑쉬가 주어졌다고 상상해 보세요.</font><font papago-translate="translated"> 바이트코드는 그런 식입니다.</font><font papago-translate="translated"> 컴파일러 작가로서의 삶을 더 쉽게 만들어주는 이상적인 판타지 명령어 세트입니다.</font></p>
<p><font papago-translate="translated">물론 판타지 아키텍처의 문제는 존재하지 않는다는 것입니다.</font><font papago-translate="translated"> 우리는 바이트코드 명령어를 한<span class="em"></span> 번에 하나씩 해석하는 소프트웨어로 작성된 시뮬레이션 칩<em>인 에뮬레이터</em>를 작성하여 이를 해결합니다.</font><font papago-translate="translated"> <em>가상 머신(VM)</em>입니다.</font></p>
<p><font papago-translate="translated">그 에뮬레이션 레이어는<span name="p-code"> 오버헤드</span>를 추가하는데, 이는 바이트코드가 네이티브 코드보다 느린 주요 이유입니다.</font><font papago-translate="translated"> 하지만 그 대가로, 그것은 우리에게 휴대성을 제공합니다.</font><font papago-translate="translated"> 우리가 신경 쓰는 모든 기계에서 이미 지원되는 C와 같은 언어로 VM을 작성하면, 원하는 하드웨어 위에 에뮬레이터를 실행할 수 있습니다.</font></p>
<aside name="p-code" style="top: 4541px;">
<p><font papago-translate="translated">최초의 바이트코드 형식 중 하나는 니클라우스 워스의 파스칼 언어를 위해 개발된<a href="https://en.wikipedia.org/wiki/P-code_machine"> p-코드</a>였습니다.</font><font papago-translate="translated"> 15MHz에서 실행되는 PDP-11은 가상 머신을 에뮬레이트하는 데 드는 오버헤드를 감당할 수 없다고 생각할 수도 있습니다.</font><font papago-translate="translated"> 하지만 그 당시 컴퓨터는 캄브리아기 시대에 폭발적으로 발전했고, 매일 새로운 건축물이 등장했습니다.</font><font papago-translate="translated"> 최신 칩을 따라잡는 것은 각각의 칩에서 최대한의 성능을 발휘하는 것 이상의 가치가 있었습니다.</font><font papago-translate="translated"> 그래서 p-코드의 "p"는 "파스칼"을 의미하지 않고 "휴대용"을 의미합니다.</font></p>
</aside>
<p><font papago-translate="translated">이것이 우리가 새로운 통역사인 clox와 함께 갈 길입니다.</font><font papago-translate="translated"> 우리는 Python, Ruby, Lua, OCaml, Erlang 등의 주요 구현 방식을 따라갈 것입니다.</font><font papago-translate="translated"> 여러 면에서 우리 VM의 설계는 이전 인터프리터의 구조와 병행할 것입니다:</font></p>
<p><img alt="Phases of the two
implementations. jlox is Parser to Syntax Trees to Interpreter. clox is Compiler
to Bytecode to Virtual Machine." src="https://youhogeon-meritz.github.io/image/chunks-of-bytecode/phases.png"></p>
<p><font papago-translate="translated">물론 단계를 엄격하게 순서대로 구현하지는 않을 것입니다.</font><font papago-translate="translated"> 이전 통역사처럼, 우리는 한 번에 하나의 언어 기능을 구현하는 과정을 반복할 것입니다.</font><font papago-translate="translated"> 이 장에서는 애플리케이션의 골격을 정리하고 바이트코드 덩어리를 저장하고 표현하는 데 필요한 데이터 구조를 만들 것입니다.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/chunks-of-bytecode.html#getting-started" id="getting-started"><small><font papago-translate="translated">14 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">시작하기</font></font></a></h2>
<p><font papago-translate="splitted"><font papago-translate="translated">어디서부터 시작해야 할지 모르겠지만 </font></font><code translate="no">main()</code><font papago-translate="splitted"><font papago-translate="translated">? 신뢰할 수 있는 텍스트 편집기<span name="ready">를 실행</span>하고 타이핑을 시작하세요.</font></font></p>
<aside name="ready" style="top: 5284px;">
<p><font papago-translate="translated">지금이 스트레칭을 하거나 손가락 마디를 부러뜨리기에 좋은 시기입니다.</font><font papago-translate="translated"> 작은 몽타주 음악도 나쁘지 않을 것입니다.</font></p>
</aside>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">주요.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 새 파일 만들기</font></font></div>
<pre translate="no"><span class="a">#include "common.h"</span>

<span class="t">int</span> <span class="i">main</span>(<span class="t">int</span> <span class="i">argc</span>, <span class="k">const</span> <span class="t">char</span>* <span class="i">argv</span>[]) {
  <span class="k">return</span> <span class="n">0</span>;
}
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, create new file</div>
<p><font papago-translate="translated">이 작은 씨앗에서 우리는 전체 VM을 키울 것입니다.</font><font papago-translate="translated"> C가 우리에게 제공하는 것이 너무 적기 때문에, 먼저 토양을 수정하는 데 시간을 좀 써야 합니다.</font><font papago-translate="translated"> 그 중 일부는 이 헤더에 들어갑니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">일반적인.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 새 파일 만들기</font></font></div>
<pre translate="no"><span class="a">#ifndef clox_common_h</span>
<span class="a">#define clox_common_h</span>

<span class="a">#include &lt;stdbool.h&gt;</span>
<span class="a">#include &lt;stddef.h&gt;</span>
<span class="a">#include &lt;stdint.h&gt;</span>

<span class="a">#endif</span>
</pre></div>
<div class="source-file-narrow"><em>common.h</em>, create new file</div>
<p><font papago-translate="splitted"><font papago-translate="translated">통역사 전반에 걸쳐 사용할 몇 가지 유형과 상수가 있으며, 이는 이를 배치하기에 편리한 장소입니다.</font><font papago-translate="translated"> 지금은 존경받는 분들입니다 </font></font><code translate="no">NULL</code><font papago-translate="splitted"><font papago-translate="translated">, </font></font><code translate="no">size_t</code><font papago-translate="splitted"><font papago-translate="translated">, 멋진 C99 부울 </font></font><code translate="no">bool</code><font papago-translate="splitted"><font papago-translate="translated">, 그리고 명시적 크기의 정수<span class="em"></span> 타입—</font></font><code translate="no">uint8_t</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고 친구들.</font></font></p>
<h2><a href="https://youhogeon-meritz.github.io/chunks-of-bytecode.html#chunks-of-instructions" id="chunks-of-instructions"><small><font papago-translate="translated">14 . 3</font></small><font papago-translate="splitted"><font papago-translate="translated">지침 덩어리</font></font></a></h2>
<p><font papago-translate="translated">다음으로, 코드 표현을 정의할 모듈이 필요합니다.</font><font papago-translate="translated"> 바이트코드 시퀀스를 참조하기 위해 "chunk"를 사용하고 있으니, 그 모듈의 공식 명칭으로 만들어 보겠습니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">청크.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 새 파일 만들기</font></font></div>
<pre translate="no"><span class="a">#ifndef clox_chunk_h</span>
<span class="a">#define clox_chunk_h</span>

<span class="a">#include "common.h"</span>

<span class="a">#endif</span>
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, create new file</div>
<p><font papago-translate="translated">바이트코드 형식에서는 각 명령어가 1바이트<strong> 연산 코드</strong>(일반적으로<strong> opcode</strong>로 줄임)를 가지고 있습니다.</font><font papago-translate="translated"> 그 숫자는 우리가 다루고 있는 명령어의 종류를 제어합니다 — 덧셈, 뺄셈, 변수 찾기 등<span class="em"></span>을 포함합니다.</font><font papago-translate="translated"> 여기서 이를 정의합니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#include "common.h"
</pre><div class="source-file"><em><font papago-translate="translated">청크.h</font></em></div>
<pre class="insert" translate="no">
<span class="k">typedef</span> <span class="k">enum</span> {
  <span class="a">OP_RETURN</span>,
} <span class="t">OpCode</span>;
</pre><pre class="insert-after" translate="no">
#endif
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em></div>
<p><font papago-translate="splitted"><font papago-translate="translated">지금은 한 가지 지침으로 시작합니다, </font></font><code translate="no">OP_RETURN</code><font papago-translate="splitted"><font papago-translate="translated">. 완전한 기능을 갖춘 VM이 있을 때, 이 명령어는 "현재 기능에서 반환"을 의미할 것입니다.</font><font papago-translate="translated"> 아직 이것이 정확히 유용하지 않다는 것을 인정하지만, 우리는 어딘가에서 시작해야 합니다. 이는 나중에 알게 될 이유로 특히 간단한 지침입니다.</font></font></p>
<h3><a href="https://youhogeon-meritz.github.io/chunks-of-bytecode.html#a-dynamic-array-of-instructions" id="a-dynamic-array-of-instructions"><small><font papago-translate="translated">14 . 3 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">동적인 지침 배열</font></font></a></h3>
<p><font papago-translate="translated">바이트코드는 일련의 지침입니다.</font><font papago-translate="translated"> 결국 지침과 함께 다른 데이터를 저장할 예정이니, 모든 것을 보관할 수 있는 구조를 만들어 보겠습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">} OpCode;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">청크.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> enum O<em>pCode</em> 후에 추가</font></font></div>
<pre class="insert" translate="no">
<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">uint8_t</span>* <span class="i">code</span>;
} <span class="t">Chunk</span>;
</pre><pre class="insert-after" translate="no">
#endif
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, add after enum <em>OpCode</em></div>
<p><font papago-translate="translated">현재로서는 단순히 바이트 배열 주위에 포장된 것일 뿐입니다.</font><font papago-translate="translated"> 청크를 컴파일하기 전에 배열이 얼마나 커야 하는지 모르기 때문에 동적이어야 합니다.</font><font papago-translate="translated"> 동적 배열은 제가 가장 좋아하는 데이터 구조 중 하나입니다.</font><font papago-translate="translated"> 바닐라<span name="flavor">가</span> 제가 가장 좋아하는 아이스크림<span name="flavor"> 맛</span>이라고 주장하는 것 같지만, 제 말을 들어보세요.</font><font papago-translate="translated"> 동적 배열은 다음을 제공합니다:</font></p>
<aside name="flavor" style="top: 7000px;">
<p><font papago-translate="translated">버터 피칸은 사실 제가 가장 좋아하는 음식입니다.</font></p>
</aside>
<ul>
<li>
<p><font papago-translate="translated">캐시 친화적이고 밀도가 높은 스토리지</font></p>
</li>
<li>
<p><font papago-translate="translated">상수 시간 인덱스 요소 조회</font></p>
</li>
<li>
<p><font papago-translate="translated">배열 끝에 일정 시간이 추가됨</font></p>
</li>
</ul>
<p><font papago-translate="translated">이러한 기능들이 바로 우리가 자바의 ArrayList 클래스를 가장하여 Jlox에서 항상 동적 배열을 사용한 이유입니다.</font><font papago-translate="translated"> 이제 C에 도착했으니, 우리는 스스로 굴릴 수 있게 되었습니다.</font><font papago-translate="translated"> 동적 배열에 녹슬었다면 아이디어는 꽤 간단합니다.</font><font papago-translate="translated"> 배열 자체 외에도 두 가지 숫자를 유지합니다: 우리가 할당한 배열의 요소 수("용량")와 할당된 항목 중 실제로 사용 중인 항목 수("카운트")입니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">typedef struct {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">청크.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 구조<em> 청크</em>에서</font></font></div>
<pre class="insert" translate="no">  <span class="t">int</span> <span class="i">count</span>;
  <span class="t">int</span> <span class="i">capacity</span>;
</pre><pre class="insert-after" translate="no">  uint8_t* code;
} Chunk;
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in struct <em>Chunk</em></div>
<p><font papago-translate="translated">요소를 추가할 때, 카운트가 용량보다 작으면 배열에 이미 사용 가능한 공간이 있습니다.</font><font papago-translate="translated"> 우리는 새로운 요소를 바로 거기에 저장하고 카운트를 범핑합니다.</font></p>
<p><img alt="Storing an element in an
array that has enough capacity." src="https://youhogeon-meritz.github.io/image/chunks-of-bytecode/insert.png"></p>
<p><font papago-translate="translated">여분의 용량이 없다면, 그 과정이 조금 더 필요합니다.</font></p>
<p><img alt="Growing the dynamic array
before storing an element." class="wide" src="https://youhogeon-meritz.github.io/image/chunks-of-bytecode/grow.png"></p>
<ol>
<li><font papago-translate="translated">더 많은 용량으로 새 배열<span name="amortized">을 할당합니다.</span></font></li>
<li><font papago-translate="translated">기존 요소를 기존 배열에서 새 배열로 복사합니다.</font></li>
<li><font papago-translate="splitted"><font papago-translate="translated">새 것 저장 </font></font><code translate="no">capacity</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></li>
<li><font papago-translate="translated">이전 배열을 삭제합니다.</font></li>
<li><font papago-translate="splitted"><font papago-translate="translated">갱신하다 </font></font><code translate="no">code</code><font papago-translate="splitted"><font papago-translate="translated"> 새 배열을 가리키기 위해.</font></font></li>
<li><font papago-translate="translated">이제 공간이 있으니 요소를 새 배열에 저장하세요.</font></li>
<li><font papago-translate="splitted"><font papago-translate="translated">업데이트 </font></font><code translate="no">count</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></li>
</ol>
<aside name="amortized" style="top: 8285px;">
<p><font papago-translate="translated">배열을 확장할 때 기존 요소를 복사하면 위에서 말한 것처럼 O<em>(1</em>)이 아닌 O<em>(n)</em> 요소를 추가하는 것처럼 보입니다.</font><font papago-translate="translated"> 그러나 이 복사 단계는<em></em> 일부 부록에서만 수행해야 합니다.</font><font papago-translate="translated"> 대부분의 경우 이미 여분의 용량이 있으므로 복사할 필요가 없습니다.</font></p>
<p><font papago-translate="translated">이것이 어떻게 작동하는지 이해하기 위해서<a href="https://en.wikipedia.org/wiki/Amortized_analysis"><strong>는 상각 분석</strong></a>이 필요합니다.</font><font papago-translate="translated"> 이는 배열<em></em>을 현재 크기의 배수로 확장하는 한, 일련의 부록 비용을 평균할 때 각 부록이 O<em>(</em>1)임을 보여줍니다.</font></p>
</aside>
<p><font papago-translate="translated">우리의 구조가 준비되었으니, 이와 함께 작동할 기능을 구현해 보겠습니다.</font><font papago-translate="translated"> C에는 생성자가 없으므로 새 청크를 초기화하는 함수를 선언합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">} Chunk;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">청크.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 구조<em> 청크</em> 뒤에 추가</font></font></div>
<pre class="insert" translate="no">
<span class="t">void</span> <span class="i">initChunk</span>(<span class="t">Chunk</span>* <span class="i">chunk</span>);
</pre><pre class="insert-after" translate="no">
#endif
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, add after struct <em>Chunk</em></div>
<p><font papago-translate="translated">그리고 그렇게 구현하세요:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">청크</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 새 파일 만들기</font></font></div>
<pre translate="no"><span class="a">#include &lt;stdlib.h&gt;</span>

<span class="a">#include "chunk.h"</span>

<span class="t">void</span> <span class="i">initChunk</span>(<span class="t">Chunk</span>* <span class="i">chunk</span>) {
  <span class="i">chunk</span>-&gt;<span class="i">count</span> = <span class="n">0</span>;
  <span class="i">chunk</span>-&gt;<span class="i">capacity</span> = <span class="n">0</span>;
  <span class="i">chunk</span>-&gt;<span class="i">code</span> = <span class="a">NULL</span>;
}
</pre></div>
<div class="source-file-narrow"><em>chunk.c</em>, create new file</div>
<p><font papago-translate="translated">동적 배열은 완전히 비어 있는 상태로 시작합니다.</font><font papago-translate="translated"> 아직 원시 배열을 할당하지도 않습니다.</font><font papago-translate="translated"> 청크 끝에 바이트를 추가하려면 새로운 함수를 사용합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">void initChunk(Chunk* chunk);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">청크.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>init</em>Ch<em>unk</em>() 뒤에 추가</font></font></div>
<pre class="insert" translate="no"><span class="t">void</span> <span class="i">writeChunk</span>(<span class="t">Chunk</span>* <span class="i">chunk</span>, <span class="t">uint8_t</span> <span class="i">byte</span>);
</pre><pre class="insert-after" translate="no">
#endif
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, add after <em>initChunk</em>()</div>
<p><font papago-translate="translated">여기서 흥미로운 작업이 일어납니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">청크</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>init</em>Ch<em>unk</em>() 뒤에 추가</font></font></div>
<pre translate="no"><span class="t">void</span> <span class="i">writeChunk</span>(<span class="t">Chunk</span>* <span class="i">chunk</span>, <span class="t">uint8_t</span> <span class="i">byte</span>) {
  <span class="k">if</span> (<span class="i">chunk</span>-&gt;<span class="i">capacity</span> &lt; <span class="i">chunk</span>-&gt;<span class="i">count</span> + <span class="n">1</span>) {
    <span class="t">int</span> <span class="i">oldCapacity</span> = <span class="i">chunk</span>-&gt;<span class="i">capacity</span>;
    <span class="i">chunk</span>-&gt;<span class="i">capacity</span> = <span class="a">GROW_CAPACITY</span>(<span class="i">oldCapacity</span>);
    <span class="i">chunk</span>-&gt;<span class="i">code</span> = <span class="a">GROW_ARRAY</span>(<span class="t">uint8_t</span>, <span class="i">chunk</span>-&gt;<span class="i">code</span>,
        <span class="i">oldCapacity</span>, <span class="i">chunk</span>-&gt;<span class="i">capacity</span>);
  }

  <span class="i">chunk</span>-&gt;<span class="i">code</span>[<span class="i">chunk</span>-&gt;<span class="i">count</span>] = <span class="i">byte</span>;
  <span class="i">chunk</span>-&gt;<span class="i">count</span>++;
}
</pre></div>
<div class="source-file-narrow"><em>chunk.c</em>, add after <em>initChunk</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">가장 먼저 해야 할 일은 현재 배열에 이미 새 바이트를 수용할 수 있는 용량이 있는지 확인하는 것입니다.</font><font papago-translate="translated"> 만약 그렇지 않다면, 먼저 공간을 확보하기 위해 배열을 확장해야 합니다.</font><font papago-translate="translated"> (우리는 배열이 다음과 같을 때 첫 번째 쓰기에서도 이 경우를 기록합니다 </font></font><code translate="no">NULL</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">capacity</code><font papago-translate="splitted"><font papago-translate="translated"> 0.)</font></font></p>
<p><font papago-translate="translated">배열을 확장하려면 먼저 새로운 용량을 계산하고 배열을 해당 크기로 확장합니다.</font><font papago-translate="translated"> 저수준 메모리 연산은 모두 새로운 모듈에서 정의됩니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#include "chunk.h"
</pre><div class="source-file"><em><font papago-translate="translated">청크</font></em></div>
<pre class="insert" translate="no"><span class="a">#include "memory.h"</span>
</pre><pre class="insert-after" translate="no">
void initChunk(Chunk* chunk) {
</pre></div>
<div class="source-file-narrow"><em>chunk.c</em></div>
<p><font papago-translate="translated">이 정도면 시작할 수 있습니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">기억.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 새 파일 만들기</font></font></div>
<pre translate="no"><span class="a">#ifndef clox_memory_h</span>
<span class="a">#define clox_memory_h</span>

<span class="a">#include "common.h"</span>

<span class="a">#define GROW_CAPACITY(capacity) \</span>
<span class="a">    ((capacity) &lt; 8 ? 8 : (capacity) * 2)</span>

<span class="a">#endif</span>
</pre></div>
<div class="source-file-narrow"><em>memory.h</em>, create new file</div>
<p><font papago-translate="translated">이 매크로는 주어진 현재 용량을 기반으로 새 용량을 계산합니다.</font><font papago-translate="translated"> 우리가 원하는 성능을 얻기 위해 중요한 부분은 기존 크기에<em> 따라 확장된다는</em> 것입니다.</font><font papago-translate="translated"> 우리는 두 배로 성장하는데, 이는 꽤 흔한 일입니다. 1.5배도 또 다른 일반적인 선택입니다.</font></p>
<p><font papago-translate="translated">현재 용량이 0일 때도 처리합니다.</font><font papago-translate="translated"> 이 경우 1개에서 시작하는 대신 8개의 요소로 바로 이동합니다.</font><font papago-translate="translated"> 이는 배열이 매우 작을 때 약간의 추가 메모리 이탈<span name="profile">을 방지</span>하며, 아주 작은 청크에 몇 바이트를 낭비하는 대가를 치르게 합니다.</font></p>
<aside name="profile" style="top: 10109px;">
<p><font papago-translate="translated">저는 책을 위해 숫자 8을 다소 자의적으로 선택했습니다.</font><font papago-translate="translated"> 대부분의 동적 배열 구현에는 이와 같은 최소 임계값이 있습니다.</font><font papago-translate="translated"> 이 값을 선택하는 올바른 방법은 실제 사용량과 비교하여 어떤 상수가 추가 성장과 낭비되는 공간 사이에서 최고의 성능 균형을 이루는지 확인하는 것입니다.</font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">원하는 용량을 알게 되면 다음을 사용하여 해당 크기로 배열을 만들거나 성장시킵니다 </font></font><code translate="no">GROW_ARRAY()</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#define GROW_CAPACITY(capacity) \
    ((capacity) &lt; 8 ? 8 : (capacity) * 2)
</pre><div class="source-file"><em><font papago-translate="translated">기억.h</font></em></div>
<pre class="insert" translate="no">
<span class="a">#define GROW_ARRAY(type, pointer, oldCount, newCount) \</span>
<span class="a">    (type*)reallocate(pointer, sizeof(type) * (oldCount), \</span>
<span class="a">        sizeof(type) * (newCount))</span>

<span class="t">void</span>* <span class="i">reallocate</span>(<span class="t">void</span>* <span class="i">pointer</span>, <span class="t">size_t</span> <span class="i">oldSize</span>, <span class="t">size_t</span> <span class="i">newSize</span>);
</pre><pre class="insert-after" translate="no">
#endif
</pre></div>
<div class="source-file-narrow"><em>memory.h</em></div>
<p><font papago-translate="splitted"><font papago-translate="translated">이 매크로는 함수 호출을 프리타이팅합니다 </font></font><code translate="no">reallocate()</code><font papago-translate="splitted"><font papago-translate="translated"> 실제 작업이 이루어지는 곳.</font><font papago-translate="translated"> 매크로 자체가 배열의 요소 유형 크기를 구하고 결과를 캐스팅하는 역할을 합니다 </font></font><code translate="no">void*</code><font papago-translate="splitted"><font papago-translate="translated"> 올바른 유형의 포인터로 돌아갑니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">이것. </font></font><code translate="no">reallocate()</code><font papago-translate="splitted"><font papago-translate="translated"> 함수는 우리가 clox에서 모든 동적 메모리 관리를 위해 사용할 단일 함수입니다. 즉, 메모리를 alloc하고, 해제하고, 기존<span class="em"></span> 할당의 크기를 변경하는 것입니다.</font><font papago-translate="translated"> 이러한 모든 작업을 단일 함수를 통해 라우팅하는 것은 나중에 사용 중인 메모리 양을 추적해야 하는 가비지 컬렉터를 추가할 때 중요합니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">전달된 두 가지 크기 인수 </font></font><code translate="no">reallocate()</code><font papago-translate="splitted"><font papago-translate="translated"> 수행할 작업을 제어합니다:</font></font></p><table>
<thead>
<tr>
<td><font papago-translate="translated">올드사이즈</font></td>
<td><font papago-translate="translated">뉴사이즈</font></td>
<td><font papago-translate="translated">작동</font></td>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><font papago-translate="translated">0이 아닌</font></td>
<td><font papago-translate="translated">새 블록 할당.</font></td>
</tr>
<tr>
<td><font papago-translate="translated">0이 아닌</font></td>
<td>0</td>
<td><font papago-translate="translated">무료 할당.</font></td>
</tr>
<tr>
<td><font papago-translate="translated">0이 아닌</font></td>
<td><font papago-translate="splitted"><font papago-translate="translated">다음보다 작음&nbsp;</font></font><code translate="no">oldSize</code></td>
<td><font papago-translate="translated">기존 할당 축소.</font></td>
</tr>
<tr>
<td><font papago-translate="translated">0이 아닌</font></td>
<td><font papago-translate="splitted"><font papago-translate="translated">보다 큰&nbsp;</font></font><code translate="no">oldSize</code></td>
<td><font papago-translate="translated">기존 할당을 확장합니다.</font></td>
</tr>
</tbody>
</table>
<p><font papago-translate="translated">처리해야 할 많은 사례처럼 들리지만 구현은 다음과 같습니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 새 파일 만들기</font></font></div>
<pre translate="no"><span class="a">#include &lt;stdlib.h&gt;</span>

<span class="a">#include "memory.h"</span>

<span class="t">void</span>* <span class="i">reallocate</span>(<span class="t">void</span>* <span class="i">pointer</span>, <span class="t">size_t</span> <span class="i">oldSize</span>, <span class="t">size_t</span> <span class="i">newSize</span>) {
  <span class="k">if</span> (<span class="i">newSize</span> == <span class="n">0</span>) {
    <span class="i">free</span>(<span class="i">pointer</span>);
    <span class="k">return</span> <span class="a">NULL</span>;
  }

  <span class="t">void</span>* <span class="i">result</span> = <span class="i">realloc</span>(<span class="i">pointer</span>, <span class="i">newSize</span>);
  <span class="k">return</span> <span class="i">result</span>;
}
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, create new file</div>
<p><font papago-translate="splitted"><font papago-translate="translated">언제 </font></font><code translate="no">newSize</code><font papago-translate="splitted"><font papago-translate="translated"> 0입니다. 우리는 전화를 통해 할당 해제 사례를 직접 처리합니다 </font></font><code translate="no">free()</code><font papago-translate="splitted"><font papago-translate="translated">. 그렇지 않으면, 우리는 C 표준 라이브러리에 의존합니다 </font></font><code translate="no">realloc()</code><font papago-translate="splitted"><font papago-translate="translated"> 기능.</font><font papago-translate="translated"> 그 기능은 우리 정책의 다른 세 가지 측면을 편리하게 지원합니다.</font><font papago-translate="translated"> 언제 </font></font><code translate="no">oldSize</code><font papago-translate="splitted"><font papago-translate="translated"> 0입니다, </font></font><code translate="no">realloc()</code><font papago-translate="splitted"><font papago-translate="translated"> 는 호출과 같습니다 </font></font><code translate="no">malloc()</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">흥미로운 경우는 다음과 같습니다 </font></font><code translate="no">oldSize</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">newSize</code><font papago-translate="splitted"><font papago-translate="translated"> 0이 아닙니다.</font><font papago-translate="translated"> 그들은 말합니다 </font></font><code translate="no">realloc()</code><font papago-translate="splitted"><font papago-translate="translated"> 이전에 할당된 블록의 크기를 조정합니다.</font><font papago-translate="translated"> 새 크기가 기존 메모리 블록보다 작으면 단순히 블록 크기<span name="shrink">를 업데이트</span>하고 제공한 포인터와 동일한 포인터를 반환합니다.</font><font papago-translate="translated"> 새 크기가 더 크면 기존 메모리 블록을 확장하려고 시도합니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">블록 이후의 메모리가 아직 사용되지 않은 경우에만 그렇게 할 수 있습니다.</font><font papago-translate="translated"> 블록을 키울 공간이 없다면, </font></font><code translate="no">realloc()</code><font papago-translate="splitted"><font papago-translate="translated"> 대신 원하는 크기의 새 메모리 블록을 할당하고, 이전 바이트를 복사한 다음, 이전 블록을 자유롭게 한 다음 포인터를 새<em></em> 블록으로 반환합니다.</font><font papago-translate="translated"> 기억하세요, 그것이 바로 우리가 동적 배열을 위해 원하는 동작입니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">컴퓨터는 유한한 물질 덩어리이며 우리가 믿는 완벽한 수학적 추상화가 아니기 때문에, 컴퓨터 과학 이론이 충분한 메모리가 없으면 할당이 실패할 수 있습니다 </font></font><code translate="no">realloc()</code><font papago-translate="splitted"><font papago-translate="translated"> 돌아올 것입니다 </font></font><code translate="no">NULL</code><font papago-translate="splitted"><font papago-translate="translated">. 우리는 그것을 처리해야 합니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  void* result = realloc(pointer, newSize);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> ()<em> 재할당</em>에서</font></font></div>
<pre class="insert" translate="no">  <span class="k">if</span> (<span class="i">result</span> == <span class="a">NULL</span>) <span class="i">exit</span>(<span class="n">1</span>);
</pre><pre class="insert-after" translate="no">  return result;
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>reallocate</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">필요한 메모리를 확보하지 못하면 VM이<em> 할 수 있는 유용</em>한 일은 없지만, 적어도 이를 감지하고 프로세스를 즉시 중단합니다 </font></font><code translate="no">NULL</code><font papago-translate="splitted"><font papago-translate="translated"> 포인터를 사용하여 나중에 궤도에서 벗어나게 합니다.</font></font></p>
<aside name="shrink" style="top: 11419px;">
<p><font papago-translate="translated">우리가 전달한 것은 메모리의 첫 번째 바이트에 대한 단순한 포인터뿐이었으니, 블록의 크기를 "업데이트"한다는 것은 무엇을 의미할까요?</font><font papago-translate="translated"> 후드 아래에서 메모리 할당기는 힙에 할당된 각 메모리 블록의 크기를 포함한 추가 부기 정보를 유지합니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">이전에 할당된 메모리에 대한 포인터가 주어지면 이 부기 정보를 찾을 수 있으며, 이를 깔끔하게 해제하는 데 필요합니다.</font><font papago-translate="translated"> 이 크기의 메타데이터는 다음과 같습니다 </font></font><code translate="no">realloc()</code><font papago-translate="splitted"><font papago-translate="translated"> 업데이트.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">많은 구현 </font></font><code translate="no">malloc()</code><font papago-translate="splitted"><font papago-translate="translated"> 할당된 크기를 반환된 주소<em> 바로 앞</em>에 메모리에 저장합니다.</font></font></p>
</aside>
<p><font papago-translate="translated">좋아요, 새 청크를 만들고 지침을 작성할 수 있습니다.</font><font papago-translate="translated"> 말 끝났죠?</font><font papago-translate="translated"> 아니요!</font><font papago-translate="translated"> 우리는 지금 C에 있습니다. 기억하세요, 예 올든 타임즈에서처럼 기억을 직접 관리해야 합니다. 이는 기억<em>을 해방시키는</em> 것을 의미합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">void initChunk(Chunk* chunk);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">청크.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>init</em>Ch<em>unk</em>() 뒤에 추가</font></font></div>
<pre class="insert" translate="no"><span class="t">void</span> <span class="i">freeChunk</span>(<span class="t">Chunk</span>* <span class="i">chunk</span>);
</pre><pre class="insert-after" translate="no">void writeChunk(Chunk* chunk, uint8_t byte);
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, add after <em>initChunk</em>()</div>
<p><font papago-translate="translated">구현은 다음과 같습니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">청크</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>init</em>Ch<em>unk</em>() 뒤에 추가</font></font></div>
<pre translate="no"><span class="t">void</span> <span class="i">freeChunk</span>(<span class="t">Chunk</span>* <span class="i">chunk</span>) {
  <span class="a">FREE_ARRAY</span>(<span class="t">uint8_t</span>, <span class="i">chunk</span>-&gt;<span class="i">code</span>, <span class="i">chunk</span>-&gt;<span class="i">capacity</span>);
  <span class="i">initChunk</span>(<span class="i">chunk</span>);
}
</pre></div>
<div class="source-file-narrow"><em>chunk.c</em>, add after <em>initChunk</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">모든 메모리를 할당 해제한 다음 호출합니다 </font></font><code translate="no">initChunk()</code><font papago-translate="splitted"><font papago-translate="translated"> 청크를 명확하게 빈 상태로 유지하면서 필드를 0으로 만듭니다.</font><font papago-translate="translated"> 메모리를 해제하기 위해 매크로를 하나 더 추가합니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#define GROW_ARRAY(type, pointer, oldCount, newCount) \
    (type*)reallocate(pointer, sizeof(type) * (oldCount), \
        sizeof(type) * (newCount))
</pre><div class="source-file"><em><font papago-translate="translated">기억.h</font></em></div>
<pre class="insert" translate="no">
<span class="a">#define FREE_ARRAY(type, pointer, oldCount) \</span>
<span class="a">    reallocate(pointer, sizeof(type) * (oldCount), 0)</span>
</pre><pre class="insert-after" translate="no">
void* reallocate(void* pointer, size_t oldSize, size_t newSize);
</pre></div>
<div class="source-file-narrow"><em>memory.h</em></div>
<p><font papago-translate="splitted"><font papago-translate="translated">맘에 들다 </font></font><code translate="no">GROW_ARRAY()</code><font papago-translate="splitted"><font papago-translate="translated">, 다음과 같은 요청에 대한 포장지입니다 </font></font><code translate="no">reallocate()</code><font papago-translate="splitted"><font papago-translate="translated">. 이것은 새로운 크기를 0으로 변환하여 메모리를 자유롭게 합니다.</font><font papago-translate="translated"> 알아요, 이건 지루한 저급한 것들이 많아요.</font><font papago-translate="translated"> 걱정하지 마세요, 우리는 나중 장에서 이것들을 많이 활용할 수 있을 것이고 더 높은 수준으로 프로그래밍할 수 있을 것입니다.</font><font papago-translate="translated"> 하지만 그렇게 하기 전에 우리만의 기초를 다져야 합니다.</font></font></p>
<h2><a href="https://youhogeon-meritz.github.io/chunks-of-bytecode.html#disassembling-chunks" id="disassembling-chunks"><small><font papago-translate="translated">14 . 4</font></small><font papago-translate="splitted"><font papago-translate="translated">덩어리 분해하기</font></font></a></h2>
<p><font papago-translate="translated">이제 바이트코드 덩어리를 만드는 작은 모듈이 있습니다.</font><font papago-translate="translated"> 샘플 청크를 직접 만들어 보겠습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">int main(int argc, const char* argv[]) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">주요.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>메인</em> ()에서</font></font></div>
<pre class="insert" translate="no">  <span class="t">Chunk</span> <span class="i">chunk</span>;
  <span class="i">initChunk</span>(&amp;<span class="i">chunk</span>);
  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="a">OP_RETURN</span>);
  <span class="i">freeChunk</span>(&amp;<span class="i">chunk</span>);
</pre><pre class="insert-after" translate="no">  return 0;
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>main</em>()</div>
<p><font papago-translate="translated">포함된 내용을 잊지 마세요.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#include "common.h"
</pre><div class="source-file"><em><font papago-translate="translated">주요.c</font></em></div>
<pre class="insert" translate="no"><span class="a">#include "chunk.h"</span>
</pre><pre class="insert-after" translate="no">
int main(int argc, const char* argv[]) {
</pre></div>
<div class="source-file-narrow"><em>main.c</em></div>
<p><font papago-translate="translated">실행해보고 한 번 시도해 보세요.</font><font papago-translate="translated"> 효과가 있던가요?</font><font papago-translate="translated"> 어<span class="ellipse">...</span> 누가 알겠어요?</font><font papago-translate="translated"> 우리가 한 일은 메모리에 몇 바이트를 밀어 넣는 것뿐입니다.</font><font papago-translate="translated"> 우리가 만든 덩어리 안에 실제로 무엇이 들어 있는지 볼 수 있는 인간 친화적인 방법은 없습니다.</font></p>
<p><font papago-translate="translated">이 문제를 해결하기 위해<strong> 우리</strong>는<strong> 분해기</strong>를 만들 것입니다.</font><font papago-translate="translated"> <strong>어셈블러</strong>는 "ADD"와 "MULT"와 같은 CPU 명령어를 위한 사람이 읽을 수 있는 니모닉 이름이 포함된 파일을 가져와 이진 기계어 코드로 변환하는 구식 프로그램입니다.</font><font papago-translate="translated"> <em>분해</em>기는 기계 코드 덩어리가 주어지면<span class="em"></span> 다른 방향으로 이동합니다.</font></p>
<p><font papago-translate="translated"><span name="printer">우리는 비슷한</span> 것을 구현할 것입니다.</font><font papago-translate="translated"> 덩어리가 주어지면 그 안에 있는 모든 지침이 출력됩니다.</font><font papago-translate="translated"> L<em>ox 사용자</em>는 이 기능을 사용하지 않지만, 우리의 L<em>ox 유지 관리자</em>들은 분명히 이점을 누릴 것입니다. 왜냐하면 이 기능은 인터프리터의 내부 코드 표현을 파악할 수 있는 창을 제공하기 때문입니다.</font></p>
<aside name="printer" style="top: 13371px;">
<p><font papago-translate="translated">Jlox에서 우리의 유사한 도구는 A<a href="https://youhogeon-meritz.github.io/representing-code.html#a-not-very-pretty-printer">stPrinter 클래스</a>였습니다.</font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">인 </font></font><code translate="no">main()</code><font papago-translate="splitted"><font papago-translate="translated">, 청크를 만든 후 분해기로 전달합니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  initChunk(&amp;chunk);
  writeChunk(&amp;chunk, OP_RETURN);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">주요.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>메인</em> ()에서</font></font></div>
<pre class="insert" translate="no">
  <span class="i">disassembleChunk</span>(&amp;<span class="i">chunk</span>, <span class="s">"test chunk"</span>);
</pre><pre class="insert-after" translate="no">  freeChunk(&amp;chunk);
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>main</em>()</div>
<p><font papago-translate="translated">다시<span name="module"> 한</span> 번<span name="module">, 우리</span>는<span name="module"> 또 다른</span> 모듈을 준비합니다.</font></p>
<aside name="module" style="top: 13663px;">
<p><font papago-translate="translated">나중 장에서는 이렇게 많은 새 파일을 만들지 않겠다고 약속드립니다.</font></p>
</aside>
<div class="codehilite"><pre class="insert-before" translate="no">#include "chunk.h"
</pre><div class="source-file"><em><font papago-translate="translated">주요.c</font></em></div>
<pre class="insert" translate="no"><span class="a">#include "debug.h"</span>
</pre><pre class="insert-after" translate="no">
int main(int argc, const char* argv[]) {
</pre></div>
<div class="source-file-narrow"><em>main.c</em></div>
<p><font papago-translate="translated">헤더는 다음과 같습니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">debug.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 새 파일 만들기</font></font></div>
<pre translate="no"><span class="a">#ifndef clox_debug_h</span>
<span class="a">#define clox_debug_h</span>

<span class="a">#include "chunk.h"</span>

<span class="t">void</span> <span class="i">disassembleChunk</span>(<span class="t">Chunk</span>* <span class="i">chunk</span>, <span class="k">const</span> <span class="t">char</span>* <span class="i">name</span>);
<span class="t">int</span> <span class="i">disassembleInstruction</span>(<span class="t">Chunk</span>* <span class="i">chunk</span>, <span class="t">int</span> <span class="i">offset</span>);

<span class="a">#endif</span>
</pre></div>
<div class="source-file-narrow"><em>debug.h</em>, create new file</div>
<p><font papago-translate="splitted"><font papago-translate="translated">인 </font></font><code translate="no">main()</code><font papago-translate="splitted"><font papago-translate="translated">, 우리는 전화합니다 </font></font><code translate="no">disassembleChunk()</code><font papago-translate="splitted"><font papago-translate="translated"> 전체 청크의 모든 명령어를 분해합니다.</font><font papago-translate="translated"> 그것은 하나의 명령어를 분해하는 다른 함수의 관점에서 구현됩니다.</font><font papago-translate="translated"> 헤더에 표시되는 이유는 나중 장에서 VM에서 호출하기 때문입니다.</font></font></p>
<p><font papago-translate="translated">구현 파일의 시작은 다음과 같습니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">debug.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 새 파일 만들기</font></font></div>
<pre translate="no"><span class="a">#include &lt;stdio.h&gt;</span>

<span class="a">#include "debug.h"</span>

<span class="t">void</span> <span class="i">disassembleChunk</span>(<span class="t">Chunk</span>* <span class="i">chunk</span>, <span class="k">const</span> <span class="t">char</span>* <span class="i">name</span>) {
  <span class="i">printf</span>(<span class="s">"== %s ==</span><span class="e">\n</span><span class="s">"</span>, <span class="i">name</span>);

  <span class="k">for</span> (<span class="t">int</span> <span class="i">offset</span> = <span class="n">0</span>; <span class="i">offset</span> &lt; <span class="i">chunk</span>-&gt;<span class="i">count</span>;) {
    <span class="i">offset</span> = <span class="i">disassembleInstruction</span>(<span class="i">chunk</span>, <span class="i">offset</span>);
  }
}
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, create new file</div>
<p><font papago-translate="splitted"><font papago-translate="translated">청크를 분해하려면 작은 헤더를 인쇄하여<em> 어떤</em> 청크를 보고 있는지 알 수 있도록 한 다음 바이트코드를 통해 각 명령어를 분해합니다.</font><font papago-translate="translated"> 우리가 코드를 반복하는 방식은 조금 이상합니다.</font><font papago-translate="translated"> 증가하는 대신 </font></font><code translate="no">offset</code><font papago-translate="splitted"><font papago-translate="translated"> 루프에서 우리는 다음을 허용합니다 </font></font><code translate="no">disassembleInstruction()</code><font papago-translate="splitted"><font papago-translate="translated"> 우리를 위해 해주세요.</font><font papago-translate="translated"> 우리가 그 함수를 호출할 때, 주어진 오프셋에서 명령어를 분해한 후<em> 다음</em> 명령어의 오프셋을 반환합니다.</font><font papago-translate="translated"> 나중에 보게 되겠지만, 지침의 크기가 다를 수 있기 때문입니다.</font></font></p>
<p><font papago-translate="translated">"디버그" 모듈의 핵심은 이 기능입니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">debug.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>분해</em> 후 추가Ch<em>unk</em>()</font></font></div>
<pre translate="no"><span class="t">int</span> <span class="i">disassembleInstruction</span>(<span class="t">Chunk</span>* <span class="i">chunk</span>, <span class="t">int</span> <span class="i">offset</span>) {
  <span class="i">printf</span>(<span class="s">"%04d "</span>, <span class="i">offset</span>);

  <span class="t">uint8_t</span> <span class="i">instruction</span> = <span class="i">chunk</span>-&gt;<span class="i">code</span>[<span class="i">offset</span>];
  <span class="k">switch</span> (<span class="i">instruction</span>) {
    <span class="k">case</span> <span class="a">OP_RETURN</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">"OP_RETURN"</span>, <span class="i">offset</span>);
    <span class="k">default</span>:
      <span class="i">printf</span>(<span class="s">"Unknown opcode %d</span><span class="e">\n</span><span class="s">"</span>, <span class="i">instruction</span>);
      <span class="k">return</span> <span class="i">offset</span> + <span class="n">1</span>;
  }
}
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, add after <em>disassembleChunk</em>()</div>
<p><font papago-translate="translated">먼저, 주어진 명령어의 바이트 오프셋을 출력하여 이 명령어가 청크에서 어디에<span class="em"></span> 있는지 알려줍니다.</font><font papago-translate="translated"> 바이트코드에서 제어 흐름을 시작하고 점프할 때 유용한 표지판이 될 것입니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">다음으로, 주어진 오프셋에서 바이트코드에서 단일 바이트를 읽습니다.</font><font papago-translate="translated"> 그것이 우리의 작전 코드입니다.</font><font papago-translate="translated"> 우리는 그것을<span name="switch"> 켭</span>니다.</font><font papago-translate="translated"> 각 종류의 지시에 대해, 우리는 그것을 표시하기 위한 작은 유틸리티 함수로 보냅니다.</font><font papago-translate="translated"> 주어진 바이트가 전혀 명령어처럼 보이지 않을 가능성이 있을 때, 즉 컴파일러의 버그로 인해<span class="em"></span><span class="em"></span> 우리는 그것도 인쇄합니다.</font><font papago-translate="translated"> 우리가 가진 한 가지 지침에 대해, </font></font><code translate="no">OP_RETURN</code><font papago-translate="splitted"><font papago-translate="translated">, 디스플레이 기능은 다음과 같습니다:</font></font></p>
<aside name="switch" style="top: 15055px;">
<p><font papago-translate="translated">지금은 하나의 지침만 있지만, 이 스위치는 책의 나머지 부분에서도 계속 사용될 것입니다.</font></p>
</aside>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">debug.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>분해</em> 후 추가Ch<em>unk</em>()</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">int</span> <span class="i">simpleInstruction</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">name</span>, <span class="t">int</span> <span class="i">offset</span>) {
  <span class="i">printf</span>(<span class="s">"%s</span><span class="e">\n</span><span class="s">"</span>, <span class="i">name</span>);
  <span class="k">return</span> <span class="i">offset</span> + <span class="n">1</span>;
}
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, add after <em>disassembleChunk</em>()</div>
<p><font papago-translate="translated">반환 명령어에는 별로 많은 것이 없으므로, 이 명령어는 opcode의 이름을 출력한 다음 이 명령어를 지나 다음 바이트 오프셋을 반환하는 것뿐입니다.</font><font papago-translate="translated"> 다른 지침들은 더 진행될 것입니다.</font></p>
<p><font papago-translate="translated">지금 초기 인터프리터를 실행하면 실제로 무언가를 출력합니다:</font></p>
<div class="codehilite"><pre translate="no">== test chunk ==
0000 OP_RETURN
</pre></div>
<p><font papago-translate="translated">성공했습니다!</font><font papago-translate="translated"> 이것은 우리 코드 표현의 일종인 "안녕하세요, 세상!"입니다.</font><font papago-translate="translated"> 우리는 청크를 만들고, 청크에 명령어를 작성한 다음, 그 명령어를 다시 추출할 수 있습니다.</font><font papago-translate="translated"> 바이너리 바이트코드의 인코딩 및 디코딩이 작동하고 있습니다.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/chunks-of-bytecode.html#constants" id="constants"><small><font papago-translate="translated">14 . 5</font></small><font papago-translate="splitted"><font papago-translate="translated">상수</font></font></a></h2>
<p><font papago-translate="translated">이제 기본적인 청크 구조가 작동하고 있으므로 더 유용하게 만들기 시작하겠습니다.</font><font papago-translate="translated"> <em>코드</em>를 덩어리로 저장할 수는 있지만<em> 데이터는</em> 어떻게 되나요?</font><font papago-translate="translated"> 인터프리터가 작업하는 많은 값은 작업의 결과로 런타임에 생성됩니다.</font></p>
<div class="codehilite"><pre translate="no"><span class="n">1</span> + <span class="n">2</span>;
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">여기 코드 어디에도 값 3이 표시되지 않습니다.</font><font papago-translate="translated"> 그러나 리터럴 </font></font><code translate="no">1</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">2</code><font papago-translate="splitted"><font papago-translate="translated"> 해당 문장을 바이트코드로 컴파일하려면 "상수를 생성한다"는 의미의 명령어가 필요하며, 이러한 문자 그대로의 값은 어딘가에 청크에 저장되어야 합니다.</font><font papago-translate="translated"> Jlox에서, 탐험가.</font><font papago-translate="translated">리터럴 AST 노드가 값을 유지했습니다.</font><font papago-translate="translated"> 구문 트리가 없기 때문에 이제 다른 솔루션이 필요합니다.</font></font></p>
<h3><a href="https://youhogeon-meritz.github.io/chunks-of-bytecode.html#representing-values" id="representing-values"><small><font papago-translate="translated">14 . 5 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">값을 나타내기</font></font></a></h3>
<p><font papago-translate="translated">이 장에서는 어떤 코드도<em> 실행하지</em> 않겠지만, 상수는 인터프리터의 정적 세계와 동적 세계 모두에 영향을 미치기 때문에 VM이 값을 어떻게 표현해야 하는지에 대해 적어도 조금은 생각하게 됩니다.</font></p>
<p><font papago-translate="translated">지금은 가능한 한 간단하게 시작하겠습니다. 우리는 오직 이중 정밀 부동 소수<span class="em"></span>점 숫자만 지원할 것입니다.</font><font papago-translate="translated"> 이것은 시간이 지남에 따라 분명히 확장될 것이므로, 우리는 성장할 수 있는 공간을 제공하기 위해 새로운 모듈을 설정할 것입니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">가치.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 새 파일 만들기</font></font></div>
<pre translate="no"><span class="a">#ifndef clox_value_h</span>
<span class="a">#define clox_value_h</span>

<span class="a">#include "common.h"</span>

<span class="k">typedef</span> <span class="t">double</span> <span class="t">Value</span>;

<span class="a">#endif</span>
</pre></div>
<div class="source-file-narrow"><em>value.h</em>, create new file</div>
<p><font papago-translate="translated">이 typedef는 Lox 값이 C에서 구체적으로 어떻게 표현되는지를 추상화합니다.</font><font papago-translate="translated"> 그렇게 하면 값을 중심으로 전달되는 기존 코드를 수정할 필요 없이 해당 표현을 변경할 수 있습니다.</font></p>
<p><font papago-translate="translated">상수를 청크에 어디에 저장할지에 대한 질문으로 돌아갑니다.</font><font papago-translate="translated"> 정수와 같은 작은 고정 크기 값의 경우, 많은 명령어 세트가 연산 코드 직후 코드 스트림에 직접 값을 저장합니다.</font><font papago-translate="translated"> 값의 비트가 연산 코드 바로 뒤에 있기 때문에<strong> 이</strong>를<strong> 즉시 명령</strong>어라고 합니다.</font></p>
<p><font papago-translate="translated">그것은 문자열과 같은 큰 또는 가변 크기의 상수에서는 잘 작동하지 않습니다.</font><font papago-translate="translated"> 네이티브 컴파일러에서 머신 코드로 변환할 때, 이러한 더 큰 상수는 바이너리 실행 파일의 별도의 "상수 데이터" 영역에 저장됩니다.</font><font papago-translate="translated"> 그런 다음 상수를 로드하라는 명령에는 해당 섹션의 값이 저장된 위치를 가리키는 주소 또는 오프셋이 있습니다.</font></p>
<p><font papago-translate="translated">대부분의 가상 머신은 비슷한 작업을 수행합니다.</font><font papago-translate="translated"> 예를 들어, Java 가상 머신은 각 컴파일된 클래스에<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.4"><strong> 일정한 풀을</strong> 연결</a>합니다.</font><font papago-translate="translated"> 클록스에게는 충분히 좋은 것 같습니다.</font><font papago-translate="translated"> 각 청크에는 프로그램에서 리터럴로 표시되는 값 목록이 함께 제공됩니다.</font><font papago-translate="translated"> 더<span name="immediate"> 간단하게</span> 만들기 위해<em> 모든</em> 상수, 심지어 단순한 정수도 넣을 것입니다.</font></p>
<aside name="immediate" style="top: 16891px;">
<p><font papago-translate="translated">즉각적인 두 가지 종류의 상수 지시가 필요할 뿐만 아니라, 하나는 즉각적인 값을 위한 것이고 다른 하나는 상수 표에 있는 상수를 위한 것입니다. 또한, 우리는 정렬, 패딩, 그리고 엔디안<span class="em"></span><span class="em"></span>니스에 대해 걱정해야 합니다.</font><font papago-translate="translated"> 어떤 아키텍처는 홀수 주소에 4바이트 정수를 채우려고 하면 만족하지 않습니다.</font></p>
</aside>
<h3><a href="https://youhogeon-meritz.github.io/chunks-of-bytecode.html#value-arrays" id="value-arrays"><small><font papago-translate="translated">14 . 5 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">가치 배열</font></font></a></h3>
<p><font papago-translate="translated">상수 풀은 값의 배열입니다.</font><font papago-translate="translated"> 상수를 로드하라는 명령은 해당 배열에서 인덱스별로 값을 조회합니다.</font><font papago-translate="translated"> <span name="generic">우리의 바이트코드</span> 배열과 마찬가지로, 컴파일러는 배열이 얼마나 커져야 하는지 미리 알지 못합니다.</font><font papago-translate="translated"> 그래서 다시 한 번 역동적인 것이 필요합니다.</font><font papago-translate="translated"> C에는 일반적인 데이터 구조가 없으므로 이번에는 Value에 대한 또 다른 동적 배열 데이터 구조를 작성하겠습니다.</font></p>
<aside name="generic" style="top: 17083px;">
<p><font papago-translate="translated">매번 다른 유형의 동적 배열이 필요할 때마다 새로운 구조와 조작 함수를 정의하는 것은 번거로운 일입니다.</font><font papago-translate="translated"> 전처리 매크로를 가짜 제네릭으로 결합할 수도 있지만, 이는 clox에게는 너무 과한 일입니다.</font><font papago-translate="translated"> 우리는 이것들이 더 이상 필요하지 않을 것입니다.</font></p>
</aside>
<div class="codehilite"><pre class="insert-before" translate="no">typedef double Value;
</pre><div class="source-file"><em><font papago-translate="translated">가치.h</font></em></div>
<pre class="insert" translate="no">
<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">int</span> <span class="i">capacity</span>;
  <span class="t">int</span> <span class="i">count</span>;
  <span class="t">Value</span>* <span class="i">values</span>;
} <span class="t">ValueArray</span>;
</pre><pre class="insert-after" translate="no">
#endif
</pre></div>
<div class="source-file-narrow"><em>value.h</em></div>
<p><font papago-translate="translated">Chunk의 바이트코드 배열과 마찬가지로, 이 구조는 할당된 용량과 사용 중인 요소의 수와 함께 배열에 대한 포인터를 감쌉니다.</font><font papago-translate="translated"> 우리는 또한 가치 배열을 처리하기 위해 동일한 세 가지 기능이 필요합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">} ValueArray;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">가치.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> struct<em> ValueArray</em> 뒤에 추가</font></font></div>
<pre class="insert" translate="no">
<span class="t">void</span> <span class="i">initValueArray</span>(<span class="t">ValueArray</span>* <span class="i">array</span>);
<span class="t">void</span> <span class="i">writeValueArray</span>(<span class="t">ValueArray</span>* <span class="i">array</span>, <span class="t">Value</span> <span class="i">value</span>);
<span class="t">void</span> <span class="i">freeValueArray</span>(<span class="t">ValueArray</span>* <span class="i">array</span>);
</pre><pre class="insert-after" translate="no">
#endif
</pre></div>
<div class="source-file-narrow"><em>value.h</em>, add after struct <em>ValueArray</em></div>
<p><font papago-translate="translated">그 구현들은 아마도 당신에게 데자뷰를 줄 것입니다.</font><font papago-translate="translated"> 먼저, 새로운 것을 만들려면:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">가치.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 새 파일 만들기</font></font></div>
<pre translate="no"><span class="a">#include &lt;stdio.h&gt;</span>

<span class="a">#include "memory.h"</span>
<span class="a">#include "value.h"</span>

<span class="t">void</span> <span class="i">initValueArray</span>(<span class="t">ValueArray</span>* <span class="i">array</span>) {
  <span class="i">array</span>-&gt;<span class="i">values</span> = <span class="a">NULL</span>;
  <span class="i">array</span>-&gt;<span class="i">capacity</span> = <span class="n">0</span>;
  <span class="i">array</span>-&gt;<span class="i">count</span> = <span class="n">0</span>;
}
</pre></div>
<div class="source-file-narrow"><em>value.c</em>, create new file</div>
<p><font papago-translate="translated">초기화된 배열을 확보하면, 그 배열에 값<span name="add">을 추가</span>할 수 있습니다.</font></p>
<aside name="add" style="top: 17939px;">
<p><font papago-translate="translated">다행히도 삽입 및 제거와 같은 다른 작업은 필요하지 않습니다.</font></p>
</aside>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">가치.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>initValueArray</em>() 다음에 추가</font></font></div>
<pre translate="no"><span class="t">void</span> <span class="i">writeValueArray</span>(<span class="t">ValueArray</span>* <span class="i">array</span>, <span class="t">Value</span> <span class="i">value</span>) {
  <span class="k">if</span> (<span class="i">array</span>-&gt;<span class="i">capacity</span> &lt; <span class="i">array</span>-&gt;<span class="i">count</span> + <span class="n">1</span>) {
    <span class="t">int</span> <span class="i">oldCapacity</span> = <span class="i">array</span>-&gt;<span class="i">capacity</span>;
    <span class="i">array</span>-&gt;<span class="i">capacity</span> = <span class="a">GROW_CAPACITY</span>(<span class="i">oldCapacity</span>);
    <span class="i">array</span>-&gt;<span class="i">values</span> = <span class="a">GROW_ARRAY</span>(<span class="t">Value</span>, <span class="i">array</span>-&gt;<span class="i">values</span>,
                               <span class="i">oldCapacity</span>, <span class="i">array</span>-&gt;<span class="i">capacity</span>);
  }

  <span class="i">array</span>-&gt;<span class="i">values</span>[<span class="i">array</span>-&gt;<span class="i">count</span>] = <span class="i">value</span>;
  <span class="i">array</span>-&gt;<span class="i">count</span>++;
}
</pre></div>
<div class="source-file-narrow"><em>value.c</em>, add after <em>initValueArray</em>()</div>
<p><font papago-translate="translated">앞서 작성한 메모리 관리 매크로에서는 코드 배열의 일부 논리를 재사용할 수 있으므로 이 점이 나쁘지 않습니다.</font><font papago-translate="translated"> 마지막으로, 배열에 사용된 모든 메모리를 해제합니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">가치.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>write</em>V<em>alueArray</em>() 후에 추가</font></font></div>
<pre translate="no"><span class="t">void</span> <span class="i">freeValueArray</span>(<span class="t">ValueArray</span>* <span class="i">array</span>) {
  <span class="a">FREE_ARRAY</span>(<span class="t">Value</span>, <span class="i">array</span>-&gt;<span class="i">values</span>, <span class="i">array</span>-&gt;<span class="i">capacity</span>);
  <span class="i">initValueArray</span>(<span class="i">array</span>);
}
</pre></div>
<div class="source-file-narrow"><em>value.c</em>, add after <em>writeValueArray</em>()</div>
<p><font papago-translate="translated">이제 확장 가능한 값 배열이 생겼으니, 청크에 하나를 추가하여 청크의 상수를 저장할 수 있습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  uint8_t* code;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">청크.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 구조<em> 청크</em>에서</font></font></div>
<pre class="insert" translate="no">  <span class="t">ValueArray</span> <span class="i">constants</span>;
</pre><pre class="insert-after" translate="no">} Chunk;
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in struct <em>Chunk</em></div>
<p><font papago-translate="translated">포함된 내용을 잊지 마세요.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#include "common.h"
</pre><div class="source-file"><em><font papago-translate="translated">청크.h</font></em></div>
<pre class="insert" translate="no"><span class="a">#include "value.h"</span>
</pre><pre class="insert-after" translate="no">
typedef enum {
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em></div>
<p><font papago-translate="translated">아, C, 그리고 그것의 석기 시대 모듈화 이야기.</font><font papago-translate="translated"> 우리가 어디까지 얘기했죠?</font><font papago-translate="translated"> 맞다.</font><font papago-translate="translated"> 새 청크를 초기화할 때, 상수 목록도 초기화합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  chunk-&gt;code = NULL;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">청크</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>init</em>Ch<em>unk</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="i">initValueArray</span>(&amp;<span class="i">chunk</span>-&gt;<span class="i">constants</span>);
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>chunk.c</em>, in <em>initChunk</em>()</div>
<p><font papago-translate="translated">마찬가지로, 우리는 청크를 풀 때 상수를 풀어줍니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  FREE_ARRAY(uint8_t, chunk-&gt;code, chunk-&gt;capacity);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">청크</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>free</em>Ch<em>unk</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="i">freeValueArray</span>(&amp;<span class="i">chunk</span>-&gt;<span class="i">constants</span>);
</pre><pre class="insert-after" translate="no">  initChunk(chunk);
</pre></div>
<div class="source-file-narrow"><em>chunk.c</em>, in <em>freeChunk</em>()</div>
<p><font papago-translate="translated">다음으로, 청크에 새로운 상수를 추가하는 편의 방법을 정의합니다.</font><font papago-translate="translated"> 아직 작성되지 않은 컴파일러는 Chunk 내부의 상수 배열에 직접 쓸 수 있습니다. C에 개인 필드가 있는 것은 아니지만, 명시<span class="em"></span><span class="em"></span>적인 함수를 추가하는 것이 조금 더 좋습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">void writeChunk(Chunk* chunk, uint8_t byte);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">청크.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>write</em>Ch<em>unk</em>() 후에 추가</font></font></div>
<pre class="insert" translate="no"><span class="t">int</span> <span class="i">addConstant</span>(<span class="t">Chunk</span>* <span class="i">chunk</span>, <span class="t">Value</span> <span class="i">value</span>);
</pre><pre class="insert-after" translate="no">
#endif
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, add after <em>writeChunk</em>()</div>
<p><font papago-translate="translated">그런 다음 구현합니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">청크</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>write</em>Ch<em>unk</em>() 후에 추가</font></font></div>
<pre translate="no"><span class="t">int</span> <span class="i">addConstant</span>(<span class="t">Chunk</span>* <span class="i">chunk</span>, <span class="t">Value</span> <span class="i">value</span>) {
  <span class="i">writeValueArray</span>(&amp;<span class="i">chunk</span>-&gt;<span class="i">constants</span>, <span class="i">value</span>);
  <span class="k">return</span> <span class="i">chunk</span>-&gt;<span class="i">constants</span>.<span class="i">count</span> - <span class="n">1</span>;
}
</pre></div>
<div class="source-file-narrow"><em>chunk.c</em>, add after <em>writeChunk</em>()</div>
<p><font papago-translate="translated">상수를 추가한 후, 상수가 추가된 인덱스를 반환하여 나중에 동일한 상수를 찾을 수 있도록 합니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/chunks-of-bytecode.html#constant-instructions" id="constant-instructions"><small><font papago-translate="translated">14 . 5 . 3</font></small><font papago-translate="splitted"><font papago-translate="translated">지속적인 지침</font></font></a></h3>
<p><font papago-translate="translated">상수를 청크 단위로<em> 저장</em>할 수도 있지만<em>, 이</em>를<em> 실행</em>해야 합니다.</font><font papago-translate="translated"> 다음과 같은 코드 조각으로:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">print</span> <span class="n">1</span>;
<span class="k">print</span> <span class="n">2</span>;
</pre></div>
<p><font papago-translate="translated">컴파일된 청크는 값 1과 2를 포함할 뿐만 아니라 올바른 순서로 인쇄할<em> 수 있도록 언제</em> 생성해야 하는지 알아야 합니다.</font><font papago-translate="translated"> 따라서 특정 상수를 생성하는 명령어가 필요합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">typedef enum {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">청크.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> enum O<em>pCode</em>에서</font></font></div>
<pre class="insert" translate="no">  <span class="a">OP_CONSTANT</span>,
</pre><pre class="insert-after" translate="no">  OP_RETURN,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>
<p><font papago-translate="splitted"><font papago-translate="translated">VM이 일정한 명령을 실행할 때, 사용하기 위해 일정한 명령을<span name="load"> "로드"</span>합니다.</font><font papago-translate="translated"> 이 새로운 명령어는 다음보다 조금 더 복잡합니다 </font></font><code translate="no">OP_RETURN</code><font papago-translate="splitted"><font papago-translate="translated">. 위의 예에서는 두 가지 다른 상수를 로드합니다.</font><font papago-translate="translated"> 단일 베어 옵코드만으로는<em></em> 어떤 상수를 로드해야 하는지 알 수 없습니다.</font></font></p>
<aside name="load" style="top: 19887px;">
<p><font papago-translate="translated">가상 머신이 런타임에 실제로 코드를 실행하는 방법을 아직 배우지 않았기 때문에 상수를 "로드"하거나 "생성"하는 것이 무엇을 의미하는지 모호하게 생각하고 있습니다.</font><font papago-translate="translated"> 이를 위해서<a href="https://youhogeon-meritz.github.io/a-virtual-machine.html">는 다음 장</a>에 도달할 때까지 기다려야 할 것입니다(또는 건너뛰어야 할 것 같아요).</font></p>
</aside>
<p><font papago-translate="translated">이와 같은 경우를 처리하기 위해 대부분의 다른 바이트코드와 마찬가지로 명령어에도<span name="operand"><strong> 피연산자</strong></span><span class="em"></span><span class="em"></span><span name="operand"><strong>가</strong></span> 포함될 수 있습니다.</font><font papago-translate="translated"> 이것들은 명령어 스트림에서 opcode 직후에 이진 데이터로 저장되며, 명령어가 수행하는 작업을 매개변수화해 보겠습니다.</font></p>
<p><img alt="OP_CONSTANT is a byte for
the opcode followed by a byte for the constant index." src="https://youhogeon-meritz.github.io/image/chunks-of-bytecode/format.png"></p>
<p><font papago-translate="translated">각 오피코드는 피연산자 바이트 수와 그 의미를 결정합니다.</font><font papago-translate="translated"> 예를 들어, "리턴"과 같은 간단한 연산에는 피연산자가 없을 수 있습니다. 여기서 "로컬 변수 로드" 명령어는 어떤 변수를 로드할지 식별하기 위해 피연산자가 필요합니다.</font><font papago-translate="translated"> clox에 새로운 opcode를 추가할 때마다 그 피연산자가 어떻게 생겼는지, 즉<strong> 명령</strong><span class="em"></span><strong>어 형식</strong>을 지정합니다.</font></p>
<aside name="operand" style="top: 20031px;">
<p><font papago-translate="translated">바이트코드 명령어 피연산자는 산술 연산자에게 전달되는 피연산자와 동일<em>하지</em> 않습니다.</font><font papago-translate="translated"> 산술 피연산자 값이 별도로 추적된다는 식을 알게 될 것입니다.</font><font papago-translate="translated"> 명령어 피연산자는 바이트코드 명령어 자체의 동작 방식을 수정하는 하위 개념입니다.</font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">이 경우, </font></font><code translate="no">OP_CONSTANT</code><font papago-translate="splitted"><font papago-translate="translated"> 청크의 상수 배열에서 로드할 상수를 지정하는 단일 바이트 피연산자를 가져옵니다.</font><font papago-translate="translated"> 아직 컴파일러가 없기 때문에 테스트 청크에서 명령어를 "수동 컴파일"합니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  initChunk(&amp;chunk);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">주요.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>메인</em> ()에서</font></font></div>
<pre class="insert" translate="no">
  <span class="t">int</span> <span class="i">constant</span> = <span class="i">addConstant</span>(&amp;<span class="i">chunk</span>, <span class="n">1.2</span>);
  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="a">OP_CONSTANT</span>);
  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="i">constant</span>);

</pre><pre class="insert-after" translate="no">  writeChunk(&amp;chunk, OP_RETURN);
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>main</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">우리는 청크의 상수 풀에 상수 값 자체를 추가합니다.</font><font papago-translate="translated"> 그것은 배열의 상수 인덱스를 반환합니다.</font><font papago-translate="translated"> 그런 다음 연산 코드부터 시작하여 상수 명령어를 작성합니다.</font><font papago-translate="translated"> 그 후, 우리는 1바이트 상수 인덱스 피연산자를 작성합니다.</font><font papago-translate="translated"> 참고로 </font></font><code translate="no">writeChunk()</code><font papago-translate="splitted"><font papago-translate="translated"> opcode 또는 피연산자를 작성할 수 있습니다.</font><font papago-translate="translated"> 그 함수에 관한 한 모든 것은 원시 바이트입니다.</font></font></p>
<p><font papago-translate="translated">지금 이 작업을 실행하려고 하면 분해자가 새 명령어를 해독하는 방법을 모르기 때문에 우리에게 소리를 지르게 될 것입니다.</font><font papago-translate="translated"> 해결해 보겠습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  switch (instruction) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">debug.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>분해</em> 중 지침()</font></font></div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="a">OP_CONSTANT</span>:
      <span class="k">return</span> <span class="i">constantInstruction</span>(<span class="s">"OP_CONSTANT"</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
</pre><pre class="insert-after" translate="no">    case OP_RETURN:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>
<p><font papago-translate="translated">이 명령어는 다른 명령어 형식을 가지고 있으므로, 이를 분해하기 위해 새로운 도우미 함수를 작성합니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">debug.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>분해</em> 후 추가Ch<em>unk</em>()</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">int</span> <span class="i">constantInstruction</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">name</span>, <span class="t">Chunk</span>* <span class="i">chunk</span>,
                               <span class="t">int</span> <span class="i">offset</span>) {
  <span class="t">uint8_t</span> <span class="i">constant</span> = <span class="i">chunk</span>-&gt;<span class="i">code</span>[<span class="i">offset</span> + <span class="n">1</span>];
  <span class="i">printf</span>(<span class="s">"%-16s %4d '"</span>, <span class="i">name</span>, <span class="i">constant</span>);
  <span class="i">printValue</span>(<span class="i">chunk</span>-&gt;<span class="i">constants</span>.<span class="i">values</span>[<span class="i">constant</span>]);
  <span class="i">printf</span>(<span class="s">"'</span><span class="e">\n</span><span class="s">"</span>);
}
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, add after <em>disassembleChunk</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">여기에 더 많은 일이 일어나고 있습니다.</font><font papago-translate="translated"> 마찬가지로 </font></font><code translate="no">OP_RETURN</code><font papago-translate="splitted"><font papago-translate="translated">, 우리는 옵코드의 이름을 출력합니다.</font><font papago-translate="translated"> 그런 다음 청크의 후속 바이트에서 상수 인덱스를 꺼냅니다.</font><font papago-translate="translated"> 우리는 그 색인을 인쇄하지만, 그것은 우리 인간 독자들에게는 그다지 유용하지 않습니다.</font><font papago-translate="translated"> 그래서 우리는 컴파일 시간에 상수가 알려져 있기 때문에 실제 상수 값도 찾아보고, 그 값<span class="em"></span><em></em><span class="em"></span> 자체도 표시합니다.</font></font></p>
<p><font papago-translate="translated">이를 위해서는 clox Value를 인쇄할 수 있는 방법이 필요합니다.</font><font papago-translate="translated"> 그 함수는 "가치" 모듈에 포함될 것이므로, 우리는 그것을 포함합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#include "debug.h"
</pre><div class="source-file"><em>debug.c</em></div>
<pre class="insert" translate="no"><span class="a">#include "value.h"</span>
</pre><pre class="insert-after" translate="no">
void disassembleChunk(Chunk* chunk, const char* name) {
</pre></div>
<div class="source-file-narrow"><em>debug.c</em></div>
<p><font papago-translate="translated">그 헤더에서는 다음과 같이 선언합니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">void freeValueArray(ValueArray* array);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">가치.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>freeValueArray</em>() 다음에 추가</font></font></div>
<pre class="insert" translate="no"><span class="t">void</span> <span class="i">printValue</span>(<span class="t">Value</span> <span class="i">value</span>);
</pre><pre class="insert-after" translate="no">
#endif
</pre></div>
<div class="source-file-narrow"><em>value.h</em>, add after <em>freeValueArray</em>()</div>
<p><font papago-translate="translated">그리고 여기 구현이 있습니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">가치.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>freeValueArray</em>() 다음에 추가</font></font></div>
<pre translate="no"><span class="t">void</span> <span class="i">printValue</span>(<span class="t">Value</span> <span class="i">value</span>) {
  <span class="i">printf</span>(<span class="s">"%g"</span>, <span class="i">value</span>);
}
</pre></div>
<div class="source-file-narrow"><em>value.c</em>, add after <em>freeValueArray</em>()</div>
<p><font papago-translate="translated">멋지지 않나요?</font><font papago-translate="translated"> 상상할 수 있듯이, Lox에 동적 타이핑을 추가하고 다양한 유형의 값을 갖게 되면 이 작업은 더욱 복잡해질 것입니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">다시 안으로 </font></font><code translate="no">constantInstruction()</code><font papago-translate="splitted"><font papago-translate="translated">, 남은 유일한 조각은 반환 값입니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  printf("'\n");
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">debug.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>일정하게</em></font><font papago-translate="translated"><em>지침</em>()</font></font></div>
<pre class="insert" translate="no">  <span class="k">return</span> <span class="i">offset</span> + <span class="n">2</span>;
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>constantInstruction</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">그 것을 기억하라. </font></font><code translate="no">disassembleInstruction()</code><font papago-translate="splitted"><font papago-translate="translated"> 는 또한 발신자에게<em> 다음</em> 명령어 시작 부분의 오프셋을 알려주는 숫자를 반환합니다.</font><font papago-translate="translated"> 어디에 </font></font><code translate="no">OP_RETURN</code><font papago-translate="splitted"><font papago-translate="translated"> 단 하나의 바이트였습니다, </font></font><code translate="no">OP_CONSTANT</code><font papago-translate="splitted"><font papago-translate="translated"> 는 두 개로, 하나는 옵코드용이고 다른 하나는<span class="em"></span> 피연산자용입니다.</font></font></p>
<h2><a href="https://youhogeon-meritz.github.io/chunks-of-bytecode.html#line-information" id="line-information"><small><font papago-translate="translated">14 . 6</font></small><font papago-translate="splitted"><font papago-translate="translated">라인 정보</font></font></a></h2>
<p><font papago-translate="translated">청크에는 런타임에 필요한 거의 모든 정보가 사용자의 소스 코드에서 포함되어 있습니다.</font><font papago-translate="translated"> Jlox에서 만든 모든 AST 클래스를 바이트 배열과 상수 배열로 줄일 수 있다고 생각하는 것은 다소 미친 짓입니다.</font><font papago-translate="translated"> 우리가 놓치고 있는 데이터는 단 하나뿐입니다.</font><font papago-translate="translated"> 사용자가 절대 보지 않기를 바라지만, 우리는 그것이 필요합니다.</font></p>
<p><font papago-translate="translated">런타임 오류가 발생하면 사용자에게 문제가 되는 소스 코드의 줄 번호를 보여줍니다.</font><font papago-translate="translated"> Jlox에서는 이러한 숫자가 토큰에 저장되며, 이를 AST 노드에 저장합니다.</font><font papago-translate="translated"> 구문 트리를 버리고 바이트코드를 선택했으니 이제 clox에 대한 다른 솔루션이 필요합니다.</font><font papago-translate="translated"> 바이트코드 명령이 주어지면, 우리는 그것이 컴파일된 사용자 소스 프로그램의 라인을 결정할 수 있어야 합니다.</font></p>
<p><font papago-translate="translated">이를 인코딩할 수 있는 영리한 방법은 많이 있습니다.</font><font papago-translate="translated"> 저는 기억력 면에서는 수치스러울 정도로 비효율적이지만, 제가 생각해낼 수 있는<span name="side"> 가장 간단한</span> 접근 방식을 취했습니다.</font><font papago-translate="translated"> 청크에서는 바이트코드와 유사한 별도의 정수 배열을 저장합니다.</font><font papago-translate="translated"> 배열의 각 숫자는 바이트코드에서 해당 바이트의 줄 번호입니다.</font><font papago-translate="translated"> 런타임 오류가 발생하면 코드 배열에서 현재 명령어의 오프셋과 동일한 인덱스에서 줄 번호를 조회합니다.</font></p>
<aside name="side" style="top: 22555.5px;">
<p><font papago-translate="translated">이 브레인데드 인코딩은 한 가지 제대로 작동합니다: 줄 정보를 바이트코드 자체에 삽입하지 않고<em> 별도</em>의 배열로 유지합니다.</font><font papago-translate="translated"> 라인 정보는 런타임 오류가 발생할 때만 사용되기 때문에, 우리는 명령어 간에 라인 정보를 사용하지 않기를 원합니다. 이는 CPU 캐시의 귀중한 공간을 차지하고, 인터프리터가 이를 건너뛰어 관심 있는 opcode와 피연산자에게 도달할 때 더 많은 캐시 누락을 초래합니다.</font></p>
</aside>
<p><font papago-translate="translated">이를 구현하기 위해 청크에 다른 배열을 추가합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  uint8_t* code;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">청크.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 구조<em> 청크</em>에서</font></font></div>
<pre class="insert" translate="no">  <span class="t">int</span>* <span class="i">lines</span>;
</pre><pre class="insert-after" translate="no">  ValueArray constants;
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in struct <em>Chunk</em></div>
<p><font papago-translate="translated">바이트코드 배열과 정확히 유사하기 때문에 별도의 카운트나 용량이 필요하지 않습니다.</font><font papago-translate="translated"> 코드 배열을 터치할 때마다 초기화부터 시작하여 줄 번호 배열에 해당하는 변경을 가합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  chunk-&gt;code = NULL;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">청크</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>init</em>Ch<em>unk</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="i">chunk</span>-&gt;<span class="i">lines</span> = <span class="a">NULL</span>;
</pre><pre class="insert-after" translate="no">  initValueArray(&amp;chunk-&gt;constants);
</pre></div>
<div class="source-file-narrow"><em>chunk.c</em>, in <em>initChunk</em>()</div>
<p><font papago-translate="translated">그리고 마찬가지로 할당 해제:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  FREE_ARRAY(uint8_t, chunk-&gt;code, chunk-&gt;capacity);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">청크</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>free</em>Ch<em>unk</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="a">FREE_ARRAY</span>(<span class="t">int</span>, <span class="i">chunk</span>-&gt;<span class="i">lines</span>, <span class="i">chunk</span>-&gt;<span class="i">capacity</span>);
</pre><pre class="insert-after" translate="no">  freeValueArray(&amp;chunk-&gt;constants);
</pre></div>
<div class="source-file-narrow"><em>chunk.c</em>, in <em>freeChunk</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">청크에 코드 바이트를 쓸 때는 어떤 소스 라인에서 왔는지 알아야 하므로 선언문에 추가 매개변수를 추가합니다 </font></font><code translate="no">writeChunk()</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">void freeChunk(Chunk* chunk);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">청크.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 함수<em> 쓰기</em>Ch<em>unk</em>()</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no"><span class="t">void</span> <span class="i">writeChunk</span>(<span class="t">Chunk</span>* <span class="i">chunk</span>, <span class="t">uint8_t</span> <span class="i">byte</span>, <span class="t">int</span> <span class="i">line</span>);
</pre><pre class="insert-after" translate="no">int addConstant(Chunk* chunk, Value value);
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, function <em>writeChunk</em>(), replace 1 line</div>
<p><font papago-translate="translated">그리고 구현에서는:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">청크</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 함수<em> 쓰기</em>Ch<em>unk</em>()</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no"><span class="t">void</span> <span class="i">writeChunk</span>(<span class="t">Chunk</span>* <span class="i">chunk</span>, <span class="t">uint8_t</span> <span class="i">byte</span>, <span class="t">int</span> <span class="i">line</span>) {
</pre><pre class="insert-after" translate="no">  if (chunk-&gt;capacity &lt; chunk-&gt;count + 1) {
</pre></div>
<div class="source-file-narrow"><em>chunk.c</em>, function <em>writeChunk</em>(), replace 1 line</div>
<p><font papago-translate="translated">코드 배열을 할당하거나 확장할 때, 라인 정보도 동일하게 처리합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    chunk-&gt;code = GROW_ARRAY(uint8_t, chunk-&gt;code,
        oldCapacity, chunk-&gt;capacity);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">청크</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>write</em>Ch<em>unk</em>()에서</font></font></div>
<pre class="insert" translate="no">    <span class="i">chunk</span>-&gt;<span class="i">lines</span> = <span class="a">GROW_ARRAY</span>(<span class="t">int</span>, <span class="i">chunk</span>-&gt;<span class="i">lines</span>,
        <span class="i">oldCapacity</span>, <span class="i">chunk</span>-&gt;<span class="i">capacity</span>);
</pre><pre class="insert-after" translate="no">  }
</pre></div>
<div class="source-file-narrow"><em>chunk.c</em>, in <em>writeChunk</em>()</div>
<p><font papago-translate="translated">마지막으로, 우리는 배열에 줄 번호를 저장합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  chunk-&gt;code[chunk-&gt;count] = byte;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">청크</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>write</em>Ch<em>unk</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="i">chunk</span>-&gt;<span class="i">lines</span>[<span class="i">chunk</span>-&gt;<span class="i">count</span>] = <span class="i">line</span>;
</pre><pre class="insert-after" translate="no">  chunk-&gt;count++;
</pre></div>
<div class="source-file-narrow"><em>chunk.c</em>, in <em>writeChunk</em>()</div>
<h3><a href="https://youhogeon-meritz.github.io/chunks-of-bytecode.html#disassembling-line-information" id="disassembling-line-information"><small><font papago-translate="translated">14 . 6 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">라인 정보 분해하기</font></font></a></h3>
<p><font papago-translate="splitted"><font papago-translate="translated">좋아요, 작은 장인의 조각으로 이것을 시도해 보겠습니다.</font><font papago-translate="translated"> 먼저, 새로운 매개변수를 추가했기 때문에 </font></font><code translate="no">writeChunk()</code><font papago-translate="splitted"><font papago-translate="translated">, 우리는 그 전화들이 일부(현재 시점에서는 arbitrary)의 전화<span class="em"></span><span class="em"></span>번호로 전달되도록 수정해야 합니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  int constant = addConstant(&amp;chunk, 1.2);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">주요.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>메인</em> ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 4줄 교체</font></font></div>
<pre class="insert" translate="no">  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="a">OP_CONSTANT</span>, <span class="n">123</span>);
  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="i">constant</span>, <span class="n">123</span>);

  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="a">OP_RETURN</span>, <span class="n">123</span>);
</pre><pre class="insert-after" translate="no">
  disassembleChunk(&amp;chunk, "test chunk");
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>main</em>(), replace 4 lines</div>
<p><font papago-translate="translated">물론, 실제 프론트엔드가 확보되면 컴파일러는 현재 행이 파싱될 때 이를 추적하여 전달할 것입니다.</font></p>
<p><font papago-translate="translated">이제 모든 지침에 대한 줄 정보를 얻었으니, 이를 잘 활용해 보겠습니다.</font><font papago-translate="translated"> 우리의 분해기에서는 각 명령어가 어느 소스 라인에서 컴파일되었는지 보여주는 것이 도움이 됩니다.</font><font papago-translate="translated"> 이를 통해 바이트코드 덩어리가 무엇을 해야 하는지 파악할 때 원래 코드로 매핑할 수 있는 방법을 얻을 수 있습니다.</font><font papago-translate="translated"> 명령어의 오프셋(청크 시작부터 바이트 수)을 인쇄한 후 소스<span class="em"></span><span class="em"></span> 라인을 표시합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">int disassembleInstruction(Chunk* chunk, int offset) {
  printf("%04d ", offset);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">debug.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>분해</em> 중 지침()</font></font></div>
<pre class="insert" translate="no">  <span class="k">if</span> (<span class="i">offset</span> &gt; <span class="n">0</span> &amp;&amp;
      <span class="i">chunk</span>-&gt;<span class="i">lines</span>[<span class="i">offset</span>] == <span class="i">chunk</span>-&gt;<span class="i">lines</span>[<span class="i">offset</span> - <span class="n">1</span>]) {
    <span class="i">printf</span>(<span class="s">"   | "</span>);
  } <span class="k">else</span> {
    <span class="i">printf</span>(<span class="s">"%4d "</span>, <span class="i">chunk</span>-&gt;<span class="i">lines</span>[<span class="i">offset</span>]);
  }
</pre><pre class="insert-after" translate="no">
  uint8_t instruction = chunk-&gt;code[offset];
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">바이트코드 지침은 꽤 세분화된 경향이 있습니다.</font><font papago-translate="translated"> 단일 소스 코드 라인은 종종 전체 명령어 시퀀스로 컴파일됩니다.</font><font papago-translate="translated"> 시각적으로 더 명확하게 하기 위해 다음과 같이 표시합니다 </font></font><code translate="no">|</code><font papago-translate="splitted"><font papago-translate="translated"> 이전 명령어와 동일한 소스 라인에서 오는 모든 명령어에 대해.</font><font papago-translate="translated"> 손으로 쓴 청크의 결과 출력은 다음과 같습니다:</font></font></p>
<div class="codehilite"><pre translate="no">== test chunk ==
0000  123 OP_CONSTANT         0 '1.2'
0002    | OP_RETURN
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">우리는 3바이트 청크를 가지고 있습니다.</font><font papago-translate="translated"> 처음 두 바이트는 청크의 상수 풀에서 1.2를 로드하는 상수 명령어입니다.</font><font papago-translate="translated"> 첫 번째 바이트는 </font></font><code translate="no">OP_CONSTANT</code><font papago-translate="splitted"><font papago-translate="translated"> opcode와 두 번째는 상수 풀의 인덱스입니다.</font><font papago-translate="translated"> 세 번째 바이트(오프셋 2에서)는 단일 바이트 반환 명령어입니다.</font></font></p>
<p><font papago-translate="translated">나머지 장에서는 이를 더 많은 종류의 지침으로 구체화할 것입니다.</font><font papago-translate="translated"> 하지만 기본 구조는 여기에 있으며, 실행 시 실행 가능한 코드 조각을 가상 머신에서 완전히 표현하는 데 필요한 모든 것을 갖추고 있습니다.</font><font papago-translate="translated"> 우리가 Jlox에서 정의한 AST 클래스의 전체 패밀리를 기억하시나요?</font><font papago-translate="translated"> clox에서는 이를 코드 바이트, 상수 값, 디버깅을 위한 라인 정보 등 세 가지 배열로 줄였습니다.</font></p>
<p><font papago-translate="translated">이 감소가 우리의 새로운 통역사가 Jlox보다 빠를 주요 이유입니다.</font><font papago-translate="translated"> 바이트코드는 AST의 일종의 압축 직렬화로 생각할 수 있으며, 인터프리터가 실행할 때 필요한 순서대로 병렬화하는 방식에 매우 최적화되어 있습니다.</font><font papago-translate="translated"> <a href="https://youhogeon-meritz.github.io/a-virtual-machine.html">다음 장</a>에서는 가상 머신이 정확히 어떻게 작동하는지 살펴보겠습니다.</font></p>
<div class="challenges">
<h2><a href="https://youhogeon-meritz.github.io/chunks-of-bytecode.html#challenges" id="challenges"><font papago-translate="translated">과제들</font></a></h2>
<ol>
<li>
<p><font papago-translate="translated">우리의 선 정보 인코딩은 터무니없이 메모리 낭비입니다.</font><font papago-translate="translated"> 일련의 명령어가 종종 동일한 소스 라인에 해당한다는 점을 고려할 때, 자연스러운 해결책은 라인 번호<a href="https://en.wikipedia.org/wiki/Run-length_encoding">의 런 길이 인코딩</a>과 유사한 것입니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">동일한 줄에 있는 일련의 명령어에 대한 줄 정보를 압축하는 인코딩을 고안합니다.</font><font papago-translate="translated"> 바꾸다 </font></font><code translate="no">writeChunk()</code><font papago-translate="splitted"><font papago-translate="translated"> 이 압축된 양식을 작성하고 구현하기 위해 </font></font><code translate="no">getLine()</code><font papago-translate="splitted"><font papago-translate="translated"> 명령의 인덱스가 주어지면 명령이 발생하는 선을 결정하는 함수입니다.</font></font></p>
<p><em><font papago-translate="splitted"><font papago-translate="translated">힌트: 그럴 필요는 없습니다 </font></font><code translate="no">getLine()</code><font papago-translate="splitted"><font papago-translate="translated"> 특히 효율적입니다.</font><font papago-translate="translated"> 런타임 오류가 발생할 때만 호출되기 때문에 성능이 중요한 중요한 경로를 훨씬 벗어났습니다.</font></font></em></p>
</li>
<li>
<p><font papago-translate="splitted"><font papago-translate="translated">왜냐면 </font></font><code translate="no">OP_CONSTANT</code><font papago-translate="splitted"><font papago-translate="translated"> 는 피연산자에 단일 바이트만 사용하며, 청크는 최대 256개의 서로 다른 상수만 포함할 수 있습니다.</font><font papago-translate="translated"> 그것은 실제 코드를 작성하는 사람들이 그 한계에 도달할 만큼 충분히 작습니다.</font><font papago-translate="translated"> 피연산자를 저장하기 위해 두 개 이상의 바이트를 사용할 수 있지만, 이로 인해 모든 상수 명령어<em></em>가 더 많은 공간을 차지하게 됩니다.</font><font papago-translate="translated"> 대부분의 청크는 고유한 상수가 그렇게 많이 필요하지 않으므로 일반적인 경우 공간을 낭비하고 일부 지역성을 희생하여 희귀한 경우를 지원합니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">이 두 가지 경쟁 목표의 균형을 맞추기 위해 많은 명령어 세트는 동일한 연산을 수행하지만 크기가 다른 피연산자를 사용하는 여러 명령어를 특징으로 합니다.</font><font papago-translate="translated"> 기존 1바이트 그대로 두겠습니다 </font></font><code translate="no">OP_CONSTANT</code><font papago-translate="splitted"><font papago-translate="translated"> 명령어만 사용하고 초를 정의합니다 </font></font><code translate="no">OP_CONSTANT_LONG</code><font papago-translate="splitted"><font papago-translate="translated"> 설명.</font><font papago-translate="translated"> 피연산자를 24비트 숫자로 저장하는데, 이는 충분할 것입니다.</font></font></p>
<p><font papago-translate="translated">이 기능을 구현합니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="t">void</span> <span class="i">writeConstant</span>(<span class="t">Chunk</span>* <span class="i">chunk</span>, <span class="t">Value</span> <span class="i">value</span>, <span class="t">int</span> <span class="i">line</span>) {
  <span class="c">// Implement me...</span>
}
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">추가합니다 </font></font><code translate="no">value</code><font papago-translate="splitted"><font papago-translate="translated"> 로. </font></font><code translate="no">chunk</code><font papago-translate="splitted"><font papago-translate="translated">상수 배열을 작성한 다음 상수를 로드하는 적절한 명령어를 작성합니다.</font><font papago-translate="translated"> 또한 다음을 위해 분해기에 지지대를 추가합니다 </font></font><code translate="no">OP_CONSTANT_LONG</code><font papago-translate="splitted"><font papago-translate="translated"> 지침들.</font></font></p>
<p><font papago-translate="translated">두 가지 지침을 정의하는 것이 두 가지 모두의 장점인 것 같습니다.</font><font papago-translate="translated"> 어떤 희생이 우리에게 강요되나요?</font></p>
</li>
<li>
<p><font papago-translate="splitted"><font papago-translate="translated">우리들의 </font></font><code translate="no">reallocate()</code><font papago-translate="splitted"><font papago-translate="translated"> 함수는 동적 메모리 할당과 자유화를 위해 C 표준 라이브러리에 의존합니다. </font></font><code translate="no">malloc()</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">free()</code><font papago-translate="splitted"><font papago-translate="translated"> 마법은 아닙니다.</font><font papago-translate="translated"> 몇 가지 오픈 소스 구현을 찾아 작동 방식을 설명합니다.</font><font papago-translate="translated"> 할당된 바이트와 무료 바이트를 어떻게 추적할 수 있습니까?</font><font papago-translate="translated"> 메모리 블록을 할당하려면 무엇이 필요합니까?</font><font papago-translate="translated"> 해방?</font><font papago-translate="translated"> 그들은 그것을 어떻게 효율적으로 만들까요?</font><font papago-translate="translated"> 파편화에 대해 그들은 무엇을 하나요?</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated"><em>하드코어 모드:</em></font><font papago-translate="translated"> 시행하다 </font></font><code translate="no">reallocate()</code><font papago-translate="splitted"><font papago-translate="translated"> 전화 없이 </font></font><code translate="no">realloc()</code><font papago-translate="splitted"><font papago-translate="translated">, </font></font><code translate="no">malloc()</code><font papago-translate="splitted"><font papago-translate="translated">, 또는 </font></font><code translate="no">free()</code><font papago-translate="splitted"><font papago-translate="translated">. 전화할 수 있습니다 </font></font><code translate="no">malloc()</code> <font papago-translate="splitted"><font papago-translate="translated">통역사가 실행을 시작할 때, 하나의 큰 메모리 블록을 할당하기 위해<em> 한 번</em> </font></font><code translate="no">reallocate()</code><font papago-translate="splitted"><font papago-translate="translated"> 함수는 다음에 접근할 수 있습니다.</font><font papago-translate="translated"> 그것은 그 단일 영역, 즉 당신의 개인적인 더미에서 기억의 덩어리를 제거합니다.</font><font papago-translate="translated"> 그것이 어떻게 작동하는지 정의하는 것은 당신의 일입니다.</font></font></p>
</li>
</ol>
</div>
<div class="design-note">
<h2><a href="https://youhogeon-meritz.github.io/chunks-of-bytecode.html#design-note" id="design-note"><font papago-translate="translated">디자인 노트:</font><font papago-translate="translated"> 언어 테스트</font></a></h2>
<p><font papago-translate="translated">우리는 책을 거의 절반쯤 읽었는데, 한 가지 이야기하지 않은 것은 당신의 언어 구현<em>을 테스트하는</em> 것입니다.</font><font papago-translate="translated"> 그것은 테스트가 중요하지 않기 때문이 아닙니다.</font><font papago-translate="translated"> 당신의 언어를 위한 좋은 종합 시험 세트를 갖추는 것이 얼마나 중요한지 아무리 강조해도 지나치지 않습니다.</font></p>
<p><font papago-translate="translated">이 책의 한 단어를 쓰기 전에 Lox<a href="https://github.com/munificent/craftinginterpreters/tree/master/test">(</a>자신의 Lox 구현에서 사용해도 괜찮습니다)<a href="https://github.com/munificent/craftinginterpreters/tree/master/test">를 위한 테스트 스위트</a>를 작성했습니다.</font><font papago-translate="translated"> 그 테스트들은 제 구현에서 수많은 버그를 발견했습니다.</font></p>
<p><font papago-translate="translated">테스트는 모든 소프트웨어에서 중요하지만, 프로그래밍 언어에서는 최소한 몇 가지 이유로 더욱 중요합니다:</font></p>
<ul>
<li>
<p><font papago-translate="translated"><strong>사용자들은 자신들의 프로그래밍 언어가 견고할 것이라고 기대합니다.</strong></font><font papago-translate="translated"> 우리는 성숙하고 안정적인 컴파일러와 인터프리터에 너무 익숙해서 "컴파일러가 아니라 당신의 코드입니다"라는 표현이<a href="https://blog.codinghorror.com/the-first-rule-of-programming-its-always-your-fault/"> 소프트웨어 문화의 뿌리 깊은 부분입니다</a>.</font><font papago-translate="translated"> 언어 구현에 버그가 있는 경우 사용자는 무슨 일이 일어나고 있는지 파악하기 전에 슬픔의 다섯 단계를 모두 거치게 되며, 이 모든 과정을 겪고 싶지 않을 것입니다.</font></p>
</li>
<li>
<p><font papago-translate="translated"><strong>언어 구현은 깊이 연결된 소프트웨어입니다.</strong></font><font papago-translate="translated"> 일부 코드베이스는 넓고 얕습니다.</font><font papago-translate="translated"> 텍스트 편집기에서 파일 로딩 코드가 고장 나면, 파일 로딩 코드가 깨<span class="em"></span>지기를 바랍니다!</font><font papago-translate="translated">-화면에서 텍스트 렌더링에 실패하지 않습니다<span class="em">.</span></font><font papago-translate="translated"> 언어 구현은 더 좁고 깊으며, 특히 언어의 실제 의미를 처리하는 통역사의 핵심입니다.</font><font papago-translate="translated"> 이로 인해 시스템의 여러 부분 간의 이상한 상호작용으로 인해 미묘한 버그가 쉽게 침입할 수 있습니다.</font><font papago-translate="translated"> 그것들을 제거하려면 좋은 테스트가 필요합니다.</font></p>
</li>
<li>
<p><font papago-translate="translated"><strong>언어 구현의 입력은 설계상 조합적입니다.</strong></font><font papago-translate="translated"> 사용자가 작성할 수 있는 프로그램은 무수히 많으며, 구현을 통해 모든 프로그램을 올바르게 실행해야 합니다.</font><font papago-translate="translated"> 물론 그것을 완전히 테스트할 수는 없지만, 가능한 한 많은 입력 공간을 다루기 위해 열심히 노력해야 합니다.</font></p>
</li>
<li>
<p><font papago-translate="translated"><strong>언어 구현은 종종 복잡하고 끊임없이 변화하며 최적화로 가득 차 있습니다.</strong></font><font papago-translate="translated"> 그것은 버그가 숨을 수 있는 어두운 모서리가 많은 이상한 코드로 이어집니다.</font></p>
</li>
</ul>
<p><font papago-translate="translated">이 모든 것은 많은 테스트가 필요하다는 것을 의미합니다.</font><font papago-translate="translated"> 하지만<em> 어떤</em> 테스트?</font><font papago-translate="translated"> 제가 본 프로젝트들은 주로 종단 간 "언어 테스트"에 중점을 두고 있습니다.</font><font papago-translate="translated"> 각 테스트는 예상되는 출력이나 오류와 함께 언어로 작성된 프로그램입니다.</font><font papago-translate="translated"> 그런 다음 테스트 프로그램을 언어 구현을 통해 실행하고 테스트 프로그램이 원래 해야 할 일을 하는지 확인하는 테스트 러너가 있습니다.</font><font papago-translate="translated"> 시험을 언어로 작성하는 것 자체에는 몇 가지 좋은 장점이 있습니다:</font></p>
<ul>
<li>
<p><font papago-translate="translated">테스트는 구현의 특정 API 또는 내부 아키텍처 결정과 연결되지 않습니다.</font><font papago-translate="translated"> 이렇게 하면 여러 테스트를 업데이트할 필요 없이 인터프리터나 컴파일러의 일부를 재구성하거나 다시 작성할 수 있습니다.</font></p>
</li>
<li>
<p><font papago-translate="translated">언어의 여러 구현에 대해 동일한 테스트를 사용할 수 있습니다.</font></p>
</li>
<li>
<p><font papago-translate="translated">시험은 단순히 당신의 언어로 된 스크립트이기 때문에 종종 간결하고 읽기 쉽고 관리하기 쉬울 수 있습니다.</font></p>
</li>
</ul>
<p><font papago-translate="translated">하지만 모든 것이 장밋빛인 것은 아닙니다:</font></p>
<ul>
<li>
<p><font papago-translate="translated">종단 간 테스트는 버그<em>가 있는지</em> 확인하는 데 도움이 되지만, 버그<em>가 어디</em>에 있는지는 확인하지 못합니다.</font><font papago-translate="translated"> 구현에서 잘못된 코드가 어디에 있는지 파악하는 것이 더 어려울 수 있습니다. 왜냐하면 테스트 결과 올바른 출력이 나타나지 않았다는 것만 알려주기 때문입니다.</font></p>
</li>
<li>
<p><font papago-translate="translated">구현의 모호한 구석을 간지럽히는 유효한 프로그램을 만드는 것은 번거로울 수 있습니다.</font><font papago-translate="translated"> 이는 특히 고도로 최적화된 컴파일러의 경우에 해당되며, 버그가 숨어 있을 수 있는 적절한 최적화 경로를 확보하기 위해 복잡한 코드를 작성해야 할 수도 있습니다.</font></p>
</li>
<li>
<p><font papago-translate="translated">인터프리터를 부팅하고, 구문 분석하고, 컴파일하고, 각 테스트 스크립트를 실행하기 위해 오버헤드가 높을 수 있습니다.</font><font papago-translate="translated"> 대규모 테스트 세트를 사용하면 테스트<span class="em"></span><em></em><span class="em"></span>가 완료될 때까지 많은 시간을 할애할 수 있습니다.</font></p>
</li>
</ul>
<p><font papago-translate="translated">계속할 수는 있지만 설교로 변질되고 싶지는 않습니다.</font><font papago-translate="translated"> 또한, 저는 언어 테스트<em> 방법</em>에 대해 전문가인 척하지 않습니다.</font><font papago-translate="translated"> 테스트하는<em> 것</em>이 얼마나 중요한지 내면화해 주셨으면 합니다.</font><font papago-translate="translated"> 정말로.</font><font papago-translate="translated"> 당신의 언어를 테스트해 보세요.</font><font papago-translate="translated"> 저에게 감사하실 겁니다.</font></p>
</div>
<footer>
<a class="next" href="https://youhogeon-meritz.github.io/a-virtual-machine.html"><font papago-translate="translated"> 다음 장: "가상 머신" → </font></a><font papago-translate="splitted"><font papago-translate="translated"> 로버트 니스트롬이 수작업으로 제작한 -<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE"> © 2015 ~ 2021</a></font></font>
</footer>
</article>
</div>


</body></html>