<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link rel="stylesheet" type="text/css" href="cid:css-2a4661c0-8366-410e-8c6e-8af3e9a24c2a@mhtml.blink" />

<title>Control Flow · Crafting Interpreters</title>
<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta content="width=device-width, initial-scale=1" name="viewport">
<link href="https://youhogeon-meritz.github.io/style.css" rel="stylesheet" type="text/css">
<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600" rel="stylesheet" type="text/css">
<link href="https://youhogeon-meritz.github.io/image/favicon.png" rel="icon" type="image/png">


<!-- Google analytics -->

</head>
<body id="top">
<!-- <div class="scrim"></div> -->
<nav class="wide">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<div class="contents">
<h3><a href="https://youhogeon-meritz.github.io/control-flow.html#top"><font papago-translate="splitted"><font papago-translate="translated">제어 흐름</font></font><small>9</small></a></h3>
<ul>
<li><a href="https://youhogeon-meritz.github.io/control-flow.html#turing-machines-briefly"><small>9.1</small><font papago-translate="splitted"><font papago-translate="translated"> 튜링 머신 (약간)</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/control-flow.html#conditional-execution"><small>9.2</small><font papago-translate="splitted"><font papago-translate="translated"> 조건부 실행</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/control-flow.html#logical-operators"><small>9.3</small><font papago-translate="splitted"><font papago-translate="translated"> 논리 연산자</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/control-flow.html#while-loops"><small>9.4</small><font papago-translate="splitted"><font papago-translate="translated"> 루프 중</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/control-flow.html#for-loops"><small>9.5</small><font papago-translate="splitted"><font papago-translate="translated"> 루프용</font></font></a></li>
<li class="divider"></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/control-flow.html#challenges"><font papago-translate="translated">과제들</font></a></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/control-flow.html#design-note"><small><font papago-translate="translated">메모</font></small><font papago-translate="splitted"><font papago-translate="translated">통사 설탕 한 스푼</font></font></a></li>
</ul>
<div class="prev-next">
<a class="left" href="https://youhogeon-meritz.github.io/statements-and-state.html" title="진술 및 진술" papago-attr-id="1"><font papago-translate="translated">← 이전</font></a>
<a href="https://youhogeon-meritz.github.io/a-tree-walk-interpreter.html" title="나무 산책 통역사" papago-attr-id="2"><font papago-translate="translated">↑ 위로</font></a>
<a class="right" href="https://youhogeon-meritz.github.io/functions.html" title="기능들" papago-attr-id="3"><font papago-translate="translated">다음 →</font></a>
</div> </div>
</nav>
<nav class="narrow">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<a class="prev" href="https://youhogeon-meritz.github.io/statements-and-state.html" title="Statements and State">←</a>
<a class="next" href="https://youhogeon-meritz.github.io/functions.html" title="Functions">→</a>
</nav>
<div class="page">
<div class="nav-wrapper">
<nav class="floating pinned">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<div class="expandable">
<h3><a href="https://youhogeon-meritz.github.io/control-flow.html#top"><font papago-translate="splitted"><font papago-translate="translated">제어 흐름</font></font><small>9</small></a></h3>
<ul>
<li><a href="https://youhogeon-meritz.github.io/control-flow.html#turing-machines-briefly"><small>9.1</small><font papago-translate="splitted"><font papago-translate="translated"> 튜링 머신 (약간)</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/control-flow.html#conditional-execution"><small>9.2</small><font papago-translate="splitted"><font papago-translate="translated"> 조건부 실행</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/control-flow.html#logical-operators"><small>9.3</small><font papago-translate="splitted"><font papago-translate="translated"> 논리 연산자</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/control-flow.html#while-loops"><small>9.4</small><font papago-translate="splitted"><font papago-translate="translated"> 루프 중</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/control-flow.html#for-loops"><small>9.5</small><font papago-translate="splitted"><font papago-translate="translated"> 루프용</font></font></a></li>
<li class="divider"></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/control-flow.html#challenges">Challenges</a></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/control-flow.html#design-note"><small>note</small><font papago-translate="splitted"><font papago-translate="translated">통사 설탕 한 스푼</font></font></a></li>
</ul>
<div class="prev-next">
<a class="left" href="https://youhogeon-meritz.github.io/statements-and-state.html" title="Statements and State">←&nbsp;Previous</a>
<a href="https://youhogeon-meritz.github.io/a-tree-walk-interpreter.html" title="A Tree-Walk Interpreter">↑&nbsp;Up</a>
<a class="right" href="https://youhogeon-meritz.github.io/functions.html" title="Functions">Next&nbsp;→</a>
</div> </div>
<a id="expand-nav">≡</a>
</nav>
</div>
<article class="chapter">
<div class="number">9</div>
<h1><font papago-translate="translated">제어 흐름</font></h1>
<blockquote>
<p><font papago-translate="translated">논리는 위스키와 마찬가지로 너무 많은 양을 섭취하면 유익한 효과를 잃게 됩니다.</font></p>
<p><cite>Edward John Moreton Drax Plunkett, Lord Dunsany</cite></p>
</blockquote>
<p><font papago-translate="translated"><a href="https://youhogeon-meritz.github.io/statements-and-state.html">지난 장의</a> 혹독한 마라톤과 비교하면, 오늘은 데이지 초원을 통과하는 가벼운 장난입니다.</font><font papago-translate="translated"> 하지만 일은 쉽지만 보상은 의외로 큽니다.</font></p>
<p><font papago-translate="translated">현재 저희 통역사는 계산기에 불과합니다.</font><font papago-translate="translated"> Lox 프로그램은 완료하기 전에 정해진 양의 작업만 수행할 수 있습니다.</font><font papago-translate="translated"> 소스 코드를 두 배로 길게 만들려면 소스 코드를 두 배로 길게 만들어야 합니다.</font><font papago-translate="translated"> 우리는 곧 그것을 고치려고 합니다.</font><font papago-translate="translated"> 이 장에서 우리 통역사는 프로그래밍 언어 메이저 리그를 향한 큰 발걸음을 내딛습니다:</font><font papago-translate="translated"> <em>튜링 완전성.</em></font></p>
<h2><a href="https://youhogeon-meritz.github.io/control-flow.html#turing-machines-briefly" id="turing-machines-briefly"><small><font papago-translate="translated">9 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">튜링 머신 (약간)</font></font></a></h2>
<p><font papago-translate="translated">지난 세기 초, 수학자들은 일련의 혼란<span name="paradox">스러운 역설</span>에 부딪혀 자신들이 쌓아온 기초의 안정성을 의심하게 되었습니다.</font><font papago-translate="translated"> 그<a href="https://en.wikipedia.org/wiki/Foundations_of_mathematics#Foundational_crisis"> 위기</a>를 해결하기 위해 그들은 원점으로 돌아갔습니다.</font><font papago-translate="translated"> 소수의 공리, 논리, 집합론에서 출발하여, 그들은 불굴의 기초 위에 수학을 재건하기를 희망했습니다.</font></p>
<aside name="paradox" style="top: 700px;">
<p><font papago-translate="translated">가장 유명한<a href="https://en.wikipedia.org/wiki/Russell%27s_paradox"><strong> 것</strong></a>은<a href="https://en.wikipedia.org/wiki/Russell%27s_paradox"><strong> 러셀의 역설</strong></a>입니다.</font><font papago-translate="translated"> 처음에는 집합 이론을 통해 모든 종류의 집합을 정의할 수 있었습니다.</font><font papago-translate="translated"> 영어로 설명할 수 있다면 유효했습니다.</font><font papago-translate="translated"> 당연히 수학자들이 자기 참조를 선호하기 때문에, 집합은 다른 집합을 포함할 수 있습니다.</font><font papago-translate="translated"> 그래서 러셀은 정말 악당이었습니다:</font></p>
<p><em><font papago-translate="translated">R은 자신을 포함하지 않는 모든 집합의 집합입니다.</font></em></p>
<p><font papago-translate="translated">R에는 자체가 포함되어 있습니까?</font><font papago-translate="translated"> 그렇지 않다면 정의의 후반부에 따라 해야 합니다.</font><font papago-translate="translated"> 하지만 그렇게 되면 더 이상 정의를 충족하지 못합니다.</font><font papago-translate="translated"> 큐 마인드 폭발.</font></p>
</aside>
<p><font papago-translate="translated">그들은 "모든 참된 진술이 증명될 수 있는가?", "우리가 정의할 수 있는 모든 함수<a href="https://en.wikipedia.org/wiki/Computable_function">를 계산</a>할 수 있는가?", 또는 "함수가 '계산 가능하다'고 주장하는 것이 무엇을 의미하는가?"와 같은 질문에 엄격하게 답하고 싶어 했습니다</font></p>
<p><font papago-translate="translated">그들은 처음 두 질문에 대한 답이 "예"라고 가정했습니다.</font><font papago-translate="translated"> 남은 것은 그것을 증명하는 것뿐이었습니다.</font><font papago-translate="translated"> 알고 보니 두 가지 모두에 대한 답은 "아니오"이며, 놀랍게도 두 질문은 깊이 얽혀 있습니다.</font><font papago-translate="translated"> 이것은 뇌가 무엇을 할 수 있고 우주가 어떻게 작동하는지에 대한 근본적인 질문을 다루는 흥미로운 수학의 한 부분입니다.</font><font papago-translate="translated"> 여기서는 공정하게 할 수 없습니다.</font></p>
<p><font papago-translate="translated">제가 주목하고 싶은 것은 처음 두 질문에 대한 답이 "아니오"라는 것을 증명하는 과정에서 앨런 튜링과 알론조 처치가 마지막 질문에 대한 정확한 답, 즉<span name="uncomputable"> 어떤</span> 종류의 함수<span name="uncomputable">가 계산</span><span class="em"></span><span name="uncomputable"> 가능</span>한지에 대한 정의를 고안했다는 점입니다.</font><font papago-translate="translated"> 그들은 각각 (매우) 큰 함수 클래스를 계산할 수 있을 만큼 여전히 강력한 최소한의 기계 세트를 갖춘 작은 시스템을 만들었습니다.</font></p>
<aside name="uncomputable" style="top: 1132px;">
<p><font papago-translate="translated">그들은 주어진 문장의 진리 값을 반환하는 함수가 계산 가능한 함수<em>가 아님</em>을 보여줌으로써 첫 번째 질문에 대한 답이 "아니오"임을 증명했습니다.</font></p>
</aside>
<p><font papago-translate="translated">이것들은 이제 "계산 가능한 함수"로 간주됩니다.</font><font papago-translate="translated"> 튜링의 시스템은<span name="turing"><strong> 튜링 머신</strong></span>이라고 불립니다.</font><font papago-translate="translated"> Church's는<strong> 람다 계산법</strong>입니다.</font><font papago-translate="translated" class="papago-selected"> 둘 다 여전히 계산 모델의 기초로 널리 사용되고 있으며, 실제로 많은 현대 함수형 프로그래밍 언어들은 그 핵심에 람다 계산법을 사용합니다.</font></p>
<aside name="turing" style="top: 1228px;">
<p><font papago-translate="translated">튜링은 자신의 발명품을 "자동"을 의미하는 "a-기계"라고 불렀습니다.</font><font papago-translate="translated"> 그는 자신<em>의</em> 이름을 붙일 만큼 자만심이 강하지 않았습니다.</font><font papago-translate="translated"> 나중에 수학자들이 그를 위해 그렇게 했습니다.</font><font papago-translate="translated"> 그렇게 하면 겸손함을 유지하면서도 유명해집니다.</font></p>
</aside><img alt="A Turing machine." src="https://youhogeon-meritz.github.io/image/control-flow/turing-machine.png">
<p><font papago-translate="translated">튜링 기계는 더 나은 이름 인식을 가지고 있습니다. 알론조 교회에 관한 할리우드 영화는 아직 없지만, 두 형식은<span class="em"></span><span class="em"></span><a href="https://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis"> 동등한 힘을</a> 가지고 있습니다.</font><font papago-translate="translated"> 사실, 표현력이 어느 정도 낮은 프로그래밍 언어는<em> 어떤</em> 계산 가능한 함수<em>도</em> 계산할 수 있을 만큼 강력합니다.</font></p>
<p><font papago-translate="translated">튜링 기계를 위한 시뮬레이터를 당신의 언어로 작성함으로써 그것을 증명할 수 있습니다.</font><font papago-translate="translated"> 튜링이 자신의 기계가 어떤 계산 가능한 함수도 계산할 수 있다는 것을 증명했기 때문에, 이는 언어도 계산할 수 있다는 것을 의미합니다.</font><font papago-translate="translated"> 함수를 튜링 기계로 변환한 다음 시뮬레이터에서 실행하기만 하면 됩니다.</font></p>
<p><font papago-translate="translated">만약 당신의 언어가 그렇게 할 만큼 충분히 표현력이 있다면<strong>, 그것</strong>은 튜<strong>링 완전체</strong>로 간주됩니다.</font><font papago-translate="translated"> 튜링 기계는 매우 간단하기 때문에 이 작업을 수행하는 데 큰 힘이 들지 않습니다.</font><font papago-translate="translated"> 기본적으로 산술, 약간의 제어 흐름, 그리고 (이론적으로) 임의의 양의 메모리를 할당하고 사용할 수 있는 능력이 필요합니다.</font><font papago-translate="translated"> 첫 번째가 있습니다.</font><font papago-translate="translated"> 이 장이 끝날 때쯤<span name="memory">이면 두 번째</span> 장을 보게 될 것입니다.</font></p>
<aside name="memory" style="top: 2038.5px;">
<p><font papago-translate="translated">세 번째 것도<em> 거의</em> 다 있습니다.</font><font papago-translate="translated"> 임의의 크기의 문자열을 생성하고 연결할 수 있으므로 무제한 메모리<em>를 저장</em>할 수 있습니다.</font><font papago-translate="translated"> 하지만 문자열의 일부에 접근할 방법이 없습니다.</font></p>
</aside>
<h2><a href="https://youhogeon-meritz.github.io/control-flow.html#conditional-execution" id="conditional-execution"><small><font papago-translate="translated">9 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">조건부 실행</font></font></a></h2>
<p><font papago-translate="translated">충분한 역사를 바탕으로, 우리의 언어를 새롭게 만들어 봅시다.</font><font papago-translate="translated"> 제어 흐름은 대략 두 가지 종류로 나눌 수 있습니다:</font></p>
<ul>
<li>
<p><font papago-translate="translated"><strong>조건</strong><strong>부 또는 분기 제어 흐름은</strong> 코드 조각을 실행<em>하지</em> 않는 데 사용됩니다<strong>.</strong></font><font papago-translate="translated"> 긴급하게<em></em>도 코드의 한 영역을 뛰어넘는다고 생각할 수 있습니다.</font></p>
</li>
<li>
<p><font papago-translate="translated"><strong>제어 흐름을 반복하면</strong> 코드 덩어리가 여러 번 실행<strong>됩니다.</strong></font><font papago-translate="translated"> <em>다시</em> 무언가를 할 수 있도록<em> 뒤로</em> 튕겨 나갑니다.</font><font papago-translate="translated"> 일반적으로<em> 무한</em> 루프를 원하지 않기 때문에 루프를 중단해야 할 때를 알 수 있는 조건부 논리가 있습니다.</font></p>
</li>
</ul>
<p><font papago-translate="splitted"><font papago-translate="translated">분기는 더 간단하므로 거기서부터 시작하겠습니다.</font><font papago-translate="translated"> C 파생 언어에는 두 가지 주요 조건부 실행 기능이 있습니다 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 문장과 특이하게 명명된 "조건<span name="ternary">부" 연산자</span> (</font></font><code translate="no">?:</code><font papago-translate="splitted"><font papago-translate="translated">). 안 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 문은 문을 조건부로 실행할 수 있게 해주며, 조건부 연산자는 표현식을 조건부로 실행할 수 있게 해줍니다.</font></font></p>
<aside name="ternary" style="top: 2494.5px;">
<p><font papago-translate="translated">조건 연산자는 C에서 세 개의 피연산자를 사용하는 유일한 연산자이기 때문에 "삼차 연산자"라고도 불립니다.</font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">간단히 하기 위해 Lox에는 조건부 연산자가 없으므로 다음과 같이 합시다 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 에 대한 설명.</font><font papago-translate="translated"> 우리의 문장 문법은 새로운 형식을 갖추게 됩니다.</font></font></p>
<p><span name="semicolon"></span></p>
<div class="codehilite"><pre translate="no"><span class="i">statement</span>      → <span class="i">exprStmt</span>
               | <span class="i">ifStmt</span>
               | <span class="i">printStmt</span>
               | <span class="i">block</span> ;

<span class="i">ifStmt</span>         → <span class="s">"if"</span> <span class="s">"("</span> <span class="i">expression</span> <span class="s">")"</span> <span class="i">statement</span>
               ( <span class="s">"else"</span> <span class="i">statement</span> )? ;
</pre></div>
<aside name="semicolon" style="top: 2660.5px;">
<p><font papago-translate="splitted"><font papago-translate="translated">규칙의 세미콜론은 인용되지 않으므로 Lox의 구문이 아닌 문법 메타신택스의 일부입니다.</font><font papago-translate="translated"> 블록에는 다음이 없습니다 </font></font><code translate="no">;</code><font papago-translate="splitted"><font papago-translate="translated"> 마지막에 그리고 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 문장은 세미콜론으로 끝나는 문장이 아니면 그렇지 않습니다.</font></font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">안 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 문에는 조건에 대한 표현이 있고, 조건이 사실일 경우 실행할 문이 있습니다.</font><font papago-translate="translated"> 선택적으로 다음과 같은 기능을 가질 수도 있습니다 </font></font><code translate="no">else</code><font papago-translate="splitted"><font papago-translate="translated"> 키워드와 조건이 거짓일 경우 실행할 문.</font><font papago-translate="translated"> <span name="if-ast">구문 트리 노드에는</span> 이 세 조각 각각에 대한 필드가 있습니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      "Expression : Expr expression",
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">도구/GenerateAst.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>메인</em> ()에서</font></font></div>
<pre class="insert" translate="no">      <span class="s">"If         : Expr condition, Stmt thenBranch,"</span> +
                  <span class="s">" Stmt elseBranch"</span>,
</pre><pre class="insert-after" translate="no">      "Print      : Expr expression",
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>main</em>()</div>
<aside name="if-ast" style="top: 2874.5px;">
<p><font papago-translate="translated">새 노드에 대한 생성된 코드는 부록<a href="https://youhogeon-meritz.github.io/appendix-ii.html#if-statement"> II</a>에 있습니다.</font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">다른 진술과 마찬가지로 파서는 다음을 인식합니다 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 선도자의 진술 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 키워드.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  private Stmt statement() {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>성명</em>서 ()에서</font></font></div>
<pre class="insert" translate="no">    <span class="k">if</span> (<span class="i">match</span>(<span class="i">IF</span>)) <span class="k">return</span> <span class="i">ifStatement</span>();
</pre><pre class="insert-after" translate="no">    if (match(PRINT)) return printStatement();
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>statement</em>()</div>
<p><font papago-translate="translated">하나를 찾으면 이 새로운 메서드를 호출하여 나머지를 구문 분석합니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>문</em> 뒤에 () 추가</font></font></div>
<pre translate="no">  <span class="k">private</span> <span class="t">Stmt</span> <span class="i">ifStatement</span>() {
    <span class="i">consume</span>(<span class="i">LEFT_PAREN</span>, <span class="s">"Expect '(' after 'if'."</span>);
    <span class="t">Expr</span> <span class="i">condition</span> = <span class="i">expression</span>();
    <span class="i">consume</span>(<span class="i">RIGHT_PAREN</span>, <span class="s">"Expect ')' after if condition."</span>);<span name="parens"> </span>

    <span class="t">Stmt</span> <span class="i">thenBranch</span> = <span class="i">statement</span>();
    <span class="t">Stmt</span> <span class="i">elseBranch</span> = <span class="k">null</span>;
    <span class="k">if</span> (<span class="i">match</span>(<span class="i">ELSE</span>)) {
      <span class="i">elseBranch</span> = <span class="i">statement</span>();
    }

    <span class="k">return</span> <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">If</span>(<span class="i">condition</span>, <span class="i">thenBranch</span>, <span class="i">elseBranch</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>statement</em>()</div>
<aside name="parens" style="top: 3265.5px;">
<p><font papago-translate="splitted"><font papago-translate="translated">조건 주변의 괄호는 절반만 유용합니다.</font><font papago-translate="translated"> 조건과 그 다음 문장<em> 사이에</em> 일종의 구분 기호가 필요합니다. 그렇지 않으면 파서는 조건 표현식의 끝에 도달했는지 알 수 없습니다.</font><font papago-translate="translated"> 하지만 그 후<em>의 첫</em> 괄호는 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 유용한 기능을 하지 않습니다.</font><font papago-translate="translated"> 데니스 리치가 사용할 수 있도록 거기에 두었습니다 </font></font><code translate="no">)</code><font papago-translate="splitted"><font papago-translate="translated"> 괄호가 불균형하지 않은 끝 구분 기호로 사용됩니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">Lua와 같은 다른 언어와 일부 BASIC는 다음과 같은 키워드를 사용합니다 </font></font><code translate="no">then</code><font papago-translate="splitted"><font papago-translate="translated"> 끝 구분 기호로 사용되며 조건 앞에 아무것도 없습니다.</font><font papago-translate="translated"> Go와 Swift는 대신 문장을 괄호로 묶어야 합니다.</font><font papago-translate="translated"> 이를 통해 다음을 사용할 수 있습니다 </font></font><code translate="no">{</code><font papago-translate="splitted"><font papago-translate="translated"> 조건이 완료되었을 때를 알려주는 문장의 시작 부분.</font></font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">평소처럼 구문 분석 코드는 문법에 가깝게 흐릅니다.</font><font papago-translate="translated"> 이전 조항을 찾아 다른 조항을 감지합니다 </font></font><code translate="no">else</code><font papago-translate="splitted"><font papago-translate="translated"> 키워드.</font><font papago-translate="translated"> 만약 없다면 </font></font><code translate="no">elseBranch</code><font papago-translate="splitted"><font papago-translate="translated"> 구문 트리의 필드는 다음과 같습니다 </font></font><code translate="no">null</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p>
<p><font papago-translate="translated">무해해 보이는 다른 선택 사항은 사실 우리 문법에 모호함을 열어주었습니다.</font><font papago-translate="translated"> 고려:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">if</span> (<span class="i">first</span>) <span class="k">if</span> (<span class="i">second</span>) <span class="i">whenTrue</span>(); <span class="k">else</span> <span class="i">whenFalse</span>();
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">수수께끼는 다음과 같습니다:</font><font papago-translate="translated"> 어떤. </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 그 다른 조항은 해당 조항에 속합니까?</font><font papago-translate="translated"> 이것은 우리가 문법을 어떻게 표기하는지에 대한 단순한 이론적 질문이 아닙니다.</font><font papago-translate="translated"> 실제로 코드가 실행되는 방식에 영향을 미칩니다:</font></font></p>
<ul>
<li>
<p><font papago-translate="splitted"><font papago-translate="translated">다른 것을 첫 번째에 붙이면 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 진술, 그러면 </font></font><code translate="no">whenFalse()</code><font papago-translate="splitted"><font papago-translate="translated"> 다음과 같은 경우 </font></font><code translate="no">first</code><font papago-translate="splitted"><font papago-translate="translated"> 값에 상관없이 거짓입니다 </font></font><code translate="no">second</code><font papago-translate="splitted"><font papago-translate="translated"> 가지다.</font></font></p>
</li>
<li>
<p><font papago-translate="splitted"><font papago-translate="translated">두 번째에 부착하면 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 진술, 그러면 </font></font><code translate="no">whenFalse()</code><font papago-translate="splitted"><font papago-translate="translated"> 다음과 같은 경우에만 호출됩니다 </font></font><code translate="no">first</code><font papago-translate="splitted"><font papago-translate="translated"> 는 진실입니다 </font></font><code translate="no">second</code><font papago-translate="splitted"><font papago-translate="translated"> 거짓입니다.</font></font></p>
</li>
</ul>
<p><font papago-translate="splitted"><font papago-translate="translated">다른 절은 선택 사항이며 끝을 표시하는 명확한 구분 기호가 없기 때문입니다 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 문장, 둥지를 틀면 문법이 모호합니다 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated">이런 식으로 s.</font><font papago-translate="translated"> 이 고전적인 구문의 함정을<strong><a href="https://en.wikipedia.org/wiki/Dangling_else"> 매달림 다른</a></strong> 문제라고 합니다.</font></font></p>
<p><span name="else"></span></p><img alt="Two ways the else can be interpreted." class="above" src="https://youhogeon-meritz.github.io/image/control-flow/dangling-else.png">
<aside name="else" style="top: 4036.5px;">
<p><font papago-translate="translated">여기서 형식 지정은 다른 두 가지 방법을 강조합니다.</font><font papago-translate="translated"> 하지만 공백 문자는 파서에 의해 무시되므로, 이는 단지 인간 독자를 위한 안내서일 뿐입니다.</font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">문맥 자유 문법을 정의하는 것은 모호성을 직접 피하는 것이 가능하지만, 대부분의 문장 규칙을 쌍으로 나누어야<em></em> 합니다. 이 쌍은 다음을 가능하게 합니다 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 와 함께 </font></font><code translate="no">else</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고 그렇지 않은 것.</font><font papago-translate="translated"> 짜증나요.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">대신 대부분의 언어와 파서는 임시방편으로 문제를 피합니다.</font><font papago-translate="translated"> 어떤 해킹을 사용하여 문제를 해결하더라도 항상 동일한 해석<span class="em"></span>을 선택합니다— </font></font><code translate="no">else</code><font papago-translate="splitted"><font papago-translate="translated"> 가장 가까운 곳에 묶여 있습니다 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 그 이전에.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">저희 파서는 이미 편리하게 그렇게 하고 있습니다.</font><font papago-translate="translated"> 부터 </font></font><code translate="no">ifStatement()</code><font papago-translate="splitted"><font papago-translate="translated"> 간절히 찾습니다 </font></font><code translate="no">else</code><font papago-translate="splitted"><font papago-translate="translated"> 반환하기 전에 중첩된 시리즈의 가장 안쪽 호출은 외부로 돌아가기 전에 스스로 다른 절을 주장합니다 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 진술들.</font></font></p>
<p><font papago-translate="translated">구문을 이해하면 우리는 해석할 준비가 되었습니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Interpreter.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>방문</em> 후 추가Ex<em>pressionStmt</em>()</font></font></div>
<pre translate="no">  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitIfStmt</span>(<span class="t">Stmt</span>.<span class="t">If</span> <span class="i">stmt</span>) {
    <span class="k">if</span> (<span class="i">isTruthy</span>(<span class="i">evaluate</span>(<span class="i">stmt</span>.<span class="i">condition</span>))) {
      <span class="i">execute</span>(<span class="i">stmt</span>.<span class="i">thenBranch</span>);
    } <span class="k">else</span> <span class="k">if</span> (<span class="i">stmt</span>.<span class="i">elseBranch</span> != <span class="k">null</span>) {
      <span class="i">execute</span>(<span class="i">stmt</span>.<span class="i">elseBranch</span>);
    }
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>visitExpressionStmt</em>()</div>
<p><font papago-translate="translated">인터프리터 구현은 자체 동일한 Java 코드 주변의 얇은 래퍼입니다.</font><font papago-translate="translated"> 상태를 평가합니다.</font><font papago-translate="translated"> 사실이라면 그때 분기를 실행합니다.</font><font papago-translate="translated"> 그렇지 않으면 다른 분기가 있으면 실행됩니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">이 코드를 우리가 구현한 다른 구문을 인터프리터가 처리하는 방식과 비교하면, 제어 흐름을 특별하게 만드는 부분은 Java입니다 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 진술.</font><font papago-translate="translated"> 대부분의 다른 구문 트리는 항상 하위 트리를 평가합니다.</font><font papago-translate="translated"> 여기서 우리는 그때나 다른 진술을 평가하지 않을 수 있습니다.</font><font papago-translate="translated"> 둘 중 하나라도 부작용이 발생하면, 이를 평가하지 않을 선택이 사용자에게 눈에 띄게 됩니다.</font></font></p>
<h2><a href="https://youhogeon-meritz.github.io/control-flow.html#logical-operators" id="logical-operators"><small><font papago-translate="translated">9 . 3</font></small><font papago-translate="splitted"><font papago-translate="translated">논리 연산자</font></font></a></h2>
<p><font papago-translate="splitted"><font papago-translate="translated">조건부 연산자가 없기 때문에 분기가 끝났다고 생각할 수 있지만, 그렇지 않습니다.</font><font papago-translate="translated"> 삼항 연산자가 없더라도 기술적으로 제어 흐름 구성<span class="em"> 요소</span>인 논리 연산자라는 두 가지 다른 연산자가 있습니다 </font></font><code translate="no">and</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">or</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p>
<p><font papago-translate="translated"><strong>이것</strong>들은<strong> 단락</strong>되기 때문에 다른 이진 연산자들과는 다릅니다.</font><font papago-translate="translated"> 왼쪽 피연산자를 평가한 후 논리식의 결과가 무엇인지 알게 되면, 올바른 피연산자를 평가하지 않습니다.</font><font papago-translate="translated"> 예를 들어:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">false</span> <span class="k">and</span> <span class="i">sideEffect</span>();
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">잠시 동안 </font></font><code translate="no">and</code><font papago-translate="splitted"><font papago-translate="translated"> 진정한 것을 평가하기 위한 표현은 두 피연산자 모두 진정한 것이어야 합니다.</font><font papago-translate="translated"> 왼쪽을 평가하면 바로 알 수 있습니다 </font></font><code translate="no">false</code><font papago-translate="splitted"><font papago-translate="translated"> 그렇지 않을 것이므로 평가할 필요가 없다고 피연산자는 말합니다 </font></font><code translate="no">sideEffect()</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고 건너뛸 수 있습니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">이것이 우리가 다른 이진 연산자들과 논리 연산자를 구현하지 않은 이유입니다.</font><font papago-translate="translated"> 이제 준비되었습니다.</font><font papago-translate="translated"> 두 개의 새로운 연산자는 우선순위 표에서 낮습니다.</font><font papago-translate="translated"> 유사하게 </font></font><code translate="no">||</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">&amp;&amp;</code><font papago-translate="splitted"><font papago-translate="translated"> C에서는 각각<span name="logical"></span> 다음과 같은 우선순위를 가지고 있습니다 </font></font><code translate="no">or</code><font papago-translate="splitted"><font papago-translate="translated"> 보다 낮은 </font></font><code translate="no">and</code><font papago-translate="splitted"><font papago-translate="translated">. 우리는 그것들을 바로 사이에 배치합니다 </font></font><code translate="no">assignment</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">equality</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p>
<aside name="logical" style="top: 5469px;">
<p><font papago-translate="translated">저는 왜 다양한 비교나 평등 연산자처럼 동일한 우선순위를 가지지 않는지 항상 궁금했습니다.</font></p>
</aside>
<div class="codehilite"><pre translate="no"><span class="i">expression</span>     → <span class="i">assignment</span> ;
<span class="i">assignment</span>     → <span class="t">IDENTIFIER</span> <span class="s">"="</span> <span class="i">assignment</span>
               | <span class="i">logic_or</span> ;
<span class="i">logic_or</span>       → <span class="i">logic_and</span> ( <span class="s">"or"</span> <span class="i">logic_and</span> )* ;
<span class="i">logic_and</span>      → <span class="i">equality</span> ( <span class="s">"and"</span> <span class="i">equality</span> )* ;
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">뒤로 물러나는 대신 </font></font><code translate="no">equality</code><font papago-translate="splitted"><font papago-translate="translated">, </font></font><code translate="no">assignment</code><font papago-translate="splitted"><font papago-translate="translated"> 이제 계단식으로 이어집니다 </font></font><code translate="no">logic_or</code><font papago-translate="splitted"><font papago-translate="translated">. 두 가지 새로운 규칙, </font></font><code translate="no">logic_or</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">logic_and</code><font papago-translate="splitted"><font papago-translate="translated">, 는 다른 이진 연산자와<span name="same"> 유사합니다</span>.</font><font papago-translate="translated"> 그리고나서 </font></font><code translate="no">logic_and</code><font papago-translate="splitted"><font papago-translate="translated"> 호출 </font></font><code translate="no">equality</code><font papago-translate="splitted"><font papago-translate="translated"> 피연산자의 피연산자에 대해, 그리고 우리는 나머지 표현 규칙들로 다시 연결됩니다.</font></font></p>
<aside name="same" style="top: 5737px;">
<p><font papago-translate="translated"><em>구문은</em> 단락 여부를 신경 쓰지 않습니다.</font><font papago-translate="translated"> 그것은 의미론적인 문제입니다.</font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">기존 Exper를 재사용할 수 있습니다.</font><font papago-translate="translated">이 두 새로운 표현식은 동일한 필드를 가지고 있기 때문에 이진 클래스입니다.</font><font papago-translate="translated"> 그러나 </font></font><code translate="no">visitBinaryExpr()</code><font papago-translate="splitted"><font papago-translate="translated"> 연산자가 논리 연산자 중 하나인지 확인하고 다른 코드 경로를 사용하여 단락을 처리해야 합니다.</font><font papago-translate="translated"> 이 운영자들이 자신만의 방문 방법을 가질 수 있도록<span name="logical-ast"> 새로운 클래스</span>를 정의하는 것이 더 깔끔하다고 생각합니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      "Literal  : Object value",
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">도구/GenerateAst.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>메인</em> ()에서</font></font></div>
<pre class="insert" translate="no">      <span class="s">"Logical  : Expr left, Token operator, Expr right"</span>,
</pre><pre class="insert-after" translate="no">      "Unary    : Token operator, Expr right",
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>main</em>()</div>
<aside name="logical-ast" style="top: 5881px;">
<p><font papago-translate="translated">새 노드에 대한 생성된 코드는 부록<a href="https://youhogeon-meritz.github.io/appendix-ii.html#logical-expression"> II</a>에 있습니다.</font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">새로운 표현식을 파서에 엮으려면 먼저 할당할 파싱 코드를 호출하도록 변경합니다 </font></font><code translate="no">or()</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  private Expr assignment() {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>과제</em> ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">    <span class="t">Expr</span> <span class="i">expr</span> = <span class="i">or</span>();
</pre><pre class="insert-after" translate="no">
    if (match(EQUAL)) {
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>assignment</em>(), replace 1 line</div>
<p><font papago-translate="splitted"><font papago-translate="translated">일련의 구문 분석 코드 </font></font><code translate="no">or</code><font papago-translate="splitted"><font papago-translate="translated"> 표현식은 다른 이진 연산자를 반영합니다.</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>할당</em> 후 () 추가</font></font></div>
<pre translate="no">  <span class="k">private</span> <span class="t">Expr</span> <span class="i">or</span>() {
    <span class="t">Expr</span> <span class="i">expr</span> = <span class="i">and</span>();

    <span class="k">while</span> (<span class="i">match</span>(<span class="i">OR</span>)) {
      <span class="t">Token</span> <span class="i">operator</span> = <span class="i">previous</span>();
      <span class="t">Expr</span> <span class="i">right</span> = <span class="i">and</span>();
      <span class="i">expr</span> = <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Logical</span>(<span class="i">expr</span>, <span class="i">operator</span>, <span class="i">right</span>);
    }

    <span class="k">return</span> <span class="i">expr</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>assignment</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">피연산자는 다음으로 높은 수준의 우선순위인 새로운 피연산자입니다 </font></font><code translate="no">and</code><font papago-translate="splitted"><font papago-translate="translated"> 표현.</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 뒤에 추가<em> 또는</em> ()</font></font></div>
<pre translate="no">  <span class="k">private</span> <span class="t">Expr</span> <span class="i">and</span>() {
    <span class="t">Expr</span> <span class="i">expr</span> = <span class="i">equality</span>();

    <span class="k">while</span> (<span class="i">match</span>(<span class="i">AND</span>)) {
      <span class="t">Token</span> <span class="i">operator</span> = <span class="i">previous</span>();
      <span class="t">Expr</span> <span class="i">right</span> = <span class="i">equality</span>();
      <span class="i">expr</span> = <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Logical</span>(<span class="i">expr</span>, <span class="i">operator</span>, <span class="i">right</span>);
    }

    <span class="k">return</span> <span class="i">expr</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>or</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">그것은 전화입니다 </font></font><code translate="no">equality()</code><font papago-translate="splitted"><font papago-translate="translated"> 그 피연산자들을 위해, 그리고 그것으로 표현 파서가 다시 연결됩니다.</font><font papago-translate="translated"> 우리는 통역할 준비가 되었습니다.</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Interpreter.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>방문</em> 후 추가L<em>iteralEx</em>pr()</font></font></div>
<pre translate="no">  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Object</span> <span class="i">visitLogicalExpr</span>(<span class="t">Expr</span>.<span class="t">Logical</span> <span class="i">expr</span>) {
    <span class="t">Object</span> <span class="i">left</span> = <span class="i">evaluate</span>(<span class="i">expr</span>.<span class="i">left</span>);

    <span class="k">if</span> (<span class="i">expr</span>.<span class="i">operator</span>.<span class="i">type</span> == <span class="t">TokenType</span>.<span class="i">OR</span>) {
      <span class="k">if</span> (<span class="i">isTruthy</span>(<span class="i">left</span>)) <span class="k">return</span> <span class="i">left</span>;
    } <span class="k">else</span> {
      <span class="k">if</span> (!<span class="i">isTruthy</span>(<span class="i">left</span>)) <span class="k">return</span> <span class="i">left</span>;
    }

    <span class="k">return</span> <span class="i">evaluate</span>(<span class="i">expr</span>.<span class="i">right</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>visitLiteralExpr</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">이것을<a href="https://youhogeon-meritz.github.io/evaluating-expressions.html"> 이전 장의</a></font></font> <code translate="no">visitBinaryExpr()</code><font papago-translate="splitted"><font papago-translate="translated"> 방법, 차이점을 확인할 수 있습니다.</font><font papago-translate="translated"> 여기서는 먼저 왼쪽 피연산자를 평가합니다.</font><font papago-translate="translated"> 단락이 가능한지 확인하기 위해 그 가치를 살펴봅니다.</font><font papago-translate="translated"> 그렇지 않다면, 그때서야 올바른 피연산자를 평가할 수 있습니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">여기서 또 다른 흥미로운 점은 실제 반환할 가치를 결정하는 것입니다.</font><font papago-translate="translated"> Lox는 동적으로 입력되므로 모든 유형의 피연산자를 허용하고 진실성을 사용하여 각 피연산자가 무엇을 나타내는지 결정합니다.</font><font papago-translate="translated"> 우리는 결과에 유사한 추론을 적용합니다.</font><font papago-translate="translated"> 문자 그대로 돌아오겠다고 약속하는 대신 </font></font><code translate="no">true</code><font papago-translate="splitted"><font papago-translate="translated"> 또는 </font></font><code translate="no">false</code><font papago-translate="splitted"><font papago-translate="translated">, 논리 연산자는 적절한 진실성을 가진 값을 반환할 것을 보장할 뿐입니다.</font></font></p>
<p><font papago-translate="translated">다행히도, 우리는 적절한 진실성을 지닌 가치를 바로 눈앞에 두고 있습니다. 바로 피연산자<span class="em"></span>들의 결과입니다.</font><font papago-translate="translated"> 그래서 우리는 그것들을 사용합니다.</font><font papago-translate="translated"> 예를 들어:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">print</span> <span class="s">"hi"</span> <span class="k">or</span> <span class="n">2</span>; <span class="c">// "hi".</span>
<span class="k">print</span> <span class="k">nil</span> <span class="k">or</span> <span class="s">"yes"</span>; <span class="c">// "yes".</span>
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">첫 번째 줄에서, </font></font><code translate="no">"hi"</code><font papago-translate="splitted"><font papago-translate="translated"> 사실입니다, 그래서 </font></font><code translate="no">or</code><font papago-translate="splitted"><font papago-translate="translated"> 단기 circuits을 하고 그것을 반환합니다.</font><font papago-translate="translated"> 두 번째 줄이요. </font></font><code translate="no">nil</code><font papago-translate="splitted"><font papago-translate="translated"> 거짓이므로 두 번째 피연산자를 평가하고 반환합니다, </font></font><code translate="no">"yes"</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p>
<p><font papago-translate="translated">이는 Lox의 모든 분기 프리미티브를 다룹니다.</font><font papago-translate="translated"> 우리는 루프로 나아갈 준비가 되었습니다.</font><font papago-translate="translated"> 제가 거기서 뭘 했는지 보이시나요?</font><font papago-translate="translated"> <em>점프.</em></font><font papago-translate="translated"><em> 앞서.</em></font><font papago-translate="translated"> 알았어요?</font><font papago-translate="translated"> 보세요, 이건 마치 .<span class="ellipse"> . . . .</span> 아, 잊어버려요.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/control-flow.html#while-loops" id="while-loops"><small><font papago-translate="translated">9 . 4</font></small><font papago-translate="splitted"><font papago-translate="translated">루프 중</font></font></a></h2>
<p><font papago-translate="splitted"><font papago-translate="translated">Lox는 두 개의 반복 제어 흐름 문을 특징으로 합니다, </font></font><code translate="no">while</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">for</code><font papago-translate="splitted"><font papago-translate="translated">.그 </font></font><code translate="no">while</code><font papago-translate="splitted"><font papago-translate="translated"> 루프가 더 간단한 것이므로 거기서부터 시작하겠습니다.</font><font papago-translate="translated"> 문법은 C와 동일합니다.</font></font></p>
<div class="codehilite"><pre translate="no"><span class="i">statement</span>      → <span class="i">exprStmt</span>
               | <span class="i">ifStmt</span>
               | <span class="i">printStmt</span>
               | <span class="i">whileStmt</span>
               | <span class="i">block</span> ;

<span class="i">whileStmt</span>      → <span class="s">"while"</span> <span class="s">"("</span> <span class="i">expression</span> <span class="s">")"</span> <span class="i">statement</span> ;
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">우리는 한동안 새로운 규칙을 가리키는 또 다른 조항을 문 규칙에 추가합니다.</font><font papago-translate="translated"> 시간이 걸립니다 </font></font><code translate="no">while</code><font papago-translate="splitted"><font papago-translate="translated"> 키워드, 괄호로 묶은 조건 표현, 본문에 대한 문장.</font><font papago-translate="translated"> 그 새로운 문법 규칙은<span name="while-ast"> 구문 트리 노드</span>를 얻습니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      "Print      : Expr expression",
</pre><pre class="insert-before" translate="no">      <span class="s">"Var        : Token name, Expr initializer"</span><span class="insert-comma">,</span>
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">도구/GenerateAst.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>메인</em> ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 이전 줄에<em> ","</em>를 추가합니다</font></font></div>
<pre class="insert" translate="no">      <span class="s">"While      : Expr condition, Stmt body"</span>
</pre><pre class="insert-after" translate="no">    ));
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>main</em>(), add <em>“,”</em> to previous line</div>
<aside name="while-ast" style="top: 8105px;">
<p><font papago-translate="translated">새 노드에 대한 생성된 코드는 부록<a href="https://youhogeon-meritz.github.io/appendix-ii.html#while-statement"> II</a>에 있습니다.</font></p>
</aside>
<p><font papago-translate="translated">노드는 상태와 신체를 저장합니다.</font><font papago-translate="translated"> 여기에서 표현과 명제에 대해 별도의 기본 클래스를 갖는 것이 좋은 이유를 알 수 있습니다.</font><font papago-translate="translated"> 필드 선언은 조건이 표현이고 신체가 진술임을 분명히 합니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">파서에서는 우리가 사용했던 동일한 프로세스를 따릅니다 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 진술들.</font><font papago-translate="translated"> 먼저, 우리는 또 다른 사례를 추가합니다 </font></font><code translate="no">statement()</code><font papago-translate="splitted"><font papago-translate="translated"> 주요 키워드를 감지하고 일치시킵니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    if (match(PRINT)) return printStatement();
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>성명</em>서 ()에서</font></font></div>
<pre class="insert" translate="no">    <span class="k">if</span> (<span class="i">match</span>(<span class="i">WHILE</span>)) <span class="k">return</span> <span class="i">whileStatement</span>();
</pre><pre class="insert-after" translate="no">    if (match(LEFT_BRACE)) return new Stmt.Block(block());
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>statement</em>()</div>
<p><font papago-translate="translated">그것이 실제 작업을 이 방법으로 위임합니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>varDeclaration</em> 뒤에 추가하기()</font></font></div>
<pre translate="no">  <span class="k">private</span> <span class="t">Stmt</span> <span class="i">whileStatement</span>() {
    <span class="i">consume</span>(<span class="i">LEFT_PAREN</span>, <span class="s">"Expect '(' after 'while'."</span>);
    <span class="t">Expr</span> <span class="i">condition</span> = <span class="i">expression</span>();
    <span class="i">consume</span>(<span class="i">RIGHT_PAREN</span>, <span class="s">"Expect ')' after condition."</span>);
    <span class="t">Stmt</span> <span class="i">body</span> = <span class="i">statement</span>();

    <span class="k">return</span> <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">While</span>(<span class="i">condition</span>, <span class="i">body</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>varDeclaration</em>()</div>
<p><font papago-translate="translated">문법은 매우 간단하며, 이것은 자바로 직접 번역한 것입니다.</font><font papago-translate="translated"> 자바로 바로 번역하는 것에 대해 말하자면, 새로운 구문을 실행하는 방법은 다음과 같습니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Interpreter.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>visit</em>V<em>arStmt</em>() 방문 후 추가</font></font></div>
<pre translate="no">  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitWhileStmt</span>(<span class="t">Stmt</span>.<span class="t">While</span> <span class="i">stmt</span>) {
    <span class="k">while</span> (<span class="i">isTruthy</span>(<span class="i">evaluate</span>(<span class="i">stmt</span>.<span class="i">condition</span>))) {
      <span class="i">execute</span>(<span class="i">stmt</span>.<span class="i">body</span>);
    }
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>visitVarStmt</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">방문 방법처럼 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated">, 이 방문자는 해당 Java 기능을 사용합니다.</font><font papago-translate="translated"> 이 방법은 복잡하지 않지만 Lox를 훨씬 더 강력하게 만듭니다.</font><font papago-translate="translated"> 마침내 소스 코드의 길이에 의해 실행 시간이 엄격하게 제한되지 않는 프로그램을 작성할 수 있습니다.</font></font></p>
<h2><a href="https://youhogeon-meritz.github.io/control-flow.html#for-loops" id="for-loops"><small><font papago-translate="translated">9 . 5</font></small><font papago-translate="splitted"><font papago-translate="translated">루프용</font></font></a></h2>
<p><font papago-translate="splitted"><font papago-translate="translated">마지막 제어 흐름 구조인 Y<span name="for">e Old</span>e C 스타일로 넘어갔습니다 </font></font><code translate="no">for</code><font papago-translate="splitted"><font papago-translate="translated"> 루프. 굳이 상기시킬 필요는 없겠지만, 이렇게 생겼습니다:</font></font></p>
<div class="codehilite"><pre translate="no"><span class="k">for</span> (<span class="k">var</span> <span class="i">i</span> = <span class="n">0</span>; <span class="i">i</span> &lt; <span class="n">10</span>; <span class="i">i</span> = <span class="i">i</span> + <span class="n">1</span>) <span class="k">print</span> <span class="i">i</span>;
</pre></div>
<p><font papago-translate="translated">문법적으로는 그렇습니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="i">statement</span>      → <span class="i">exprStmt</span>
               | <span class="i">forStmt</span>
               | <span class="i">ifStmt</span>
               | <span class="i">printStmt</span>
               | <span class="i">whileStmt</span>
               | <span class="i">block</span> ;

<span class="i">forStmt</span>        → <span class="s">"for"</span> <span class="s">"("</span> ( <span class="i">varDecl</span> | <span class="i">exprStmt</span> | <span class="s">";"</span> )
                 <span class="i">expression</span>? <span class="s">";"</span>
                 <span class="i">expression</span>? <span class="s">")"</span> <span class="i">statement</span> ;
</pre></div>
<aside name="for" style="top: 9193px;">
<p><font papago-translate="splitted"><font papago-translate="translated">대부분의 현대 언어는 임의의 사용자 정의 시퀀스를 반복하는 더 높은 수준의 반복문을 가지고 있습니다.</font><font papago-translate="translated"> C#은 다음을 가지고 있습니다 </font></font><code translate="no">foreach</code><font papago-translate="splitted"><font papago-translate="translated">, Java는 "향상된" 용도로 사용되었으며, C++에도 범위 기반 기능이 있습니다 </font></font><code translate="no">for</code><font papago-translate="splitted"><font papago-translate="translated"> 지금 진술합니다.</font><font papago-translate="translated"> 그것들은 C보다 더 깔끔한 구문을 제공합니다 </font></font><code translate="no">for</code><font papago-translate="splitted"><font papago-translate="translated"> 객체가 루프오버되는 반복 프로토콜을 암묵적으로 호출하여 설명합니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">난 그것들이 너무 좋다.</font><font papago-translate="translated"> 하지만 Lox의 경우, 통역사를 한 번에 한 장씩 구축하는 데 한계가 있습니다.</font><font papago-translate="translated"> 아직 객체와 메서드가 없기 때문에 반복 프로토콜을 정의할 방법이 없습니다 </font></font><code translate="no">for</code><font papago-translate="splitted"><font papago-translate="translated"> 루프를 사용할 수 있습니다.</font><font papago-translate="translated"> 그래서 우리는 기존의 C 학교를 고수할 것입니다 </font></font><code translate="no">for</code><font papago-translate="splitted"><font papago-translate="translated"> 루프. "빈티지"라고 생각하세요.</font><font papago-translate="translated"> 제어 흐름 문의 고정점.</font></font></p>
</aside>
<p><font papago-translate="translated">괄호 안에는 세미콜론으로 구분된 세 개의 절이 있습니다:</font></p>
<ol>
<li>
<p><font papago-translate="splitted"><font papago-translate="translated">첫 번째 조항은<em> 초기화입니다</em>.</font><font papago-translate="translated"> 그것은 무엇보다도 정확히 한 번 실행됩니다.</font><font papago-translate="translated"> 보통 표현이지만, 편의를 위해 변수 선언도 허용합니다.</font><font papago-translate="translated"> 이 경우 변수는 나머지 부분으로 범위가 지정됩니다 </font></font><code translate="no">for</code><font papago-translate="splitted"><font papago-translate="translated"> 루프—다른 두 절과<span class="em"></span> 본문.</font></font></p>
</li>
<li>
<p><font papago-translate="splitted"><font papago-translate="translated">다음<em>은 조건</em>입니다.</font><font papago-translate="translated"> 마치 </font></font><code translate="no">while</code><font papago-translate="splitted"><font papago-translate="translated"> 루프, 이 표현식은 루프를 종료할 시기를 제어합니다.</font><font papago-translate="translated"> 첫 번째 반복을 포함하여 각 반복이 시작될 때마다 한 번씩 평가됩니다.</font><font papago-translate="translated"> 결과가 사실이라면 루프 본체를 실행합니다.</font><font papago-translate="translated"> 그렇지 않으면 실패합니다.</font></font></p>
</li>
<li>
<p><font papago-translate="translated">마지막 조항은<em> 증가입니다</em>.</font><font papago-translate="translated"> 각 루프 반복이 끝날 때마다 작동하는 임의의 표현입니다.</font><font papago-translate="translated"> 그 표현의 결과는 버려지기 때문에, 유용하려면 부작용이 있어야 합니다.</font><font papago-translate="translated"> 실제로는 보통 변수를 증가시킵니다.</font></p>
</li>
</ol>
<p><font papago-translate="translated">이 조항들 중 어느 것이든 생략할 수 있습니다.</font><font papago-translate="translated"> 다음 괄호 뒤에는 본문에 대한 문장이 있으며, 일반적으로 블록입니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/control-flow.html#desugaring" id="desugaring"><small><font papago-translate="translated">9 . 5 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">디슈가링</font></font></a></h3>
<p><font papago-translate="splitted"><font papago-translate="translated">그것은 많은 기계들이지만, 우리가 이미 가지고 있는 진술로는 할 수 없는 일을 하지 않는다는 점에 유의하세요. 만약 </font></font><code translate="no">for</code><font papago-translate="splitted"><font papago-translate="translated"> 루프는 이니셜라이저 절을 지원하지 않았으므로 이니셜라이저 식을 다음과 같이 입력할 수 있습니다 </font></font><code translate="no">for</code><font papago-translate="splitted"><font papago-translate="translated"> 진술.</font><font papago-translate="translated"> 증분 절 없이, 직접 본문의 끝에 증분 표현식을 넣을 수 있습니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">다시 말해, Lox<em>는 필요하지</em> 않습니다</font></font> <code translate="no">for</code><font papago-translate="splitted"><font papago-translate="translated"> 루프는 일반적인 코드 패턴을 더 쉽게 작성할 수 있게 해줍니다.</font><font papago-translate="translated"> 이러한 특징들을<span name="sugar"><strong> 통사 설탕</strong></span>이라고 합니다.</font><font papago-translate="translated"> 예를 들어, 이전 </font></font><code translate="no">for</code><font papago-translate="splitted"><font papago-translate="translated"> 루프는 이렇게 다시 쓸 수 있습니다:</font></font></p>
<aside name="sugar" style="top: 10253px;">
<p><font papago-translate="translated">이 유쾌한 문구의 전환은 1964년 피터 J. 랜딘이 ALGOL과 같은 언어가 지원하는 멋진 표현 형식 중 일부가 더 근본적이지만 아마도 덜 맛깔스러운 람다<span class="em"></span><span class="em"></span> 미적분학 위에 감미료를 뿌린 것을 설명하기 위해 만들어졌습니다.</font></p><img alt="Slightly more than a spoonful of sugar." class="above" src="https://youhogeon-meritz.github.io/image/control-flow/sugar.png">
</aside>
<div class="codehilite"><pre translate="no">{
  <span class="k">var</span> <span class="i">i</span> = <span class="n">0</span>;
  <span class="k">while</span> (<span class="i">i</span> &lt; <span class="n">10</span>) {
    <span class="k">print</span> <span class="i">i</span>;
    <span class="i">i</span> = <span class="i">i</span> + <span class="n">1</span>;
  }
}
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">이 스크립트는 이전 스크립트와 정확히 동일한 의미를 가지고 있지만, 보기에는 쉽지 않습니다.</font><font papago-translate="translated"> Lox와 같은 구문 설탕 특징 </font></font><code translate="no">for</code><font papago-translate="splitted"><font papago-translate="translated"> 루프는 언어를 더 즐겁고 생산적으로 만들어 줍니다.</font><font papago-translate="translated"> 하지만, 특히 정교한 언어 구현에서는 백엔드 지원과 최적화가 필요한 모든 언어 기능이 비용이 많이 듭니다.</font></font></p>
<p><font papago-translate="translated">우리는 케이크를 먹고<span name="caramel"><strong> 설탕을 빼</strong></span>서 먹을 수도 있습니다.</font><font papago-translate="translated"> 그 재미있는 단어는 프론트엔드가 구문 슈가를 사용하여 코드를 가져와 백엔드가 이미 실행 방법을 알고 있는 더 원시적인 형태로 번역하는 과정을 설명합니다.</font></p>
<aside name="caramel" style="top: 10609px;">
<p><font papago-translate="translated">오, 이 용어가 "카라멜화"였으면 좋겠어요.</font><font papago-translate="translated"> 은유를 고수하지 않을 텐데 왜 은유를 도입하나요?</font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">우리는 데수가를 만들 것입니다 </font></font><code translate="no">for</code><font papago-translate="splitted"><font papago-translate="translated"> 로의 루프 </font></font><code translate="no">while</code><font papago-translate="splitted"><font papago-translate="translated"> 해석자가 이미 처리하고 있는 루프 및 기타 문.</font><font papago-translate="translated"> 우리의 간단한 통역사에서, 불필요함을 없애는 것은 우리에게 많은 일을 덜어주지 않지만, 그 기술을 소개해 줄 핑계를 제공합니다.</font><font papago-translate="translated"> 따라서 이전 문장과 달리 새 구문 트리 노드를 추가하지<em> 않습니다</em>.</font><font papago-translate="translated"> 대신, 우리는 바로 구문 분석으로 넘어갑니다.</font><font papago-translate="translated"> 먼저, 곧 필요한 수입품을 추가하세요.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">import java.util.ArrayList;
</pre><div class="source-file"><em>lox/Parser.java</em></div>
<pre class="insert" translate="no"><span class="k">import</span> <span class="i">java.util.Arrays</span>;
</pre><pre class="insert-after" translate="no">import java.util.List;
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em></div>
<p><font papago-translate="splitted"><font papago-translate="translated">모든 문장과 마찬가지로, 우리는 구문 분석을 시작합니다 </font></font><code translate="no">for</code><font papago-translate="splitted"><font papago-translate="translated"> 키워드를 일치시켜 루프합니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  private Stmt statement() {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>성명</em>서 ()에서</font></font></div>
<pre class="insert" translate="no">    <span class="k">if</span> (<span class="i">match</span>(<span class="i">FOR</span>)) <span class="k">return</span> <span class="i">forStatement</span>();
</pre><pre class="insert-after" translate="no">    if (match(IF)) return ifStatement();
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>statement</em>()</div>
<p><font papago-translate="translated">여기서부터 흥미로워집니다.</font><font papago-translate="translated"> 여기서 분리 작업이 진행될 예정이므로, 이 방법은 절 앞의 괄호를 여는 것부터 시작하여 한 번에 하나씩 구축할 것입니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>문</em> 뒤에 () 추가</font></font></div>
<pre translate="no">  <span class="k">private</span> <span class="t">Stmt</span> <span class="i">forStatement</span>() {
    <span class="i">consume</span>(<span class="i">LEFT_PAREN</span>, <span class="s">"Expect '(' after 'for'."</span>);

    <span class="c">// More here...</span>
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>statement</em>()</div>
<p><font papago-translate="translated">그 다음 첫 번째 절은 초기화입니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    consume(LEFT_PAREN, "Expect '(' after 'for'.");

</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>forStatement</em>()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">    <span class="t">Stmt</span> <span class="i">initializer</span>;
    <span class="k">if</span> (<span class="i">match</span>(<span class="i">SEMICOLON</span>)) {
      <span class="i">initializer</span> = <span class="k">null</span>;
    } <span class="k">else</span> <span class="k">if</span> (<span class="i">match</span>(<span class="i">VAR</span>)) {
      <span class="i">initializer</span> = <span class="i">varDeclaration</span>();
    } <span class="k">else</span> {
      <span class="i">initializer</span> = <span class="i">expressionStatement</span>();
    }
</pre><pre class="insert-after" translate="no">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>forStatement</em>(), replace 1 line</div>
<p><font papago-translate="splitted"><font papago-translate="translated">다음 토큰이 다음과 같은 경우 </font></font><code translate="no">(</code><font papago-translate="splitted"><font papago-translate="translated"> 세미콜론입니다. 그러면 이니셜라이저가 생략되었습니다.</font><font papago-translate="translated"> 그렇지 않으면 다음을 확인합니다 </font></font><code translate="no">var</code><font papago-translate="splitted"><font papago-translate="translated"> <span name="variable">변수</span> 선언인지 확인하는 키워드.</font><font papago-translate="translated"> 둘 다 일치하지 않는다면, 그것은 표현이어야 합니다.</font><font papago-translate="translated"> 이를 구문 분석하고 초기화자가 항상 Stmt 유형이 되도록 표현식 문으로 마무리합니다.</font></font></p>
<aside name="variable" style="top: 11625px;">
<p><font papago-translate="translated">이전 장에서 저는 표현과 문장 구문 트리를 두 개의 별도 클래스 계층으로 나눌 수 있다고 말했습니다. 문법에서 표현과 문장을 모두 허용하는 한 자리가 없기 때문입니다.</font><font papago-translate="translated"> <em>완전히</em> 사실<em>은 아니</em>었던 것 같습니다.</font></p>
</aside>
<p><font papago-translate="translated">다음은 조건입니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      initializer = expressionStatement();
    }
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>forStatement</em>()에서</font></font></div>
<pre class="insert" translate="no">
    <span class="t">Expr</span> <span class="i">condition</span> = <span class="k">null</span>;
    <span class="k">if</span> (!<span class="i">check</span>(<span class="i">SEMICOLON</span>)) {
      <span class="i">condition</span> = <span class="i">expression</span>();
    }
    <span class="i">consume</span>(<span class="i">SEMICOLON</span>, <span class="s">"Expect ';' after loop condition."</span>);
</pre><pre class="insert-after" translate="no">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>forStatement</em>()</div>
<p><font papago-translate="translated">다시 한 번, 우리는 그 절이 생략되었는지 확인하기 위해 세미콜론을 찾습니다.</font><font papago-translate="translated"> 마지막 조항은 증가입니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    consume(SEMICOLON, "Expect ';' after loop condition.");
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>forStatement</em>()에서</font></font></div>
<pre class="insert" translate="no">
    <span class="t">Expr</span> <span class="i">increment</span> = <span class="k">null</span>;
    <span class="k">if</span> (!<span class="i">check</span>(<span class="i">RIGHT_PAREN</span>)) {
      <span class="i">increment</span> = <span class="i">expression</span>();
    }
    <span class="i">consume</span>(<span class="i">RIGHT_PAREN</span>, <span class="s">"Expect ')' after for clauses."</span>);
</pre><pre class="insert-after" translate="no">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>forStatement</em>()</div>
<p><font papago-translate="translated">조건 조항과 유사하지만, 이 조항은 종결 괄호로 종료됩니다.</font><font papago-translate="translated"> 남은 것은<span name="body"> 몸</span>뿐입니다.</font></p>
<aside name="body" style="top: 12253px;">
<p><font papago-translate="translated">저만 그런 건가요, 아니면 병적으로 들리는 건가요?</font><font papago-translate="translated"> 남은 것은<em> 몸</em>뿐<span class="ellipse"></span>이었습니다.</font></p>
</aside>
<div class="codehilite"><pre class="insert-before" translate="no">    consume(RIGHT_PAREN, "Expect ')' after for clauses.");
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>forStatement</em>()에서</font></font></div>
<pre class="insert" translate="no">    <span class="t">Stmt</span> <span class="i">body</span> = <span class="i">statement</span>();

    <span class="k">return</span> <span class="i">body</span>;
</pre><pre class="insert-after" translate="no">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>forStatement</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">우리는 모든 다양한 조각들을 분석했습니다 </font></font><code translate="no">for</code><font papago-translate="splitted"><font papago-translate="translated"> 루프와 결과적으로 생성된 AST 노드는 몇 가지 Java 로컬 변수에 포함되어 있습니다.</font><font papago-translate="translated"> 여기서 탈당근이 등장합니다.</font><font papago-translate="translated"> 우리는 그것들을 가져와서 의미론을 표현하는 구문 트리 노드를 합성하는 데 사용합니다 </font></font><code translate="no">for</code><font papago-translate="splitted"><font papago-translate="translated"> 루프, 앞서 보여드린 손으로 만든 예시처럼.</font></font></p>
<p><font papago-translate="translated">코드는 거꾸로 작업하면 조금 더 간단하므로 증분 절부터 시작합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    Stmt body = statement();

</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>forStatement</em>()에서</font></font></div>
<pre class="insert" translate="no">    <span class="k">if</span> (<span class="i">increment</span> != <span class="k">null</span>) {
      <span class="i">body</span> = <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">Block</span>(
          <span class="t">Arrays</span>.<span class="i">asList</span>(
              <span class="i">body</span>,
              <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">Expression</span>(<span class="i">increment</span>)));
    }

</pre><pre class="insert-after" translate="no">    return body;
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>forStatement</em>()</div>
<p><font papago-translate="translated">증분이 하나 있는 경우, 루프의 각 반복에서 본문 이후에 실행됩니다.</font><font papago-translate="translated"> 우리는 원래의 신체를 포함하는 작은 블록으로 신체를 교체한 후, 증가를 평가하는 표현문을 사용하여 이를 수행합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    }

</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>forStatement</em>()에서</font></font></div>
<pre class="insert" translate="no">    <span class="k">if</span> (<span class="i">condition</span> == <span class="k">null</span>) <span class="i">condition</span> = <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Literal</span>(<span class="k">true</span>);
    <span class="i">body</span> = <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">While</span>(<span class="i">condition</span>, <span class="i">body</span>);

</pre><pre class="insert-after" translate="no">    return body;
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>forStatement</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">다음으로, 우리는 조건과 신체를 취하고 원시적인 방법을 사용하여 루프를 만듭니다 </font></font><code translate="no">while</code><font papago-translate="splitted"><font papago-translate="translated"> 루프. 조건이 생략되면, 우리는 참여합니다 </font></font><code translate="no">true</code><font papago-translate="splitted"><font papago-translate="translated"> 무한 루프를 만들기 위해.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    body = new Stmt.While(condition, body);

</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>forStatement</em>()에서</font></font></div>
<pre class="insert" translate="no">    <span class="k">if</span> (<span class="i">initializer</span> != <span class="k">null</span>) {
      <span class="i">body</span> = <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">Block</span>(<span class="t">Arrays</span>.<span class="i">asList</span>(<span class="i">initializer</span>, <span class="i">body</span>));
    }

</pre><pre class="insert-after" translate="no">    return body;
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>forStatement</em>()</div>
<p><font papago-translate="translated">마지막으로, 초기화 장치가 있으면 전체 루프 앞에서 한 번 실행됩니다.</font><font papago-translate="translated"> 우리는 다시 전체 문장을 초기화기를 실행한 다음 루프를 실행하는 블록으로 대체함으로써 이를 수행합니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">그게 다입니다.</font><font papago-translate="translated"> 우리의 통역사는 이제 C-스타일을 지원합니다 </font></font><code translate="no">for</code><font papago-translate="splitted"><font papago-translate="translated"> 루프와 인터프리터 클래스를 전혀 터치할 필요가 없었습니다.</font><font papago-translate="translated"> 우리는 이미 노드를 무시하고 통역사가 방문하는 방법을 알고 있기 때문에 더 이상 할 일이 없습니다.</font></font></p>
<p><font papago-translate="translated">마지막으로, Lox는 적어도 몇 분 동안 우리를 즐겁게 해줄 만큼 강력합니다.</font><font papago-translate="translated"> 피보나치 수열의 첫 21개 요소를 인쇄하는 작은 프로그램을 소개합니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="i">a</span> = <span class="n">0</span>;
<span class="k">var</span> <span class="i">temp</span>;

<span class="k">for</span> (<span class="k">var</span> <span class="i">b</span> = <span class="n">1</span>; <span class="i">a</span> &lt; <span class="n">10000</span>; <span class="i">b</span> = <span class="i">temp</span> + <span class="i">b</span>) {
  <span class="k">print</span> <span class="i">a</span>;
  <span class="i">temp</span> = <span class="i">a</span>;
  <span class="i">a</span> = <span class="i">b</span>;
}
</pre></div>
<div class="challenges">
<h2><a href="https://youhogeon-meritz.github.io/control-flow.html#challenges" id="challenges"><font papago-translate="translated">과제들</font></a></h2>
<ol>
<li>
<p><font papago-translate="translated">지금부터 몇 장 후, Lox가 일류 함수와 동적 디스패치를 지원할 때, 우리는 기술적으로 언어에 내장된 분기문이<em> 필요</em>하지 않을 것입니다.</font><font papago-translate="translated"> 조건부 실행이 어떻게 구현될 수 있는지 보여줍니다.</font><font papago-translate="translated"> 제어 흐름을 위해 이 기법을 사용하는 언어의 이름을 말하세요.</font></p>
</li>
<li>
<p><font papago-translate="translated">마찬가지로, 우리의 인터프리터가 중요한 최적화를 지원하는 경우 동일한 도구를 사용하여 루프를 구현할 수 있습니다.</font><font papago-translate="translated"> 그것은 무엇이며 왜 필요합니까?</font><font papago-translate="translated"> 이 기법을 반복에 사용하는 언어의 이름을 말하세요.</font></p>
</li>
<li>
<p><font papago-translate="splitted"><font papago-translate="translated">Lox와 달리 대부분의 다른 C 스타일 언어도 다음을 지원합니다 </font></font><code translate="no">break</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">continue</code><font papago-translate="splitted"><font papago-translate="translated"> 루프 내부 문장.</font><font papago-translate="translated"> 지원 추가 </font></font><code translate="no">break</code><font papago-translate="splitted"><font papago-translate="translated"> 진술들.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">구문은 </font></font><code translate="no">break</code><font papago-translate="splitted"><font papago-translate="translated"> 키워드 뒤에 세미콜론이 붙습니다.</font><font papago-translate="translated"> 구문 오류가 있어야 합니다 </font></font><code translate="no">break</code><font papago-translate="splitted"><font papago-translate="translated"> 문은 모든 둘러싸는 루프 외부에 나타납니다.</font><font papago-translate="translated"> 실행 시, a </font></font><code translate="no">break</code><font papago-translate="splitted"><font papago-translate="translated"> 문은 실행을 가장 가까운 둘러싸 루프의 끝으로 이동시키고 거기서부터 진행합니다.</font><font papago-translate="translated"> 참고로 </font></font><code translate="no">break</code><font papago-translate="splitted"><font papago-translate="translated"> 다른 블록 내부에 중첩될 수 있습니다 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 또한 종료해야 하는 진술.</font></font></p>
</li>
</ol>
</div>
<div class="design-note">
<h2><a href="https://youhogeon-meritz.github.io/control-flow.html#design-note" id="design-note"><font papago-translate="translated">디자인 노트: 구문 설탕 한 스푼</font></a></h2>
<p><font papago-translate="translated">자신만의 언어를 설계할 때 문법에 얼마나 많은 구문 설탕을 따를지 선택합니다.</font><font papago-translate="translated"> 각 의미 연산이 하나의 구문 단위로 매핑되는 무가당 건강식품을 만드나요, 아니면 모든 행동의 모든 부분이 열 가지 다른 방식으로 표현될 수 있는 퇴폐적인 디저트를 만드나요?</font><font papago-translate="translated"> 성공적인 언어들은 이 연속체를 따라 모든 지점에 존재합니다.</font></p>
<p><font papago-translate="translated">극단적으로 매서운 끝에는 리스프, 포스, 스몰토크와 같이 무자비하게 최소한의 구문을 가진 사람들이 있습니다.</font><font papago-translate="translated"> 리스퍼스는 자신들의 언어가 "구문법이 없다"고 주장하는 것으로 유명하지만, 스몰토커는 인덱스 카드에 전체 문법을 맞출 수 있다는 것을 자랑스럽게 보여줍니다.</font><font papago-translate="translated"> 이 부족은<em> 언어</em>에 구문 설탕이 필요하지 않다는 철학을 가지고 있습니다.</font><font papago-translate="translated"> 대신, 라이브러리 코드가 제공하는 최소한의 구문과 의미는 마치 언어 자체의 일부처럼 표현력을 발휘할 수 있을 만큼 강력합니다.</font></p>
<p><font papago-translate="translated">이 근처에는 C, Lua, Go와 같은 언어들이 있습니다.</font><font papago-translate="translated"> 그들은 미니멀리즘보다 단순함과 명확함을 목표로 합니다.</font><font papago-translate="translated"> Go와 같은 일부 사람들은 의도적으로 구문 설탕과 이전 범주의 구문 확장성을 모두 피합니다.</font><font papago-translate="translated"> 문법과 라이브러리를 단순하게 유지하는 데 중점을 두기 위해 구문이 의미론에서 벗어나길 원합니다.</font><font papago-translate="translated"> 코드는 아름답기보다는 분명해야 합니다.</font></p>
<p><font papago-translate="translated">중간 어딘가에는 Java, C#, Python과 같은 언어가 있습니다.</font><font papago-translate="translated"> 결국 Ruby, C++, Perl, D 언어에 도달하게 됩니다. 이 언어들은 문법에 구문을 너무 많이 포함하고 있어서<span class="em"></span> 키보드의 구두점 문자가 부족해지고 있습니다.</font></p>
<p><font papago-translate="translated">스펙트럼의 위치는 어느 정도 나이와 상관관계가 있습니다.</font><font papago-translate="translated"> 이후 릴리스에서는 구문 설탕을 약간 추가하는 것이 비교적 쉽습니다.</font><font papago-translate="translated"> 새로운 구문은 군중을 즐겁게 하며, 의미론을 무시하는 것보다 기존 프로그램을 깨뜨릴 가능성이 적습니다.</font><font papago-translate="translated"> 한 번 추가되면 절대 빼앗을 수 없기 때문에 언어는 시간이 지남에 따라 달콤해지는 경향이 있습니다.</font><font papago-translate="translated"> 새로운 언어를 처음부터 창조하는 주요 이점 중 하나는 쌓인 프로스팅 층을 긁어내고 다시 시작할 수 있는 기회를 제공한다는 점입니다.</font></p>
<p><font papago-translate="translated">통사당은 PL 지식인들 사이에서 나쁜 랩을 가지고 있습니다.</font><font papago-translate="translated"> 그 군중 속에는 미니멀리즘에 대한 진정한 페티시가 있습니다.</font><font papago-translate="translated"> 그럴 만한 이유가 있습니다.</font><font papago-translate="translated"> 제대로 설계되지 않은 불필요한 구문은 그 무게를 지탱할 만큼 충분한 표현력을 추가하지 않고도 인지 부하를 증가시킵니다.</font><font papago-translate="translated"> 항상 새로운 기능을 언어에 주입해야 한다는 압박이 있기 때문에, 부종을 피하기 위해서는 규율과 단순성에 중점을 두어야 합니다.</font><font papago-translate="translated"> 구문을 추가하면 구문에 집착하게 되므로 간결하게 표현하는 것이 현명합니다.</font></p>
<p><font papago-translate="translated">동시에 대부분의 성공적인 언어는 적어도 널리 사용될 때까지는 상당히 복잡한 문법을 가지고 있습니다.</font><font papago-translate="translated"> 프로그래머들은 자신들이 선택한 언어로 많은 시간을 보내며, 여기저기서 몇 가지 친절함을 통해 작업의 편안함과 효율성을 향상시킬 수 있습니다.</font></p>
<p><font papago-translate="translated">적절한 균형을 맞추는 것, 즉 당신의 언어에 맞는 적절한 단맛을 선택하는 것은<span class="em"></span><span class="em"></span> 당신의 취향에 달려 있습니다.</font></p>
</div>
<footer>
<a class="next" href="https://youhogeon-meritz.github.io/functions.html"><font papago-translate="translated"> 다음 장: "함수" → </font></a><font papago-translate="splitted"><font papago-translate="translated"> 로버트 니스트롬이 수작업으로 제작한 -<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE"> © 2015 ~ 2021</a></font></font>
</footer>
</article>
</div>


<div id="papagoTooltip" margin="5">
        <h1 id="tooltipTitle">원문</h1>
        <p id="tooltipText"></p>
      </div>
      </body></html>