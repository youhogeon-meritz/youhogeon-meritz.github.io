<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link rel="stylesheet" type="text/css" href="cid:css-75ac3ca7-4062-4a17-8299-7ae873dc54da@mhtml.blink" />

<title>Parsing Expressions · Crafting Interpreters</title>
<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta content="width=device-width, initial-scale=1" name="viewport">
<link href="https://youhogeon-meritz.github.io/style.css" rel="stylesheet" type="text/css">
<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600" rel="stylesheet" type="text/css">
<link href="https://youhogeon-meritz.github.io/image/favicon.png" rel="icon" type="image/png">


<!-- Google analytics -->

</head>
<body id="top">
<!-- <div class="scrim"></div> -->
<nav class="wide">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<div class="contents">
<h3><a href="https://youhogeon-meritz.github.io/parsing-expressions.html#top"><font papago-translate="splitted"><font papago-translate="translated">구문 분석 표현</font></font><small>6</small></a></h3>
<ul>
<li><a href="https://youhogeon-meritz.github.io/parsing-expressions.html#ambiguity-and-the-parsing-game"><small>6.1</small><font papago-translate="splitted"><font papago-translate="translated"> 모호성과 파싱 게임</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/parsing-expressions.html#recursive-descent-parsing"><small>6.2</small><font papago-translate="splitted"><font papago-translate="translated"> 재귀 하강 구문 분석</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/parsing-expressions.html#syntax-errors"><small>6.3</small><font papago-translate="splitted"><font papago-translate="translated"> 구문 오류</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/parsing-expressions.html#wiring-up-the-parser"><small>6.4</small><font papago-translate="splitted"><font papago-translate="translated"> 파서 배선하기</font></font></a></li>
<li class="divider"></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/parsing-expressions.html#challenges"><font papago-translate="translated">과제들</font></a></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/parsing-expressions.html#design-note"><small><font papago-translate="translated">메모</font></small><font papago-translate="splitted"><font papago-translate="translated">논리 대 역사</font></font></a></li>
</ul>
<div class="prev-next">
<a class="left" href="https://youhogeon-meritz.github.io/representing-code.html" title="대표 코드" papago-attr-id="1"><font papago-translate="translated">← 이전</font></a>
<a href="https://youhogeon-meritz.github.io/a-tree-walk-interpreter.html" title="나무 산책 통역사" papago-attr-id="2"><font papago-translate="translated">↑ 위로</font></a>
<a class="right" href="https://youhogeon-meritz.github.io/evaluating-expressions.html" title="표현식 평가하기" papago-attr-id="3"><font papago-translate="translated">다음 →</font></a>
</div> </div>
</nav>
<nav class="narrow">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<a class="prev" href="https://youhogeon-meritz.github.io/representing-code.html" title="Representing Code">←</a>
<a class="next" href="https://youhogeon-meritz.github.io/evaluating-expressions.html" title="Evaluating Expressions">→</a>
</nav>
<div class="page">
<div class="nav-wrapper">
<nav class="floating pinned">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<div class="expandable">
<h3><a href="https://youhogeon-meritz.github.io/parsing-expressions.html#top"><font papago-translate="splitted"><font papago-translate="translated">구문 분석 표현</font></font><small>6</small></a></h3>
<ul>
<li><a href="https://youhogeon-meritz.github.io/parsing-expressions.html#ambiguity-and-the-parsing-game"><small>6.1</small><font papago-translate="splitted"><font papago-translate="translated"> 모호성과 파싱 게임</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/parsing-expressions.html#recursive-descent-parsing"><small>6.2</small><font papago-translate="splitted"><font papago-translate="translated"> 재귀 하강 구문 분석</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/parsing-expressions.html#syntax-errors"><small>6.3</small><font papago-translate="splitted"><font papago-translate="translated"> 구문 오류</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/parsing-expressions.html#wiring-up-the-parser"><small>6.4</small><font papago-translate="splitted"><font papago-translate="translated"> 파서 배선하기</font></font></a></li>
<li class="divider"></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/parsing-expressions.html#challenges">Challenges</a></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/parsing-expressions.html#design-note"><small>note</small><font papago-translate="splitted"><font papago-translate="translated">논리 대 역사</font></font></a></li>
</ul>
<div class="prev-next">
<a class="left" href="https://youhogeon-meritz.github.io/representing-code.html" title="Representing Code">←&nbsp;Previous</a>
<a href="https://youhogeon-meritz.github.io/a-tree-walk-interpreter.html" title="A Tree-Walk Interpreter">↑&nbsp;Up</a>
<a class="right" href="https://youhogeon-meritz.github.io/evaluating-expressions.html" title="Evaluating Expressions">Next&nbsp;→</a>
</div> </div>
<a id="expand-nav">≡</a>
</nav>
</div>
<article class="chapter">
<div class="number">6</div>
<h1><font papago-translate="translated">구문 분석 표현</font></h1>
<blockquote>
<p><font papago-translate="splitted"><font papago-translate="translated">문법, 심지어 왕들도 통제할 줄 아는. </font></font><cite>Molière</cite></p>
</blockquote>
<p><font papago-translate="translated"><span name="parse">이</span> 장은 책의 첫 번째 주요 이정표입니다<span name="parse">.</span></font><font papago-translate="translated"> 우리 중 많은 사람들이 텍스트 더미에서 어떤 감각을 추출하기 위해 정규 표현식과 부분 문자열 연산의 실수를 종합해 보았습니다.</font><font papago-translate="translated"> 코드는 아마도 유지 관리해야 할 버그와 짐승으로 가득 차 있었을 것입니다.</font><font papago-translate="translated"> <em>오류</em> 처리가 적절하고 일관된 내부 구조를 가지고 있으며 정교한 구문을 강력하게 씹을 수 있는<em> 진정</em>한 파서를 작성하는 것은 드문 인상<span class="em"></span><span class="em"></span>적인 기술로 간주됩니다.</font><font papago-translate="translated"> 이 장에서는 이를<span name="attain"> 달성</span>할 것입니다.</font></p>
<aside name="parse" style="top: 304px;">
<p><font papago-translate="translated">"Parse"는 고대 프랑스어 "pars"에서 영어로 "말의 일부"를 의미합니다.</font><font papago-translate="translated"> 텍스트를 가져와서 각 단어를 언어의 문법에 맞게 매핑하는 것을 의미합니다.</font><font papago-translate="translated"> 우리는 여기서 같은 의미로 사용하지만, 우리의 언어가 고대 프랑스어보다 조금 더 현대적이라는 점을 제외하고는 그렇습니다.</font></p>
</aside>
<aside name="attain" style="top: 448px;">
<p><font papago-translate="translated">많은 통과 의식과 마찬가지로, 아마도 앞에 다가올 때보다 뒤에 있을 때 조금 더 작고 덜 위압적으로 보일 것입니다.</font></p>
</aside>
<p><font papago-translate="translated">지난<a href="https://youhogeon-meritz.github.io/representing-code.html"> 장</a>에서 많은 노력을 기울였기 때문에 생각보다 쉽습니다.</font><font papago-translate="translated"> 당신은 이미 공식적인 문법을 잘 알고 있습니다.</font><font papago-translate="translated"> 구문 트리에 익숙하시며, 이를 표현할 수 있는 Java 클래스가 몇 가지 있습니다.</font><font papago-translate="translated"> 남은 유일한 조각은 구문 분석으로, 일련의 토큰을 구문<span class="em"></span> 트리 중 하나로 변환하는 것입니다.</font></p>
<p><font papago-translate="translated">일부 CS 교과서는 파서로 큰 의미를 갖습니다.</font><font papago-translate="translated"> 60년대에 컴퓨터 과학자들은 어셈블리 언어로 프로그래밍하는 데 지친 것이 당연하지만 포트란이나 ALGOL과 같은 더 정교<span name="human">하고 인간</span> 친화적인 언어를 설계하기 시작했습니다. 안타깝게도 당시의 원시<span class="em"></span><span class="em"></span> 컴퓨터에는<em> 그다지 기계</em> 친화적이지 않았습니다.</font></p>
<aside name="human" style="top: 688px;">
<p><font papago-translate="translated">그 오래된 기계들에서 조립 프로그래밍이 얼마나 끔찍했을지 상상해 보세요. 그들은 포트<em>란</em>을 개선된 것으로 여겼습니다.</font></p>
</aside>
<p><font papago-translate="translated">이 선구자들은 컴파일러를 작성하는 방법조차 모르는 언어를 설계한 후, 오래되고 작은 기계에서 이러한 새로운 큰 언어를 처리할 수 있는 구문 분석 및 컴파일 기술을 고안하는 획기적인 작업을 수행했습니다.</font></p>
<p><font papago-translate="translated">고전적인 컴파일러 책들은 이 영웅들과 그들의 도구들에 대한 이야기를 마치 허풍쟁이처럼 읽습니다.</font><font papago-translate="translated"> <em>Compil</em>er<em>: 원칙, 기법</em>,<em> 도구</em>의 표지에는 "컴파일러 설계의 복잡성"이라는 제목의 용이 검과 방패 브랜드인 "LALR 파서 생성기"와 "구문 지시 번역"을 가진 기사에게 살해당하는 장면이 담겨 있습니다.</font><font papago-translate="translated"> 그들은 그것을 두껍게 깔았습니다.</font></p>
<p><font papago-translate="translated">약간의 자화자찬은 당연한 일이지만, 사실 현대 기계를 위한 고품질 파서를 출시하기 위해 대부분의 정보를 알 필요는 없습니다.</font><font papago-translate="translated"> 언제나 그렇듯이, 교육 범위를 넓히고 나중에 받아들이도록 권장하지만, 이 책은 트로피 사례를 생략하고 있습니다.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/parsing-expressions.html#ambiguity-and-the-parsing-game" id="ambiguity-and-the-parsing-game"><small><font papago-translate="translated">6 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">모호성과 파싱 게임</font></font></a></h2>
<p><font papago-translate="translated">지난 장에서 저는 문자열<em>을 생성</em>하기 위해 맥락 없는 문법을 게임처럼 "재생"할 수 있다고 말했습니다.</font><font papago-translate="translated"> 파서들은 그 게임을 역으로 합니다.</font><font papago-translate="translated"> 문자열, 즉 일련의 토큰이 주어졌을 때, 우리는 해당 토큰을 문법의 터미널에 매핑하여<span class="em"></span><span class="em"></span> 해당 문자열을 생성할 수 있는 규칙을 알아냅니다.</font></p>
<p><font papago-translate="translated">"있을 수도 있었다"는 부분이 흥미롭습니다.</font><font papago-translate="translated"> <em>다양</em>한 제작 선택이 동일한 문자열로 이어질 수 있는<em> 모호한</em> 문법을 만드는 것은 전적으로 가능합니다.</font><font papago-translate="translated"> 문법을 사용하여 문자열<em>을 생성</em>할 때는 큰 문제가 되지 않습니다.</font><font papago-translate="translated"> 일단 끈을 잡으면, 어떻게 그 끈에 도달했는지 누가 신경 쓰겠어요?</font></p>
<p><font papago-translate="translated">파싱할 때 모호성은 파싱자가 사용자의 코드를 오해할 수 있음을 의미합니다.</font><font papago-translate="translated"> 구문 분석을 할 때 문자열이 유효한 Lox 코드인지 여부를 결정하는 것뿐만 아니라, 각 토큰이 언어의 어느 부분에 속하는지 알 수 있도록 어떤 규칙이 일치하는지 추적하고 있습니다.</font><font papago-translate="translated"> 지난 장에서 정리한 Lox 표현 문법은 다음과 같습니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="i">expression</span>     → <span class="i">literal</span>
               | <span class="i">unary</span>
               | <span class="i">binary</span>
               | <span class="i">grouping</span> ;

<span class="i">literal</span>        → <span class="t">NUMBER</span> | <span class="t">STRING</span> | <span class="s">"true"</span> | <span class="s">"false"</span> | <span class="s">"nil"</span> ;
<span class="i">grouping</span>       → <span class="s">"("</span> <span class="i">expression</span> <span class="s">")"</span> ;
<span class="i">unary</span>          → ( <span class="s">"-"</span> | <span class="s">"!"</span> ) <span class="i">expression</span> ;
<span class="i">binary</span>         → <span class="i">expression</span> <span class="i">operator</span> <span class="i">expression</span> ;
<span class="i">operator</span>       → <span class="s">"=="</span> | <span class="s">"!="</span> | <span class="s">"&lt;"</span> | <span class="s">"&lt;="</span> | <span class="s">"&gt;"</span> | <span class="s">"&gt;="</span>
               | <span class="s">"+"</span>  | <span class="s">"-"</span>  | <span class="s">"*"</span> | <span class="s">"/"</span> ;
</pre></div>
<p><font papago-translate="translated">이것은 해당 문법에서 유효한 문자열입니다:</font></p><img alt="6 / 3 - 1" src="https://youhogeon-meritz.github.io/image/parsing-expressions/tokens.png">
<p><font papago-translate="translated">하지만 우리가 그것을 생성할 수 있었던 두 가지 방법이 있습니다.</font><font papago-translate="translated"> 한 가지 방법은:</font></p>
<ol>
<li><font papago-translate="splitted"><font papago-translate="translated">처음부터 </font></font><code translate="no">expression</code><font papago-translate="splitted"><font papago-translate="translated">,고르다 </font></font><code translate="no">binary</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></li>
<li><font papago-translate="splitted"><font papago-translate="translated">왼쪽의 경우 </font></font><code translate="no">expression</code><font papago-translate="splitted"><font papago-translate="translated">,고르다 </font></font><code translate="no">NUMBER</code><font papago-translate="splitted"><font papago-translate="translated">, 그리고 사용 </font></font><code translate="no">6</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></li>
<li><font papago-translate="splitted"><font papago-translate="translated">연산자의 경우 </font></font><code translate="no">"/"</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></li>
<li><font papago-translate="splitted"><font papago-translate="translated">오른쪽의 경우 </font></font><code translate="no">expression</code><font papago-translate="splitted"><font papago-translate="translated">,고르다 </font></font><code translate="no">binary</code><font papago-translate="splitted"><font papago-translate="translated"> 다시.</font></font></li>
<li><font papago-translate="splitted"><font papago-translate="translated">그 중첩된 안에서 </font></font><code translate="no">binary</code><font papago-translate="splitted"><font papago-translate="translated"> 표현, 선택 </font></font><code translate="no">3 - 1</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></li>
</ol>
<p><font papago-translate="translated">또 다른 것은:</font></p>
<ol>
<li><font papago-translate="splitted"><font papago-translate="translated">처음부터 </font></font><code translate="no">expression</code><font papago-translate="splitted"><font papago-translate="translated">,고르다 </font></font><code translate="no">binary</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></li>
<li><font papago-translate="splitted"><font papago-translate="translated">왼쪽의 경우 </font></font><code translate="no">expression</code><font papago-translate="splitted"><font papago-translate="translated">,고르다 </font></font><code translate="no">binary</code><font papago-translate="splitted"><font papago-translate="translated"> 다시.</font></font></li>
<li><font papago-translate="splitted"><font papago-translate="translated">그 중첩된 안에서 </font></font><code translate="no">binary</code><font papago-translate="splitted"><font papago-translate="translated"> 표현, 선택 </font></font><code translate="no">6 / 3</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></li>
<li><font papago-translate="splitted"><font papago-translate="translated">바깥쪽으로 돌아가기 </font></font><code translate="no">binary</code><font papago-translate="splitted"><font papago-translate="translated">, 연산자의 경우, 선택 </font></font><code translate="no">"-"</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></li>
<li><font papago-translate="splitted"><font papago-translate="translated">오른쪽의 경우 </font></font><code translate="no">expression</code><font papago-translate="splitted"><font papago-translate="translated">,고르다 </font></font><code translate="no">NUMBER</code><font papago-translate="splitted"><font papago-translate="translated">, 그리고 사용 </font></font><code translate="no">1</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></li>
</ol>
<p><font papago-translate="translated">같은<em> 문자열</em>을 생성하지만<em> 구문 트리는</em> 생성되지 않습니다:</font></p><img alt="Two valid syntax trees: (6 / 3) - 1 and 6 / (3 - 1)" src="https://youhogeon-meritz.github.io/image/parsing-expressions/syntax-trees.png">
<p><font papago-translate="splitted"><font papago-translate="translated">다시 말해, 문법은 다음과 같은 표현을 볼 수 있게 해줍니다 </font></font><code translate="no">(6 / 3) - 1</code><font papago-translate="splitted"><font papago-translate="translated"> 또는 </font></font><code translate="no">6 / (3 - 1)</code><font papago-translate="splitted"><font papago-translate="translated">.그 </font></font><code translate="no">binary</code><font papago-translate="splitted"><font papago-translate="translated"> 규칙은 피연산자가 원하는 방식으로 둥지를 틀 수 있게 해줍니다.</font><font papago-translate="translated"> 그것은 결국 파싱된 트리를 평가하는 결과에 영향을 미칩니다.</font><font papago-translate="translated"> 수학자들이 칠판이 처음 발명된 이래로 이 모호함을 해결해 온 방법은 우선순위와 연관성에 대한 규칙을 정의하는 것입니다.</font></font></p>
<ul>
<li>
<p><font papago-translate="splitted"><font papago-translate="translated"><span name="nonassociative"><strong>우선순위는</strong></span> 다양한 연산자가 혼합된 표현식에서 어떤 연산자가 먼저 평가되는지를 결정합니다<span name="nonassociative"><strong>.</strong></span></font><font papago-translate="translated"> 우선순위 규칙에 따르면 우리는 다음을 평가합니다 </font></font><code translate="no">/</code><font papago-translate="splitted"><font papago-translate="translated"> 이전에 </font></font><code translate="no">-</code><font papago-translate="splitted"><font papago-translate="translated"> 위의 예시에서.</font><font papago-translate="translated"> 우선순위가 높은 연산자는 우선순위가 낮은 연산자보다 먼저 평가됩니다.</font><font papago-translate="translated"> 마찬가지로, 상위 우선순위 연산자는 "더 엄격하게 묶인다"고 합니다.</font></font></p>
</li>
<li>
<p><font papago-translate="splitted"><font papago-translate="translated"><strong>연상성은</strong><em> 동일</em>한 연산자 시리즈에서 어떤 연산자가 먼저 평가되는지를 결정<strong>합니다.</strong></font><font papago-translate="translated"> 연산자가<strong> 왼쪽으로 연상</strong>될 때(예: "왼쪽에서 오른쪽으로"), 왼쪽의 연산자는 오른쪽의 연산자보다 먼저 평가합니다.</font><font papago-translate="translated"> 부터 </font></font><code translate="no">-</code><font papago-translate="splitted"><font papago-translate="translated"> 는 왼쪽 연상입니다. 이 표현은:</font></font></p>
<div class="codehilite"><pre translate="no"><span class="n">5</span> - <span class="n">3</span> - <span class="n">1</span>
</pre></div>
<p><font papago-translate="translated">는 다음과 같습니다:</font></p>
<div class="codehilite"><pre translate="no">(<span class="n">5</span> - <span class="n">3</span>) - <span class="n">1</span>
</pre></div>
<p><font papago-translate="translated">반면에 과제는<strong> 오른쪽 연관</strong>성이 있습니다.</font><font papago-translate="translated"> 이것:</font></p>
<div class="codehilite"><pre translate="no"><span class="i">a</span> = <span class="i">b</span> = <span class="i">c</span>
</pre></div>
<p><font papago-translate="translated">는 다음과 같습니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="i">a</span> = (<span class="i">b</span> = <span class="i">c</span>)
</pre></div>
</li>
</ul>
<aside name="nonassociative" style="top: 2746.5px;">
<p><font papago-translate="translated">요즘에는 흔하지 않지만, 일부 언어에서는 특정 연산자 쌍에 상대적인 우선순위<em>가 없다고</em> 명시하고 있습니다.</font><font papago-translate="translated"> 따라서 명시적인 그룹화를 사용하지 않고 표현식에서 이러한 연산자를 혼합하는 것은 구문 오류가 됩니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">마찬가지로, 일부 연산자는<strong> 비결합</strong> 연산자입니다.</font><font papago-translate="translated"> 즉, 시퀀스에서 해당 연산자를 두 번 이상 사용하는 것은 오류입니다.</font><font papago-translate="translated"> 예를 들어, Perl의 범위 연산자는 연관성이 없으므로 </font></font><code translate="no">a .. b</code><font papago-translate="splitted"><font papago-translate="translated"> 괜찮아요, 하지만 </font></font><code translate="no">a .. b .. c</code><font papago-translate="splitted"><font papago-translate="translated"> 오류입니다.</font></font></p>
</aside>
<p><font papago-translate="translated">명확하게 정의된 우선순위와 연관성이 없다면, 여러 연산자를 사용하는 표현은 모호합니다. 이 표현은 서로 다른 구문 트리로 해석될 수 있으며, 이는 다시 서로 다른<span class="em"></span> 결과로 평가될 수 있습니다.</font><font papago-translate="translated"> 우리는 Lox에서 C와 동일한 우선순위 규칙을 적용하여 가장 낮은 것부터 가장 높은 것까지 이 문제를 해결할 것입니다.</font></p><table>
<thead>
<tr>
<td><font papago-translate="translated">이름.</font></td>
<td><font papago-translate="translated">운영자</font></td>
<td><font papago-translate="translated">어소시에이츠</font></td>
</tr>
</thead>
<tbody>
<tr>
<td><font papago-translate="translated">평등</font></td>
<td><code translate="no">==</code> <code translate="no">!=</code></td>
<td><font papago-translate="translated">왼쪽</font></td>
</tr>
<tr>
<td><font papago-translate="translated">비교</font></td>
<td><code translate="no">&gt;</code> <code translate="no">&gt;=</code>
<code translate="no">&lt;</code> <code translate="no">&lt;=</code></td>
<td><font papago-translate="translated">왼쪽</font></td>
</tr>
<tr>
<td><font papago-translate="translated">용어</font></td>
<td><code translate="no">-</code> <code translate="no">+</code></td>
<td><font papago-translate="translated">왼쪽</font></td>
</tr>
<tr>
<td><font papago-translate="translated">요인</font></td>
<td><code translate="no">/</code> <code translate="no">*</code></td>
<td><font papago-translate="translated">왼쪽</font></td>
</tr>
<tr>
<td><font papago-translate="translated">유니리</font></td>
<td><code translate="no">!</code> <code translate="no">-</code></td>
<td><font papago-translate="translated">맞다</font></td>
</tr>
</tbody>
</table>
<p><font papago-translate="splitted"><font papago-translate="translated">현재 문법은 모든 표현 유형을 하나로 묶습니다 </font></font><code translate="no">expression</code><font papago-translate="splitted"><font papago-translate="translated"> 규칙. 동일한 규칙이 피연산자의 비터미널로 사용되며, 이는 우선순위 규칙이 허용하는지 여부에 관계없이 문법이 모든 종류의 표현을 하위 표현으로 받아들일 수 있도록 합니다.</font></font></p>
<p><font papago-translate="translated">문법<span name="massage">을 계층화</span>하여 이를 수정합니다.</font><font papago-translate="translated"> 우리는 각 우선순위 수준에 대해 별도의 규칙을 정의합니다.</font></p>
<div class="codehilite"><pre translate="no"><span class="i">expression</span>     → ...
<span class="i">equality</span>       → ...
<span class="i">comparison</span>     → ...
<span class="i">term</span>           → ...
<span class="i">factor</span>         → ...
<span class="i">unary</span>          → ...
<span class="i">primary</span>        → ...
</pre></div>
<aside name="massage" style="top: 3726.5px;">
<p><font papago-translate="translated">일부 파서 생성기는 문법 규칙에 우선순위를 입력하는 대신, 모호하지만 간단한 문법을 그대로 유지한 다음, 명확하지 않게 하기 위해 약간 명시적인 연산자 우선순위 메타데이터를 측면에 추가할 수 있도록 합니다.</font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">여기서 각 규칙은 우선순위 수준 이상의 표현식만 일치합니다.</font><font papago-translate="translated"> 예를들면, </font></font><code translate="no">unary</code><font papago-translate="splitted"><font papago-translate="translated"> 다음과 같은 단항식과 일치합니다 </font></font><code translate="no">!negated</code><font papago-translate="splitted"><font papago-translate="translated"> 또는 다음과 같은 주요 표현식 </font></font><code translate="no">1234</code><font papago-translate="splitted"><font papago-translate="translated">.그리고. </font></font><code translate="no">term</code><font papago-translate="splitted"><font papago-translate="translated"> 일치할 수 있습니다 </font></font><code translate="no">1 + 2</code><font papago-translate="splitted"><font papago-translate="translated"> 하지만 또한 </font></font><code translate="no">3 * 4 / 5</code><font papago-translate="splitted"><font papago-translate="translated">. 결승전 </font></font><code translate="no">primary</code><font papago-translate="splitted"><font papago-translate="translated"> 규칙은 가장 우선순위가 높은 형식인 리터럴과 괄호로 묶은<span class="em"></span> 표현을 다룹니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">우리는 각 규칙에 대한 생산물을 작성하기만 하면 됩니다.</font><font papago-translate="translated"> 쉬운 것부터 먼저 하겠습니다.</font><font papago-translate="translated"> 상단 </font></font><code translate="no">expression</code><font papago-translate="splitted"><font papago-translate="translated"> 규칙은 모든 우선순위 수준에서 모든 표현식과 일치합니다.</font><font papago-translate="translated"> 우선순위가 가장 낮기 때문에, 우리가 그것과 일치시키면 모든 것이 포함됩니다<span name="equality"></span>.</font></font></p>
<aside name="equality" style="top: 4178.5px;">
<p><font papago-translate="splitted"><font papago-translate="translated">제거할 수 있습니다 </font></font><code translate="no">expression</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고 단순히 사용하기 </font></font><code translate="no">equality</code><font papago-translate="splitted"><font papago-translate="translated"> 표현이 포함된 다른 규칙에서는 다음과 같은 방법을 사용합니다 </font></font><code translate="no">expression</code><font papago-translate="splitted"><font papago-translate="translated"> 다른 규칙들을 조금 더 잘 읽게 해줍니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">또한, 나중 장에서 문법을 할당과 논리 연산자로 확장할 때는 다음과 같은 경우에만 프로덕션을 변경하면 됩니다 </font></font><code translate="no">expression</code><font papago-translate="splitted"><font papago-translate="translated"> 표현이 포함된 모든 규칙을 터치하는 대신.</font></font></p>
</aside>
<div class="codehilite"><pre translate="no"><span class="i">expression</span>     → <span class="i">equality</span>
</pre></div>
<p><font papago-translate="translated">우선순위 표의 다른 쪽 끝에는 기본 표현식이 모든 리터럴과 그룹화 표현식을 포함합니다.</font></p>
<div class="codehilite"><pre translate="no"><span class="i">primary</span>        → <span class="t">NUMBER</span> | <span class="t">STRING</span> | <span class="s">"true"</span> | <span class="s">"false"</span> | <span class="s">"nil"</span>
               | <span class="s">"("</span> <span class="i">expression</span> <span class="s">")"</span> ;
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">단항식은 단항 연산자로 시작하여 피연산자로 이어집니다.</font><font papago-translate="translated"> 단항 연산자<span class="em"></span>가 둥지를 틀 수 있기 때문에</font></font><code translate="no">!!true</code><font papago-translate="splitted"><font papago-translate="translated"> 가 이상한 표현일 경우 유효합니다—오퍼랜드 자체가 단항<span class="em"></span> 연산자가 될 수 있습니다.</font><font papago-translate="translated"> 재귀적 규칙은 그것을 잘 처리합니다.</font></font></p>
<div class="codehilite"><pre translate="no"><span class="i">unary</span>          → ( <span class="s">"!"</span> | <span class="s">"-"</span> ) <span class="i">unary</span> ;
</pre></div>
<p><font papago-translate="translated">하지만 이 규칙에는 문제가 있습니다.</font><font papago-translate="translated"> 결코 끝나지 않습니다.</font></p>
<p><font papago-translate="translated">기억하세요, 각 규칙은 해당 우선순위 수준<em> 이상</em>의 표현식과 일치해야 하므로 이 표현식도 기본 표현식과 일치하도록 해야 합니다.</font></p>
<div class="codehilite"><pre translate="no"><span class="i">unary</span>          → ( <span class="s">"!"</span> | <span class="s">"-"</span> ) <span class="i">unary</span>
               | <span class="i">primary</span> ;
</pre></div>
<p><font papago-translate="translated">작동합니다.</font></p>
<p><font papago-translate="translated">나머지 규칙들은 모두 이진 연산자입니다.</font><font papago-translate="translated"> 곱셈과 나눗셈의 규칙부터 시작하겠습니다.</font><font papago-translate="translated"> 첫 번째 시도입니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="i">factor</span>         → <span class="i">factor</span> ( <span class="s">"/"</span> | <span class="s">"*"</span> ) <span class="i">unary</span>
               | <span class="i">unary</span> ;
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">규칙이 왼쪽 피연산자와 일치하도록 재귀합니다.</font><font papago-translate="translated"> 이를 통해 규칙은 다음과 같은 일련의 곱셈 및 나눗셈 표현과 일치할 수 있습니다 </font></font><code translate="no">1 * 2 / 3</code><font papago-translate="splitted"><font papago-translate="translated">. 재귀적 생산을 왼쪽에 배치하고 </font></font><code translate="no">unary</code><font papago-translate="splitted"><font papago-translate="translated"> 오른쪽은 규칙<span name="mult">을 왼쪽 연관</span>적이고 명확하게 만듭니다.</font></font></p>
<aside name="mult" style="top: 4962.5px;">
<p><font papago-translate="translated">원칙적으로 곱셈을 왼쪽 또는 오른쪽 연상으로 취급하든 상관없이<span class="em"></span> 어느 쪽이든 동일한 결과를 얻을 수 있습니다.</font><font papago-translate="translated"> 안타깝게도, 정밀도가 제한된 현실 세계에서는 반올림과 오버플로우가 결합성이 일련의 곱셈 결과에 영향을 미칠 수 있습니다.</font><font papago-translate="translated"> 고려:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">print</span> <span class="n">0.1</span> * (<span class="n">0.2</span> * <span class="n">0.3</span>);
<span class="k">print</span> (<span class="n">0.1</span> * <span class="n">0.2</span>) * <span class="n">0.3</span>;
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated"><a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">IEEE 75</a>4 이중 정밀 부동 소수점 숫자를 사용하는 Lox와 같은 언어에서 첫 번째 평가는 다음과 같습니다 </font></font><code translate="no">0.006</code><font papago-translate="splitted"><font papago-translate="translated">, 두 번째 결과는 </font></font><code translate="no">0.006000000000000001</code><font papago-translate="splitted"><font papago-translate="translated">. 때때로 그 작은 차이가 중요합니다.</font><font papago-translate="translated"> 여기는 더 배우기에 좋은 곳<a href="https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html">입니다.</a></font></font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">이 모든 것이 맞지만, 규칙 본문의 첫 번째 기호가 규칙의 머리와 같다는 사실은 이 생산이<strong> 왼쪽으로 순환</strong>한다는 것을 의미합니다.</font><font papago-translate="translated"> 일부 구문 분석 기법, 특히 우리가 사용할 기법은 왼쪽 재귀에 문제가 있습니다.</font><font papago-translate="translated"> (다른 곳에서의 재귀, 우리가 했던 것처럼) </font></font><code translate="no">unary</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고 그룹화를 위한 간접 재귀 </font></font><code translate="no">primary</code><font papago-translate="splitted"><font papago-translate="translated"> 문제 없습니다.)</font></font></p>
<p><font papago-translate="translated">같은 언어와 일치하는 많은 문법을 정의할 수 있습니다.</font><font papago-translate="translated"> 특정 언어를 모델링하는 방법에 대한 선택은 부분적으로는 취향의 문제이고, 부분적으로는 실용적인 선택입니다.</font><font papago-translate="translated"> 이 규칙은 맞지만, 우리가 그것을 분석하려는 방식에는 최적이 아닙니다.</font><font papago-translate="translated"> 왼쪽 재귀 규칙 대신 다른 규칙을 사용하겠습니다.</font></p>
<div class="codehilite"><pre translate="no"><span class="i">factor</span>         → <span class="i">unary</span> ( ( <span class="s">"/"</span> | <span class="s">"*"</span> ) <span class="i">unary</span> )* ;
</pre></div>
<p><font papago-translate="translated">우리는 요인 표현식을 곱셈과 나눗셈의 평탄<em>한 순서로</em> 정의합니다.</font><font papago-translate="translated"> 이것은 이전 규칙과 동일한 구문과 일치하지만, 우리가 Lox를 구문 분석하기 위해 작성할 코드를 더 잘 반영합니다.</font><font papago-translate="translated"> 다른 모든 이진 연산자 우선순위 레벨에 대해 동일한 구조를 사용하여 완전한 표현 문법을 제공합니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="i">expression</span>     → <span class="i">equality</span> ;
<span class="i">equality</span>       → <span class="i">comparison</span> ( ( <span class="s">"!="</span> | <span class="s">"=="</span> ) <span class="i">comparison</span> )* ;
<span class="i">comparison</span>     → <span class="i">term</span> ( ( <span class="s">"&gt;"</span> | <span class="s">"&gt;="</span> | <span class="s">"&lt;"</span> | <span class="s">"&lt;="</span> ) <span class="i">term</span> )* ;
<span class="i">term</span>           → <span class="i">factor</span> ( ( <span class="s">"-"</span> | <span class="s">"+"</span> ) <span class="i">factor</span> )* ;
<span class="i">factor</span>         → <span class="i">unary</span> ( ( <span class="s">"/"</span> | <span class="s">"*"</span> ) <span class="i">unary</span> )* ;
<span class="i">unary</span>          → ( <span class="s">"!"</span> | <span class="s">"-"</span> ) <span class="i">unary</span>
               | <span class="i">primary</span> ;
<span class="i">primary</span>        → <span class="t">NUMBER</span> | <span class="t">STRING</span> | <span class="s">"true"</span> | <span class="s">"false"</span> | <span class="s">"nil"</span>
               | <span class="s">"("</span> <span class="i">expression</span> <span class="s">")"</span> ;
</pre></div>
<p><font papago-translate="translated">이 문법은 이전에 사용했던 문법보다 더 복잡하지만, 대신 이전 문법의 모호함을 제거했습니다.</font><font papago-translate="translated"> 파서를 만들기 위해 필요한 것입니다.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/parsing-expressions.html#recursive-descent-parsing" id="recursive-descent-parsing"><small><font papago-translate="translated">6 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">재귀 하강 구문 분석</font></font></a></h2>
<p><font papago-translate="translated">파싱 기법에는 주로 "L"과 "R<span class="em">"</span><a href="https://en.wikipedia.org/wiki/LL_parser">—LL(k)</a>,<a href="https://en.wikipedia.org/wiki/LR_parser"> LR(1)</a>, LA<span class="em">LR</span>— 그리고<a href="https://en.wikipedia.org/wiki/Parser_combinator"> 파서 조합자</a><a href="https://en.wikipedia.org/wiki/Earley_parser">, 얼리 파서</a><a href="https://en.wikipedia.org/wiki/Shunting-yard_algorithm">, 션팅 야드 알고리즘,</a><a href="https://en.wikipedia.org/wiki/Parsing_expression_grammar"> 팩랫</a><a href="https://en.wikipedia.org/wiki/LALR_parser"></a><a href="https://en.wikipedia.org/wiki/Parsing_expression_grammar"> 파싱</a>과 같은 이국적인 동물들의 조합으로 이루어진 전체 팩이 있습니다.</font><font papago-translate="translated"> 첫 번째 통역사에게는<strong> 한</strong> 가지 기술<strong>만으로도 충분합니다: 재귀적 하강입니다</strong>.</font></p>
<p><font papago-translate="translated">재귀 하강법은 파서를 만드는 가장 간단한 방법이며, Yacc, Bison 또는 ANTLR과 같은 복잡한 파서 생성 도구를 사용할 필요가 없습니다.</font><font papago-translate="translated"> 간단한 손글씨 코드만 있으면 됩니다.</font><font papago-translate="translated"> 하지만 그 단순함에 속지 마세요.</font><font papago-translate="translated"> 재귀 하강 파서는 빠르고 견고하며 정교한 오류 처리를 지원할 수 있습니다.</font><font papago-translate="translated"> 실제로 GCC, V8(Chrome의 JavaScript VM), Roslyn(C#으로 작성된 C# 컴파일러) 및 기타 많은 헤비급 프로덕션 언어 구현은 재귀적 하강법을 사용합니다.</font><font papago-translate="translated"> 바위가 있습니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">재귀적 하강법은 상위 또는 가장 바깥쪽 문법 규칙에서 시작하기 때문에<strong> 하향식 파서</strong>로 간주됩니다(여기서) </font></font><code translate="no">expression</code><font papago-translate="splitted"><font papago-translate="translated">)를 사용하여 중첩된 하위 표현식으로<span name="descent"> 이동</span>한 후 구문 트리의 잎에 도달합니다.</font><font papago-translate="translated"> 이는 기본 표현식으로 시작하여 점점 더 큰 구문 덩어리로 구성되는 LR과 같은 상향식 파서와는 대조적입니다.</font></font></p>
<aside name="descent" style="top: 6170.5px;">
<p><font papago-translate="translated">문법<em>을 따라</em> 내려가기 때문에 "재귀<em>적 하강"</em>이라고 불립니다.</font><font papago-translate="translated"> 혼란스럽게도, 우리는 "높음"과 "낮음"의 우선순위에 대해 이야기할 때 방향을 은유적으로 사용하지만, 방향은 반대입니다.</font><font papago-translate="translated"> 하향식 파서에서는 가장 낮은 우선순위의 표현식에 먼저 도달합니다. 왜냐하면 이 표현식들은 더 높은 우선순위의 하위 표현식을 포함할 수 있기 때문입니다.</font></p><img alt="Top-down grammar rules in order of increasing precedence." src="https://youhogeon-meritz.github.io/image/parsing-expressions/direction.png">
<p><font papago-translate="translated">CS 사람들은 정말로 모여서 은유를 바로잡아야 합니다.</font><font papago-translate="translated"> 스택이 어느 방향으로 자라며 나무의 뿌리가 왜 위에 있는지에 대해서는 시작조차 하지 마세요.</font></p>
</aside>
<p><font papago-translate="translated">재귀적 하강 파서는 문법 규칙을 명령어 코드로 직접 번역한 것입니다.</font><font papago-translate="translated"> 각 규칙은 함수가 됩니다.</font><font papago-translate="translated"> 규칙의 본문은 대략 다음과 같이 코드로 번역됩니다:</font></p><table>
<thead>
<tr>
<td><font papago-translate="translated">문법 표기법</font></td>
<td><font papago-translate="translated">코드 표현</font></td>
</tr>
</thead>
<tbody>
<tr><td><font papago-translate="translated">터미널</font></td><td><font papago-translate="translated">토큰을 일치시키고 소비하는 코드</font></td></tr>
<tr><td><font papago-translate="translated">비터미널</font></td><td><font papago-translate="translated">해당 규칙의 함수 호출</font></td></tr>
<tr><td><code translate="no">|</code></td><td><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 또는 </font></font><code translate="no">switch</code><font papago-translate="splitted"><font papago-translate="translated"> 진술</font></font></td></tr>
<tr><td><code translate="no">*</code><font papago-translate="splitted"><font papago-translate="translated"> 또는 </font></font><code translate="no">+</code></td><td><code translate="no">while</code><font papago-translate="splitted"><font papago-translate="translated"> 또는 </font></font><code translate="no">for</code><font papago-translate="splitted"><font papago-translate="translated"> 고리</font></font></td></tr>
<tr><td><code translate="no">?</code></td><td><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 진술</font></font></td></tr>
</tbody>
</table>
<p><font papago-translate="translated">문법 규칙이 직접적으로 또는 간접적으로 자신을 지칭할 때, 이는 재귀 함수<span class="em"></span><span class="em"></span> 호출로 변환되기 때문에 하강은 "재귀적"이라고 설명됩니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/parsing-expressions.html#the-parser-class" id="the-parser-class"><small><font papago-translate="translated">6 . 2 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">파서 클래스</font></font></a></h3>
<p><font papago-translate="translated">각 문법 규칙은 이 새로운 클래스 내에서 하나의 메서드가 됩니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 새 파일 만들기</font></font></div>
<pre translate="no"><span class="k">package</span> <span class="i">com.craftinginterpreters.lox</span>;

<span class="k">import</span> <span class="i">java.util.List</span>;

<span class="k">import static</span> <span class="i">com.craftinginterpreters.lox.TokenType.*</span>;

<span class="k">class</span> <span class="t">Parser</span> {
  <span class="k">private</span> <span class="k">final</span> <span class="t">List</span>&lt;<span class="t">Token</span>&gt; <span class="i">tokens</span>;
  <span class="k">private</span> <span class="t">int</span> <span class="i">current</span> = <span class="n">0</span>;

  <span class="t">Parser</span>(<span class="t">List</span>&lt;<span class="t">Token</span>&gt; <span class="i">tokens</span>) {
    <span class="k">this</span>.<span class="i">tokens</span> = <span class="i">tokens</span>;
  }
}
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, create new file</div>
<p><font papago-translate="splitted"><font papago-translate="translated">스캐너와 마찬가지로 파서도 평평한 입력 시퀀스를 사용하지만, 이제서야 문자 대신 토큰을 읽고 있습니다.</font><font papago-translate="translated"> 토큰 목록을 저장하고 사용합니다 </font></font><code translate="no">current</code><font papago-translate="splitted"><font papago-translate="translated"> 구문 분석을 간절히 기다리는 다음 토큰을 가리키기 위해.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">이제 표현 문법을 바로 살펴보고 각 규칙을 자바 코드로 번역해 보겠습니다.</font><font papago-translate="translated"> 첫 번째 규칙, </font></font><code translate="no">expression</code><font papago-translate="splitted"><font papago-translate="translated">, 단순히 다음으로 확장됩니다 </font></font><code translate="no">equality</code><font papago-translate="splitted"><font papago-translate="translated"> 규칙은 간단합니다.</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>Parser</em>() 뒤에 추가</font></font></div>
<pre translate="no">  <span class="k">private</span> <span class="t">Expr</span> <span class="i">expression</span>() {
    <span class="k">return</span> <span class="i">equality</span>();
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>Parser</em>()</div>
<p><font papago-translate="translated">문법 규칙을 구문 분석하는 각 방법은 해당 규칙에 대한 구문 트리를 생성하여 호출자에게 반환합니다.</font><font papago-translate="translated"> 규칙 본문에 비터미널(다른 규칙에 대한 참조)이 포함되어 있을 때, 우리는 그 다른 규칙<span class="em"></span><span class="em"></span>의 메서드<span name="left">를 호출합니다</span>.</font></p>
<aside name="left" style="top: 7386.5px;">
<p><font papago-translate="translated">이것이 바로 왼쪽 재귀가 재귀 하강에 문제가 되는 이유입니다.</font><font papago-translate="translated"> 왼쪽 순환 규칙의 함수는 즉시 자신을 호출하며, 파서가 스택 오버플로에 부딪혀 죽을 때까지 다시 호출합니다.</font></p>
</aside>
<p><font papago-translate="translated">평등에 대한 규칙은 조금 더 복잡합니다.</font></p>
<div class="codehilite"><pre translate="no"><span class="i">equality</span>       → <span class="i">comparison</span> ( ( <span class="s">"!="</span> | <span class="s">"=="</span> ) <span class="i">comparison</span> )* ;
</pre></div>
<p><font papago-translate="translated">자바에서는 이렇게 됩니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 식<em></em> () 뒤에 추가</font></font></div>
<pre translate="no">  <span class="k">private</span> <span class="t">Expr</span> <span class="i">equality</span>() {
    <span class="t">Expr</span> <span class="i">expr</span> = <span class="i">comparison</span>();

    <span class="k">while</span> (<span class="i">match</span>(<span class="i">BANG_EQUAL</span>, <span class="i">EQUAL_EQUAL</span>)) {
      <span class="t">Token</span> <span class="i">operator</span> = <span class="i">previous</span>();
      <span class="t">Expr</span> <span class="i">right</span> = <span class="i">comparison</span>();
      <span class="i">expr</span> = <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Binary</span>(<span class="i">expr</span>, <span class="i">operator</span>, <span class="i">right</span>);
    }

    <span class="k">return</span> <span class="i">expr</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>expression</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">한 걸음 더 나아가 보겠습니다.</font><font papago-translate="translated"> 첫 번째 </font></font><code translate="no">comparison</code><font papago-translate="splitted"><font papago-translate="translated"> 체내 비말단은 다음과 같은 첫 번째 호출로 번역됩니다 </font></font><code translate="no">comparison()</code><font papago-translate="splitted"><font papago-translate="translated"> 방법에서.</font><font papago-translate="translated"> 우리는 그 결과를 가져와서 지역 변수에 저장합니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">그러면 </font></font><code translate="no">( ... )*</code><font papago-translate="splitted"><font papago-translate="translated"> 규칙의 루프 맵은 다음과 같습니다 </font></font><code translate="no">while</code><font papago-translate="splitted"><font papago-translate="translated"> 루프. 우리는 그 루프를 언제 종료해야 하는지 알아야 합니다.</font><font papago-translate="translated"> 규칙 안에서 먼저 다음 중 하나를 찾아야 한다는 것을 알 수 있습니다 </font></font><code translate="no">!=</code><font papago-translate="splitted"><font papago-translate="translated"> 또는 </font></font><code translate="no">==</code><font papago-translate="splitted"><font papago-translate="translated"> 상품권.</font><font papago-translate="translated"> 따라서 이러한<em></em> 연산자 중 하나를 보지 못하면 평등 연산자의 순서를 완료해야 합니다.</font><font papago-translate="translated"> 우리는 그 수표를 핸디를 사용하여 표현합니다 </font></font><code translate="no">match()</code><font papago-translate="splitted"><font papago-translate="translated"> 방법.</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>평등</em> () 후에 추가하기</font></font></div>
<pre translate="no">  <span class="k">private</span> <span class="t">boolean</span> <span class="i">match</span>(<span class="t">TokenType</span>... <span class="i">types</span>) {
    <span class="k">for</span> (<span class="t">TokenType</span> <span class="i">type</span> : <span class="i">types</span>) {
      <span class="k">if</span> (<span class="i">check</span>(<span class="i">type</span>)) {
        <span class="i">advance</span>();
        <span class="k">return</span> <span class="k">true</span>;
      }
    }

    <span class="k">return</span> <span class="k">false</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>equality</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">현재 토큰에 주어진 유형이 있는지 확인합니다.</font><font papago-translate="translated"> 그렇다면 토큰을 소비하고 반환합니다 </font></font><code translate="no">true</code><font papago-translate="splitted"><font papago-translate="translated">. 그렇지 않으면 반환됩니다 </font></font><code translate="no">false</code><font papago-translate="splitted"><font papago-translate="translated"> 현재 토큰은 그대로 둡니다.</font><font papago-translate="translated"> 그 </font></font><code translate="no">match()</code><font papago-translate="splitted"><font papago-translate="translated"> 메서드는 두 가지 기본 연산으로 정의됩니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">그 </font></font><code translate="no">check()</code><font papago-translate="splitted"><font papago-translate="translated"> 메서드 반환 </font></font><code translate="no">true</code><font papago-translate="splitted"><font papago-translate="translated"> 현재 토큰이 지정된 유형인 경우.</font><font papago-translate="translated"> 와는 달리 </font></font><code translate="no">match()</code><font papago-translate="splitted"><font papago-translate="translated">, 토큰을 소비하지 않고 보기만 합니다.</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>경기</em> 후 () 추가</font></font></div>
<pre translate="no">  <span class="k">private</span> <span class="t">boolean</span> <span class="i">check</span>(<span class="t">TokenType</span> <span class="i">type</span>) {
    <span class="k">if</span> (<span class="i">isAtEnd</span>()) <span class="k">return</span> <span class="k">false</span>;
    <span class="k">return</span> <span class="i">peek</span>().<span class="i">type</span> == <span class="i">type</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>match</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">그 </font></font><code translate="no">advance()</code><font papago-translate="splitted"><font papago-translate="translated"> 메서드는 현재 토큰을 소비하고 반환합니다. 이는 스캐너의 해당 메서드가 문자를 크롤링하는 방식과 유사합니다.</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>확인</em> 후 추가 ()</font></font></div>
<pre translate="no">  <span class="k">private</span> <span class="t">Token</span> <span class="i">advance</span>() {
    <span class="k">if</span> (!<span class="i">isAtEnd</span>()) <span class="i">current</span>++;
    <span class="k">return</span> <span class="i">previous</span>();
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>check</em>()</div>
<p><font papago-translate="translated">이 방법들은 마지막 소수의 원시 연산에 기초합니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>사전</em> () 후 추가</font></font></div>
<pre translate="no">  <span class="k">private</span> <span class="t">boolean</span> <span class="i">isAtEnd</span>() {
    <span class="k">return</span> <span class="i">peek</span>().<span class="i">type</span> == <span class="i">EOF</span>;
  }

  <span class="k">private</span> <span class="t">Token</span> <span class="i">peek</span>() {
    <span class="k">return</span> <span class="i">tokens</span>.<span class="i">get</span>(<span class="i">current</span>);
  }

  <span class="k">private</span> <span class="t">Token</span> <span class="i">previous</span>() {
    <span class="k">return</span> <span class="i">tokens</span>.<span class="i">get</span>(<span class="i">current</span> - <span class="n">1</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>advance</em>()</div>
<p><code translate="no">isAtEnd()</code><font papago-translate="splitted"><font papago-translate="translated"> 구문 분석할 토큰이 부족한지 확인합니다. </font></font><code translate="no">peek()</code><font papago-translate="splitted"><font papago-translate="translated"> 아직 소비하지 않은 현재 토큰을 반환합니다 </font></font><code translate="no">previous()</code><font papago-translate="splitted"><font papago-translate="translated"> 가장 최근에 소비된 토큰을 반환합니다.</font><font papago-translate="translated"> 후자는 사용하기 쉽게 만듭니다 </font></font><code translate="no">match()</code><font papago-translate="splitted"><font papago-translate="translated"> 그런 다음 방금 matched 토큰에 액세스합니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">그것이 우리가 필요한 대부분의 파싱 인프라입니다.</font><font papago-translate="translated"> 우리가 어디까지 얘기했죠?</font><font papago-translate="translated"> 맞아요, 그래서 만약 우리가 안에 있다면 </font></font><code translate="no">while</code><font papago-translate="splitted"><font papago-translate="translated"> 루프 인 </font></font><code translate="no">equality()</code><font papago-translate="splitted"><font papago-translate="translated">, 그러면 우리는 우리가 </font></font><code translate="no">!=</code><font papago-translate="splitted"><font papago-translate="translated"> 또는 </font></font><code translate="no">==</code><font papago-translate="splitted"><font papago-translate="translated"> 연산자이며 등식을 구문 분석해야 합니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">우리는 일치하는 연산자 토큰을 가져와서 어떤 종류의 평등 표현이 있는지 추적할 수 있습니다.</font><font papago-translate="translated"> 그러면 우리는 전화합니다 </font></font><code translate="no">comparison()</code><font papago-translate="splitted"><font papago-translate="translated"> 다시 오른쪽 피연산자를 구문 분석합니다.</font><font papago-translate="translated"> 연산자와 그 두 피연산자를 결합하여 새로운 연산자를 만듭니다 </font></font><code translate="no">Expr.Binary</code><font papago-translate="splitted"><font papago-translate="translated"> 구문 트리 노드를 반복합니다.</font><font papago-translate="translated"> 각 반복마다 결과 표현식을 동일하게 다시 저장합니다 </font></font><code translate="no">expr</code><font papago-translate="splitted"><font papago-translate="translated"> 지역 변수.</font><font papago-translate="translated"> 일련의 등식 표현식을 살펴봄에 따라 이진 연산자 노드의 왼쪽 연관 중첩 트리가 생성됩니다.</font></font></p>
<p><span name="sequence"></span></p><img alt="The syntax tree created by parsing 'a == b == c == d == e'" src="https://youhogeon-meritz.github.io/image/parsing-expressions/sequence.png">
<aside name="sequence" style="top: 9404.5px;">
<p><font papago-translate="splitted"><font papago-translate="translated">구문 분석 </font></font><code translate="no">a == b == c == d == e</code><font papago-translate="splitted"><font papago-translate="translated">. 각 반복마다 이전 것을 왼쪽 피연산자로 사용하여 새로운 이진 표현식을 만듭니다.</font></font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">파서는 동등 연산자가 아닌 토큰에 도달하면 루프에서 제외됩니다.</font><font papago-translate="translated"> 마침내 표현을 반환합니다.</font><font papago-translate="translated"> 파서가 등호 연산자를 만나지 않으면 루프에 들어가지 않는다는 점에 유의하세요.</font><font papago-translate="translated"> 이 경우 </font></font><code translate="no">equality()</code><font papago-translate="splitted"><font papago-translate="translated"> 메서드가 효과적으로 호출하고 반환합니다 </font></font><code translate="no">comparison()</code><font papago-translate="splitted"><font papago-translate="translated">. 이러한 방식으로 이 방법은 동등 연산자<em> 또는 더 높은 우선순위를</em> 가진<em> 모든 것</em>과 일치합니다.</font></font></p>
<p><font papago-translate="translated">다음 규칙<span class="ellipse">으로</span> 넘어가<span class="ellipse">겠습니다 . . .</span></font></p>
<div class="codehilite"><pre translate="no"><span class="i">comparison</span>     → <span class="i">term</span> ( ( <span class="s">"&gt;"</span> | <span class="s">"&gt;="</span> | <span class="s">"&lt;"</span> | <span class="s">"&lt;="</span> ) <span class="i">term</span> )* ;
</pre></div>
<p><font papago-translate="translated">자바로 번역:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>평등</em> () 후에 추가하기</font></font></div>
<pre translate="no">  <span class="k">private</span> <span class="t">Expr</span> <span class="i">comparison</span>() {
    <span class="t">Expr</span> <span class="i">expr</span> = <span class="i">term</span>();

    <span class="k">while</span> (<span class="i">match</span>(<span class="i">GREATER</span>, <span class="i">GREATER_EQUAL</span>, <span class="i">LESS</span>, <span class="i">LESS_EQUAL</span>)) {
      <span class="t">Token</span> <span class="i">operator</span> = <span class="i">previous</span>();
      <span class="t">Expr</span> <span class="i">right</span> = <span class="i">term</span>();
      <span class="i">expr</span> = <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Binary</span>(<span class="i">expr</span>, <span class="i">operator</span>, <span class="i">right</span>);
    }

    <span class="k">return</span> <span class="i">expr</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>equality</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">문법 규칙은 사실상 다음과<span name="handle"> 동일합니다</span> </font></font><code translate="no">equality</code><font papago-translate="splitted"><font papago-translate="translated"> 해당 코드도 마찬가지입니다.</font><font papago-translate="translated"> 유일한 차이점은 우리가 매칭하는 연산자의 토큰 유형과 피연산자를 호출하는 방법입니다—<span class="em"></span>현재로서는 </font></font><code translate="no">term()</code><font papago-translate="splitted"><font papago-translate="translated"> 대신 </font></font><code translate="no">comparison()</code><font papago-translate="splitted"><font papago-translate="translated">. 나머지 두 이진 연산자 규칙은 동일한 패턴을 따릅니다.</font></font></p>
<p><font papago-translate="translated">우선순위, 첫 번째 덧셈 및 뺄셈 순서:</font></p>
<aside name="handle" style="top: 10162px;">
<p><font papago-translate="translated">영리한 Java 8을 사용하고 싶다면 토큰 유형 목록이 주어진 왼쪽 연관 이진 연산자 시리즈를 구문 분석하는 도우미 메서드와 이 중복 코드를 단순화하는 피연산자 메서드 핸들을 만들 수 있습니다.</font></p>
</aside>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>비교</em> 후 추가 ()</font></font></div>
<pre translate="no">  <span class="k">private</span> <span class="t">Expr</span> <span class="i">term</span>() {
    <span class="t">Expr</span> <span class="i">expr</span> = <span class="i">factor</span>();

    <span class="k">while</span> (<span class="i">match</span>(<span class="i">MINUS</span>, <span class="i">PLUS</span>)) {
      <span class="t">Token</span> <span class="i">operator</span> = <span class="i">previous</span>();
      <span class="t">Expr</span> <span class="i">right</span> = <span class="i">factor</span>();
      <span class="i">expr</span> = <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Binary</span>(<span class="i">expr</span>, <span class="i">operator</span>, <span class="i">right</span>);
    }

    <span class="k">return</span> <span class="i">expr</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>comparison</em>()</div>
<p><font papago-translate="translated">마지막으로, 곱셈과 나눗셈입니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>용어</em> () 후 추가</font></font></div>
<pre translate="no">  <span class="k">private</span> <span class="t">Expr</span> <span class="i">factor</span>() {
    <span class="t">Expr</span> <span class="i">expr</span> = <span class="i">unary</span>();

    <span class="k">while</span> (<span class="i">match</span>(<span class="i">SLASH</span>, <span class="i">STAR</span>)) {
      <span class="t">Token</span> <span class="i">operator</span> = <span class="i">previous</span>();
      <span class="t">Expr</span> <span class="i">right</span> = <span class="i">unary</span>();
      <span class="i">expr</span> = <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Binary</span>(<span class="i">expr</span>, <span class="i">operator</span>, <span class="i">right</span>);
    }

    <span class="k">return</span> <span class="i">expr</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>term</em>()</div>
<p><font papago-translate="translated">이것이 올바른 우선순위와 연관성으로 구문 분석된 모든 이진 연산자입니다.</font><font papago-translate="translated"> 우리는 우선순위 계층을 기어 올라가 이제 단항 연산자에 도달했습니다.</font></p>
<div class="codehilite"><pre translate="no"><span class="i">unary</span>          → ( <span class="s">"!"</span> | <span class="s">"-"</span> ) <span class="i">unary</span>
               | <span class="i">primary</span> ;
</pre></div>
<p><font papago-translate="translated">이것의 코드는 조금 다릅니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 애프터<em> 팩터</em> () 추가</font></font></div>
<pre translate="no">  <span class="k">private</span> <span class="t">Expr</span> <span class="i">unary</span>() {
    <span class="k">if</span> (<span class="i">match</span>(<span class="i">BANG</span>, <span class="i">MINUS</span>)) {
      <span class="t">Token</span> <span class="i">operator</span> = <span class="i">previous</span>();
      <span class="t">Expr</span> <span class="i">right</span> = <span class="i">unary</span>();
      <span class="k">return</span> <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Unary</span>(<span class="i">operator</span>, <span class="i">right</span>);
    }

    <span class="k">return</span> <span class="i">primary</span>();
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>factor</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">다시<span name="current"> 현재</span> 토큰을 살펴보고 구문 분석 방법을 살펴봅니다.</font><font papago-translate="translated"> 만약 </font></font><code translate="no">!</code><font papago-translate="splitted"><font papago-translate="translated"> 또는 </font></font><code translate="no">-</code><font papago-translate="splitted"><font papago-translate="translated">, 우리는 단항식을 가져야 합니다.</font><font papago-translate="translated"> 이 경우 토큰을 잡은 다음 재귀적으로 호출합니다 </font></font><code translate="no">unary()</code><font papago-translate="splitted"><font papago-translate="translated"> 다시 피연산자를 구문 분석합니다.</font><font papago-translate="translated"> 이 모든 것을 단항식 구문 트리로 마무리하면 끝입니다.</font></font></p>
<aside name="current" style="top: 11278px;">
<p><font papago-translate="translated">파서가 파서 방법을 결정하기 위해 다가오는 토큰을 미리 살펴본다는 사실은 재귀적 하강을<strong> 예측 파서</strong>의 범주에 포함시킵니다.</font></p>
</aside>
<p><font papago-translate="translated">그렇지 않으면 우리는 최고 수준의 우선순위, 즉 일차 표현에 도달했을 것입니다.</font></p>
<div class="codehilite"><pre translate="no"><span class="i">primary</span>        → <span class="t">NUMBER</span> | <span class="t">STRING</span> | <span class="s">"true"</span> | <span class="s">"false"</span> | <span class="s">"nil"</span>
               | <span class="s">"("</span> <span class="i">expression</span> <span class="s">")"</span> ;
</pre></div>
<p><font papago-translate="translated">규칙의 대부분은 단일 터미널이기 때문에 구문 분석이 간단합니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>단항</em> () 후에 추가</font></font></div>
<pre translate="no">  <span class="k">private</span> <span class="t">Expr</span> <span class="i">primary</span>() {
    <span class="k">if</span> (<span class="i">match</span>(<span class="i">FALSE</span>)) <span class="k">return</span> <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Literal</span>(<span class="k">false</span>);
    <span class="k">if</span> (<span class="i">match</span>(<span class="i">TRUE</span>)) <span class="k">return</span> <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Literal</span>(<span class="k">true</span>);
    <span class="k">if</span> (<span class="i">match</span>(<span class="i">NIL</span>)) <span class="k">return</span> <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Literal</span>(<span class="k">null</span>);

    <span class="k">if</span> (<span class="i">match</span>(<span class="i">NUMBER</span>, <span class="i">STRING</span>)) {
      <span class="k">return</span> <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Literal</span>(<span class="i">previous</span>().<span class="i">literal</span>);
    }

    <span class="k">if</span> (<span class="i">match</span>(<span class="i">LEFT_PAREN</span>)) {
      <span class="t">Expr</span> <span class="i">expr</span> = <span class="i">expression</span>();
      <span class="i">consume</span>(<span class="i">RIGHT_PAREN</span>, <span class="s">"Expect ')' after expression."</span>);
      <span class="k">return</span> <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Grouping</span>(<span class="i">expr</span>);
    }
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>unary</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">흥미로운 지점은 괄호를 다루는 지점입니다.</font><font papago-translate="translated"> 오프닝을 맞춘 후 </font></font><code translate="no">(</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고 그 안의 표현을 분석하면, 우리는 다음을 찾아야<em> 합니다</em> </font></font><code translate="no">)</code><font papago-translate="splitted"><font papago-translate="translated"> 상품권.</font><font papago-translate="translated"> 그렇지 않으면 오류입니다.</font></font></p>
<h2><a href="https://youhogeon-meritz.github.io/parsing-expressions.html#syntax-errors" id="syntax-errors"><small><font papago-translate="translated">6 . 3</font></small><font papago-translate="splitted"><font papago-translate="translated">구문 오류</font></font></a></h2>
<p><font papago-translate="translated">파서는 정말 두 가지 직업을 가지고 있습니다:</font></p>
<ol>
<li>
<p><font papago-translate="translated">유효한 토큰 시퀀스가 주어지면 해당 구문 트리를 생성합니다.</font></p>
</li>
<li>
<p><font papago-translate="translated">잘못된 토큰 시퀀스가 주어지면 오류를 감지하고 사용자에게<em></em> 오류에 대해 알려줍니다.</font></p>
</li>
</ol>
<p><font papago-translate="translated">두 번째 직업이 얼마나 중요한지 과소평가하지 마세요!</font><font papago-translate="translated"> 현대 IDE와 편집기에서 파서는 구문을 강조하고 자동<span class="em"></span><span class="em"></span> 완성과 같은 기능을 지원하기 위해 사용자가 여전히 편집하는 동안에도 코드를 지속적으로 재파싱합니다.</font><font papago-translate="translated"> 그것은 항상 불완전하고 반쯤 잘못된<em></em> 상태의 코드를 만나게 된다는 것을 의미합니다.</font></p>
<p><font papago-translate="translated">사용자가 구문이 잘못되었다는 것을 깨닫지 못하면 파서가 올바른 경로로 다시 안내하는 데 도움을 줄 수 있습니다.</font><font papago-translate="translated"> 오류를 보고하는 방식은 언어 사용자 인터페이스의 큰 부분을 차지합니다.</font><font papago-translate="translated"> 구문 오류를 잘 처리하는 것은 어렵습니다.</font><font papago-translate="translated"> 정의에 따르면 코드가 명확하게 정의된 상태가 아니므로 사용자가 무엇을 작성<em>했는지</em> 알 수 있는 확실한 방법은 없습니다.</font><font papago-translate="translated"> 파서는 당신<span name="telepathy">의 마음</span>을 읽을 수 없습니다.</font></p>
<aside name="telepathy" style="top: 12482px;">
<p><font papago-translate="translated">적어도 아직은.</font><font papago-translate="translated"> 요즘 기계 학습이 이렇게 진행되고 있는데, 미래가 어떻게 될지 누가 알겠습니까?</font></p>
</aside>
<p><font papago-translate="translated">구문 오류가 발생할 때 파서에 몇 가지 어려운 요구 사항이 있습니다.</font><font papago-translate="translated"> 파서는 반드시 해야 합니다:</font></p>
<ul>
<li>
<p><font papago-translate="translated"><strong>오류를 감지하고 보고합니다.</strong></font><font papago-translate="translated"> <span name="error">오류</span>를 감지하지 못하고 결과적으로 잘못된 구문 트리를 인터프리터에게 전달하면 모든 종류의 공포가 소환될 수 있습니다.</font></p>
<aside name="error" style="top: 12602px;">
<p><font papago-translate="translated">철학적으로 말하자면, 오류가 감지되지 않고 통역사가 코드를 실행한다면<em>, 그것</em>이<em> 정말</em> 오류일까요?</font></p>
</aside></li>
<li>
<p><font papago-translate="translated"><strong>충돌하거나 매달리지 마세요.</strong></font><font papago-translate="translated"> 구문 오류는 삶의 일부이며, 언어 도구는 그들 앞에서 견고해야 합니다.</font><font papago-translate="translated"> 세프 고장이나 무한 루프에 갇히는 것은 허용되지 않습니다.</font><font papago-translate="translated"> 소스<em>가</em> 유효<em>한 코드</em>가 아닐 수도 있지만, 사용자가 파서를 사용하여 허용되는 구문을 학습하기 때문에<em> 파서에 대한 유효한 입력입니다</em>.</font></p>
</li>
</ul>
<p><font papago-translate="translated">파서 게임에 참여하고 싶지만 그 이상으로 판돈을 올리고 싶다면 이것이 테이블 스테이크입니다.</font><font papago-translate="translated"> 괜찮은 파서는 다음과 같이 해야 합니다:</font></p>
<ul>
<li>
<p><font papago-translate="translated"><strong>빨리 하세요.</strong></font><font papago-translate="translated"> 컴퓨터는 파서 기술이 처음 발명되었을 때보다 수천 배 더 빠릅니다.</font><font papago-translate="translated"> 커피 휴식 시간 동안 전체 소스 파일을 통과할 수 있도록 파서를 최적화해야 했던 시대는 끝났습니다.</font><font papago-translate="translated"> 하지만 프로그래머의 기대치는 더 빠르지는 않더라도 빠르게 상승했습니다.</font><font papago-translate="translated"> 그들은 편집자들이 모든 키 입력 후에 파일을 밀리초 만에 다시 분석하기를 기대합니다.</font></p>
</li>
<li>
<p><font papago-translate="translated"><strong>명확한 오류가 있는 만큼 보고하세요.</strong></font><font papago-translate="translated"> 첫 번째 오류 이후에 중단하는 것은 구현하기 쉽지만, 사용자들이 파일의 유일한 오류라고 생각하는 내용을 수정할 때마다 새로운 오류가 나타나면 성가시게 만듭니다.</font><font papago-translate="translated"> 그들은 모두 보고 싶어 합니다.</font></p>
</li>
<li>
<p><font papago-translate="translated"><strong><em>계단</em>식 오류를 최소화합니다.</strong></font><font papago-translate="translated"> 한 번의 오류가 발견되면 파서는 더 이상 무슨 일이 일어나고 있는지 제대로 알지 못합니다.</font><font papago-translate="translated"> 다시 정상 궤도에 진입하고 계속 진행하려고 하지만, 혼란스러워지면 코드의 다른 실제 문제를 나타내지 않는 수많은 유령 오류를 보고할 수 있습니다.</font><font papago-translate="translated"> 첫 번째 오류가 수정되면 파서의 혼란만 반영하기 때문에 이러한 유령은 사라집니다.</font><font papago-translate="translated"> 계단식 오류는 사용자가 자신의 코드 상태가 더 나쁘다고 생각하도록 겁을 줄 수 있기 때문에 성가십니다.</font></p>
</li>
</ul>
<p><font papago-translate="translated">마지막 두 지점은 긴장 상태에 있습니다.</font><font papago-translate="translated"> 우리는 가능한 한 많은 개별 오류를 보고하고 싶지만, 이전 오류의 부작용에 불과한 오류는 보고하고 싶지 않습니다.</font></p>
<p><font papago-translate="translated">파서가 오류에 대응하고 이후 오류를 계속 찾는 방식을<strong> 오류 복구</strong>라고 합니다.</font><font papago-translate="translated"> 이것은 60년대에 뜨거운 연구 주제였습니다.</font><font papago-translate="translated"> 그 당시에는 비서에게 펀치 카드 더미를 건네주고 다음 날 돌아와서 컴파일러가 성공했는지 확인하곤 했습니다.</font><font papago-translate="translated"> 반복 루프가 느리면 코드의 모든 오류를 한<em></em> 번의 패스로 찾고 싶었습니다.</font></p>
<p><font papago-translate="translated">오늘날, 입력이 끝나기도 전에 파서가 완성되면 문제가 덜 됩니다.</font><font papago-translate="translated"> 간단하고 빠른 오류 복구는 괜찮습니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/parsing-expressions.html#panic-mode-error-recovery" id="panic-mode-error-recovery"><small><font papago-translate="translated">6 . 3 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">패닉 모드 오류 복구</font></font></a></h3>
<aside name="panic" style="top: 13826px;">
<p><font papago-translate="translated">당신은 그것을 밀어붙이고 싶어 한다는 것을 알고 있습니다.</font></p><img alt="A big shiny 'PANIC' button." src="https://youhogeon-meritz.github.io/image/parsing-expressions/panic.png">
</aside>
<p><font papago-translate="translated">과거에 고안된 모든 회복 기법 중에서 시간의 시험을 가장 잘 견뎌낸 기법은<span name="panic"><strong> 다소</strong></span> 놀랍도록<span name="panic"><strong> 공황</strong></span><span class="em"></span><span class="em"></span><span name="panic"><strong> 모드</strong></span>라고 불립니다.</font><font papago-translate="translated"> 파서가 오류를 감지하자마자 패닉 모드로 전환됩니다.</font><font papago-translate="translated"> 현재 상태가 일부 문법 작품의 중간에 있다는 점을 고려할 때 적어도 하나의 토큰이 의미가 없다는 것을 알고 있습니다.</font></p>
<p><font papago-translate="translated">구문 분석으로 돌아가기 전에 다음 토큰이 구문 분석 중인 규칙과 일치하도록 상태와 다가오는 토큰의 순서를 정렬해야 합니다.</font><font papago-translate="translated"> 이 과정을<strong> 동기화</strong>라고 합니다.</font></p>
<p><font papago-translate="translated">이를 위해 문법에서 동기화 지점을 표시할 몇 가지 규칙을 선택합니다.</font><font papago-translate="translated"> 파서는 해당 규칙으로 돌아갈 때까지 중첩된 프로덕션에서 뛰어내려 파싱 상태를 수정합니다.</font><font papago-translate="translated"> 그런 다음 토큰이 규칙의 해당 지점에 나타날 수 있는 토큰에 도달할 때까지 토큰을 폐기하여 토큰 스트림을 동기화합니다.</font></p>
<p><font papago-translate="translated">폐기된 토큰에 숨겨진 추가적인 실제 구문 오류는 보고되지 않지만, 이는 초기 오류의 부작용인 실수 연쇄 오류도<em> 거짓</em>으로 보고되지 않는다는 것을 의미하며, 이는 괜찮은 절충안입니다.</font></p>
<p><font papago-translate="translated">문법에서 전통적으로 동기화하는 위치는 문장 사이입니다.</font><font papago-translate="translated"> 아직 그런 것들이 없어서 이 장에서는 실제로 동기화하지 않겠지만, 나중에 기계를 설치할 예정입니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/parsing-expressions.html#entering-panic-mode" id="entering-panic-mode"><small><font papago-translate="translated">6 . 3 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">패닉 모드 진입</font></font></a></h3>
<p><font papago-translate="splitted"><font papago-translate="translated">우리가 오류 복구 문제를 해결하기 전에, 우리는 괄호로 묶은 표현식을 구문 분석하기 위해 코드를 작성하고 있었습니다.</font><font papago-translate="translated"> 식을 파싱한 후 파서는 마무리를 찾습니다 </font></font><code translate="no">)</code><font papago-translate="splitted"><font papago-translate="translated"> 전화로 </font></font><code translate="no">consume()</code><font papago-translate="splitted"><font papago-translate="translated">. 마지막으로, 이것이 그 방법입니다:</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>경기</em> 후 () 추가</font></font></div>
<pre translate="no">  <span class="k">private</span> <span class="t">Token</span> <span class="i">consume</span>(<span class="t">TokenType</span> <span class="i">type</span>, <span class="t">String</span> <span class="i">message</span>) {
    <span class="k">if</span> (<span class="i">check</span>(<span class="i">type</span>)) <span class="k">return</span> <span class="i">advance</span>();

    <span class="k">throw</span> <span class="i">error</span>(<span class="i">peek</span>(), <span class="i">message</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>match</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">다음과 유사합니다 </font></font><code translate="no">match()</code><font papago-translate="splitted"><font papago-translate="translated"> 다음 토큰이 예상되는 유형인지 확인한다는 점에서.</font><font papago-translate="translated"> 그렇다면 토큰을 소비하고 모든 것이 그루비합니다.</font><font papago-translate="translated"> 다른 토큰이 있으면 오류가 발생한 것입니다.</font><font papago-translate="translated"> 우리는 이것을 호출하여 보고합니다:</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>이전</em> () 뒤에 추가</font></font></div>
<pre translate="no">  <span class="k">private</span> <span class="t">ParseError</span> <span class="i">error</span>(<span class="t">Token</span> <span class="i">token</span>, <span class="t">String</span> <span class="i">message</span>) {
    <span class="t">Lox</span>.<span class="i">error</span>(<span class="i">token</span>, <span class="i">message</span>);
    <span class="k">return</span> <span class="k">new</span> <span class="t">ParseError</span>();
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>previous</em>()</div>
<p><font papago-translate="translated">먼저, 사용자에게 전화를 걸어 오류를 표시합니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Lox.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>보고서</em> () 후 추가</font></font></div>
<pre translate="no">  <span class="k">static</span> <span class="t">void</span> <span class="i">error</span>(<span class="t">Token</span> <span class="i">token</span>, <span class="t">String</span> <span class="i">message</span>) {
    <span class="k">if</span> (<span class="i">token</span>.<span class="i">type</span> == <span class="t">TokenType</span>.<span class="i">EOF</span>) {
      <span class="i">report</span>(<span class="i">token</span>.<span class="i">line</span>, <span class="s">" at end"</span>, <span class="i">message</span>);
    } <span class="k">else</span> {
      <span class="i">report</span>(<span class="i">token</span>.<span class="i">line</span>, <span class="s">" at '"</span> + <span class="i">token</span>.<span class="i">lexeme</span> + <span class="s">"'"</span>, <span class="i">message</span>);
    }
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Lox.java</em>, add after <em>report</em>()</div>
<p><font papago-translate="translated">이것은 주어진 토큰에서 오류를 보고합니다.</font><font papago-translate="translated"> 토큰의 위치와 토큰 자체를 표시합니다.</font><font papago-translate="translated"> 이것은 나중에 유용할 것입니다. 왜냐하면 우리는 코드에서 위치를 추적하기 위해 인터프리터 전반에 걸쳐 토큰을 사용하기 때문입니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">오류를 보고한 후 사용자는 자신의 실수에 대해 알고 있지만<em> 파서</em>는 다음에 무엇을 하나요?</font><font papago-translate="translated"> 다시 안으로 </font></font><code translate="no">error()</code><font papago-translate="splitted"><font papago-translate="translated">, 우리는 이 새로운 클래스의 인스턴스인 ParseError를 생성하고 반환합니다:</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">class Parser {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 클래스 파<em>서</em> 내부 둥지</font></font></div>
<pre class="insert" translate="no">  <span class="k">private</span> <span class="k">static</span> <span class="k">class</span> <span class="t">ParseError</span> <span class="k">extends</span> <span class="t">RuntimeException</span> {}

</pre><pre class="insert-after" translate="no">  private final List&lt;Token&gt; tokens;
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, nest inside class <em>Parser</em></div>
<p><font papago-translate="splitted"><font papago-translate="translated">이것은 파서를 풀기 위해 사용하는 간단한 감시 수업입니다.</font><font papago-translate="translated"> 그 </font></font><code translate="no">error()</code><font papago-translate="splitted"><font papago-translate="translated"> 메서드는 오류<em>를 던지는</em> 대신<em> 오류를 반환합니다</em>. 왜냐하면 파서 내부의 호출 메서드가 해제 여부를 결정하도록 하고 싶기 때문입니다.</font><font papago-translate="translated"> 파서가 이상한 상태가 되지 않을 가능성이 높고<span name="production"> 동기화</span>할 필요가 없는 곳에서 일부 파서 오류가 발생합니다.</font><font papago-translate="translated"> 그런 곳에서는 단순히 오류를 보고하고 트럭을 계속 운행합니다.</font></font></p>
<p><font papago-translate="translated">예를 들어, Lox는 함수에 전달할 수 있는 인수의 수를 제한합니다.</font><font papago-translate="translated"> 너무 많이 통과하면 파서가 그 오류를 보고해야 하지만, 당황해서 패닉 모드로 들어가는 대신 추가 인수를 파싱할 수 있고 계속해서 파싱해야 합니다.</font></p>
<aside name="production" style="top: 15498px;">
<p><font papago-translate="translated">일반적인 구문 오류를 처리하는 또 다른 방법은<strong> 오류 생성</strong>입니다.</font><font papago-translate="translated"> <em>문법</em>을 잘못된<em></em> 구문과 성공적으로 일치시키는 규칙으로 보강합니다.</font><font papago-translate="translated"> 파서는 이를 안전하게 파싱하지만 구문 트리를 생성하는 대신 오류로 보고합니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">예를 들어, 일부 언어에는 유니너리가 있습니다 </font></font><code translate="no">+</code><font papago-translate="splitted"><font papago-translate="translated"> 연산자, 예를 들어 </font></font><code translate="no">+123</code><font papago-translate="splitted"><font papago-translate="translated">, 하지만 Lox는 그렇지 않습니다.</font><font papago-translate="translated"> 파서가 실수할 때 혼란스러워하는 대신 </font></font><code translate="no">+</code><font papago-translate="splitted"><font papago-translate="translated"> 표현식의 시작 부분에서 우리는 단항 규칙을 확장하여 이를 허용할 수 있습니다.</font></font></p>
<div class="codehilite"><pre translate="no"><span class="i">unary</span> → ( <span class="s">"!"</span> | <span class="s">"-"</span> | <span class="s">"+"</span> ) <span class="i">unary</span>
      | <span class="i">primary</span> ;
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">이것은 파서가 소비할 수 있도록 합니다 </font></font><code translate="no">+</code><font papago-translate="splitted"><font papago-translate="translated"> 패닉 모드에 들어가지 않거나 파서를 이상한 상태로 두지 않습니다.</font></font></p>
<p><font papago-translate="translated">오류 생성은 파서 작성자인 사용자가 코드가<em> 어떻게</em> 잘못되었는지, 사용자가 무엇을 하려고 했는지 알고 있기 때문에 잘 작동합니다.</font><font papago-translate="translated"> 즉, "단순한 '+' 표현식은 지원되지 않습니다."와 같은 더 유용한 메시지를 제공하여 사용자를 정상으로 되돌릴 수 있습니다</font><font papago-translate="translated"> 성숙한 파서는 사용자가 일반적인 실수를 수정하는 데 도움이 되기 때문에 따개비와 같은 오류 생성이 누적되는 경향이 있습니다.</font></p>
</aside>
<p><font papago-translate="translated">하지만 우리의 경우 구문 오류가 너무 심해서 당황하고 동기화하고 싶을 정도입니다.</font><font papago-translate="translated"> 토큰을 폐기하는 것은 꽤 쉽지만, 파서의 상태를 어떻게 동기화할 수 있을까요?</font></p>
<h3><a href="https://youhogeon-meritz.github.io/parsing-expressions.html#synchronizing-a-recursive-descent-parser" id="synchronizing-a-recursive-descent-parser"><small><font papago-translate="translated">6 . 3 . 3</font></small><font papago-translate="splitted"><font papago-translate="translated">재귀 하강 파서 동기화</font></font></a></h3>
<p><font papago-translate="translated">재귀적 하강법에서는 파서의 상태(인식 중인 상태를 제어)<span class="em"></span><span class="em"></span>가 필드에 명시적으로 저장되지 않습니다.</font><font papago-translate="translated"> 대신, 우리는 Java의 자체 호출 스택을 사용하여 파서가 무엇을 하고 있는지 추적합니다.</font><font papago-translate="translated"> 구문 분석 중인 각 규칙은 스택의 호출 프레임입니다.</font><font papago-translate="translated"> 해당 상태를 재설정하려면 해당 통화 프레임을 삭제해야 합니다.</font></p>
<p><font papago-translate="translated">Java에서 이를 자연스럽게 수행하는 방법은 예외입니다.</font><font papago-translate="translated"> 동기화할 때는 ParseError 객체<em>를 던집니다</em>.</font><font papago-translate="translated"> 우리가 동기화하고 있는 문법 규칙의 상위 단계에서, 우리는 그것을 잡을 것입니다.</font><font papago-translate="translated"> 문장 경계에서 동기화되므로 예외를 잡을 수 있습니다.</font><font papago-translate="translated"> 예외가 발견되면 파서는 올바른 상태가 됩니다.</font><font papago-translate="translated"> 남은 것은 토큰을 동기화하는 것뿐입니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">다음 문장의 시작 부분에 도달할 때까지 토큰을 폐기하고 싶습니다.</font><font papago-translate="translated"> 그 경계는 꽤 쉽게 찾을 수 있습니다. 이것이 우리가 그것<span class="em"></span>을 선택한 주요 이유 중 하나입니다.</font><font papago-translate="translated"> 세미콜론<em>이 끝나면</em> 아마도 문장으로 마무리<span name="semicolon">될 것입니다</span><em>.</em></font><font papago-translate="translated"> 대부분의 문장은<span class="em"></span> 키워드로 시작합니다</font></font><code translate="no">for</code><font papago-translate="splitted"><font papago-translate="translated">, </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated">, </font></font><code translate="no">return</code><font papago-translate="splitted"><font papago-translate="translated">, </font></font><code translate="no">var</code><font papago-translate="splitted"><font papago-translate="translated">, 등.<em> 다음</em> 토큰이 그 중 하나일 때, 우리는 아마 성명서를 시작하려고 할 것입니다.</font></font></p>
<aside name="semicolon" style="top: 16218px;">
<p><font papago-translate="splitted"><font papago-translate="translated">제가 "아마도"라고 말하는 이유는 우리가 절을 구분하는 세미콜론을 사용할 수 있기 때문입니다 </font></font><code translate="no">for</code><font papago-translate="splitted"><font papago-translate="translated"> 루프. 동기화가 완벽하지는 않지만 괜찮습니다.</font><font papago-translate="translated"> 우리는 이미 첫 번째 오류를 정확하게 보고했기 때문에, 그 이후의 모든 것은 일종의 "최선의 노력"입니다.</font></font></p>
</aside>
<p><font papago-translate="translated">이 방법은 해당 논리를 캡슐화합니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>오류</em> 후 추가 ()</font></font></div>
<pre translate="no">  <span class="k">private</span> <span class="t">void</span> <span class="i">synchronize</span>() {
    <span class="i">advance</span>();

    <span class="k">while</span> (!<span class="i">isAtEnd</span>()) {
      <span class="k">if</span> (<span class="i">previous</span>().<span class="i">type</span> == <span class="i">SEMICOLON</span>) <span class="k">return</span>;

      <span class="k">switch</span> (<span class="i">peek</span>().<span class="i">type</span>) {
        <span class="k">case</span> <span class="i">CLASS</span>:
        <span class="k">case</span> <span class="i">FUN</span>:
        <span class="k">case</span> <span class="i">VAR</span>:
        <span class="k">case</span> <span class="i">FOR</span>:
        <span class="k">case</span> <span class="i">IF</span>:
        <span class="k">case</span> <span class="i">WHILE</span>:
        <span class="k">case</span> <span class="i">PRINT</span>:
        <span class="k">case</span> <span class="i">RETURN</span>:
          <span class="k">return</span>;
      }

      <span class="i">advance</span>();
    }
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>error</em>()</div>
<p><font papago-translate="translated">문장 경계를 찾았다고 생각할 때까지 토큰을 폐기합니다.</font><font papago-translate="translated"> ParseError를 포착한 후 이를 호출하고 다시 동기화되기를 바랍니다.</font><font papago-translate="translated"> 잘 작동하면 어차피 연쇄 오류를 일으킬 수 있는 토큰을 폐기했고, 이제 다음 문장부터 나머지 파일을 구문 분석할 수 있습니다.</font></p>
<p><font papago-translate="translated">안타깝게도 아직 진술이 없기 때문에 이 방법이 실제로 작동하는 것을 볼 수 없습니다.</font><font papago-translate="translated"> <a href="https://youhogeon-meritz.github.io/statements-and-state.html">몇 장 후에</a> 이 문제를 해결할 것입니다.</font><font papago-translate="translated"> 지금은 오류가 발생하면 당황하여 맨 위까지 긴장을 풀고 구문 분석을 중단하겠습니다.</font><font papago-translate="translated"> 어차피 하나의 표현만 구문 분석할 수 있기 때문에 큰 손실은 아닙니다.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/parsing-expressions.html#wiring-up-the-parser" id="wiring-up-the-parser"><small><font papago-translate="translated">6 . 4</font></small><font papago-translate="splitted"><font papago-translate="translated">파서 배선하기</font></font></a></h2>
<p><font papago-translate="splitted"><font papago-translate="translated">이제 대부분의 구문 분석이 끝났습니다.</font><font papago-translate="translated"> 오류 처리를 조금 더 추가해야 할 또 다른 곳이 있습니다.</font><font papago-translate="translated"> 파서가 각 문법 규칙에 대한 파싱 방법을 통해 내려가면서 결국 </font></font><code translate="no">primary()</code><font papago-translate="splitted"><font papago-translate="translated">. 해당 사례 중 어느 것도 일치하지 않는다면 표현식을 시작할 수 없는 토큰에 앉아 있다는 의미입니다.</font><font papago-translate="translated"> 우리도 그 오류를 처리해야 합니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    if (match(LEFT_PAREN)) {
      Expr expr = expression();
      consume(RIGHT_PAREN, "Expect ')' after expression.");
      return new Expr.Grouping(expr);
    }
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>일차</em> ()에서</font></font></div>
<pre class="insert" translate="no">
    <span class="k">throw</span> <span class="i">error</span>(<span class="i">peek</span>(), <span class="s">"Expect expression."</span>);
</pre><pre class="insert-after" translate="no">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>primary</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">이제 파서에 남아 있는 것은 파서를 시작할 초기 방법을 정의하는 것뿐입니다.</font><font papago-translate="translated"> 그 방법은 당연히 충분히 불립니다, </font></font><code translate="no">parse()</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>Parser</em>() 뒤에 추가</font></font></div>
<pre translate="no">  <span class="t">Expr</span> <span class="i">parse</span>() {
    <span class="k">try</span> {
      <span class="k">return</span> <span class="i">expression</span>();
    } <span class="k">catch</span> (<span class="t">ParseError</span> <span class="i">error</span>) {
      <span class="k">return</span> <span class="k">null</span>;
    }
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>Parser</em>()</div>
<p><font papago-translate="translated">이 방법은 나중에 언어에 문장을 추가할 때 다시 검토하겠습니다.</font><font papago-translate="translated"> 현재로서는 하나의 표현을 구문 분석하고 반환합니다.</font><font papago-translate="translated"> 패닉 모드에서 종료할 수 있는 임시 코드도 있습니다.</font><font papago-translate="translated"> 구문 오류 복구는 파서의 작업이므로 ParseError 예외가 인터프리터의 나머지 부분으로 빠져나가는 것을 원하지 않습니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">구문 오류가 발생하면 이 메서드는 반환됩니다 </font></font><code translate="no">null</code><font papago-translate="splitted"><font papago-translate="translated">. 괜찮습니다.</font><font papago-translate="translated"> 파서는 잘못된 구문을 크래시하거나 보류하지 않겠다고 약속하지만, 오류가 발견되면<em> 사용 가능한 구문 트리</em>를 반환하겠다고 약속하지는 않습니다.</font><font papago-translate="translated"> 파서가 오류를 보고하는 즉시, </font></font><code translate="no">hadError</code><font papago-translate="splitted"><font papago-translate="translated"> 설정된 후 단계를 건너뛸 수 있습니다.</font></font></p>
<p><font papago-translate="translated">마지막으로, 새로운 파서를 메인 Lox 클래스에 연결하여 사용해 볼 수 있습니다.</font><font papago-translate="translated"> 아직 인터프리터가 없기 때문에 지금은 구문 트리로 파싱한 다음<a href="https://youhogeon-meritz.github.io/representing-code.html#a-not-very-pretty-printer"> 마지막 장</a>의 AstPrinter 클래스를 사용하여 표시하겠습니다.</font></p>
<p><font papago-translate="translated">스캔한 토큰을 인쇄하려면 이전 코드를 삭제하고 다음 코드로 대체합니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    List&lt;Token&gt; tokens = scanner.scanTokens();
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Lox.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 5줄 교체</font></font></div>
<pre class="insert" translate="no">    <span class="t">Parser</span> <span class="i">parser</span> = <span class="k">new</span> <span class="t">Parser</span>(<span class="i">tokens</span>);
    <span class="t">Expr</span> <span class="i">expression</span> = <span class="i">parser</span>.<span class="i">parse</span>();

    <span class="c">// Stop if there was a syntax error.</span>
    <span class="k">if</span> (<span class="i">hadError</span>) <span class="k">return</span>;

    <span class="t">System</span>.<span class="i">out</span>.<span class="i">println</span>(<span class="k">new</span> <span class="t">AstPrinter</span>().<span class="i">print</span>(<span class="i">expression</span>));
</pre><pre class="insert-after" translate="no">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Lox.java</em>, in <em>run</em>(), replace 5 lines</div>
<p><font papago-translate="translated">축하합니다<span name="harder">, 문턱</span>을 넘으셨습니다!</font><font papago-translate="translated"> 파서를 손으로 쓰는 것이 정말 전부입니다.</font><font papago-translate="translated"> 문법은 나중 장에서 과제, 문장 및 기타 내용으로 확장하겠지만, 여기서 다룬 이진 연산자보다 더 복잡한 것은 없습니다.</font></p>
<aside name="harder" style="top: 18294px;">
<p><font papago-translate="translated">재귀적 하강법을 사용하여 분석하기 어려운 Lox 문법보다 더 복잡한 문법을 정의하는 것이 가능합니다.</font><font papago-translate="translated"> 예측 구문 분석은 자신이 무엇을 하고 있는지 파악하기 위해 많은 토큰을 미리 살펴봐야 할 때 까다로워집니다.</font></p>
<p><font papago-translate="translated">실제로 대부분의 언어는 이를 방지하도록 설계되어 있습니다.</font><font papago-translate="translated"> 그렇지 않은 경우에도 보통 큰 고통 없이 해킹할 수 있습니다.</font><font papago-translate="translated"> 만약 많은 C++ 컴파일러들이 하는 재귀적 하강법을 사용하여 C++를 파싱할 수 있다면<span class="em"></span><span class="em"></span>, 무엇이든 파싱할 수 있습니다.</font></p>
</aside>
<p><font papago-translate="translated">통역사를 실행하고 몇 가지 표현을 입력합니다.</font><font papago-translate="translated"> 우선순위와 연관성을 올바르게 처리하는 방법을 확인할 수 있습니까?</font><font papago-translate="translated"> 200줄 미만의 코드로도 나쁘지 않습니다.</font></p>
<div class="challenges">
<h2><a href="https://youhogeon-meritz.github.io/parsing-expressions.html#challenges" id="challenges"><font papago-translate="translated">과제들</font></a></h2>
<ol>
<li>
<p><font papago-translate="translated">C에서 블록은 하나의 문장이 예상되는 일련의 문장을 포장할 수 있는 문장 형식입니다.</font><font papago-translate="translated"> <a href="https://en.wikipedia.org/wiki/Comma_operator">쉼표 연산자</a>는 표현식에 대한 유사한 구문입니다.</font><font papago-translate="translated"> 쉼표로 구분된 일련의 표현식은 단일 표현식이 예상되는 경우(함수 호출의 인수 목록 내 제외) 제공될 수 있습니다.</font><font papago-translate="translated"> 런타임 시, 쉼표 연산자는 왼쪽 피연산자를 평가하고 결과를 버립니다.</font><font papago-translate="translated"> 그런 다음 올바른 피연산자를 평가하고 반환합니다.</font></p>
<p><font papago-translate="translated">쉼표 표현식에 대한 지원을 추가합니다.</font><font papago-translate="translated"> 그들에게 C에서와 같은 우선순위와 연관성을 부여하세요.</font><font papago-translate="translated"> 문법을 작성한 다음 필요한 구문 분석 코드를 구현합니다.</font></p>
</li>
<li>
<p><font papago-translate="splitted"><font papago-translate="translated">마찬가지로 C 스타일 조건부 또는 "삼차" 연산자에 대한 지원을 추가합니다 </font></font><code translate="no">?:</code><font papago-translate="splitted"><font papago-translate="translated">. 다음 사이에 허용되는 우선 순위 수준 </font></font><code translate="no">?</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">:</code><font papago-translate="splitted"><font papago-translate="translated">? 전체 연산자가 왼쪽 결합 연산자인가요, 오른쪽 결합 연산자인가요?</font></font></p>
</li>
<li>
<p><font papago-translate="translated">왼쪽 피연산자 없이 나타나는 각 이진 연산자를 처리하기 위해 오류 연산을 추가합니다.</font><font papago-translate="translated"> 즉, 식의 시작 부분에 나타나는 이진 연산자를 감지합니다.</font><font papago-translate="translated"> 그것을 오류로 보고하되, 적절한 우선순위를 가진 오른쪽 피연산자를 분석하고 폐기해야 합니다.</font></p>
</li>
</ol>
</div>
<div class="design-note">
<h2><a href="https://youhogeon-meritz.github.io/parsing-expressions.html#design-note" id="design-note"><font papago-translate="translated">디자인 노트: 논리 대 역사</font></a></h2>
<p><font papago-translate="splitted"><font papago-translate="translated">비트 단위로 추가하기로 결정했다고 가정해 보겠습니다 </font></font><code translate="no">&amp;</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">|</code><font papago-translate="splitted"><font papago-translate="translated"> 록스로 가는 운영자.</font><font papago-translate="translated"> 그들을 우선순위 계층에서 어디에 두어야 할까요?</font><font papago-translate="translated"> C와 C의 발자취를 따르는 대부분의 언어는<span class="em"></span><span class="em"></span> 아래에 배치합니다 </font></font><code translate="no">==</code><font papago-translate="splitted"><font papago-translate="translated">. 이는 깃발을 테스트하는 것과 같은 일반적인 작업에는 괄호가 필요하기 때문에 실수로 널리 간주됩니다.</font></font></p>
<div class="codehilite"><pre translate="no"><span class="k">if</span> (<span class="i">flags</span> &amp; <span class="a">FLAG_MASK</span> == <span class="a">SOME_FLAG</span>) { ... } <span class="c">// Wrong.</span>
<span class="k">if</span> ((<span class="i">flags</span> &amp; <span class="a">FLAG_MASK</span>) == <span class="a">SOME_FLAG</span>) { ... } <span class="c">// Right.</span>
</pre></div>
<p><font papago-translate="translated">Lox에 대해 이 문제를 해결하고 비트 단위 연산자를 C보다 우선순위 테이블 위에 올려야 할까요?</font><font papago-translate="translated"> 우리가 취할 수 있는 두 가지 전략이 있습니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">거의 다음과 같은 결과를 사용하고 싶지 않을 것입니다 </font></font><code translate="no">==</code><font papago-translate="splitted"><font papago-translate="translated"> 비트 단위 연산자에 대한 피연산자로서의 표현.</font><font papago-translate="translated"> 비트와이즈 바인딩을 더 단단히 설정하면 사용자가 자주 괄호를 묶을 필요가 없습니다.</font><font papago-translate="translated"> 따라서 사용자가 괄호를 최소화하기 위해 논리적으로 우선순위를 선택한다고 가정하면 올바르게 추론할 가능성이 높습니다.</font></font></p>
<p><font papago-translate="translated">이러한 내부 일관성은 사용자가 우연히 발견한 후 수정해야 하는 엣지 케이스와 예외가 적기 때문에 언어를 더 쉽게 배울 수 있게 합니다.</font><font papago-translate="translated"> 사용자가 우리 언어를 사용하기 전에 모든 구문과 의미를 머릿속에 채워야 하기 때문에 좋습니다.</font><font papago-translate="translated"> 더 간단하고 합리적인 언어가<em> 합리적</em>입니다.</font></p>
<p><font papago-translate="translated">하지만 많은 사용자에게는<em> 이미</em><span class="em"></span><em> 알고 있는 개념을 사용하여</em> 우리 언어의 아이디어를 웨트웨어로 가져오는 더 빠른 지름길이 있습니다.</font><font papago-translate="translated"> 우리 언어의 많은 새로운 사람들이 다른 언어나 언어에서 올 것입니다.</font><font papago-translate="translated"> 우리 언어가 그것들과 동일한 구문이나 의미론을 사용한다면, 사용자가 배울 것이 훨씬 적습니다 (그리고<em> 배우지 않음</em>).</font></p>
<p><font papago-translate="translated">이것은 구문에 특히 도움이 됩니다.</font><font papago-translate="translated"> 오늘날 잘 기억하지 못할 수도 있지만, 처음 프로그래밍 언어를 배웠을 때 코드는 아마도 낯설고 접근하기 어려워 보였을 것입니다.</font><font papago-translate="translated"> 오직 열심히 노력해야만 읽고 받아들이는 법을 배웠습니다.</font><font papago-translate="translated"> 새로운 언어를 위한 새로운 구문을 설계하면 사용자가 해당 프로세스를 처음부터 다시 시작하도록 강제합니다.</font></p>
<p><font papago-translate="translated">사용자가 이미 알고 있는 것을 활용하는 것은 언어 채택을 용이하게 하는 데 사용할 수 있는 가장 강력한 도구 중 하나입니다.</font><font papago-translate="translated"> 이것이 얼마나 가치 있는지 과대평가하는 것은 거의 불가능합니다.</font><font papago-translate="translated"> 하지만 그것은 끔찍한 문제에 직면해 있습니다:</font><font papago-translate="translated"> 사용자들이 모두 알고 있는<em> 것이 조금 형편없</em>으면 어떻게 될까요?</font><font papago-translate="translated"> C의 비트 단위 연산자 우선순위는 말이 안 되는 실수입니다.</font><font papago-translate="translated"> 하지만 이미 수백만 명이 익숙해지고 함께 살아가는 법을 배운<em> 익숙한</em> 실수입니다.</font></p>
<p><font papago-translate="translated">당신은 자신의 언어 내부 논리에 충실하고 역사를 무시합니까?</font><font papago-translate="translated"> 빈 슬레이트와 첫 번째 원칙에서 시작하시겠습니까?</font><font papago-translate="translated" class="papago-selected"> 아니면 당신의 언어를 풍부한 프로그래밍 역사의 태피스트리에 엮어 사용자들이 이미 알고 있는 것부터 시작함으로써 우위를 점할 수 있을까요?</font></p>
<p><font papago-translate="translated">여기에는 완벽한 답이 없고, 단지 절충안일 뿐입니다.</font><font papago-translate="translated"> 당신과 나는 분명히 새로운 언어를 좋아하는 것에 편향되어 있기 때문에, 우리의 자연스러운 성향은 역사책을 불태우고 우리만의 이야기를 시작하는 것입니다.</font></p>
<p><font papago-translate="translated">실제로는 사용자가 이미 알고 있는 것을 최대한 활용하는 것이 더 좋습니다.</font><font papago-translate="translated"> 그들이 당신의 언어를 접하게 하려면 큰 도약이 필요합니다.</font><font papago-translate="translated"> 그 틈새를 작게 만들 수 있을수록 더 많은 사람들이 기꺼이 건너갈 것입니다.</font><font papago-translate="translated"> 하지만 항상 역사를 고수할 수는 없으며, 그렇지 않으면 사람들에게<em></em> 뛰어넘을<em> 이유</em>를 제공할 새롭고 설득력 있는 언어가 없을 것입니다.</font></p>
</div>
<footer>
<a class="next" href="https://youhogeon-meritz.github.io/evaluating-expressions.html"><font papago-translate="translated"> 다음 장: "표현식 평가" → </font></a><font papago-translate="splitted"><font papago-translate="translated"> 로버트 니스트롬이 수작업으로 제작한 -<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE"> © 2015 ~ 2021</a></font></font>
</footer>
</article>
</div>


<div id="papagoTooltip" margin="5">
        <h1 id="tooltipTitle">원문</h1>
        <p id="tooltipText"></p>
      </div>
      </body></html>