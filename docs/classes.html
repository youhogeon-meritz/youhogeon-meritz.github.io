<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link rel="stylesheet" type="text/css" href="cid:css-74e3a93c-895a-4784-b2b1-f4411ed5aeb0@mhtml.blink" />

<title>Classes · Crafting Interpreters</title>
<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta content="width=device-width, initial-scale=1" name="viewport">
<link href="https://youhogeon-meritz.github.io/style.css" rel="stylesheet" type="text/css">
<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600" rel="stylesheet" type="text/css">
<link href="https://youhogeon-meritz.github.io/image/favicon.png" rel="icon" type="image/png">


<!-- Google analytics -->

</head>
<body id="top">
<!-- <div class="scrim"></div> -->
<nav class="wide">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<div class="contents">
<h3><a href="https://youhogeon-meritz.github.io/classes.html#top"><font papago-translate="splitted"><font papago-translate="translated">반</font></font><small>12</small></a></h3>
<ul>
<li><a href="https://youhogeon-meritz.github.io/classes.html#oop-and-classes"><small>12.1</small><font papago-translate="splitted"><font papago-translate="translated"> OOP 및 클래스</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/classes.html#class-declarations"><small>12.2</small><font papago-translate="splitted"><font papago-translate="translated"> 클래스 선언</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/classes.html#creating-instances"><small>12.3</small><font papago-translate="splitted"><font papago-translate="translated"> 인스턴스 생성</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/classes.html#properties-on-instances"><small>12.4</small><font papago-translate="splitted"><font papago-translate="translated"> 인스턴스의 속성</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/classes.html#methods-on-classes"><small>12.5</small><font papago-translate="splitted"><font papago-translate="translated"> 수업 방법</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/classes.html#this"><small>12.6</small><font papago-translate="splitted"><font papago-translate="translated"> 이것.</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/classes.html#constructors-and-initializers"><small>12.7</small><font papago-translate="splitted"><font papago-translate="translated"> 생성자 및 초기화자</font></font></a></li>
<li class="divider"></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/classes.html#challenges"><font papago-translate="translated">과제들</font></a></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/classes.html#design-note"><small><font papago-translate="translated">메모</font></small><font papago-translate="splitted"><font papago-translate="translated">프로토타입과 파워</font></font></a></li>
</ul>
<div class="prev-next">
<a class="left" href="https://youhogeon-meritz.github.io/resolving-and-binding.html" title="해결 및 바인딩" papago-attr-id="1"><font papago-translate="translated">← 이전</font></a>
<a href="https://youhogeon-meritz.github.io/a-tree-walk-interpreter.html" title="나무 산책 통역사" papago-attr-id="2"><font papago-translate="translated">↑ 위로</font></a>
<a class="right" href="https://youhogeon-meritz.github.io/inheritance.html" title="상속" papago-attr-id="3"><font papago-translate="translated">다음 →</font></a>
</div> </div>
</nav>
<nav class="narrow">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<a class="prev" href="https://youhogeon-meritz.github.io/resolving-and-binding.html" title="Resolving and Binding">←</a>
<a class="next" href="https://youhogeon-meritz.github.io/inheritance.html" title="Inheritance">→</a>
</nav>
<div class="page">
<div class="nav-wrapper">
<nav class="floating pinned">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<div class="expandable">
<h3><a href="https://youhogeon-meritz.github.io/classes.html#top"><font papago-translate="splitted"><font papago-translate="translated">반</font></font><small>12</small></a></h3>
<ul>
<li><a href="https://youhogeon-meritz.github.io/classes.html#oop-and-classes"><small>12.1</small><font papago-translate="splitted"><font papago-translate="translated"> OOP 및 클래스</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/classes.html#class-declarations"><small>12.2</small><font papago-translate="splitted"><font papago-translate="translated"> 클래스 선언</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/classes.html#creating-instances"><small>12.3</small><font papago-translate="splitted"><font papago-translate="translated"> 인스턴스 생성</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/classes.html#properties-on-instances"><small>12.4</small><font papago-translate="splitted"><font papago-translate="translated"> 인스턴스의 속성</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/classes.html#methods-on-classes"><small>12.5</small><font papago-translate="splitted"><font papago-translate="translated"> 수업 방법</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/classes.html#this"><small>12.6</small><font papago-translate="splitted"><font papago-translate="translated"> 이것.</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/classes.html#constructors-and-initializers"><small>12.7</small><font papago-translate="splitted"><font papago-translate="translated"> 생성자 및 초기화자</font></font></a></li>
<li class="divider"></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/classes.html#challenges">Challenges</a></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/classes.html#design-note"><small>note</small><font papago-translate="splitted"><font papago-translate="translated">프로토타입과 파워</font></font></a></li>
</ul>
<div class="prev-next">
<a class="left" href="https://youhogeon-meritz.github.io/resolving-and-binding.html" title="Resolving and Binding">←&nbsp;Previous</a>
<a href="https://youhogeon-meritz.github.io/a-tree-walk-interpreter.html" title="A Tree-Walk Interpreter">↑&nbsp;Up</a>
<a class="right" href="https://youhogeon-meritz.github.io/inheritance.html" title="Inheritance">Next&nbsp;→</a>
</div> </div>
<a id="expand-nav">≡</a>
</nav>
</div>
<article class="chapter">
<div class="number">12</div>
<h1><font papago-translate="translated">반</font></h1>
<blockquote>
<p><font papago-translate="translated" class="">어떤 것이든 그 본질에 대한 철저한 지식을 습득하지 못하면 사랑하거나 미워할 권리가 없습니다.</font><font papago-translate="translated"> 위대한 사랑은 사랑하는 대상에 대한 위대한 지식에서 비롯되며, 그것을 조금만 알고 있어도 그것을 조금만 사랑하거나 전혀 사랑하지 못할 것입니다.</font></p>
<p><cite>Leonardo da Vinci</cite></p>
</blockquote>
<p><font papago-translate="translated">우리는 11개의 챕터로 구성되어 있으며, 당신의 기계에 앉아 있는 통역사는 거의 완전한 스크립트 언어입니다.</font><font papago-translate="translated"> 목록이나 지도와 같은 몇 가지 내장 데이터 구조를 사용할 수 있으며, 파일 입출력, 사용자 입력 등을 위한 핵심 라이브러리가 필요합니다.</font><font papago-translate="translated"> 하지만 언어 자체만으로도 충분합니다.</font><font papago-translate="translated"> 우리는 BASIC, Tcl, Scheme (마이너스 매크로), 그리고 초기 버전의 Python과 Lua와 같은 맥락에서 약간의 절차적 언어를 가지고 있습니다.</font></p>
<p><font papago-translate="translated">만약 이것이 80년대였다면, 우리는 여기서 멈췄을 것입니다.</font><font papago-translate="translated"> 하지만 오늘날 많은 인기 언어들이 "객체 지향 프로그래밍"을 지원합니다.</font><font papago-translate="translated" class=""> 이 기능을 Lox에 추가하면 사용자에게 더 큰 프로그램을 작성할 수 있는 친숙한 도구 세트를 제공할 수 있습니다.</font><font papago-translate="translated"> 개인적으로 OOP<span name="hate">를 좋아하지</span> 않더라도 이 장과<a href="https://youhogeon-meritz.github.io/inheritance.html"> 다음 장</a>에서는 다른 사람들이 객체 시스템을 어떻게 설계하고 구축하는지 이해하는 데 도움이 될 것입니다.</font></p>
<aside name="hate" style="top: 724px;">
<p><font papago-translate="translated">하지만 수업이<em> 정말</em> 싫다면 이 두 장을 건너뛰어도 됩니다.</font><font papago-translate="translated"> 그들은 책의 나머지 부분과 상당히 격리되어 있습니다.</font><font papago-translate="translated"> 개인적으로 제가 싫어하는 것들에 대해 더 많이 배우는 것이 좋다고 생각합니다.</font><font papago-translate="translated" class=""> 멀리서 보면 단순해 보이지만 가까이 다가갈수록 디테일이 나타나고 더 미묘한 관점을 갖게 됩니다.</font></p>
</aside>
<h2><a href="https://youhogeon-meritz.github.io/classes.html#oop-and-classes" id="oop-and-classes"><small><font papago-translate="translated">12 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">OOP 및 클래스</font></font></a></h2>
<p><font papago-translate="translated">객체 지향 프로그래밍에는 크게 세 가지 경로가 있습니다: 클래스<a href="http://gameprogrammingpatterns.com/prototype.html">, 프로토타입</a>,<span name="multimethods"><a href="https://en.wikipedia.org/wiki/Multiple_dispatch"> 그리고 멀티메소드</a></span>입니다.</font><font papago-translate="translated"> 수업이 먼저 시작되었고 가장 인기 있는 스타일입니다.</font><font papago-translate="translated"> 자바스크립트(그리고 L<a href="https://www.lua.org/pil/13.4.1.html">u</a>a)의 등장으로 프로토타입이 예전보다 더 널리 알려지게 되었습니다.</font><font papago-translate="translated"> 그것들에 대해서<a href="https://youhogeon-meritz.github.io/classes.html#design-note">는 나중에</a> 더 이야기하겠습니다.</font><font papago-translate="translated"> Lox의 경우, 우리는 고전적인 접근 방식을 취하고 있습니다.</font></p>
<aside name="multimethods" style="top: 892px;">
<p><font papago-translate="translated">다중 방법은 당신이 익숙하지 않을 가능성이 가장 낮은 접근 방식입니다.</font><font papago-translate="translated"> <a href="http://magpie-lang.org/">저</a>는<a href="http://magpie-lang.org/"> 그</a>들에 대해 더 이야기하고 싶어요.<a href="http://magpie-lang.org/"> 한</a> 번<a href="http://magpie-lang.org/"> 취미 언어</a>를 디자인한 적이 있는데<em>, 그것</em>들은<em> 정말 매력적</em>이에요. 하지만<span class="em"></span><span class="em"></span> 제가 넣을 수 있는 페이지가 너무 많아요.</font><font papago-translate="translated"> 더 배우고 싶다면, C<a href="https://en.wikipedia.org/wiki/Common_Lisp_Object_System">LO</a>(Common Lisp의 객체 시스템),<a href="https://opendylan.org/"> Dylan</a><a href="https://julialang.org/">, Julia</a> 또는<a href="https://docs.raku.org/language/functions#Multi-dispatch"> Raku</a>를 살펴보세요.</font></p>
</aside>
<p><font papago-translate="translated">이미 저와 함께 약 천 줄의 자바 코드를 작성하셨기 때문에 객체 방향에 대한 자세한 소개가 필요하지 않다고 생각합니다.</font><font papago-translate="translated"> 주요 목표는 데이터를 작동하는 코드와 결합하는 것입니다.</font><font papago-translate="translated"> 사용자는<em> 다음과</em> 같은<em> 클래스</em>를 선언함으로써 이를 수행합니다:</font></p>
<p><span name="circle"></span></p>
<ol>
<li>
<p><font papago-translate="translated"><em>생성자</em>를 노출하여 클래스의 새<em> 인스턴스</em>를 생성하고 초기화합니다</font></p>
</li>
<li>
<p><font papago-translate="translated">인스턴스<em>에 필드</em>를 저장하고 액세스하는 방법을 제공합니다</font></p>
</li>
<li>
<p><font papago-translate="translated">각 인스턴스의 상태에서 작동하는 클래스의 모든 인스턴스가 공유하는<em> 메서드</em> 집합을 정의합니다.</font></p>
</li>
</ol>
<p><font papago-translate="translated">그것은 거의 최소한의 것입니다.</font><font papago-translate="translated"> 대부분의 객체 지향 언어는 Simula로 거슬러 올라가며, 클래스 간의 동작을 재사용하기 위해 상속을 합니다.</font><font papago-translate="translated"> 다음<a href="https://youhogeon-meritz.github.io/inheritance.html"> 장</a>에 추가하겠습니다.</font><font papago-translate="translated"> 이 문제를 해결하더라도 아직 해결해야 할 일이 많습니다.</font><font papago-translate="translated"> 이것은 큰 장이며 위의 모든 것이 완성되기 전까지는 모든 것이 잘 맞지 않으므로 체력을 비축하세요.</font></p>
<aside name="circle" style="top: 1130px;"><img alt="The relationships between classes, methods, instances, constructors, and fields." src="https://youhogeon-meritz.github.io/image/classes/circle.png">
<p><font papago-translate="translated">그것은 마치 생명의 순환과도 같습니다<em>, 엘</em>튼 존 경<em>.</em></font></p>
</aside>
<h2><a href="https://youhogeon-meritz.github.io/classes.html#class-declarations" id="class-declarations"><small><font papago-translate="translated">12 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">클래스 선언</font></font></a></h2>
<p><font papago-translate="splitted"><font papago-translate="translated">우리처럼 구문부터 시작하겠습니다. A </font></font><code translate="no">class</code><font papago-translate="splitted"><font papago-translate="translated"> 문장은 새로운 이름을 도입하여 다음과 같이 살아갑니다 </font></font><code translate="no">declaration</code><font papago-translate="splitted"><font papago-translate="translated"> 문법 규칙.</font></font></p>
<div class="codehilite"><pre translate="no"><span class="i">declaration</span>    → <span class="i">classDecl</span>
               | <span class="i">funDecl</span>
               | <span class="i">varDecl</span>
               | <span class="i">statement</span> ;

<span class="i">classDecl</span>      → <span class="s">"class"</span> <span class="t">IDENTIFIER</span> <span class="s">"{"</span> <span class="i">function</span>* <span class="s">"}"</span> ;
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">새로운 </font></font><code translate="no">classDecl</code><font papago-translate="splitted"><font papago-translate="translated"> 규칙은 다음에 따라 달라집니다 </font></font><code translate="no">function</code><font papago-translate="splitted"><font papago-translate="translated"> 앞서<a href="https://youhogeon-meritz.github.io/functions.html#function-declarations"></a> 정의한 규칙.</font><font papago-translate="translated"> 기억을 새로 고침하려면:</font></font></p>
<div class="codehilite"><pre translate="no"><span class="i">function</span>       → <span class="t">IDENTIFIER</span> <span class="s">"("</span> <span class="i">parameters</span>? <span class="s">")"</span> <span class="i">block</span> ;
<span class="i">parameters</span>     → <span class="t">IDENTIFIER</span> ( <span class="s">","</span> <span class="t">IDENTIFIER</span> )* ;
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">일반 영어로 수업 선언문은 다음과 같습니다 </font></font><code translate="no">class</code><font papago-translate="splitted"><font papago-translate="translated"> 키워드, 그 다음에 반 이름, 그리고 곱슬머리 몸매.</font><font papago-translate="translated"> 그 본문 안에는 메서드 선언 목록이 있습니다.</font><font papago-translate="translated"> 함수 선언과 달리 메서드에는 주요<span name="fun"> 키워드가</span> 없습니다.</font><font papago-translate="translated"> 각 메서드는 이름, 매개변수 목록, 본문입니다.</font><font papago-translate="translated"> 다음은 예시입니다:</font></font></p>
<aside name="fun" style="top: 1916px;">
<p><font papago-translate="translated">방법이 재미없다는 말은 아닙니다.</font></p>
</aside>
<div class="codehilite"><pre translate="no"><span class="k">class</span> <span class="t">Breakfast</span> {
  <span class="i">cook</span>() {
    <span class="k">print</span> <span class="s">"Eggs a-fryin'!"</span>;
  }

  <span class="i">serve</span>(<span class="i">who</span>) {
    <span class="k">print</span> <span class="s">"Enjoy your breakfast, "</span> + <span class="i">who</span> + <span class="s">"."</span>;
  }
}
</pre></div>
<p><font papago-translate="translated">대부분의 동적으로 입력된 언어들처럼, 필드는 클래스 선언에 명시적으로 나열되어 있지 않습니다.</font><font papago-translate="translated"> 인스턴스는 느슨한 데이터 묶음이며, 일반 명령어 코드를 사용하여 원하는 대로 필드를 자유롭게 추가할 수 있습니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">AST 생성기의 </font></font><code translate="no">classDecl</code><font papago-translate="splitted"><font papago-translate="translated"> 문법 규칙은 고유한 문<span name="class-ast"> 노드</span>를 갖습니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      "Block      : List&lt;Stmt&gt; statements",
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">도구/GenerateAst.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>메인</em> ()에서</font></font></div>
<pre class="insert" translate="no">      <span class="s">"Class      : Token name, List&lt;Stmt.Function&gt; methods"</span>,
</pre><pre class="insert-after" translate="no">      "Expression : Expr expression",
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>main</em>()</div>
<aside name="class-ast" style="top: 2288px;">
<p><font papago-translate="translated">새 노드에 대한 생성된 코드는 부록<a href="https://youhogeon-meritz.github.io/appendix-ii.html#class-statement"> II</a>에 있습니다.</font></p>
</aside>
<p><font papago-translate="translated">클래스의 이름과 메서드를 본문에 저장합니다.</font><font papago-translate="translated"> 메서드는 기존 Stmt로 표현됩니다.</font><font papago-translate="translated">함수 선언 AST 노드에 사용하는 함수 클래스.</font><font papago-translate="translated"> 그것은 우리가 방법에 필요한 모든 상태의 비트를 제공합니다: 이름, 매개변수 목록, 본문.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">클래스는 이름이 지정된 선언이 허용되는 모든 곳에 나타날 수 있으며, 선두에 의해 트리거됩니다 </font></font><code translate="no">class</code><font papago-translate="splitted"><font papago-translate="translated"> 키워드.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    try {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>선언</em>문 ()에서</font></font></div>
<pre class="insert" translate="no">      <span class="k">if</span> (<span class="i">match</span>(<span class="i">CLASS</span>)) <span class="k">return</span> <span class="i">classDeclaration</span>();
</pre><pre class="insert-after" translate="no">      if (match(FUN)) return function("function");
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>declaration</em>()</div>
<p><font papago-translate="translated">이는 다음과 같습니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>선언</em> 후 () 추가</font></font></div>
<pre translate="no">  <span class="k">private</span> <span class="t">Stmt</span> <span class="i">classDeclaration</span>() {
    <span class="t">Token</span> <span class="i">name</span> = <span class="i">consume</span>(<span class="i">IDENTIFIER</span>, <span class="s">"Expect class name."</span>);
    <span class="i">consume</span>(<span class="i">LEFT_BRACE</span>, <span class="s">"Expect '{' before class body."</span>);

    <span class="t">List</span>&lt;<span class="t">Stmt</span>.<span class="t">Function</span>&gt; <span class="i">methods</span> = <span class="k">new</span> <span class="t">ArrayList</span>&lt;&gt;();
    <span class="k">while</span> (!<span class="i">check</span>(<span class="i">RIGHT_BRACE</span>) &amp;&amp; !<span class="i">isAtEnd</span>()) {
      <span class="i">methods</span>.<span class="i">add</span>(<span class="i">function</span>(<span class="s">"method"</span>));
    }

    <span class="i">consume</span>(<span class="i">RIGHT_BRACE</span>, <span class="s">"Expect '}' after class body."</span>);

    <span class="k">return</span> <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">Class</span>(<span class="i">name</span>, <span class="i">methods</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>declaration</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">여기에는 대부분의 다른 구문 분석 방법보다 더 많은 양의 고기가 있지만, 대략 문법을 따릅니다.</font><font papago-translate="translated"> 우리는 이미 </font></font><code translate="no">class</code><font papago-translate="splitted"><font papago-translate="translated"> 키워드를 사용하여 다음으로 예상되는 클래스 이름을 찾고, 그 다음으로 열린 컬리 브레이스를 찾습니다.</font><font papago-translate="translated"> 일단 몸 안에 들어가면, 우리는 종료 괄호를 맞출 때까지 메서드 선언을 계속 파싱합니다.</font><font papago-translate="translated"> 각 메서드 선언은 다음과 같은 호출로 구문 분석됩니다 </font></font><code translate="no">function()</code><font papago-translate="splitted"><font papago-translate="translated">, <a href="https://youhogeon-meritz.github.io/functions.html">함수가 도입된 장</a>에서 정의한 내용입니다.</font></font></p>
<p><font papago-translate="translated">파서의 모든 오픈 엔드 루프에서와 마찬가지로 파일의 끝을 맞추는 것도 확인합니다.</font><font papago-translate="translated"> 올바른 코드에서는 클래스가 끝에 닫는 괄호가 있어야 하므로 이러한 일이 발생하지 않지만, 구문 오류가 발생하여 클래스 본문을 올바르게 종료하는 것을 잊어버린 경우 파서가 무한 루프에 갇히지 않도록 보장합니다.</font></p>
<p><font papago-translate="translated">메서드의 이름과 목록을 Stmt로 포장합니다.</font><font papago-translate="translated">클래스 노드와 완료되었습니다.</font><font papago-translate="translated"> 이전에는 인터프리터로 바로 들어가곤 했지만, 이제는 먼저 리졸버를 통해 노드를 연결해야 합니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>방문</em> 후 추가 Bl<em>ockStmt</em>()</font></font></div>
<pre translate="no">  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitClassStmt</span>(<span class="t">Stmt</span>.<span class="t">Class</span> <span class="i">stmt</span>) {
    <span class="i">declare</span>(<span class="i">stmt</span>.<span class="i">name</span>);
    <span class="i">define</span>(<span class="i">stmt</span>.<span class="i">name</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>visitBlockStmt</em>()</div>
<p><font papago-translate="translated">아직 방법 자체를 해결하는 것에 대해 걱정하지 않을 것이므로 지금은 이름을 사용하여 수업을 선언하기만 하면 됩니다.</font><font papago-translate="translated"> 클래스를 로컬 변수로 선언하는 것은 흔하지 않지만, Lox는 이를 허용하므로 올바르게 처리해야 합니다.</font></p>
<p><font papago-translate="translated">이제 클래스 선언을 해석합니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Interpreter.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>방문</em> 후 추가 Bl<em>ockStmt</em>()</font></font></div>
<pre translate="no">  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitClassStmt</span>(<span class="t">Stmt</span>.<span class="t">Class</span> <span class="i">stmt</span>) {
    <span class="i">environment</span>.<span class="i">define</span>(<span class="i">stmt</span>.<span class="i">name</span>.<span class="i">lexeme</span>, <span class="k">null</span>);
    <span class="t">LoxClass</span> <span class="i">klass</span> = <span class="k">new</span> <span class="t">LoxClass</span>(<span class="i">stmt</span>.<span class="i">name</span>.<span class="i">lexeme</span>);
    <span class="i">environment</span>.<span class="i">assign</span>(<span class="i">stmt</span>.<span class="i">name</span>, <span class="i">klass</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>visitBlockStmt</em>()</div>
<p><font papago-translate="translated">이것은 함수 선언을 실행하는 방식과 유사해 보입니다.</font><font papago-translate="translated"> 현재 환경에서 수업 이름을 선언합니다.</font><font papago-translate="translated"> 그런 다음 클래스<em> 구문 노드를</em> 클래스<em>의 런타임</em> 표현인 LoxClass로 변환합니다.</font><font papago-translate="translated"> 우리는 이전에 선언한 변수에 클래스 객체를 다시 원을 그리며 저장합니다.</font><font papago-translate="translated"> 이 2단계 변수 바인딩 프로세스는 자체 메서드 내의 클래스를 참조할 수 있게 합니다.</font></p>
<p><font papago-translate="translated">장 전체에 걸쳐 자세히 설명하겠지만, LoxClass의 초안은 다음과 같습니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/LoxClass.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 새 파일 만들기</font></font></div>
<pre translate="no"><span class="k">package</span> <span class="i">com.craftinginterpreters.lox</span>;

<span class="k">import</span> <span class="i">java.util.List</span>;
<span class="k">import</span> <span class="i">java.util.Map</span>;

<span class="k">class</span> <span class="t">LoxClass</span> {
  <span class="k">final</span> <span class="t">String</span> <span class="i">name</span>;

  <span class="t">LoxClass</span>(<span class="t">String</span> <span class="i">name</span>) {
    <span class="k">this</span>.<span class="i">name</span> = <span class="i">name</span>;
  }

  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">String</span> <span class="i">toString</span>() {
    <span class="k">return</span> <span class="i">name</span>;
  }
}
</pre></div>
<div class="source-file-narrow"><em>lox/LoxClass.java</em>, create new file</div>
<p><font papago-translate="splitted"><font papago-translate="translated">말 그대로 이름을 감싸는 포장지입니다.</font><font papago-translate="translated"> 우리는 아직 방법들을 저장하지도 않습니다.</font><font papago-translate="translated"> 그다지 유용하지는 않지만 다음과 같은 기능이 있습니다 </font></font><code translate="no">toString()</code><font papago-translate="splitted"><font papago-translate="translated"> 간단한 스크립트를 작성하고 클래스 객체가 실제로 구문 분석 및 실행되고 있는지 테스트할 수 있는 방법입니다.</font></font></p>
<div class="codehilite"><pre translate="no"><span class="k">class</span> <span class="t">DevonshireCream</span> {
  <span class="i">serveOn</span>() {
    <span class="k">return</span> <span class="s">"Scones"</span>;
  }
}

<span class="k">print</span> <span class="t">DevonshireCream</span>; <span class="c">// Prints "DevonshireCream".</span>
</pre></div>
<h2><a href="https://youhogeon-meritz.github.io/classes.html#creating-instances" id="creating-instances"><small><font papago-translate="translated">12 . 3</font></small><font papago-translate="splitted"><font papago-translate="translated">인스턴스 생성</font></font></a></h2>
<p><font papago-translate="translated">수업이 있지만 아직 아무것도 하지 않습니다.</font><font papago-translate="translated"> Lox는 수업 자체에서 호출할 수 있는 "정적인" 방법이 없기 때문에 실제 사례가 없으면 수업은 쓸모가 없습니다.</font><font papago-translate="translated"> 따라서 사례는 다음 단계입니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">일부 구문과 의미론은 OOP 언어 전반에서 상당히 표준적이지만, 새로운 인스턴스를 만드는 방식은 그렇지 않습니다.</font><font papago-translate="translated"> Ruby는 Smalltalk를 따라 클래스 객체 자체에 메서드를 호출하여 인스턴스를 생성하는데<span name="turtles">, 이</span>는<span name="turtles"> 재귀</span>적으로 우아한 접근 방식입니다.</font><font papago-translate="translated"> C++ 및 Java와 같은 일부는 </font></font><code translate="no">new</code><font papago-translate="splitted"><font papago-translate="translated"> 새로운 객체를 탄생시키는 데 전념하는 키워드.</font><font papago-translate="translated"> 파이썬은 클래스 자체를 함수처럼 "호출"하게 합니다.</font><font papago-translate="translated"> (JavaScript는 이상하게도 둘 다 합니다.)</font></font></p>
<aside name="turtles" style="top: 4920px;">
<p><font papago-translate="translated">Smalltalk에서는 기존 객체, 일반적으로 원하는 슈퍼클래스에 대해 호출 메서드를 사용하여<em> 클래스</em>도 생성됩니다.</font><font papago-translate="translated"> 그것은 일종의 거북이처럼 끝까지 내려오는 것입니다.</font><font papago-translate="translated"> 궁극적으로 이 게임은 객체와 메타클래스와 같은 몇 가지 마법 클래스를 기반으로 하며, 런타임을<em> 통해 전 니힐로</em>가 탄생하게 됩니다.</font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">저는 Lox에 대해 최소한의 접근 방식을 취했습니다.</font><font papago-translate="translated"> 클래스 객체가 이미 있고 함수 호출도 이미 있으므로 클래스 객체에 대한 호출 표현식을 사용하여 새로운 인스턴스를 만들겠습니다.</font><font papago-translate="translated"> 마치 클래스가 자신의 인스턴스를 생성하는 공장 함수인 것 같습니다.</font><font papago-translate="translated"> 이것은 저에게 우아하게 느껴지며, 또한 다음과 같은 구문을 도입할 필요성을 줄여줍니다 </font></font><code translate="no">new</code><font papago-translate="splitted"><font papago-translate="translated">. 따라서, 우리는 앞쪽 끝을 지나 바로 런타임으로 넘어갈 수 있습니다.</font></font></p>
<p><font papago-translate="translated">지금 이 순간을 시도해 보세요:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">class</span> <span class="t">Bagel</span> {}
<span class="t">Bagel</span>();
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">런타임 오류가 발생합니다. </font></font><code translate="no">visitCallExpr()</code><font papago-translate="splitted"><font papago-translate="translated"> 호출된 객체가 다음을 구현하는지 확인합니다 </font></font><code translate="no">LoxCallable</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고 LoxClass가 그렇지 않기 때문에 오류를 보고합니다.</font><font papago-translate="translated"> <em>아직</em>은 그렇지 않습니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">import java.util.Map;

</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/LoxClass.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no"><span class="k">class</span> <span class="t">LoxClass</span> <span class="k">implements</span> <span class="t">LoxCallable</span> {
</pre><pre class="insert-after" translate="no">  final String name;
</pre></div>
<div class="source-file-narrow"><em>lox/LoxClass.java</em>, replace 1 line</div>
<p><font papago-translate="translated">그 인터페이스를 구현하려면 두 가지 방법이 필요합니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/LoxClass.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 문자열(<em></em>) 뒤에 추가</font></font></div>
<pre translate="no">  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Object</span> <span class="i">call</span>(<span class="t">Interpreter</span> <span class="i">interpreter</span>,
                     <span class="t">List</span>&lt;<span class="t">Object</span>&gt; <span class="i">arguments</span>) {
    <span class="t">LoxInstance</span> <span class="i">instance</span> = <span class="k">new</span> <span class="t">LoxInstance</span>(<span class="k">this</span>);
    <span class="k">return</span> <span class="i">instance</span>;
  }

  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">int</span> <span class="i">arity</span>() {
    <span class="k">return</span> <span class="n">0</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/LoxClass.java</em>, add after <em>toString</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">흥미로운 점은 </font></font><code translate="no">call()</code><font papago-translate="splitted"><font papago-translate="translated">. 클래스를 "호출"하면 호출된 클래스에 대해 새로운 LoxInstance를 인스턴스화하고 반환합니다.</font><font papago-translate="translated"> 그 </font></font><code translate="no">arity()</code><font papago-translate="splitted"><font papago-translate="translated"> 메서드는 인터프리터가 호출 가능한 사람에게 올바른 인수를 전달했는지 확인하는 방법입니다.</font><font papago-translate="translated"> 지금은 아무 것도 통과할 수 없다고 말씀드리겠습니다.</font><font papago-translate="translated"> 사용자 정의 생성자에 도달하면 다시 살펴보겠습니다.</font></font></p>
<p><font papago-translate="translated">이는 Lox 클래스 인스턴스의 런타임 표현인 LoxInstance로 이어집니다.</font><font papago-translate="translated"> 다시 말하지만, 우리의 첫 번째 구현은 작게 시작됩니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/LoxInstance.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 새 파일 만들기</font></font></div>
<pre translate="no"><span class="k">package</span> <span class="i">com.craftinginterpreters.lox</span>;

<span class="k">import</span> <span class="i">java.util.HashMap</span>;
<span class="k">import</span> <span class="i">java.util.Map</span>;

<span class="k">class</span> <span class="t">LoxInstance</span> {
  <span class="k">private</span> <span class="t">LoxClass</span> <span class="i">klass</span>;

  <span class="t">LoxInstance</span>(<span class="t">LoxClass</span> <span class="i">klass</span>) {
    <span class="k">this</span>.<span class="i">klass</span> = <span class="i">klass</span>;
  }

  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">String</span> <span class="i">toString</span>() {
    <span class="k">return</span> <span class="i">klass</span>.<span class="i">name</span> + <span class="s">" instance"</span>;
  }
}
</pre></div>
<div class="source-file-narrow"><em>lox/LoxInstance.java</em>, create new file</div>
<p><font papago-translate="translated">LoxClass와 마찬가지로, 이는 아직 시작 단계에 불과합니다.</font><font papago-translate="translated"> 한 번 시도해보고 싶으시다면, 다음과 같은 스크립트를 실행해 보세요:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">class</span> <span class="t">Bagel</span> {}
<span class="k">var</span> <span class="i">bagel</span> = <span class="t">Bagel</span>();
<span class="k">print</span> <span class="i">bagel</span>; <span class="c">// Prints "Bagel instance".</span>
</pre></div>
<p><font papago-translate="translated">이 프로그램은 별로 효과가 없지만<em>, 이제 뭔가</em> 효과가 나타나기 시작했습니다.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/classes.html#properties-on-instances" id="properties-on-instances"><small><font papago-translate="translated">12 . 4</font></small><font papago-translate="splitted"><font papago-translate="translated">인스턴스의 속성</font></font></a></h2>
<p><font papago-translate="translated">인스턴스가 있으므로 유용하게 만들어야 합니다.</font><font papago-translate="translated"> 우리는 지금 갈림길에 서 있습니다.</font><font papago-translate="translated"> 행동을 먼저 추가할 수도 있고, 방법을 추가할 수도 있고, 상태<span class="em"></span><span class="em"></span><span class="em"></span> 속성부터 시작할 수도 있습니다.</font><font papago-translate="translated"> 우리가 후자를 선택할 이유는, 보시다시피, 두 가지가 흥미로운 방식으로 얽혀 있기 때문입니다. 먼저 속성을 작동시키면 그들을 이해하기가 더 쉬워질 것이기 때문입니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">Lox는 상태를 처리하는 방식에서 JavaScript와 Python을 따릅니다.</font><font papago-translate="translated"> 모든 인스턴스는 명명된 값의 열린 컬렉션입니다.</font><font papago-translate="translated"> 인스턴스 클래스의 메서드는 속성에 접근하고 수정할 수 있지만<span name="outside">, 외부</span> 코드도 마찬가지입니다.</font><font papago-translate="translated"> 속성은 다음을 사용하여 액세스합니다 </font></font><code translate="no">.</code><font papago-translate="splitted"><font papago-translate="translated"> 구문.</font></font></p>
<aside name="outside" style="top: 6884px;">
<p><font papago-translate="splitted"><font papago-translate="translated">클래스 외부의 코드가 객체의 필드를 직접 수정하도록 허용하는 것은 클래스가 상태<em>를 캡슐화하는</em> 객체 지향 크리도에 반하는 것입니다.</font><font papago-translate="translated"> 일부 언어는 더 원칙적인 입장을 취합니다.</font><font papago-translate="translated"> Smalltalk에서는 필드에 간단한 식별자, 즉 클래스<span class="em"></span> 메서드 내에서만 허용되는 변수를 사용하여 접근합니다.</font><font papago-translate="translated"> 루비 사용 </font></font><code translate="no">@</code><font papago-translate="splitted"><font papago-translate="translated"> 객체의 필드에 접근할 수 있는 이름이 이어집니다.</font><font papago-translate="translated"> 그 구문은 메서드 내부에서만 의미가 있으며 항상 현재 객체의 상태에 액세스합니다.</font></font></p>
<p><font papago-translate="translated">좋든 나쁘든 록스는 OOP 신앙에 대해 그렇게 경건하지 않습니다.</font></p>
</aside>
<div class="codehilite"><pre translate="no"><span class="i">someObject</span>.<span class="i">someProperty</span>
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">다음에 오는 표현 </font></font><code translate="no">.</code><font papago-translate="splitted"><font papago-translate="translated"> 식별자는 표현식이 평가하는 객체에서 해당 이름을 가진 속성을 읽습니다.</font><font papago-translate="translated"> 그 점은 함수 호출 표현식의 괄호와 동일한 우선순위를 가지므로, 기존 점을 대체하여 문법에 삽입합니다 </font></font><code translate="no">call</code><font papago-translate="splitted"><font papago-translate="translated"> 다음과 같이 통치합니다:</font></font></p>
<div class="codehilite"><pre translate="no"><span class="i">call</span>           → <span class="i">primary</span> ( <span class="s">"("</span> <span class="i">arguments</span>? <span class="s">")"</span> | <span class="s">"."</span> <span class="t">IDENTIFIER</span> )* ;
</pre></div>
<p><font papago-translate="translated">기본 표현 후에는 괄호로 묶은 호출과 점선 속성 접근의 혼합을 허용합니다.</font><font papago-translate="translated"> "재산 접근"은 입에 담기 때문에, 이제부터는 이를 "표현식 얻기"라고 부르겠습니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/classes.html#get-expressions" id="get-expressions"><small><font papago-translate="translated">12 . 4 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">표현식 가져오기</font></font></a></h3>
<p><font papago-translate="translated"><span name="get-ast">구문 트리 노드</span>는 다음과 같습니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      "Call     : Expr callee, Token paren, List&lt;Expr&gt; arguments",
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">도구/GenerateAst.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>메인</em> ()에서</font></font></div>
<pre class="insert" translate="no">      <span class="s">"Get      : Expr object, Token name"</span>,
</pre><pre class="insert-after" translate="no">      "Grouping : Expr expression",
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>main</em>()</div>
<aside name="get-ast" style="top: 7308px;">
<p><font papago-translate="translated">새 노드에 대한 생성된 코드는 부록<a href="https://youhogeon-meritz.github.io/appendix-ii.html#get-expression"> II</a>에 있습니다.</font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">문법에 따라 새로운 구문 분석 코드가 기존 구문에 적용됩니다 </font></font><code translate="no">call()</code><font papago-translate="splitted"><font papago-translate="translated"> 방법.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    while (true) {<span name="while-true"> </span>
      if (match(LEFT_PAREN)) {
        expr = finishCall(expr);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>콜</em> ()에서</font></font></div>
<pre class="insert" translate="no">      } <span class="k">else</span> <span class="k">if</span> (<span class="i">match</span>(<span class="i">DOT</span>)) {
        <span class="t">Token</span> <span class="i">name</span> = <span class="i">consume</span>(<span class="i">IDENTIFIER</span>,
            <span class="s">"Expect property name after '.'."</span>);
        <span class="i">expr</span> = <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Get</span>(<span class="i">expr</span>, <span class="i">name</span>);
</pre><pre class="insert-after" translate="no">      } else {
        break;
      }
    }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>call</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">바깥쪽 </font></font><code translate="no">while</code><font papago-translate="splitted"><font papago-translate="translated"> 루프는 다음과 같습니다 </font></font><code translate="no">*</code><font papago-translate="splitted"><font papago-translate="translated"> 문법 규칙에서.</font><font papago-translate="translated"> 토큰을 따라 이동하여 일련의 호출을 구성하고 괄호와 점을 찾으면 다음과 같이 얻을 수 있습니다:</font></font></p><img alt="Parsing a series of '.' and '()' expressions to an AST." src="https://youhogeon-meritz.github.io/image/classes/zip.png">
<p><font papago-translate="translated">새로운 탐험가의 사례들.</font><font papago-translate="translated">노드 피드를 리졸버로 가져옵니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>방문</em> 후 추가C<em>allEx</em>pr()</font></font></div>
<pre translate="no">  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitGetExpr</span>(<span class="t">Expr</span>.<span class="t">Get</span> <span class="i">expr</span>) {
    <span class="i">resolve</span>(<span class="i">expr</span>.<span class="i">object</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>visitCallExpr</em>()</div>
<p><font papago-translate="translated">네, 별로 그렇지 않습니다.</font><font papago-translate="translated"> 속성이<span name="dispatch"> 동적으로</span> 조회되기 때문에 문제가 해결되지 않습니다.</font><font papago-translate="translated"> 해상도 중에는 점의 왼쪽에 있는 표현식에만 반복됩니다.</font><font papago-translate="translated"> 실제 부동산 접근은 통역사에서 이루어집니다.</font></p>
<aside name="dispatch" style="top: 8306px;">
<p><font papago-translate="translated">정적 해상도 패스 중에는 속성 이름을 처리하지 않기 때문에 Lox에서 속성 디스패치가 동적이라는 것을 알 수 있습니다.</font></p>
</aside>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Interpreter.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>방문</em> 후 추가C<em>allEx</em>pr()</font></font></div>
<pre translate="no">  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Object</span> <span class="i">visitGetExpr</span>(<span class="t">Expr</span>.<span class="t">Get</span> <span class="i">expr</span>) {
    <span class="t">Object</span> <span class="i">object</span> = <span class="i">evaluate</span>(<span class="i">expr</span>.<span class="i">object</span>);
    <span class="k">if</span> (<span class="i">object</span> <span class="k">instanceof</span> <span class="t">LoxInstance</span>) {
      <span class="k">return</span> ((<span class="t">LoxInstance</span>) <span class="i">object</span>).<span class="i">get</span>(<span class="i">expr</span>.<span class="i">name</span>);
    }

    <span class="k">throw</span> <span class="k">new</span> <span class="t">RuntimeError</span>(<span class="i">expr</span>.<span class="i">name</span>,
        <span class="s">"Only instances have properties."</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>visitCallExpr</em>()</div>
<p><font papago-translate="translated">먼저, 우리는 접근 중인 속성을 평가합니다.</font><font papago-translate="translated"> Lox에서는 클래스 인스턴스만 속성을 가집니다.</font><font papago-translate="translated"> 객체가 숫자와 같은 다른 유형이라면 게터를 호출하는 것은 런타임 오류입니다.</font></p>
<p><font papago-translate="translated">객체가 LoxInstance인 경우 속성을 조회하도록 요청합니다.</font><font papago-translate="translated"> LoxInstance에 실제 상태를 제공할 때가 된 것 같습니다.</font><font papago-translate="translated"> 지도면 괜찮습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  private LoxClass klass;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/LoxInstance.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 클래스 L<em>oxInstance</em>에서</font></font></div>
<pre class="insert" translate="no">  <span class="k">private</span> <span class="k">final</span> <span class="t">Map</span>&lt;<span class="t">String</span>, <span class="t">Object</span>&gt; <span class="i">fields</span> = <span class="k">new</span> <span class="t">HashMap</span>&lt;&gt;();
</pre><pre class="insert-after" translate="no">
  LoxInstance(LoxClass klass) {
</pre></div>
<div class="source-file-narrow"><em>lox/LoxInstance.java</em>, in class <em>LoxInstance</em></div>
<p><font papago-translate="translated">지도의 각 키는 속성 이름이며 해당 값은 속성의 값입니다.</font><font papago-translate="translated"> 인스턴스에서 속성을 검색하려면:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/LoxInstance.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> L<em>ox</em>In<em>stance</em>() 다음에 추가</font></font></div>
<pre translate="no">  <span class="t">Object</span> <span class="i">get</span>(<span class="t">Token</span> <span class="i">name</span>) {
    <span class="k">if</span> (<span class="i">fields</span>.<span class="i">containsKey</span>(<span class="i">name</span>.<span class="i">lexeme</span>)) {
      <span class="k">return</span> <span class="i">fields</span>.<span class="i">get</span>(<span class="i">name</span>.<span class="i">lexeme</span>);
    }

    <span class="k">throw</span> <span class="k">new</span> <span class="t">RuntimeError</span>(<span class="i">name</span>,<span name="hidden"> </span>
        <span class="s">"Undefined property '"</span> + <span class="i">name</span>.<span class="i">lexeme</span> + <span class="s">"'."</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/LoxInstance.java</em>, add after <em>LoxInstance</em>()</div>
<aside name="hidden" style="top: 9069px;">
<p><font papago-translate="translated">모든 필드 접근에 대해 해시 테이블 조회를 수행하는 것은 많은 언어 구현에 충분히 빠르지만 이상적이지는 않습니다.</font><font papago-translate="translated"> JavaScript와 같은 언어의 고성능 VM은 이러한 오버헤드를 피하기 위해 "<a href="http://richardartoul.github.io/jekyll/update/2015/04/26/hidden-classes.html">숨겨진 클래스"</a>와 같은 정교한 최적화를 사용합니다.</font></p>
<p><font papago-translate="translated">역설적이게도, 동적 언어를 빠르게 만들기 위해 발명된 많은 최적화는 대부분의 코드가 작업하는 객체의 유형과<span class="em"></span><span class="em"></span> 필드 측면에서 상당히 정적이라는 관찰에 의존하고 있습니다.</font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">우리가 처리해야 할 흥미로운 엣지 케이스는 인스턴스<em></em>에 주어진 이름을 가진 속성이 없을 경우 어떤 일이 일어나는지입니다.</font><font papago-translate="translated"> 우리는 다음과 같은 더미 값을 조용히 반환할 수 있습니다 </font></font><code translate="no">nil</code><font papago-translate="splitted"><font papago-translate="translated">, 하지만 JavaScript와 같은 언어에 대한 제 경험은 이 행동이 유용한 것보다 버그를 더 자주 가린다는 것입니다.</font><font papago-translate="translated"> 대신, 우리는 그것을 런타임 오류로 만들 것입니다.</font></font></p>
<p><font papago-translate="translated">그래서 우리가 가장 먼저 하는 일은 인스턴스에 실제로 주어진 이름을 가진 필드가 있는지 확인하는 것입니다.</font><font papago-translate="translated"> 그제서야 우리는 그것을 반환합니다.</font><font papago-translate="translated"> 그렇지 않으면 오류가 발생합니다.</font></p>
<p><font papago-translate="translated">"속성"에 대해 이야기하던 것에서 "필드"로 바꾼 방법을 주목하세요.</font><font papago-translate="translated"> 둘 사이에는 미묘한 차이가 있습니다.</font><font papago-translate="translated"> 필드는 인스턴스에 직접 저장된 상태의 비트로 명명됩니다.</font><font papago-translate="translated"> 속성은 get 표현식이 반환할 수 있는 명명<em>된 것</em>들입니다.</font><font papago-translate="translated"> 모든 필드는 속성이지만<span name="foreshadowing">, 나중에</span> 보게 되겠지만 모든 속성이 필드인 것은 아닙니다.</font></p>
<aside name="foreshadowing" style="top: 9442px;">
<p><font papago-translate="translated">오, 예언.</font><font papago-translate="translated"> 으스스!</font></p>
</aside>
<p><font papago-translate="translated">이론적으로 이제 우리는 물체의 속성을 읽을 수 있습니다.</font><font papago-translate="translated"> 하지만 실제로 상태를 인스턴스에 넣을 수 있는 방법이 없기 때문에 접근할 수 있는 필드가 없습니다.</font><font papago-translate="translated"> 읽기를 테스트하기 전에 글쓰기를 지원해야 합니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/classes.html#set-expressions" id="set-expressions"><small><font papago-translate="translated">12 . 4 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">표현식 설정</font></font></a></h3>
<p><font papago-translate="translated">세터는 할당의 왼쪽에 표시되는 것을 제외하고는 게터와 동일한 구문을 사용합니다.</font></p>
<div class="codehilite"><pre translate="no"><span class="i">someObject</span>.<span class="i">someProperty</span> = <span class="i">value</span>;
</pre></div>
<p><font papago-translate="translated">문법 랜드에서는 왼쪽에 점선 식별자를 허용하도록 할당 규칙을 확장합니다.</font></p>
<div class="codehilite"><pre translate="no"><span class="i">assignment</span>     → ( <span class="i">call</span> <span class="s">"."</span> )? <span class="t">IDENTIFIER</span> <span class="s">"="</span> <span class="i">assignment</span>
               | <span class="i">logic_or</span> ;
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">게터와 달리 세터는 체인이 없습니다.</font><font papago-translate="translated"> 그러나 다음에 대한 참조 </font></font><code translate="no">call</code><font papago-translate="splitted"><font papago-translate="translated"> 는 마지막 점 앞에 있는 모든 높은 우선순위 표현을 허용하며<em>, 여기</em>에는<em> 다음</em>과 같은<em> 게터</em> 수가 포함됩니다:</font></font></p><img alt="breakfast.omelette.filling.meat = ham" src="https://youhogeon-meritz.github.io/image/classes/setter.png">
<p><font papago-translate="splitted"><font papago-translate="translated">여기서 주목할 점은<em> 마지막</em> 부분인 </font></font><code translate="no">.meat</code><font papago-translate="splitted"><font papago-translate="translated"> <em>세터</em>입니다.</font><font papago-translate="translated"> 그 </font></font><code translate="no">.omelette</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">.filling</code><font papago-translate="splitted"><font papago-translate="translated"> 부분은 둘 다<em> 표현식을 얻습니다</em>.</font></font></p>
<p><font papago-translate="translated">변수 접근 및 변수 할당을 위한 두 개의 개별 AST 노드가 있는 것처럼, 게터 노드를 보완하기 위해<span name="set-ast"> 두 번째 세터 노드</span>가 필요합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      "Logical  : Expr left, Token operator, Expr right",
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">도구/GenerateAst.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>메인</em> ()에서</font></font></div>
<pre class="insert" translate="no">      <span class="s">"Set      : Expr object, Token name, Expr value"</span>,
</pre><pre class="insert-after" translate="no">      "Unary    : Token operator, Expr right",
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>main</em>()</div>
<aside name="set-ast" style="top: 10415px;">
<p><font papago-translate="translated">새 노드에 대한 생성된 코드는 부록<a href="https://youhogeon-meritz.github.io/appendix-ii.html#set-expression"> II</a>에 있습니다.</font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">기억나지 않으실까 봐 파서에서 과제를 처리하는 방식이 조금 웃기네요.</font><font papago-translate="translated"> 일련의 토큰이 과제의 왼쪽에 있다는 것을 쉽게 알 수 있는 것은 다음과 같습니다 </font></font><code translate="no">=</code><font papago-translate="splitted"><font papago-translate="translated">. 이제 우리의 과제 문법 규칙이 </font></font><code translate="no">call</code><font papago-translate="splitted"><font papago-translate="translated"> 왼쪽에서 임의로 큰 표현으로 확장할 수 있는 마지막 부분은 </font></font><code translate="no">=</code><font papago-translate="splitted"><font papago-translate="translated"> 우리가 과제를 분석하고 있다는 것을 알아야 할 시점에서 많은 토큰이 있을 수 있습니다.</font></font></p>
<p><font papago-translate="translated">대신, 우리가 하는 방법은 왼쪽을 정규 표현식으로 파싱하는 것입니다.</font><font papago-translate="translated"> 그런 다음 등호 뒤에 있는 등호에 부딪히면 이미 구문 분석한 식을 올바른 구문 트리 노드로 변환합니다.</font></p>
<p><font papago-translate="translated">우리는 Expr을 돌리기 위해 그 변환에 또 다른 절을 추가합니다.</font><font papago-translate="translated">왼쪽에 있는 식을 해당 Expr에 입력합니다.</font><font papago-translate="translated">세트.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">        return new Expr.Assign(name, value);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>과제</em> ()에서</font></font></div>
<pre class="insert" translate="no">      } <span class="k">else</span> <span class="k">if</span> (<span class="i">expr</span> <span class="k">instanceof</span> <span class="t">Expr</span>.<span class="t">Get</span>) {
        <span class="t">Expr</span>.<span class="t">Get</span> <span class="i">get</span> = (<span class="t">Expr</span>.<span class="t">Get</span>)<span class="i">expr</span>;
        <span class="k">return</span> <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Set</span>(<span class="i">get</span>.<span class="i">object</span>, <span class="i">get</span>.<span class="i">name</span>, <span class="i">value</span>);
</pre><pre class="insert-after" translate="no">      }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>assignment</em>()</div>
<p><font papago-translate="translated">그것이 우리의 구문을 분석하는 것입니다.</font><font papago-translate="translated"> 우리는 그 노드를 해결기로 밀어 넣습니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>방문</em> 후 Log<em>icalEx</em>pr() 추가</font></font></div>
<pre translate="no">  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitSetExpr</span>(<span class="t">Expr</span>.<span class="t">Set</span> <span class="i">expr</span>) {
    <span class="i">resolve</span>(<span class="i">expr</span>.<span class="i">value</span>);
    <span class="i">resolve</span>(<span class="i">expr</span>.<span class="i">object</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>visitLogicalExpr</em>()</div>
<p><font papago-translate="translated">다시 말해, Exper처럼.</font><font papago-translate="translated">속성 자체가 동적으로 평가되므로 해결할 수 있는 것이 없습니다.</font><font papago-translate="translated"> 우리가 해야 할 일은 Expr의 두 하위 표현식에 반복하기만 하면 됩니다.</font><font papago-translate="translated">설정, 속성이 설정되는 객체 및 설정되는 값.</font></p>
<p><font papago-translate="translated">그것이 우리를 통역사로 안내합니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Interpreter.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>방문</em> 후 Log<em>icalEx</em>pr() 추가</font></font></div>
<pre translate="no">  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Object</span> <span class="i">visitSetExpr</span>(<span class="t">Expr</span>.<span class="t">Set</span> <span class="i">expr</span>) {
    <span class="t">Object</span> <span class="i">object</span> = <span class="i">evaluate</span>(<span class="i">expr</span>.<span class="i">object</span>);

    <span class="k">if</span> (!(<span class="i">object</span> <span class="k">instanceof</span> <span class="t">LoxInstance</span>)) {<span name="order"> </span>
      <span class="k">throw</span> <span class="k">new</span> <span class="t">RuntimeError</span>(<span class="i">expr</span>.<span class="i">name</span>,
                             <span class="s">"Only instances have fields."</span>);
    }

    <span class="t">Object</span> <span class="i">value</span> = <span class="i">evaluate</span>(<span class="i">expr</span>.<span class="i">value</span>);
    ((<span class="t">LoxInstance</span>)<span class="i">object</span>).<span class="i">set</span>(<span class="i">expr</span>.<span class="i">name</span>, <span class="i">value</span>);
    <span class="k">return</span> <span class="i">value</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>visitLogicalExpr</em>()</div>
<p><font papago-translate="translated">속성이 설정되는 객체를 평가하고 LoxInstance인지 확인합니다.</font><font papago-translate="translated"> 그렇지 않으면 런타임 오류입니다.</font><font papago-translate="translated"> 그렇지 않으면 설정 중인 값을 평가하고 인스턴스에 저장합니다.</font><font papago-translate="translated"> 이는 LoxInstance의 새로운 방법에 의존합니다.</font></p>
<aside name="order" style="top: 11422px;">
<p><font papago-translate="translated">이것은 또 다른 의미론적 엣지 사례입니다.</font><font papago-translate="translated"> 세 가지 뚜렷한 작업이 있습니다:</font></p>
<ol>
<li>
<p><font papago-translate="translated">객체를 평가합니다.</font></p>
</li>
<li>
<p><font papago-translate="translated">클래스의 인스턴스가 아닌 경우 런타임 오류를 발생시킵니다.</font></p>
</li>
<li>
<p><font papago-translate="translated">가치를 평가합니다.</font></p>
</li>
</ol>
<p><font papago-translate="translated">이러한 작업이 수행되는 순서는 사용자가 볼 수 있으므로 신중하게 지정하고 구현이 동일한 순서로 수행되도록 해야 합니다.</font></p>
</aside>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/LoxInstance.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>()</em>를<em> 얻은</em> 후에 추가하기</font></font></div>
<pre translate="no">  <span class="t">void</span> <span class="i">set</span>(<span class="t">Token</span> <span class="i">name</span>, <span class="t">Object</span> <span class="i">value</span>) {
    <span class="i">fields</span>.<span class="i">put</span>(<span class="i">name</span>.<span class="i">lexeme</span>, <span class="i">value</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/LoxInstance.java</em>, add after <em>get</em>()</div>
<p><font papago-translate="translated">여기에는 진짜 마법이 없습니다.</font><font papago-translate="translated"> 필드가 있는 Java 지도에 값을 바로 입력합니다.</font><font papago-translate="translated"> Lox는 인스턴스에 새로운 필드를 자유롭게 생성할 수 있기 때문에 키가 이미 있는지 확인할 필요가 없습니다.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/classes.html#methods-on-classes" id="methods-on-classes"><small><font papago-translate="translated">12 . 5</font></small><font papago-translate="splitted"><font papago-translate="translated">수업 방법</font></font></a></h2>
<p><font papago-translate="translated">수업의 인스턴스를 만들고 데이터를 넣을 수는 있지만, 수업 자체는 실제로 아무것도<em> 하지</em> 않습니다.</font><font papago-translate="translated"> 인스턴스는 단지 지도일 뿐이며 모든 인스턴스는 대체로 동일합니다.</font><font papago-translate="translated"> <em>그</em>들이<em> 수업</em>의 사례처럼 느껴지도록 하기 위해서는 행동,<span class="em"></span> 즉 방법이 필요합니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">우리의 유용한 파서는 이미 메서드 선언을 파싱하므로, 우리는 여기까지입니다.</font><font papago-translate="translated"> 메서드<em> 호출</em>에 대한 새로운 파서 지원도 추가할 필요가 없습니다.</font><font papago-translate="translated"> 우리는 이미 </font></font><code translate="no">.</code><font papago-translate="splitted"><font papago-translate="translated"> (게터) 그리고 </font></font><code translate="no">()</code><font papago-translate="splitted"><font papago-translate="translated"> (함수 호출).</font><font papago-translate="translated"> "메소드 호출"은 단순히 그것들을 연결합니다.</font></font></p><img alt="The syntax tree for 'object.method(argument)" src="https://youhogeon-meritz.github.io/image/classes/method.png">
<p><font papago-translate="splitted"><font papago-translate="translated">그것은 흥미로운 질문을 제기합니다.</font><font papago-translate="translated"> 이 두 표현이 분리되면 어떻게 되나요?</font><font papago-translate="translated"> 다음과 같이 가정합니다 </font></font><code translate="no">method</code><font papago-translate="splitted"><font papago-translate="translated"> 이 예에서는 다음과 같은 클래스에 대한 방법이 있습니다 </font></font><code translate="no">object</code><font papago-translate="splitted"><font papago-translate="translated"> 인스턴스에 필드가 없는데 다음 코드 조각은 어떻게 해야 하나요?</font></font></p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="i">m</span> = <span class="i">object</span>.<span class="i">method</span>;
<span class="i">m</span>(<span class="i">argument</span>);
</pre></div>
<p><font papago-translate="translated">이 프로그램은 메서드를 "위를 검색"하여 결과를 변수에 저장한 다음<span class="em"></span><span class="em"></span> 나중에 해당 객체를 호출합니다.</font><font papago-translate="translated"> 이거 허용되나요?</font><font papago-translate="translated"> 메서드를 인스턴스의 함수처럼 취급할 수 있습니까?</font></p>
<p><font papago-translate="translated">다른 방향은 어떻습니까?</font></p>
<div class="codehilite"><pre translate="no"><span class="k">class</span> <span class="t">Box</span> {}

<span class="k">fun</span> <span class="i">notMethod</span>(<span class="i">argument</span>) {
  <span class="k">print</span> <span class="s">"called function with "</span> + <span class="i">argument</span>;
}

<span class="k">var</span> <span class="i">box</span> = <span class="t">Box</span>();
<span class="i">box</span>.<span class="i">function</span> = <span class="i">notMethod</span>;
<span class="i">box</span>.<span class="i">function</span>(<span class="s">"argument"</span>);
</pre></div>
<p><font papago-translate="translated">이 프로그램은 인스턴스를 생성한 다음 해당 필드에 함수를 저장합니다.</font><font papago-translate="translated"> 그런 다음 메서드 호출과 동일한 구문을 사용하여 해당 함수를 호출합니다.</font><font papago-translate="translated"> 그일 어떻게 되가요?</font></p>
<p><font papago-translate="translated">언어마다 이러한 질문에 대한 답변이 다릅니다.</font><font papago-translate="translated"> 그것에 대해 논문을 쓸 수 있습니다.</font><font papago-translate="translated"> Lox의 경우, 이 두 가지에 대한 답은 '예'라고 할 수 있습니다.</font><font papago-translate="translated"> 우리는 그것을 정당화할 몇 가지 이유가 있습니다.</font><font papago-translate="translated"> 두 번째 예로, 필드에 저장된 함수를 호출하는 것은 일급 함수가 유용하기 때문에 필드에 저장하는 것이 지극히 정상적<span class="em"></span><span class="em"></span>인 작업이라는 점을 뒷받침하고자 합니다.</font></p>
<p><font papago-translate="translated">첫 번째 예시는 더 모호합니다.</font><font papago-translate="translated"> 한 가지 동기는 사용자들이 일반적으로 프로그램의 의미를 변경하지 않고도 하위 표현식을 로컬 변수로 끌어올릴 수 있기를 기대한다는 것입니다.</font><font papago-translate="translated"> 이것을 가져가셔도 됩니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="i">breakfast</span>(<span class="i">omelette</span>.<span class="i">filledWith</span>(<span class="i">cheese</span>), <span class="i">sausage</span>);
</pre></div>
<p><font papago-translate="translated">그리고 이렇게 만드세요:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="i">eggs</span> = <span class="i">omelette</span>.<span class="i">filledWith</span>(<span class="i">cheese</span>);
<span class="i">breakfast</span>(<span class="i">eggs</span>, <span class="i">sausage</span>);
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">그리고 그것은 같은 일을 합니다.</font><font papago-translate="translated"> 마찬가지로, 그 이후로 </font></font><code translate="no">.</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고 </font></font><code translate="no">()</code><font papago-translate="splitted"><font papago-translate="translated"> 메서드 호출에는 두 개의 별도 표현식<em>이 있습니다</em>.<em> 조회</em> 부분을 변수로 올린 다음<span name="callback"> 나중</span>에 호출할 수 있을 것 같습니다.</font><font papago-translate="translated"> 방법을 찾아보면 어떤 것이 무엇인지, 그리고 이상<em></em>한 경우에도 어떻게 작동하는지 신중하게 생각해야 합니다:</font></font></p>
<aside name="callback" style="top: 13462.5px;">
<p><font papago-translate="translated">이를 동기 부여하는 용도는 콜백입니다.</font><font papago-translate="translated"> 종종 어떤 객체에 대해 단순히 메서드를 호출하는 콜백을 전달하고 싶을 때가 있습니다.</font><font papago-translate="translated"> 메서드를 찾아 직접 전달할 수 있으면 함수를 수동으로 선언하는 번거로움을 덜 수 있습니다.</font><font papago-translate="translated"> 비교해 보세요:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">fun</span> <span class="i">callback</span>(<span class="i">a</span>, <span class="i">b</span>, <span class="i">c</span>) {
  <span class="i">object</span>.<span class="i">method</span>(<span class="i">a</span>, <span class="i">b</span>, <span class="i">c</span>);
}

<span class="i">takeCallback</span>(<span class="i">callback</span>);
</pre></div>
<p><font papago-translate="translated">이걸로:</font></p>
<div class="codehilite"><pre translate="no"><span class="i">takeCallback</span>(<span class="i">object</span>.<span class="i">method</span>);
</pre></div>
</aside>
<div class="codehilite"><pre translate="no"><span class="k">class</span> <span class="t">Person</span> {
  <span class="i">sayName</span>() {
    <span class="k">print</span> <span class="k">this</span>.<span class="i">name</span>;
  }
}

<span class="k">var</span> <span class="i">jane</span> = <span class="t">Person</span>();
<span class="i">jane</span>.<span class="i">name</span> = <span class="s">"Jane"</span>;

<span class="k">var</span> <span class="i">method</span> = <span class="i">jane</span>.<span class="i">sayName</span>;
<span class="i">method</span>(); <span class="c">// ?</span>
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">어떤 인스턴스에서 메서드의 핸들을 잡고 나중에 호출하면 해당 메서드가 제거된 인스턴스를 "기억"하나요?</font><font papago-translate="translated"> 한다 </font></font><code translate="no">this</code><font papago-translate="splitted"><font papago-translate="translated"> 메서드 내부에서 여전히 원래 객체를 참조합니까?</font></font></p>
<p><font papago-translate="translated">다음은 당신의 뇌를 구부릴 수 있는 더 병리적인 예입니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">class</span> <span class="t">Person</span> {
  <span class="i">sayName</span>() {
    <span class="k">print</span> <span class="k">this</span>.<span class="i">name</span>;
  }
}

<span class="k">var</span> <span class="i">jane</span> = <span class="t">Person</span>();
<span class="i">jane</span>.<span class="i">name</span> = <span class="s">"Jane"</span>;

<span class="k">var</span> <span class="i">bill</span> = <span class="t">Person</span>();
<span class="i">bill</span>.<span class="i">name</span> = <span class="s">"Bill"</span>;

<span class="i">bill</span>.<span class="i">sayName</span> = <span class="i">jane</span>.<span class="i">sayName</span>;
<span class="i">bill</span>.<span class="i">sayName</span>(); <span class="c">// ?</span>
</pre></div>
<p><font papago-translate="translated">마지막 줄에 "Bill"이 표시되는 이유는 메서드를 통과<em>시킨</em> 인스턴스이기 때문인가요, 아니면 메서드를 처음 잡은 인스턴스이기 때문에 "Jane"이 표시되나요?</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">Lua와 JavaScript의 동등한 코드는 "Bill"을 출력합니다.</font><font papago-translate="translated"> 그 언어들은 실제로 "방법"이라는 개념을 가지고 있지 않습니다.</font><font papago-translate="translated"> 모든 것이 일종의 함수형 필드이기 때문에 명확하지 않습니다 </font></font><code translate="no">jane</code><font papago-translate="splitted"><font papago-translate="translated"> “owns” </font></font><code translate="no">sayName</code><font papago-translate="splitted"><font papago-translate="translated"> 그 이상 </font></font><code translate="no">bill</code><font papago-translate="splitted"><font papago-translate="translated"> 한다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">하지만 Lox는 실수 클래스 구문을 가지고 있기 때문에 어떤 호출 가능한 것이 메서드이고 어떤 함수인지 알 수 있습니다.</font><font papago-translate="translated"> 따라서 Python, C# 등과 같은 메서드는 "바인딩"됩니다 </font></font><code translate="no">this</code> <font papago-translate="splitted"><font papago-translate="translated"> 메서드를 처음 잡을 때 원래 인스턴스로 이동합니다.</font><font papago-translate="translated"> 파이썬은<span name="bound"> 이러한</span><strong> 바인딩 메서드</strong>를 호출합니다.</font></font></p>
<aside name="bound" style="top: 14490.5px;">
<p><font papago-translate="translated">상상력이 풍부한 이름, 맞죠?</font></p>
</aside>
<p><font papago-translate="translated">실제로는 보통 그렇게 원합니다.</font><font papago-translate="translated"> 어떤 객체에 대한 메서드를 참조하여 나중에 콜백으로 사용할 수 있도록 한다면, 해당 콜백이 다른 객체의 필드에 저장되어 있더라도 해당 메서드가 속한 인스턴스를 기억하고 싶을 것입니다.</font></p>
<p><font papago-translate="translated">좋아요, 그건 당신의 머릿속에 많은 의미를 담고 있어요.</font><font papago-translate="translated"> 엣지 케이스는 잠시 잊어버리세요.</font><font papago-translate="translated"> 다시 말씀드리겠습니다.</font><font papago-translate="translated"> 지금은 기본 메서드 호출을 작동시키겠습니다.</font><font papago-translate="translated"> 우리는 이미 수업 본문 내에서 메서드 선언문을 구문 분석하고 있으므로 다음 단계는 이를 해결하는 것입니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    define(stmt.name);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>visit</em>Cl<em>assStmt</em>()에서</font></font></div>
<pre class="insert" translate="no">
    <span class="k">for</span> (<span class="t">Stmt</span>.<span class="t">Function</span> <span class="i">method</span> : <span class="i">stmt</span>.<span class="i">methods</span>) {
      <span class="t">FunctionType</span> <span class="i">declaration</span> = <span class="t">FunctionType</span>.<span class="i">METHOD</span>;
      <span class="i">resolveFunction</span>(<span class="i">method</span>, <span class="i">declaration</span>);<span name="local"> </span>
    }

</pre><pre class="insert-after" translate="no">    return null;
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in <em>visitClassStmt</em>()</div>
<aside name="local" style="top: 14833.5px;">
<p><font papago-translate="translated">함수 유형을 로컬 변수에 저장하는 것은 지금 당장은 무의미하지만, 우리는 이 코드를 너무 오래 전에 확장할 것이며 더 이해가 될 것입니다.</font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">우리는 클래스 본문의 방법을 반복하여 다음과 같이 부릅니다 </font></font><code translate="no">resolveFunction()</code><font papago-translate="splitted"><font papago-translate="translated"> 함수 선언을 처리하기 위해 이미 작성한 방법.</font><font papago-translate="translated"> 유일한 차이점은 새로운 함수를 전달한다는 것입니다</font><font papago-translate="translated">열거 값을 입력합니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    NONE,
</pre><pre class="insert-before" translate="no">    <span class="i">FUNCTION</span><span class="insert-comma">,</span>
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 열거<em> 함수</em>에서</font><font papago-translate="translated"><em>유형</em></font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 이전 줄에<em> ","</em>를 추가합니다</font></font></div>
<pre class="insert" translate="no">    <span class="i">METHOD</span>
</pre><pre class="insert-after" translate="no">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in enum <em>FunctionType</em>, add <em>“,”</em> to previous line</div>
<p><font papago-translate="splitted"><font papago-translate="translated">그것은 우리가 해결할 때 중요할 것입니다 </font></font><code translate="no">this</code><font papago-translate="splitted"><font papago-translate="translated"> 표현.</font><font papago-translate="translated"> 지금은 걱정하지 마세요.</font><font papago-translate="translated"> 흥미로운 내용은 통역사에게 있습니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    environment.define(stmt.name.lexeme, null);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Interpreter.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>visit</em>Cl<em>assStmt</em>()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">
    <span class="t">Map</span>&lt;<span class="t">String</span>, <span class="t">LoxFunction</span>&gt; <span class="i">methods</span> = <span class="k">new</span> <span class="t">HashMap</span>&lt;&gt;();
    <span class="k">for</span> (<span class="t">Stmt</span>.<span class="t">Function</span> <span class="i">method</span> : <span class="i">stmt</span>.<span class="i">methods</span>) {
      <span class="t">LoxFunction</span> <span class="i">function</span> = <span class="k">new</span> <span class="t">LoxFunction</span>(<span class="i">method</span>, <span class="i">environment</span>);
      <span class="i">methods</span>.<span class="i">put</span>(<span class="i">method</span>.<span class="i">name</span>.<span class="i">lexeme</span>, <span class="i">function</span>);
    }

    <span class="t">LoxClass</span> <span class="i">klass</span> = <span class="k">new</span> <span class="t">LoxClass</span>(<span class="i">stmt</span>.<span class="i">name</span>.<span class="i">lexeme</span>, <span class="i">methods</span>);
</pre><pre class="insert-after" translate="no">    environment.assign(stmt.name, klass);
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in <em>visitClassStmt</em>(), replace 1 line</div>
<p><font papago-translate="translated">클래스 선언문을 해석할 때, 클래스의 구문 표현인 AST 노드를 런타임<span class="em"></span><span class="em"></span> 표현으로 변환합니다.</font><font papago-translate="translated"> 이제 수업에 포함된 방법들에 대해서도 그렇게 해야 합니다.</font><font papago-translate="translated"> 각 메서드 선언은 LoxFunction 객체로 꽃을 피웁니다.</font></p>
<p><font papago-translate="translated">우리는 그것들을 모두 가져와서 메서드 이름으로 키를 지정한 지도로 포장합니다.</font><font papago-translate="translated"> 그것은 LoxClass에 저장됩니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  final String name;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/LoxClass.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> L<em>ox</em>Cl<em>ass</em> 수업에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 4줄 교체</font></font></div>
<pre class="insert" translate="no">  <span class="k">private</span> <span class="k">final</span> <span class="t">Map</span>&lt;<span class="t">String</span>, <span class="t">LoxFunction</span>&gt; <span class="i">methods</span>;

  <span class="t">LoxClass</span>(<span class="t">String</span> <span class="i">name</span>, <span class="t">Map</span>&lt;<span class="t">String</span>, <span class="t">LoxFunction</span>&gt; <span class="i">methods</span>) {
    <span class="k">this</span>.<span class="i">name</span> = <span class="i">name</span>;
    <span class="k">this</span>.<span class="i">methods</span> = <span class="i">methods</span>;
  }
</pre><pre class="insert-after" translate="no">
  @Override
  public String toString() {
</pre></div>
<div class="source-file-narrow"><em>lox/LoxClass.java</em>, in class <em>LoxClass</em>, replace 4 lines</div>
<p><font papago-translate="translated">인스턴스가 상태를 저장하는 경우 클래스는 동작을 저장합니다.</font><font papago-translate="translated"> LoxInstance에는 필드 맵이 있고 LoxClass에는 메서드 맵이 있습니다.</font><font papago-translate="translated"> 메서드는 클래스가 소유하고 있지만, 여전히 해당 클래스의 인스턴스를 통해 액세스됩니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  Object get(Token name) {
    if (fields.containsKey(name.lexeme)) {
      return fields.get(name.lexeme);
    }

</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/LoxInstance.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>겟</em> ()에서</font></font></div>
<pre class="insert" translate="no">    <span class="t">LoxFunction</span> <span class="i">method</span> = <span class="i">klass</span>.<span class="i">findMethod</span>(<span class="i">name</span>.<span class="i">lexeme</span>);
    <span class="k">if</span> (<span class="i">method</span> != <span class="k">null</span>) <span class="k">return</span> <span class="i">method</span>;

</pre><pre class="insert-after" translate="no">    throw new RuntimeError(name,<span name="hidden"> </span>
        "Undefined property '" + name.lexeme + "'.");
</pre></div>
<div class="source-file-narrow"><em>lox/LoxInstance.java</em>, in <em>get</em>()</div>
<p><font papago-translate="translated">인스턴스에서 속성을 찾을 때 일치하는 필드를<span name="shadow"> 찾지</span> 못하면 인스턴스 클래스에서 해당 이름을 가진 메서드를 찾습니다.</font><font papago-translate="translated"> 발견되면 반품합니다.</font><font papago-translate="translated"> 여기서 '필드'와 '재산'의 구분이 의미 있게 됩니다.</font><font papago-translate="translated"> 속성에 액세스할 때 필드(인스턴스에 저장된 상태의 일부)가 표시되거나 인스턴스<span class="em"></span><span class="em"></span> 클래스에 정의된 메서드를 누를 수 있습니다.</font></p>
<p><font papago-translate="translated">이 방법을 사용하여 조회합니다:</font></p>
<aside name="shadow" style="top: 16146.5px;">
<p><font papago-translate="translated">필드를 찾는 것은 먼저 필드가 미묘하지만 중요한 의미론적 포인트인 방법을 가리킨다는 것을 의미합니다.</font></p>
</aside>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/LoxClass.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> L<em>oxClass</em>() 다음에 추가</font></font></div>
<pre translate="no">  <span class="t">LoxFunction</span> <span class="i">findMethod</span>(<span class="t">String</span> <span class="i">name</span>) {
    <span class="k">if</span> (<span class="i">methods</span>.<span class="i">containsKey</span>(<span class="i">name</span>)) {
      <span class="k">return</span> <span class="i">methods</span>.<span class="i">get</span>(<span class="i">name</span>);
    }

    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/LoxClass.java</em>, add after <em>LoxClass</em>()</div>
<p><font papago-translate="translated">이 방법이 나중에 더 흥미로워질 것이라고 짐작할 수 있을 것입니다.</font><font papago-translate="translated"> 지금은 수업 방법 표에서 간단한 지도 조회만으로 시작할 수 있습니다.</font><font papago-translate="translated"> 한 번 시도해 보세요:</font></p>
<p><span name="crunch"></span></p>
<div class="codehilite"><pre translate="no"><span class="k">class</span> <span class="t">Bacon</span> {
  <span class="i">eat</span>() {
    <span class="k">print</span> <span class="s">"Crunch crunch crunch!"</span>;
  }
}

<span class="t">Bacon</span>().<span class="i">eat</span>(); <span class="c">// Prints "Crunch crunch crunch!".</span>
</pre></div>
<aside name="crunch" style="top: 16548.5px;">
<p><font papago-translate="translated">바삭바삭한 베이컨보다 쫄깃한 베이컨을 선호하신다면 죄송합니다.</font><font papago-translate="translated"> 대본을 자유롭게 취향에 맞게 조정하세요.</font></p>
</aside>
<h2><a href="https://youhogeon-meritz.github.io/classes.html#this" id="this"><small><font papago-translate="translated">12 . 6</font></small><font papago-translate="splitted"><font papago-translate="translated">이것.</font></font></a></h2>
<p><font papago-translate="translated">우리는 객체에 대한 행동과 상태를 모두 정의할 수 있지만, 아직 서로 연결되지 않았습니다.</font><font papago-translate="translated"> 메서드 내부에서는 메서드가 호출된 인스턴스인 "현재" 객체의 필드에 액세스할 수 있는 방법이 없으며, 동일<span class="em"></span><span class="em"></span>한 객체에 대해 다른 메서드를 호출할 수도 없습니다.</font></p>
<p><font papago-translate="translated">그 경우에 도달하려면<span name="i"> 이름</span>이 필요합니다.</font><font papago-translate="translated"> Smalltalk, Ruby, 그리고 Swift는 "self"를 사용합니다.</font><font papago-translate="translated"> Simula, C++, Java 및 기타 사용자들은 "이것"을 사용합니다.</font><font papago-translate="translated"> 파이썬은 관례적으로 "자기"를 사용하지만, 기술적으로는 원하는 대로 부를 수 있습니다.</font></p>
<aside name="i" style="top: 16930.5px;">
<p><font papago-translate="translated">"I"는 훌륭한 선택이었을 텐데, 루프 변수에 "i"를 사용하면 OOP 이전에 포트란까지 거슬러 올라갑니다.</font><font papago-translate="translated"> 우리는 선조들의 우연한 선택의 희생자입니다.</font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">Lox의 경우, 일반적으로 자바 스타일을 따르기 때문에 "이것"으로 하겠습니다.</font><font papago-translate="translated"> 메서드 본문 내부에서, a </font></font><code translate="no">this</code><font papago-translate="splitted"><font papago-translate="translated"> 표현식은 메서드가 호출된 인스턴스로 평가됩니다.</font><font papago-translate="translated"> 더 구체적으로 말하자면, 메서드는 두 단계로 접근한 후 호출되기 때문에 메서드<em>가 접근</em>한 객체를 가리킬 것입니다.</font></font></p>
<p><font papago-translate="translated">그것은 우리의 일을 더 어렵게 만듭니다.</font><font papago-translate="translated"> 들여다보기:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">class</span> <span class="t">Egotist</span> {
  <span class="i">speak</span>() {
    <span class="k">print</span> <span class="k">this</span>;
  }
}

<span class="k">var</span> <span class="i">method</span> = <span class="t">Egotist</span>().<span class="i">speak</span>;
<span class="i">method</span>();
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">두 번째 줄에서 마지막 줄로, 우리는 다음을 참조합니다 </font></font><code translate="no">speak()</code><font papago-translate="splitted"><font papago-translate="translated"> 클래스 인스턴스에서 메서드를 제거합니다.</font><font papago-translate="translated"> 그것은 함수를 반환하며, 그 함수는 나중<em>에</em> 함수가 호출될 때 마지막 줄에서 여전히 찾을 수 있도록 제거된 인스턴스를 기억해야 합니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">우리는 다음을 수행해야 합니다 </font></font><code translate="no">this</code><font papago-translate="splitted"><font papago-translate="translated"> 메서드에 접근하여 함수에 어떻게든 부착하여 필요한 만큼 오래 유지되도록 합니다.</font><font papago-translate="translated"> 음<span class="ellipse">...</span> 함수 주변에 있는 추가 데이터를 저장하는 방법?</font><font papago-translate="translated"> <em>그건 정말 폐쇄</em>처럼 들리지 않나요?</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">우리가 정의한 경우 </font></font><code translate="no">this</code><font papago-translate="splitted"><font papago-translate="translated"> 함수를 둘러싸고 있는 환경에서 메서드를 찾을 때 반환되는 일종의 숨겨진 변수로서 다음과 같은 용도로 사용됩니다 </font></font><code translate="no">this</code><font papago-translate="splitted"><font papago-translate="translated"> 몸에서 나중에 찾을 수 있을 것입니다.</font><font papago-translate="translated"> LoxFunction은 이미 주변 환경을 유지할 수 있는 능력을 갖추고 있어서 필요한 기계를 갖추고 있습니다.</font></font></p>
<p><font papago-translate="translated">예시를 통해 어떻게 작동하는지 살펴보겠습니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">class</span> <span class="t">Cake</span> {
  <span class="i">taste</span>() {
    <span class="k">var</span> <span class="i">adjective</span> = <span class="s">"delicious"</span>;
    <span class="k">print</span> <span class="s">"The "</span> + <span class="k">this</span>.<span class="i">flavor</span> + <span class="s">" cake is "</span> + <span class="i">adjective</span> + <span class="s">"!"</span>;
  }
}

<span class="k">var</span> <span class="i">cake</span> = <span class="t">Cake</span>();
<span class="i">cake</span>.<span class="i">flavor</span> = <span class="s">"German chocolate"</span>;
<span class="i">cake</span>.<span class="i">taste</span>(); <span class="c">// Prints "The German chocolate cake is delicious!".</span>
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">클래스 정의를 처음 평가할 때, 우리는 다음을 위한 LoxFunction을 만듭니다 </font></font><code translate="no">taste()</code><font papago-translate="splitted"><font papago-translate="translated">. 그 폐쇄성은 수업을 둘러싼 환경, 이 경우에는 전 세계적인 환경입니다.</font><font papago-translate="translated"> 따라서 클래스의 메서드 맵에 저장하는 LoxFunction은 다음과 같습니다:</font></font></p><img alt="The initial closure for the method." src="https://youhogeon-meritz.github.io/image/classes/closure.png">
<p><font papago-translate="splitted"><font papago-translate="translated">평가할 때 </font></font><code translate="no">cake.taste</code><font papago-translate="splitted"><font papago-translate="translated"> 표현을 얻으면 다음과 같은 새로운 환경을 만들 수 있습니다 </font></font><code translate="no">this</code><font papago-translate="splitted"><font papago-translate="translated"> 방법이 접근되는 객체에 대해 (여기서, </font></font><code translate="no">cake</code><font papago-translate="splitted"><font papago-translate="translated">). 그런 다음 원본과 동일한 코드를 사용하지만 해당 새로운 환경을 폐쇄로 사용하여<em> 새로운</em> LoxFunction을 만듭니다.</font></font></p><img alt="The new closure that binds 'this'." src="https://youhogeon-meritz.github.io/image/classes/bound-method.png">
<p><font papago-translate="splitted"><font papago-translate="translated">메서드 이름의 get 식을 평가할 때 반환되는 LoxFunction입니다.</font><font papago-translate="translated"> 나중에 그 함수가 다음과 같이 호출될 때 </font></font><code translate="no">()</code><font papago-translate="splitted"><font papago-translate="translated"> 표현, 우리는 평소처럼 메서드 본문을 위한 환경을 만듭니다.</font></font></p><img alt="Calling the bound method and creating a new environment for the method body." src="https://youhogeon-meritz.github.io/image/classes/call.png">
<p><font papago-translate="splitted"><font papago-translate="translated">신체 환경의 부모는 우리가 이전에 결합하기 위해 만든 환경입니다 </font></font><code translate="no">this</code><font papago-translate="splitted"><font papago-translate="translated"> 현재 객체로.</font><font papago-translate="translated"> 따라서 다음과 같은 모든 사용 </font></font><code translate="no">this</code><font papago-translate="splitted"><font papago-translate="translated"> 몸 안에서 그 상황을 성공적으로 해결합니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">환경 코드를 재사용하여 구현하기 </font></font><code translate="no">this</code><font papago-translate="splitted"><font papago-translate="translated"> 또한 메서드와 함수가 상호 작용하는 흥미로운 경우도 처리합니다:</font></font></p>
<div class="codehilite"><pre translate="no"><span class="k">class</span> <span class="t">Thing</span> {
  <span class="i">getCallback</span>() {
    <span class="k">fun</span> <span class="i">localFunction</span>() {
      <span class="k">print</span> <span class="k">this</span>;
    }

    <span class="k">return</span> <span class="i">localFunction</span>;
  }
}

<span class="k">var</span> <span class="i">callback</span> = <span class="t">Thing</span>().<span class="i">getCallback</span>();
<span class="i">callback</span>();
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">예를 들어, JavaScript에서는 메서드 내부에서 콜백을 반환하는 것이 일반적입니다.</font><font papago-translate="translated"> 그 콜백은 원래 객체<span class="em"></span>인 </font></font><code translate="no">this</code><font papago-translate="splitted"><font papago-translate="translated"> 메서드와<span class="em"></span> 연관된 값.</font><font papago-translate="translated"> 폐쇄 및 환경 체인에 대한 기존 지원은 이 모든 것을 올바르게 수행해야 합니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">코드화해 보겠습니다.</font><font papago-translate="translated"> 첫 번째 단계는 다음에 대한<span name="this-ast"> 새로운 구문</span>을 추가하는 것입니다 </font></font><code translate="no">this</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      "Set      : Expr object, Token name, Expr value",
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">도구/GenerateAst.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>메인</em> ()에서</font></font></div>
<pre class="insert" translate="no">      <span class="s">"This     : Token keyword"</span>,
</pre><pre class="insert-after" translate="no">      "Unary    : Token operator, Expr right",
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>main</em>()</div>
<aside name="this-ast" style="top: 19618.5px;">
<p><font papago-translate="translated">새 노드에 대한 생성된 코드는 부록<a href="https://youhogeon-meritz.github.io/appendix-ii.html#this-expression"> II</a>에 있습니다.</font></p>
</aside>
<p><font papago-translate="translated">구문 분석은 우리의 어휘가 이미 예약된 단어로 인식하는 단일 토큰이기 때문에 간단합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      return new Expr.Literal(previous().literal);
    }
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>일차</em> ()에서</font></font></div>
<pre class="insert" translate="no">
    <span class="k">if</span> (<span class="i">match</span>(<span class="i">THIS</span>)) <span class="k">return</span> <span class="k">new</span> <span class="t">Expr</span>.<span class="t">This</span>(<span class="i">previous</span>());
</pre><pre class="insert-after" translate="no">
    if (match(IDENTIFIER)) {
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>primary</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">어떻게 하는지 알 수 있습니다 </font></font><code translate="no">this</code><font papago-translate="splitted"><font papago-translate="translated"> 해결사에 도달하면 변수처럼 작동합니다.</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>visit</em>S<em>etExpr</em>() 후 추가</font></font></div>
<pre translate="no">  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitThisExpr</span>(<span class="t">Expr</span>.<span class="t">This</span> <span class="i">expr</span>) {
    <span class="i">resolveLocal</span>(<span class="i">expr</span>, <span class="i">expr</span>.<span class="i">keyword</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }

</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>visitSetExpr</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">우리는 "이것"을 "변수"의 이름으로 사용하여 다른 지역 변수와 똑같이 해결합니다.</font><font papago-translate="translated"> 물론 지금 당장은 효과가 없을 것입니다. 왜냐하면 "이것"<em>은</em> 어떤 범위에서도 선언<em>되지</em> 않았기 때문입니다.</font><font papago-translate="translated"> 이 문제를 해결해 보겠습니다 </font></font><code translate="no">visitClassStmt()</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    define(stmt.name);

</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>visit</em>Cl<em>assStmt</em>()에서</font></font></div>
<pre class="insert" translate="no">    <span class="i">beginScope</span>();
    <span class="i">scopes</span>.<span class="i">peek</span>().<span class="i">put</span>(<span class="s">"this"</span>, <span class="k">true</span>);

</pre><pre class="insert-after" translate="no">    for (Stmt.Function method : stmt.methods) {
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in <em>visitClassStmt</em>()</div>
<p><font papago-translate="translated">우리가 개입하여 방법론을 해결하기 시작하기 전에, 새로운 범위를 설정하고 그 범위 안에서 "이것"을 마치 변수처럼 정의합니다.</font><font papago-translate="translated"> 그런 다음 완료되면 주변 범위를 버립니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    }

</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>visit</em>Cl<em>assStmt</em>()에서</font></font></div>
<pre class="insert" translate="no">    <span class="i">endScope</span>();

</pre><pre class="insert-after" translate="no">    return null;
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in <em>visitClassStmt</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">이제, 언제든지 </font></font><code translate="no">this</code><font papago-translate="splitted"><font papago-translate="translated"> 표현식은 (적어도 메서드 내부에서) 메서드 본문의 블록 외부에 있는 암묵적 범위에 정의된 "로컬 변수"로 해결됩니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">해결사<em>는</em> 다음과 같은 새로운<em> 범위</em>를 가지고 있습니다 </font></font><code translate="no">this</code><font papago-translate="splitted"><font papago-translate="translated">, 따라서 통역사는 해당<em> 환경</em>을 만들어야 합니다.</font><font papago-translate="translated"> 항상 해결사의 스코프 체인과 인터프리터의 연결된 환경을 서로 동기화해야 한다는 점을 기억하세요.</font><font papago-translate="translated"> 런타임에 인스턴스에서 메서드를 찾은 후 환경을 만듭니다.</font><font papago-translate="translated"> 메서드의 LoxFunction을 단순히 반환했던 이전 코드 라인을 다음과 같이 교체합니다:</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    LoxFunction method = klass.findMethod(name.lexeme);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/LoxInstance.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>겟</em> ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">    <span class="k">if</span> (<span class="i">method</span> != <span class="k">null</span>) <span class="k">return</span> <span class="i">method</span>.<span class="i">bind</span>(<span class="k">this</span>);
</pre><pre class="insert-after" translate="no">
    throw new RuntimeError(name,<span name="hidden"> </span>
        "Undefined property '" + name.lexeme + "'.");
</pre></div>
<div class="source-file-narrow"><em>lox/LoxInstance.java</em>, in <em>get</em>(), replace 1 line</div>
<p><font papago-translate="splitted"><font papago-translate="translated">새로운 호출을 기록합니다 </font></font><code translate="no">bind()</code><font papago-translate="splitted"><font papago-translate="translated">. 그렇게 보입니다:</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/LoxFunction.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>LoxFunction</em>() 다음에 추가</font></font></div>
<pre translate="no">  <span class="t">LoxFunction</span> <span class="i">bind</span>(<span class="t">LoxInstance</span> <span class="i">instance</span>) {
    <span class="t">Environment</span> <span class="i">environment</span> = <span class="k">new</span> <span class="t">Environment</span>(<span class="i">closure</span>);
    <span class="i">environment</span>.<span class="i">define</span>(<span class="s">"this"</span>, <span class="i">instance</span>);
    <span class="k">return</span> <span class="k">new</span> <span class="t">LoxFunction</span>(<span class="i">declaration</span>, <span class="i">environment</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/LoxFunction.java</em>, add after <em>LoxFunction</em>()</div>
<p><font papago-translate="translated">별거 아닙니다.</font><font papago-translate="translated"> 우리는 방법의 원래 폐쇄 안에 새로운 환경을 조성합니다.</font><font papago-translate="translated"> 일종의 폐쇄 내 폐쇄.</font><font papago-translate="translated"> 메서드가 호출되면 메서드 본문 환경의 부모가 됩니다.</font></p>
<p><font papago-translate="translated">우리는 그 환경에서 "이것"을 변수로 선언하고, 이를 주어진 인스턴스, 즉 메서드가 접근하고 있는 인스턴스에 바인딩합니다.</font><font papago-translate="translated"> E<em>t voil</em>à, 반환된<em> L</em>oxFunction은 이제 "이것"이 객체에 묶여 있는 자신만의 작은 지속적인 세계를 돌고 있습니다<em>.</em></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">남은 과제는 다음을 해석하는 것입니다 </font></font><code translate="no">this</code><font papago-translate="splitted"><font papago-translate="translated"> 표현.</font><font papago-translate="translated"> 해결사와 마찬가지로 변수 표현식을 해석하는 것과 동일합니다.</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Interpreter.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>visit</em>S<em>etExpr</em>() 후 추가</font></font></div>
<pre translate="no">  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Object</span> <span class="i">visitThisExpr</span>(<span class="t">Expr</span>.<span class="t">This</span> <span class="i">expr</span>) {
    <span class="k">return</span> <span class="i">lookUpVariable</span>(<span class="i">expr</span>.<span class="i">keyword</span>, <span class="i">expr</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>visitSetExpr</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">아까 그 케이크 예시를 사용해서 한번 시도해 보세요.</font><font papago-translate="translated"> 20줄 미만의 코드로 통역사가 처리합니다 </font></font><code translate="no">this</code><font papago-translate="splitted"><font papago-translate="translated"> 내부 메서드는 중첩된 클래스, 메서드 내부의 함수, 메서드에 대한 핸들 등 모든 이상한 방식으로 상호 작용할 수 있습니다.</font></font></p>
<h3><a href="https://youhogeon-meritz.github.io/classes.html#invalid-uses-of-this" id="invalid-uses-of-this"><small><font papago-translate="translated">12 . 6 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">이것의 유효하지 않은 사용</font></font></a></h3>
<p><font papago-translate="splitted"><font papago-translate="translated">잠깐만.</font><font papago-translate="translated"> 사용하려고 하면 어떻게 되나요 </font></font><code translate="no">this</code> <font papago-translate="splitted"><font papago-translate="translated">방법<em> 밖에서?</em></font><font papago-translate="translated"> 그럼 어떻게 할까요:</font></font></p>
<div class="codehilite"><pre translate="no"><span class="k">print</span> <span class="k">this</span>;
</pre></div>
<p><font papago-translate="translated">또는:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">fun</span> <span class="i">notAMethod</span>() {
  <span class="k">print</span> <span class="k">this</span>;
}
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">인스턴스가 없습니다 </font></font><code translate="no">this</code><font papago-translate="splitted"><font papago-translate="translated"> 당신이 방법을 사용하지 않는 경우를 가리키기 위해.</font><font papago-translate="translated"> 다음과 같은 기본값을 제공할 수 있습니다 </font></font><code translate="no">nil</code><font papago-translate="splitted"><font papago-translate="translated"> 또는 런타임 오류로 만들지만 사용자가 분명히 실수를 저질렀습니다.</font><font papago-translate="translated"> 그 실수를 더 빨리 발견하고 고칠수록 그들은 더 행복해질 것입니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">우리의 해상도 패스는 이 오류를 정적으로 감지하기에 좋은 장소입니다.</font><font papago-translate="translated"> 이미 감지합니다 </font></font><code translate="no">return</code><font papago-translate="splitted"><font papago-translate="translated"> 기능 외의 진술.</font><font papago-translate="translated"> 우리는 비슷한 일을 할 것입니다 </font></font><code translate="no">this</code><font papago-translate="splitted"><font papago-translate="translated">. 기존 기능의 맥락에서</font><font papago-translate="translated">enum을 입력하면 새로운 ClassType를 정의합니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  }
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 열거<em> 함수</em> 뒤에 추가</font><font papago-translate="translated"><em>유형</em></font></font></div>
<pre class="insert" translate="no">
  <span class="k">private</span> <span class="k">enum</span> <span class="t">ClassType</span> {
    <span class="i">NONE</span>,
    <span class="i">CLASS</span>
  }

  <span class="k">private</span> <span class="t">ClassType</span> <span class="i">currentClass</span> = <span class="t">ClassType</span>.<span class="i">NONE</span>;

</pre><pre class="insert-after" translate="no">  void resolve(List&lt;Stmt&gt; statements) {
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after enum <em>FunctionType</em></div>
<p><font papago-translate="splitted"><font papago-translate="translated">예, 불리언일 수 있습니다.</font><font papago-translate="translated"> 상속에 도달하면 세 번째 값을 얻게 되므로 현재 열거형입니다.</font><font papago-translate="translated"> 우리는 또한 해당 필드를 추가합니다, </font></font><code translate="no">currentClass</code><font papago-translate="splitted"><font papago-translate="translated">. 구문 트리를 탐색하는 동안 클래스 선언 내에 현재 있는지 여부를 알려줍니다.</font><font papago-translate="translated"> 시작됩니다 </font></font><code translate="no">NONE</code><font papago-translate="splitted"><font papago-translate="translated"> 즉, 우리는 하나가 아닙니다.</font></font></p>
<p><font papago-translate="translated">클래스 선언을 해결하기 시작하면 이를 변경합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  public Void visitClassStmt(Stmt.Class stmt) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>visit</em>Cl<em>assStmt</em>()에서</font></font></div>
<pre class="insert" translate="no">    <span class="t">ClassType</span> <span class="i">enclosingClass</span> = <span class="i">currentClass</span>;
    <span class="i">currentClass</span> = <span class="t">ClassType</span>.<span class="i">CLASS</span>;

</pre><pre class="insert-after" translate="no">    declare(stmt.name);
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in <em>visitClassStmt</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">마찬가지로 </font></font><code translate="no">currentFunction</code><font papago-translate="splitted"><font papago-translate="translated">, 필드의 이전 값을 로컬 변수에 저장합니다.</font><font papago-translate="translated"> 이렇게 하면 JVM에 다시 올라와서 다음과 같은 스택을 유지할 수 있습니다 </font></font><code translate="no">currentClass</code><font papago-translate="splitted"><font papago-translate="translated"> 가치.</font><font papago-translate="translated"> 그렇게 하면 한 클래스가 다른 클래스 안에 둥지를 틀어도 이전 값을 잃지 않습니다.</font></font></p>
<p><font papago-translate="translated">방법들이 해결되면, 우리는 이전 값을 복원하여 그 스택을 "팝"합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    endScope();

</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>visit</em>Cl<em>assStmt</em>()에서</font></font></div>
<pre class="insert" translate="no">    <span class="i">currentClass</span> = <span class="i">enclosingClass</span>;
</pre><pre class="insert-after" translate="no">    return null;
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in <em>visitClassStmt</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">해결할 때 </font></font><code translate="no">this</code><font papago-translate="splitted"><font papago-translate="translated"> 표현 </font></font><code translate="no">currentClass</code><font papago-translate="splitted"><font papago-translate="translated"> 필드는 메서드 본문 내에서 표현식이 발생하지 않을 경우 오류를 보고하는 데 필요한 비트의 데이터를 제공합니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  public Void visitThisExpr(Expr.This expr) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>방문</em> 중에</font><font papago-translate="translated"><em>디스익</em>스프레스(<em>)</em></font></font></div>
<pre class="insert" translate="no">    <span class="k">if</span> (<span class="i">currentClass</span> == <span class="t">ClassType</span>.<span class="i">NONE</span>) {
      <span class="t">Lox</span>.<span class="i">error</span>(<span class="i">expr</span>.<span class="i">keyword</span>,
          <span class="s">"Can't use 'this' outside of a class."</span>);
      <span class="k">return</span> <span class="k">null</span>;
    }

</pre><pre class="insert-after" translate="no">    resolveLocal(expr, expr.keyword);
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in <em>visitThisExpr</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">사용자가 다음을 사용하는 데 도움이 될 것입니다 </font></font><code translate="no">this</code><font papago-translate="splitted"><font papago-translate="translated"> 맞아요, 그리고 그것은 우리가 인터프리터에서 실행 시 오용을 처리할 필요를 덜어줍니다.</font></font></p>
<h2><a href="https://youhogeon-meritz.github.io/classes.html#constructors-and-initializers" id="constructors-and-initializers"><small><font papago-translate="translated">12 . 7</font></small><font papago-translate="splitted"><font papago-translate="translated">생성자 및 초기화자</font></font></a></h2>
<p><font papago-translate="translated">이제 수업으로 거의 모든 것을 할 수 있게 되었고, 장이 끝날 무렵에는 이상하게도 시작에 집중하게 되었습니다.</font><font papago-translate="translated"> 메서드와 필드를 통해 객체가 항상 유효한 구성<em>으로 유지</em>되도록 상태와 동작을 함께 캡슐화할 수 있습니다.</font><font papago-translate="translated"> 하지만 새로운 물체<em>가</em> 좋은 상태<em>로 시작</em>하도록 하려면 어떻게 해야 할까요?</font></p>
<p><font papago-translate="translated">이를 위해서는 건설자가 필요합니다.</font><font papago-translate="translated"> 저는 그것들이 언어에서 디자인하기 가장 까다로운 부분 중 하나라고 생각합니다. 대부분의 다른 언어들을 자세히 살펴보면, 디자인의 이음새가 완벽하게 맞지 않는 객체 구성에<span name="cracks"> 균열이</span> 생길 수 있습니다.</font><font papago-translate="translated"> 어쩌면 출생 순간에 본질적으로 혼란스러운 무언가가 있을지도 모릅니다.</font></p>
<aside name="cracks" style="top: 23510.5px;">
<p><font papago-translate="translated">몇 가지 예:</font><font papago-translate="translated"> Java에서는 최종 필드를 초기화해야 하지만<em>, 이전에</em> 읽기<em> 전</em>에 여전히 필드를 읽을 수 있습니다.</font><font papago-translate="translated"> 예외—거대하고 복잡한 특징—는 주로 생성<span class="em"></span><span class="em"></span>자의 오류를 배출하기 위한 방법으로 C++에 추가되었습니다.</font></p>
</aside>
<p><font papago-translate="translated">객체를 "구성"하는 것은 실제로 한 쌍의 작업입니다:</font></p>
<ol>
<li>
<p><font papago-translate="translated">런타임은 새 인스턴스에 필요한 메모리<span name="allocate"><em>를 할당합니다</em></span>.</font><font papago-translate="translated"> 대부분의 언어에서 이 작업은 사용자 코드가 접근할 수 있는 기본 수준 이하에 있습니다.</font></p>
<aside name="allocate" style="top: 23630.5px;">
<p><font papago-translate="translated">C++의 "<a href="https://en.wikipedia.org/wiki/Placement_syntax">배치 새"</a>는 프로그래머가 제작할 수 있도록 할당의 장을 공개하는 드문 예입니다.</font></p>
</aside></li>
<li>
<p><font papago-translate="translated">그런 다음 사용자가 제공한 코드 덩어리를 호출하여 형성되지 않은 객체<em>를 초기화</em>합니다.</font></p>
</li>
</ol>
<p><font papago-translate="translated">후자는 우리가 "구성자"라는 말을 들을 때 흔히 생각하는 것이지만, 그 언어 자체는 보통 그 시점에 도달하기 전에 우리에게 어떤 기초 작업을 해왔습니다.</font><font papago-translate="translated"> 사실, 우리의 Lox 인터프리터는 새로운 LoxInstance 객체를 생성할 때 이미 그 문제를 다루고 있습니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">이제 남은 부분인 사용자 정의 초기화 작업을<span class="em"></span><span class="em"></span> 진행하겠습니다.</font><font papago-translate="translated"> 언어에는 클래스의 새로운 객체를 설정하는 코드 덩어리에 대한 다양한 표기법이 있습니다.</font><font papago-translate="translated"> C++, Java, 그리고 C#는 클래스 이름과 일치하는 메서드를 사용합니다.</font><font papago-translate="translated"> 루비와 파이썬은 이를 부릅니다 </font></font><code translate="no">init()</code><font papago-translate="splitted"><font papago-translate="translated">. 후자는 멋지고 짧아서 그렇게 하겠습니다.</font></font></p>
<p><font papago-translate="translated">LoxClass의 LoxCallable 구현에서는 몇 줄을 더 추가합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">                     List&lt;Object&gt; arguments) {
    LoxInstance instance = new LoxInstance(this);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/LoxClass.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>콜</em> ()에서</font></font></div>
<pre class="insert" translate="no">    <span class="t">LoxFunction</span> <span class="i">initializer</span> = <span class="i">findMethod</span>(<span class="s">"init"</span>);
    <span class="k">if</span> (<span class="i">initializer</span> != <span class="k">null</span>) {
      <span class="i">initializer</span>.<span class="i">bind</span>(<span class="i">instance</span>).<span class="i">call</span>(<span class="i">interpreter</span>, <span class="i">arguments</span>);
    }

</pre><pre class="insert-after" translate="no">    return instance;
</pre></div>
<div class="source-file-narrow"><em>lox/LoxClass.java</em>, in <em>call</em>()</div>
<p><font papago-translate="translated">클래스가 호출되면 LoxInstance가 생성된 후 "init" 메서드를 찾습니다.</font><font papago-translate="translated"> 하나를 찾으면 일반 메서드 호출처럼 즉시 바인딩하고 호출합니다.</font><font papago-translate="translated"> 인수 목록이 전달됩니다.</font></p>
<p><font papago-translate="translated">그 인수 목록은 우리가 클래스의 희귀성을 선언하는 방식도 조정해야 한다는 것을 의미합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  public int arity() {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/LoxClass.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>희귀</em> ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">    <span class="t">LoxFunction</span> <span class="i">initializer</span> = <span class="i">findMethod</span>(<span class="s">"init"</span>);
    <span class="k">if</span> (<span class="i">initializer</span> == <span class="k">null</span>) <span class="k">return</span> <span class="n">0</span>;
    <span class="k">return</span> <span class="i">initializer</span>.<span class="i">arity</span>();
</pre><pre class="insert-after" translate="no">  }
</pre></div>
<div class="source-file-narrow"><em>lox/LoxClass.java</em>, in <em>arity</em>(), replace 1 line</div>
<p><font papago-translate="translated">이니셜라이저가 있는 경우, 해당 메서드의 희소성에 따라 클래스 자체를 호출할 때 통과해야 하는 인수의 수가 결정됩니다.</font><font papago-translate="translated"> 하지만 편의상 이니셜라이저를 정의하는 클래스<em>는 필요</em>하지 않습니다.</font><font papago-translate="translated"> 초기화기가 없더라도, 초기화기는 여전히 0입니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">그게 전부입니다.</font><font papago-translate="translated"> 우리가 결합하기 때문에 </font></font><code translate="no">init()</code><font papago-translate="splitted"><font papago-translate="translated"> 우리가 그것을 부르기 전에, 그것은 다음과 같은 접근 권한을 가지고 있습니다 </font></font><code translate="no">this</code><font papago-translate="splitted"><font papago-translate="translated"> 몸 안에서.</font><font papago-translate="translated"> 수업에 전달된 논거와 함께 원하는 대로 새 인스턴스를 설정하는 데 필요한 것은 그것뿐입니다.</font></font></p>
<h3><a href="https://youhogeon-meritz.github.io/classes.html#invoking-init-directly" id="invoking-init-directly"><small><font papago-translate="translated">12 . 7 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">init() 직접 호출</font></font></a></h3>
<p><font papago-translate="translated">평소처럼 이 새로운 의미 영역을 탐험하면 몇 가지 이상한 생물이 생겨납니다.</font><font papago-translate="translated"> 고려:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">class</span> <span class="t">Foo</span> {
  <span class="i">init</span>() {
    <span class="k">print</span> <span class="k">this</span>;
  }
}

<span class="k">var</span> <span class="i">foo</span> = <span class="t">Foo</span>();
<span class="k">print</span> <span class="i">foo</span>.<span class="i">init</span>();
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">객체를 직접 호출하여 "재초기화"할 수 있습니까 </font></font><code translate="no">init()</code><font papago-translate="splitted"><font papago-translate="translated"> 방법?</font><font papago-translate="translated"> 그렇게 하면 무엇이 돌아오나요?</font><font papago-translate="translated"> <span name="compromise">합리</span>적인 대답은 다음과 같습니다 </font></font><code translate="no">nil</code><font papago-translate="splitted"><font papago-translate="translated"> 그렇게 보이기 때문에 몸이 돌아옵니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">그러나 저는 일반적으로 구현을 만족시키기 위해 타협하는 것을 싫어합니다. 이렇게<span class="em"></span><span class="em"></span> 말하면 Clox의 생성자 구현이 훨씬 더 쉬워질 것입니다 </font></font><code translate="no">init()</code><font papago-translate="splitted"><font papago-translate="translated"> 메서드는 항상 반환됩니다 </font></font><code translate="no">this</code><font papago-translate="splitted"><font papago-translate="translated">, 직접 호출해도.</font><font papago-translate="translated"> jlox와 호환되도록 하기 위해 LoxFunction에 특별한 케이스 코드를 추가했습니다.</font></font></p>
<aside name="compromise" style="top: 25082.5px;">
<p><font papago-translate="translated">아마도 "싫어한다"는 주장이 너무 강할 수도 있습니다.</font><font papago-translate="translated" class=""> 구현의 제약 조건과 리소스가 언어 설계에 영향을 미치는 것은 합리적입니다.</font><font papago-translate="translated"> 하루에는 시간이 너무 많지 않으며, 여기저기서 컷 코너를 통해 사용자에게 더 많은 기능을 더 짧은 시간 안에 제공할 수 있다면 사용자의 행복과 생산성을 위한 순익이 될 수 있습니다.</font><font papago-translate="translated"> 요령은 사용자와 미래의 자신이 근시안적인 시각을 저주하지 않도록<em> 어떤</em> 모서리를 잘라야 할지 알아내는 것입니다.</font></p>
</aside>
<div class="codehilite"><pre class="insert-before" translate="no">      return returnValue.value;
    }
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/LoxFunction.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>콜</em> ()에서</font></font></div>
<pre class="insert" translate="no">
    <span class="k">if</span> (<span class="i">isInitializer</span>) <span class="k">return</span> <span class="i">closure</span>.<span class="i">getAt</span>(<span class="n">0</span>, <span class="s">"this"</span>);
</pre><pre class="insert-after" translate="no">    return null;
</pre></div>
<div class="source-file-narrow"><em>lox/LoxFunction.java</em>, in <em>call</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">함수가 초기화 함수인 경우 실제 반환 값을 무시하고 강제로 반환합니다 </font></font><code translate="no">this</code><font papago-translate="splitted"><font papago-translate="translated">. 그것은 새로운 것에 의존합니다 </font></font><code translate="no">isInitializer</code><font papago-translate="splitted"><font papago-translate="translated"> 들판.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  private final Environment closure;

</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/LoxFunction.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> L<em>oxFunction</em> 클래스에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">  <span class="k">private</span> <span class="k">final</span> <span class="t">boolean</span> <span class="i">isInitializer</span>;

  <span class="t">LoxFunction</span>(<span class="t">Stmt</span>.<span class="t">Function</span> <span class="i">declaration</span>, <span class="t">Environment</span> <span class="i">closure</span>,
              <span class="t">boolean</span> <span class="i">isInitializer</span>) {
    <span class="k">this</span>.<span class="i">isInitializer</span> = <span class="i">isInitializer</span>;
</pre><pre class="insert-after" translate="no">    this.closure = closure;
    this.declaration = declaration;
</pre></div>
<div class="source-file-narrow"><em>lox/LoxFunction.java</em>, in class <em>LoxFunction</em>, replace 1 line</div>
<p><font papago-translate="splitted"><font papago-translate="translated">사용자가 해당 이름으로<em> 함수</em>를 정의할 수 있었기 때문에 LoxFunction의 이름이 "init"인지 단순히 확인할 수 없습니다.</font><font papago-translate="translated"> 그 경우에는<em> 없습니다</em> </font></font><code translate="no">this</code><font papago-translate="splitted"><font papago-translate="translated"> 돌아가기 위해.</font><font papago-translate="translated"> 이 이상한 엣지 케이스를 피하기 위해 LoxFunction이 초기화<em></em> 메서드를 나타내는지 여부를 직접 저장합니다.</font><font papago-translate="translated"> 즉, 우리가 LoxFunctions를 만드는 몇 안 되는 장소들을 다시 고쳐야 합니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  public Void visitFunctionStmt(Stmt.Function stmt) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Interpreter.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>방문</em> 중에</font><font papago-translate="translated"><em>FunctionStmt</em>()</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">    <span class="t">LoxFunction</span> <span class="i">function</span> = <span class="k">new</span> <span class="t">LoxFunction</span>(<span class="i">stmt</span>, <span class="i">environment</span>,
                                           <span class="k">false</span>);
</pre><pre class="insert-after" translate="no">    environment.define(stmt.name.lexeme, function);
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in <em>visitFunctionStmt</em>(), replace 1 line</div>
<p><font papago-translate="splitted"><font papago-translate="translated">실제 함수 선언의 경우, </font></font><code translate="no">isInitializer</code><font papago-translate="splitted"><font papago-translate="translated"> 는 항상 거짓입니다.</font><font papago-translate="translated"> 방법은 이름을 확인합니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    for (Stmt.Function method : stmt.methods) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Interpreter.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>visit</em>Cl<em>assStmt</em>()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">      <span class="t">LoxFunction</span> <span class="i">function</span> = <span class="k">new</span> <span class="t">LoxFunction</span>(<span class="i">method</span>, <span class="i">environment</span>,
          <span class="i">method</span>.<span class="i">name</span>.<span class="i">lexeme</span>.<span class="i">equals</span>(<span class="s">"init"</span>));
</pre><pre class="insert-after" translate="no">      methods.put(method.name.lexeme, function);
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in <em>visitClassStmt</em>(), replace 1 line</div>
<p><font papago-translate="splitted"><font papago-translate="translated">그리고 나서 </font></font><code translate="no">bind()</code><font papago-translate="splitted"><font papago-translate="translated"> 우리가 결합하는 클로저를 만드는 곳 </font></font><code translate="no">this</code><font papago-translate="splitted"><font papago-translate="translated"> 메서드에 원래 메서드의 값을 전달합니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    environment.define("this", instance);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/LoxFunction.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>바인딩</em>된 ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">    <span class="k">return</span> <span class="k">new</span> <span class="t">LoxFunction</span>(<span class="i">declaration</span>, <span class="i">environment</span>,
                           <span class="i">isInitializer</span>);
</pre><pre class="insert-after" translate="no">  }
</pre></div>
<div class="source-file-narrow"><em>lox/LoxFunction.java</em>, in <em>bind</em>(), replace 1 line</div>
<h3><a href="https://youhogeon-meritz.github.io/classes.html#returning-from-init" id="returning-from-init"><small><font papago-translate="translated">12 . 7 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">init()에서 돌아오기</font></font></a></h3>
<p><font papago-translate="translated">아직 숲에서 벗어나지 못했습니다.</font><font papago-translate="translated"> 대부분의 생성자가 그렇지 않기 때문에 사용자가 작성한 초기화기가 명시적으로 값을 반환하지 않는다고 가정해 왔습니다.</font><font papago-translate="translated"> 사용자가 시도할 경우 발생해야 할 일:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">class</span> <span class="t">Foo</span> {
  <span class="i">init</span>() {
    <span class="k">return</span> <span class="s">"something else"</span>;
  }
}
</pre></div>
<p><font papago-translate="translated">그들이 원하는 대로 되지 않을 것이기 때문에, 우리는 그것을 정적인 오류로 만드는 것이 좋습니다.</font><font papago-translate="translated"> 해결사로 돌아가서, FunctionType에 다른 케이스를 추가합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    FUNCTION,
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 열거<em> 함수</em>에서</font><font papago-translate="translated"><em>유형</em></font></font></div>
<pre class="insert" translate="no">    <span class="i">INITIALIZER</span>,
</pre><pre class="insert-after" translate="no">    METHOD
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in enum <em>FunctionType</em></div>
<p><font papago-translate="translated">방문한 메서드의 이름을 사용하여 초기화기를 해결하고 있는지 여부를 확인합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      FunctionType declaration = FunctionType.METHOD;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>visit</em>Cl<em>assStmt</em>()에서</font></font></div>
<pre class="insert" translate="no">      <span class="k">if</span> (<span class="i">method</span>.<span class="i">name</span>.<span class="i">lexeme</span>.<span class="i">equals</span>(<span class="s">"init"</span>)) {
        <span class="i">declaration</span> = <span class="t">FunctionType</span>.<span class="i">INITIALIZER</span>;
      }

</pre><pre class="insert-after" translate="no">      resolveFunction(method, declaration);<span name="local"> </span>
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in <em>visitClassStmt</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">나중에 다음과 같이 이동할 때 </font></font><code translate="no">return</code><font papago-translate="splitted"><font papago-translate="translated"> 문, 해당 필드를 확인한 후 내부에서 값을 반환하는 것을 오류로 만듭니다 </font></font><code translate="no">init()</code><font papago-translate="splitted"><font papago-translate="translated"> 방법.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    if (stmt.value != null) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>visitReturnStmt</em>()</font></font></div>
<pre class="insert" translate="no">      <span class="k">if</span> (<span class="i">currentFunction</span> == <span class="t">FunctionType</span>.<span class="i">INITIALIZER</span>) {
        <span class="t">Lox</span>.<span class="i">error</span>(<span class="i">stmt</span>.<span class="i">keyword</span>,
            <span class="s">"Can't return a value from an initializer."</span>);
      }

</pre><pre class="insert-after" translate="no">      resolve(stmt.value);
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in <em>visitReturnStmt</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated"><em>아직</em> 끝나지 않았습니다.</font><font papago-translate="translated"> 초기화기<em>에서 값</em>을 반환하는 것은 정적으로 허용되지 않지만, 빈 초기 값은 여전히 사용할 수 있습니다 </font></font><code translate="no">return</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p>
<div class="codehilite"><pre translate="no"><span class="k">class</span> <span class="t">Foo</span> {
  <span class="i">init</span>() {
    <span class="k">return</span>;
  }
}
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">그것은 사실 때때로 꽤 유용합니다. 그래서 우리는 그것을 완전히 부정하고 싶지 않습니다.</font><font papago-translate="translated"> 대신 반환해야 합니다 </font></font><code translate="no">this</code><font papago-translate="splitted"><font papago-translate="translated"> 대신 </font></font><code translate="no">nil</code><font papago-translate="splitted"><font papago-translate="translated">. 이는 LoxFunction에서 쉽게 해결할 수 있는 방법입니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    } catch (Return returnValue) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/LoxFunction.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>콜</em> ()에서</font></font></div>
<pre class="insert" translate="no">      <span class="k">if</span> (<span class="i">isInitializer</span>) <span class="k">return</span> <span class="i">closure</span>.<span class="i">getAt</span>(<span class="n">0</span>, <span class="s">"this"</span>);

</pre><pre class="insert-after" translate="no">      return returnValue.value;
</pre></div>
<div class="source-file-narrow"><em>lox/LoxFunction.java</em>, in <em>call</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">초기화 단계에 있고 실행 중인 경우 </font></font><code translate="no">return</code><font papago-translate="splitted"><font papago-translate="translated"> 문장, 값을 반환하는 대신 (항상 다음과 같은 경우) </font></font><code translate="no">nil</code><font papago-translate="splitted"><font papago-translate="translated">), 다시 돌아옵니다 </font></font><code translate="no">this</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">휴! 그건 전체 작업 목록이었지만, 우리의 보상은 우리의 작은 통역사가 전체 프로그래밍 패러다임을 발전시켰다는 것입니다.</font><font papago-translate="translated"> 수업, 방법, 분야, </font></font><code translate="no">this</code><font papago-translate="splitted"><font papago-translate="translated">, 그리고 생성자.</font><font papago-translate="translated"> 우리의 아기 언어는 정말 어른스러워 보입니다.</font></font></p>
<div class="challenges">
<h2><a href="https://youhogeon-meritz.github.io/classes.html#challenges" id="challenges"><font papago-translate="translated">과제들</font></a></h2>
<ol>
<li>
<p><font papago-translate="splitted"><font papago-translate="translated">인스턴스에 대한 메서드는 있지만 클래스 객체 자체에서 직접 호출할 수 있는 "정적" 메서드를 정의할 수 있는 방법은 없습니다.</font><font papago-translate="translated"> 그들에 대한 지원을 추가하세요.</font><font papago-translate="translated"> 사용 </font></font><code translate="no">class</code><font papago-translate="splitted"><font papago-translate="translated"> 메서드 앞에 있는 키워드는 클래스 객체에 연결된 정적 메서드를 나타냅니다.</font></font></p>
<div class="codehilite"><pre translate="no"><span class="k">class</span> <span class="t">Math</span> {
  <span class="k">class</span> <span class="i">square</span>(<span class="i">n</span>) {
    <span class="k">return</span> <span class="i">n</span> * <span class="i">n</span>;
  }
}

<span class="k">print</span> <span class="t">Math</span>.<span class="i">square</span>(<span class="n">3</span>); <span class="c">// Prints "9".</span>
</pre></div>
<p><font papago-translate="translated">이 문제는 원하는 대로 해결할 수 있지만, Smalltalk와 Ruby가 사용하는 "<a href="https://en.wikipedia.org/wiki/Metaclass">메타클래스"</a>는 특히 우아한 접근 방식입니다.</font><font papago-translate="translated"> <em>힌트: LoxClass를 LoxInstance로 확장하고 거기서부터 시작하세요.</em></font></p>
</li>
<li>
<p><font papago-translate="translated">대부분의 현대 언어는 필드 읽기와 쓰기처럼 보이지만 실제로는 사용자 정의<span class="em"></span> 코드를 실행하는 클래스의 멤버인 "게터"와 "세터"를 지원합니다.</font><font papago-translate="translated"> Getter 메서드를 지원하도록 Lox를 확장합니다.</font><font papago-translate="translated"> 이것들은 매개변수 목록 없이 선언됩니다.</font><font papago-translate="translated"> 게터의 본문은 해당 이름을 가진 속성에 접근할 때 실행됩니다.</font></p>
<div class="codehilite"><pre translate="no"><span class="k">class</span> <span class="t">Circle</span> {
  <span class="i">init</span>(<span class="i">radius</span>) {
    <span class="k">this</span>.<span class="i">radius</span> = <span class="i">radius</span>;
  }

  <span class="i">area</span> {
    <span class="k">return</span> <span class="n">3.141592653</span> * <span class="k">this</span>.<span class="i">radius</span> * <span class="k">this</span>.<span class="i">radius</span>;
  }
}

<span class="k">var</span> <span class="i">circle</span> = <span class="t">Circle</span>(<span class="n">4</span>);
<span class="k">print</span> <span class="i">circle</span>.<span class="i">area</span>; <span class="c">// Prints roughly "50.2655".</span>
</pre></div>
</li>
<li>
<p><font papago-translate="splitted"><font papago-translate="translated">Python과 JavaScript를 사용하면 자체 메서드 외에서도 객체의 필드에 자유롭게 액세스할 수 있습니다.</font><font papago-translate="translated"> Ruby와 Smalltalk는 인스턴스 상태를 캡슐화합니다.</font><font papago-translate="translated"> 클래스의 메서드만 원시 필드에 액세스할 수 있으며, 어떤 상태가 노출되는지는 클래스의 결정에 달려 있습니다.</font><font papago-translate="translated"> 대부분의 정적으로 입력된 언어는 다음과 같은 수식어를 제공합니다 </font></font><code translate="no">private</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">public</code><font papago-translate="splitted"><font papago-translate="translated"> 외부에서 접근할 수 있는 클래스의 일부를 구성원 단위로 제어합니다.</font></font></p>
<p><font papago-translate="translated">이러한 접근 방식 간의 상충 관계는 무엇이며, 왜 언어가 둘 중 하나를 선호할 수 있을까요?</font></p>
</li>
</ol>
</div>
<div class="design-note">
<h2><a href="https://youhogeon-meritz.github.io/classes.html#design-note" id="design-note"><font papago-translate="translated">디자인 노트: 프로토타입과 파워</font></a></h2>
<p><font papago-translate="translated">이 장에서는 LoxClass와 LoxInstance라는 두 가지 새로운 런타임 엔티티를 소개했습니다.</font><font papago-translate="translated"> 전자는 물체에 대한 행동이 존재하는 곳이고, 후자는 국가에 대한 행동입니다.</font><font papago-translate="translated"> LoxInstance 내부의 단일 객체에서 메서드를 바로 정의할 수 있다면 어떨까요?</font><font papago-translate="translated"> 그렇다면 LoxClass가 전혀 필요하지 않을 것입니다.</font><font papago-translate="translated"> LoxInstance는 객체의 동작과 상태를 정의하는 완전한 패키지입니다.</font></p>
<p><font papago-translate="translated">우리는 여전히 수업 없이 여러 사례에서 행동을 재사용할 수 있는 방법을 원합니다.</font><font papago-translate="translated"> LoxInstance가 상속과 같은 필드와 메서드를 재사용하도록 다른 LoxInstance<a href="https://en.wikipedia.org/wiki/Prototype-based_programming#Delegation"><em>에</em></a> 직접<a href="https://en.wikipedia.org/wiki/Prototype-based_programming#Delegation"><em> 위임</em></a>할 수 있습니다.</font></p>
<p><font papago-translate="translated">사용자들은 자신의 프로그램을 객체들의 집합으로 모델링할 것이며, 그 중 일부는 공통성을 반영하기 위해 서로에게 위임합니다.</font><font papago-translate="translated"> 대표로 사용되는 객체는 다른 사람들이 정제하는 "정규적" 또는 "원형적" 객체를 나타냅니다.</font><font papago-translate="translated"> 그 결과, 단일 내부 구성 요소인 LoxInstance만 있는 더 간단한 실행 시간이 생깁니다.</font></p>
<p><font papago-translate="translated"><strong><a href="https://en.wikipedia.org/wiki/Prototype-based_programming">이것</a></strong>이 바로<strong><a href="https://en.wikipedia.org/wiki/Prototype-based_programming"> 이</a></strong> 패러다임의<strong><a href="https://en.wikipedia.org/wiki/Prototype-based_programming"> 프로토타입</a></strong>이라는 이름에서 유래한 것입니다.</font><font papago-translate="translated"> 그것은<a href="http://www.selflanguage.org/"> 데이비드</a> 웅가와 랜달 스미스에 의해<a href="http://www.selflanguage.org/"> 셀프</a>라는 언어로 발명되었습니다.</font><font papago-translate="translated"> 그들은 스몰토크부터 시작하여 위의 정신 운동을 따라 얼마나 줄일 수 있는지 확인하면서 그것을 생각해냈습니다.</font></p>
<p><font papago-translate="translated">프로토타입은 오랫동안 학문적인 호기심을 불러일으켰고, 흥미로운 연구를 불러일으켰지만 더 큰 프로그래밍 세계에서는 큰 타격을 주지 않았습니다.</font><font papago-translate="translated"> 즉, 브렌든 아이히가 프로토타입을 자바스크립트에 압축하여 곧바로 세상을 장악하기 전까지는 말입니다.</font><font papago-translate="translated"> 자바스크립트의 프로토타입에 대해 많은<span name="words"> (</span>많은<span name="words">) 단어들</span>이 작성되었습니다.</font><font papago-translate="translated"> 프로토타입이 훌륭하거나 혼란스럽다는 것을 보여주든,<span class="em"></span> 아니면 둘 다!</font><font papago-translate="translated"><span class="em">-</span>는 미해결 질문입니다<span class="em">.</span></font></p>
<aside name="words" style="top: 29424.5px;">
<p><font papago-translate="translated">정말<a href="http://gameprogrammingpatterns.com/prototype.html">로 당신</a>의 곁에<a href="http://gameprogrammingpatterns.com/prototype.html"> 한 줌 이상</a>의 것을 포함합니다.</font></p>
</aside>
<p><font papago-translate="translated">프로토타입이 언어에 좋은 아이디어라고 생각하는지 여부에 대해서는 말씀드리지 않겠습니다.</font><font papago-translate="translated"> <a href="http://finch.stuffwithstuff.com/">저</a>는<a href="http://finch.stuffwithstuff.com/"> 프로토타입</a> 언어와<a href="http://wren.io/"> 클래스 기반</a> 언어를 만들었는데, 두 언어에 대한 제 의견은 복잡합니다.</font><font papago-translate="translated"> 제가 논의하고 싶은 것은 언어에서<em> 단순함</em>의 역할입니다.</font></p>
<p><font papago-translate="translated">프로토타입은 수업보다 간단합니다. 언어 구현자가 작성하기에는 코드가 적고, 사용자가 배우고<span class="em"></span> 이해할 수 있는 개념도 적습니다.</font><font papago-translate="translated"> 그게 그들을 더 나아지게 하나요?</font><font papago-translate="translated"> 우리 언어 덕후들은 미니멀리즘을 페티시화하는 경향이 있습니다.</font><font papago-translate="translated"> 개인적으로 단순함은 방정식의 일부일 뿐이라고 생각합니다.</font><font papago-translate="translated"> 우리가 사용자에게 진정으로 주고 싶은<em> 것</em>은<em> 힘</em>입니다. 저는<em> 이</em>를<em> 다음</em>과 같이 정의합니다:</font></p>
<div class="codehilite"><pre translate="no">power = breadth × ease ÷ complexity
</pre></div>
<p><font papago-translate="translated" class="">이들 중 어느 것도 정확한 수치 측정치가 아닙니다.</font><font papago-translate="translated"> 저는 수학을 실제 정량화가 아닌 비유로 사용하고 있습니다.</font></p>
<ul>
<li>
<p><font papago-translate="translated" class=""><strong>폭은</strong> 언어가 표현할 수 있게 해주는 다양한 것들의 범위입니다<strong>.</strong></font><font papago-translate="translated"> C는 운영 체제부터 사용자 애플리케이션,<span class="em"></span> 게임에 이르기까지 모든 것에 사용되어 왔습니다.</font><font papago-translate="translated" class=""> AppleScript 및 Matlab과 같은 도메인별 언어는 폭이 적습니다.</font></p>
</li>
<li>
<p><font papago-translate="translated"><strong>쉬운 것</strong>은 언어가 원하는 대로 작동하도록 만드는 데 얼마나 적은 노력이 필요<strong>한지</strong>를 의미<strong>합니다.</strong></font><font papago-translate="translated"> "사용 가능성"이라는 용어는 다른 용어일 수도 있지만, 제가 반입하고 싶은 짐보다 더 많은 짐을 운반합니다.</font><font papago-translate="translated"> "상위 언어"는 "하위 언어"보다 더 쉬운 경향이 있습니다.</font><font papago-translate="translated"> 대부분의 언어는 어떤 것들이 다른 것들보다 더 쉽게 표현될 수 있는 "곡물"을 가지고 있습니다.</font></p>
</li>
<li>
<p><font papago-translate="translated"><strong>복잡성은</strong> 언어의 실행 시간, 핵심 라이브러리, 도구, 생태계 등을 포함하여 언어의 크기를 의미합니다<strong>.</strong></font><font papago-translate="translated"> 사람들은 한 언어의 스펙에 몇 페이지가 있는지, 또는 키워드가 몇 개 있는지에 대해 이야기합니다.</font><font papago-translate="translated"> 사용자가 시스템에서 생산성을 발휘하기 전에 웨트웨어에 얼마나 많은 양을 로드해야 하는지를 나타냅니다.</font><font papago-translate="translated"> 그것은 단순함의 반대말입니다.</font></p>
</li>
</ul>
<p><font papago-translate="translated">복잡성을 줄이면 힘이 증가<em>합니다</em>.</font><font papago-translate="translated"> 분모가 작을수록 결과 값이 커지므로 단순함이 좋다는 직관은 유효합니다.</font><font papago-translate="translated"> 그러나 복잡성을 줄일 때는 과정에서 폭이나 여유를 희생하지 않도록 주의해야 하며, 그렇지 않으면 총 전력이 감소할 수 있습니다.</font><font papago-translate="translated"> 문자열을 제거하면 자바는 훨씬<em> 더 간단한</em> 언어가 될 수 있지만, 텍스트 조작 작업을 잘 처리하지 못할 수도 있고, 작업을 완료하는 것도 쉽지 않을 것입니다.</font></p>
<p><font papago-translate="translated">따라서 예술은 언어<span class="em"></span> 사용의 폭이나 용이성을 높여 그 무게를 지탱하지 못하는 언어적 특징과 상호작용을 생략할 수 있는<em> 우연한</em> 복잡성을 찾는 것입니다.</font></p>
<p><font papago-translate="translated">사용자가 자신의 프로그램을 객체의 범주로 표현하고자 한다면, 언어에 수업을 입력하면 추가 복잡성을 보완할 수 있을 만큼 충분한 여유가 생기길 바랍니다.</font><font papago-translate="translated"> 하지만 사용자들이 당신의 언어를 그렇게 사용하지 않는다면, 수업은 절대 빼야 합니다.</font></p>
</div>
<footer>
<a class="next" href="https://youhogeon-meritz.github.io/inheritance.html"><font papago-translate="translated"> 다음 장: "상속" → </font></a><font papago-translate="splitted"><font papago-translate="translated"> 로버트 니스트롬이 수작업으로 제작한 -<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE"> © 2015 ~ 2021</a></font></font>
</footer>
</article>
</div>


<div id="papagoTooltip" margin="5" style="display: none;">
        <h1 id="tooltipTitle">원문</h1>
        <p id="tooltipText"></p>
      </div>
      </body></html>