<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link rel="stylesheet" type="text/css" href="cid:css-cc060dd1-e790-4216-b3b7-a3ddcc97e0a8@mhtml.blink" />

<title>Statements and State · Crafting Interpreters</title>
<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta content="width=device-width, initial-scale=1" name="viewport">
<link href="https://youhogeon-meritz.github.io/style.css" rel="stylesheet" type="text/css">
<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600" rel="stylesheet" type="text/css">
<link href="https://youhogeon-meritz.github.io/image/favicon.png" rel="icon" type="image/png">


<!-- Google analytics -->

</head>
<body id="top">
<!-- <div class="scrim"></div> -->
<nav class="wide">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<div class="contents">
<h3><a href="https://youhogeon-meritz.github.io/statements-and-state.html#top"><font papago-translate="splitted"><font papago-translate="translated">진술 및 진술</font></font><small>8</small></a></h3>
<ul>
<li><a href="https://youhogeon-meritz.github.io/statements-and-state.html#statements"><small>8.1</small><font papago-translate="splitted"><font papago-translate="translated"> 진술들</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/statements-and-state.html#global-variables"><small>8.2</small><font papago-translate="splitted"><font papago-translate="translated"> 글로벌 변수</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/statements-and-state.html#environments"><small>8.3</small><font papago-translate="splitted"><font papago-translate="translated"> 환경</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/statements-and-state.html#assignment"><small>8.4</small><font papago-translate="splitted"><font papago-translate="translated"> 과제</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/statements-and-state.html#scope"><small>8.5</small><font papago-translate="splitted"><font papago-translate="translated"> 범위</font></font></a></li>
<li class="divider"></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/statements-and-state.html#challenges"><font papago-translate="translated">과제들</font></a></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/statements-and-state.html#design-note"><small><font papago-translate="translated">메모</font></small><font papago-translate="splitted"><font papago-translate="translated">암묵적 변수 선언</font></font></a></li>
</ul>
<div class="prev-next">
<a class="left" href="https://youhogeon-meritz.github.io/evaluating-expressions.html" title="표현식 평가하기" papago-attr-id="1"><font papago-translate="translated">← 이전</font></a>
<a href="https://youhogeon-meritz.github.io/a-tree-walk-interpreter.html" title="나무 산책 통역사" papago-attr-id="2"><font papago-translate="translated">↑ 위로</font></a>
<a class="right" href="https://youhogeon-meritz.github.io/control-flow.html" title="제어 흐름" papago-attr-id="3"><font papago-translate="translated">다음 →</font></a>
</div> </div>
</nav>
<nav class="narrow">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<a class="prev" href="https://youhogeon-meritz.github.io/evaluating-expressions.html" title="Evaluating Expressions">←</a>
<a class="next" href="https://youhogeon-meritz.github.io/control-flow.html" title="Control Flow">→</a>
</nav>
<div class="page">
<div class="nav-wrapper">
<nav class="floating">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<div class="expandable">
<h3><a href="https://youhogeon-meritz.github.io/statements-and-state.html#top"><font papago-translate="splitted"><font papago-translate="translated">진술 및 진술</font></font><small>8</small></a></h3>
<ul>
<li><a href="https://youhogeon-meritz.github.io/statements-and-state.html#statements"><small>8.1</small><font papago-translate="splitted"><font papago-translate="translated"> 진술들</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/statements-and-state.html#global-variables"><small>8.2</small><font papago-translate="splitted"><font papago-translate="translated"> 글로벌 변수</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/statements-and-state.html#environments"><small>8.3</small><font papago-translate="splitted"><font papago-translate="translated"> 환경</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/statements-and-state.html#assignment"><small>8.4</small><font papago-translate="splitted"><font papago-translate="translated"> 과제</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/statements-and-state.html#scope"><small>8.5</small><font papago-translate="splitted"><font papago-translate="translated"> 범위</font></font></a></li>
<li class="divider"></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/statements-and-state.html#challenges">Challenges</a></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/statements-and-state.html#design-note"><small>note</small><font papago-translate="splitted"><font papago-translate="translated">암묵적 변수 선언</font></font></a></li>
</ul>
<div class="prev-next">
<a class="left" href="https://youhogeon-meritz.github.io/evaluating-expressions.html" title="Evaluating Expressions">←&nbsp;Previous</a>
<a href="https://youhogeon-meritz.github.io/a-tree-walk-interpreter.html" title="A Tree-Walk Interpreter">↑&nbsp;Up</a>
<a class="right" href="https://youhogeon-meritz.github.io/control-flow.html" title="Control Flow">Next&nbsp;→</a>
</div> </div>
<a id="expand-nav">≡</a>
</nav>
</div>
<article class="chapter">
<div class="number">8</div>
<h1><font papago-translate="translated" class="">진술 및 진술</font></h1>
<blockquote>
<p><font papago-translate="splitted"><font papago-translate="translated">평생 동안 제 마음은 말할 수 없는 것을 갈망해 왔습니다. </font></font><cite>André Breton, <em>Mad Love</em></cite></p>
</blockquote>
<p><font papago-translate="translated">지금까지 우리가 가지고 있는 통역사는 실제 언어를 프로그래밍하는 것보다는 계산기의 펀칭 버튼에 가깝습니다.</font><font papago-translate="translated"> 저에게 "프로그래밍"이란 작은 조각들로 시스템을 구축하는 것을 의미합니다.</font><font papago-translate="translated" class=""> 데이터나 함수에 이름을 바인딩할 방법이 없기 때문에 아직 그렇게 할 수 없습니다.</font><font papago-translate="translated" class=""> 우리는 작품들을 참조할 방법 없이 소프트웨어를 구성할 수 없습니다.</font></p>
<p><font papago-translate="translated" class="">바인딩을 지원하려면 인터프리터의 내부 상태가 필요합니다.</font><font papago-translate="translated" class=""> 프로그램의 시작 부분에서 변수를 정의하고 마지막에 변수를 사용할 때, 통역사는 그 동안 그 변수의 값을 유지해야 합니다.</font><font papago-translate="translated"> 따라서 이 장에서는 통역사에게 단순한 처리뿐만 아니라<em> 기억할</em> 수 있는 두뇌를 제공할 것입니다.</font></p><img alt="A brain, presumably remembering stuff." src="https://youhogeon-meritz.github.io/image/statements-and-state/brain.png">
<p><font papago-translate="translated">진술과<span name="expr"> 진술</span>은 함께 이루어집니다.</font><font papago-translate="translated"> 정의에 따르면, 진술은 가치 있게 평가되지 않기 때문에 유용하기 위해서는 다른 무언가를 해야 합니다.</font><font papago-translate="translated"> 그것을<strong> 부작용</strong>이라고 부릅니다.</font><font papago-translate="translated"> 사용자가 볼 수 있는 출력을 생성하거나 나중에 감지할 수 있는 인터프리터의 일부 상태를 수정하는 것을 의미할 수 있습니다.</font><font papago-translate="translated"> 후자는 변수나 다른 명명된 엔티티를 정의하는 데 매우 적합합니다.</font></p>
<aside name="expr" style="top: 898.5px;">
<p><font papago-translate="splitted"><font papago-translate="translated">변수 선언을 바인딩을 생성하고 값을 생성하는 표현으로 취급하는 언어를 만들 수 있습니다.</font><font papago-translate="translated"> 제가 아는 유일한 언어는 Tcl입니다.</font><font papago-translate="translated"> 계획은 경쟁자처럼 보이지만 다음과 같은 점에 유의하세요 </font></font><code translate="no">let</code><font papago-translate="splitted"><font papago-translate="translated"> 표현식을 평가하면 제한된 변수가 잊혀집니다.</font><font papago-translate="translated"> 그 </font></font><code translate="no">define</code><font papago-translate="splitted"><font papago-translate="translated"> 구문은 표현이 아닙니다.</font></font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">이 장에서는 이 모든 것을 다룰 것입니다.</font><font papago-translate="translated"> 출력을 생성하는 문장을 정의하겠습니다 (</font></font><code translate="no">print</code><font papago-translate="splitted"><font papago-translate="translated">) 및 상태 생성 (</font></font><code translate="no">var</code><font papago-translate="splitted"><font papago-translate="translated">). 변수에 접근하고 할당하기 위해 식을 추가할 것입니다.</font><font papago-translate="translated"> 마지막으로 블록과 로컬 범위를 추가합니다.</font><font papago-translate="translated"> 한 장에 담을 양은 많지만 한 입씩 씹어 먹어보겠습니다.</font></font></p>
<h2><a href="https://youhogeon-meritz.github.io/statements-and-state.html#statements" id="statements"><small><font papago-translate="translated">8 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">진술들</font></font></a></h2>
<p><font papago-translate="translated">우리는 먼저 Lox의 문법을 문장으로 확장하는 것으로 시작합니다.</font><font papago-translate="translated"> 그것들은 표현과 크게 다르지 않습니다.</font><font papago-translate="translated"> 우리는 두 가지 가장 간단한 종류부터 시작합니다:</font></p>
<ol>
<li>
<p><font papago-translate="splitted"><font papago-translate="translated"><strong>표현식 문장</strong>은 문장이 예상되는 곳에 표현식을 배치할 수 있게 해줍니다.</font><font papago-translate="translated"> 그들은 부작용이 있는 표현을 평가하기 위해 존재합니다.</font><font papago-translate="translated"> 눈치채지 못할 수도 있지만 C, Java 및 기타<span name="expr-stmt"></span> 언어에서 항상 사용합니다.</font><font papago-translate="translated"> 함수나 메서드 호출 후에 다음과 같은 것을 볼 때마다 </font></font><code translate="no">;</code><font papago-translate="splitted"><font papago-translate="translated">, 당신은 표현 문을 보고 있습니다.</font></font></p>
<aside name="expr-stmt" style="top: 1378.5px;">
<p><font papago-translate="translated">파스칼은 특이치입니다.</font><font papago-translate="translated"> <em>절차</em>와<em> 기능</em>을 구분합니다.</font><font papago-translate="translated"> 함수는 값을 반환하지만 절차는 반환할 수 없습니다.</font><font papago-translate="translated"> 프로시저를 호출하는 문 형식이 있지만, 함수는 표현식이 예상되는 경우에만 호출할 수 있습니다.</font><font papago-translate="translated"> 파스칼에는 표현 문이 없습니다.</font></p>
</aside></li>
<li>
<p><font papago-translate="translated"><strong>문장</strong>은 표현식<strong>을 평가</strong>하고 그 결과를 사용자에게 표시합니다.</font><font papago-translate="translated"> 인쇄를 라이브러리 기능으로 만드는 대신 언어로 바로 굽는 것이 이상하다는 것을 인정합니다.</font><font papago-translate="translated"> 그렇게 하는 것은 우리가 이 통역사를 한 번에 한 챕터씩 만들고 있으며, 모든 것이 끝나기 전에 그것을 가지고 놀 수 있기를 원한다는 사실에 대한 양보입니다.</font><font papago-translate="translated"> 인쇄물을 라이브러리 기능으로 만들기 위해서<span name="print"></span>는 함수를 정의하고 호출하는 모든 기계가 작동할 때까지 기다려야 부작용을 목격할 수 있습니다.</font></p>
<aside name="print" style="top: 1594.5px;">
<p><font papago-translate="splitted"><font papago-translate="translated">BASIC와 Python이 헌신한 방어력에 대해서는 어느 정도만 언급하겠습니다 </font></font><code translate="no">print</code><font papago-translate="splitted"><font papago-translate="translated"> 진술과 그것들은 실제 언어입니다.</font><font papago-translate="translated"> 물론, 파이썬은 그들을 제거했습니다 </font></font><code translate="no">print</code><font papago-translate="splitted"><font papago-translate="translated"> 3.<span class="ellipse">0</span>의 문장.</font></font></p>
</aside></li>
</ol>
<p><font papago-translate="translated">새로운 구문은 새로운 문법 규칙을 의미합니다.</font><font papago-translate="translated"> 이 장에서는 마침내 전체 Lox 스크립트를 구문 분석할 수 있는 능력을 얻습니다.</font><font papago-translate="translated"> Lox는 명령형 동적으로 입력되는 언어이기 때문에 스크립트의 "상위 레벨"은 단순히 문장 목록일 뿐입니다.</font><font papago-translate="translated"> 새로운 규칙은 다음과 같습니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="i">program</span>        → <span class="i">statement</span>* <span class="t">EOF</span> ;

<span class="i">statement</span>      → <span class="i">exprStmt</span>
               | <span class="i">printStmt</span> ;

<span class="i">exprStmt</span>       → <span class="i">expression</span> <span class="s">";"</span> ;
<span class="i">printStmt</span>      → <span class="s">"print"</span> <span class="i">expression</span> <span class="s">";"</span> ;
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">첫 번째 규칙은 지금입니다 </font></font><code translate="no">program</code><font papago-translate="splitted"><font papago-translate="translated">, 문법의 시작점이며 완전한 Lox 스크립트 또는 REPL 항목을 나타냅니다.</font><font papago-translate="translated"> 프로그램은 특수 "파일 종료" 토큰 뒤에 오는 문 목록입니다.</font><font papago-translate="translated"> 필수 종료 토큰은 파서가 전체 입력을 소비하고 스크립트 끝에 잘못된 미사용 토큰을 조용히 무시하지 않도록 보장합니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">지금 당장. </font></font><code translate="no">statement</code><font papago-translate="splitted"><font papago-translate="translated"> 우리가 설명한 두 종류의 진술에는 두 가지 경우만 있습니다.</font><font papago-translate="translated"> 이 장의 뒷부분과 다음 장에서 더 자세히 설명하겠습니다.</font><font papago-translate="translated"> 다음 단계는 이 문법을 메모리에 저장할 수 있는 구문<span class="em"></span> 트리로 변환하는 것입니다.</font></font></p>
<h3><a href="https://youhogeon-meritz.github.io/statements-and-state.html#statement-syntax-trees" id="statement-syntax-trees"><small><font papago-translate="translated">8 . 1 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">문 구문 트리</font></font></a></h3>
<p><font papago-translate="splitted"><font papago-translate="translated">문법에서 표현과 문장이 모두 허용되는 곳은 없습니다.</font><font papago-translate="translated"> 피연산자들은, 예를 들어, </font></font><code translate="no">+</code><font papago-translate="splitted"><font papago-translate="translated"> 는 항상 표현이지, 결코 진술이 아닙니다.</font><font papago-translate="translated"> 본문 </font></font><code translate="no">while</code><font papago-translate="splitted"><font papago-translate="translated"> 루프는 항상 문장입니다.</font></font></p>
<p><font papago-translate="translated">두 구문이 서로 분리되어 있기 때문에 모두 상속되는 단일 기본 클래스가 필요하지 않습니다.</font><font papago-translate="translated"> 표현식과 문을 별도의 클래스 계층 구조로 분할하면 Java 컴파일러가 표현식을 기대하는 Java 메서드에 문을 전달하는 것과 같은 어리석은 실수를 찾는 데 도움이 됩니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">그것은 진술에 대한 새로운 기본 클래스를 의미합니다.</font><font papago-translate="translated"> 우리 어른들이 이전에 그랬던 것처럼, 우리는 "Stmt"라는 암호명을 사용할 것입니다.</font><font papago-translate="translated"> 저는 이<span name="foresight"></span>를 예상하고 작은 AST 메타프로그래밍 스크립트를 설계했습니다.</font><font papago-translate="translated"> 그래서 우리는 "Expr"을 매개변수로 전달했습니다 </font></font><code translate="no">defineAst()</code><font papago-translate="splitted"><font papago-translate="translated">. 이제 Stmt와 그<span name="stmt-ast"> 하위 클래스</span>를 정의하기 위해 또 다른 호출을 추가합니다.</font></font></p>
<aside name="foresight" style="top: 2454.5px;">
<p><font papago-translate="translated">선견지명은 없습니다: 책을 장으로 나누기 전에 모든 코드를 작성했습니다.</font></p>
</aside>
<div class="codehilite"><pre class="insert-before" translate="no">      "Unary    : Token operator, Expr right"
    ));
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">도구/GenerateAst.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>메인</em> ()에서</font></font></div>
<pre class="insert" translate="no">
    <span class="i">defineAst</span>(<span class="i">outputDir</span>, <span class="s">"Stmt"</span>, <span class="t">Arrays</span>.<span class="i">asList</span>(
      <span class="s">"Expression : Expr expression"</span>,
      <span class="s">"Print      : Expr expression"</span>
    ));
</pre><pre class="insert-after" translate="no">  }
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>main</em>()</div>
<aside name="stmt-ast" style="top: 2502.5px;">
<p><font papago-translate="translated">새 노드에 대한 생성된 코드는<a href="https://youhogeon-meritz.github.io/appendix-ii.html"> 부록 II</a><a href="https://youhogeon-meritz.github.io/appendix-ii.html#expression-statement">: 표현식 문</a><a href="https://youhogeon-meritz.github.io/appendix-ii.html#print-statement">, 인쇄 문</a>에 있습니다.</font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">AST 생성기 스크립트를 실행하고 표현에 필요한 구문 트리 클래스가 포함된 결과 "Stmt.java" 파일을 확인합니다 </font></font><code translate="no">print</code><font papago-translate="splitted"><font papago-translate="translated"> 진술들.</font><font papago-translate="translated"> IDE 프로젝트나 makefile 등에 파일을 추가하는 것을 잊지 마세요.</font></font></p>
<h3><a href="https://youhogeon-meritz.github.io/statements-and-state.html#parsing-statements" id="parsing-statements"><small><font papago-translate="translated">8 . 1 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">구문 분석</font></font></a></h3>
<p><font papago-translate="splitted"><font papago-translate="translated">파서의 </font></font><code translate="no">parse()</code><font papago-translate="splitted"><font papago-translate="translated"> 단일 표현식을 구문 분석하고 반환하는 방법은 마지막 장을 실행하기 위한 임시 해킹이었습니다.</font><font papago-translate="translated"> 이제 문법에 올바른 시작 규칙이 생겼으니, </font></font><code translate="no">program</code><font papago-translate="splitted"><font papago-translate="translated">, 돌릴 수 있습니다 </font></font><code translate="no">parse()</code><font papago-translate="splitted"><font papago-translate="translated"> 실제 거래로.</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 메서드<em> 구문 분석</em> ()</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 7줄 교체</font></font></div>
<pre translate="no">  <span class="t">List</span>&lt;<span class="t">Stmt</span>&gt; <span class="i">parse</span>() {
    <span class="t">List</span>&lt;<span class="t">Stmt</span>&gt; <span class="i">statements</span> = <span class="k">new</span> <span class="t">ArrayList</span>&lt;&gt;();
    <span class="k">while</span> (!<span class="i">isAtEnd</span>()) {
      <span class="i">statements</span>.<span class="i">add</span>(<span class="i">statement</span>());
    }

    <span class="k">return</span> <span class="i">statements</span>;<span name="parse-error-handling"> </span>
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, method <em>parse</em>(), replace 7 lines</div>
<aside name="parse-error-handling" style="top: 3165.5px;">
<p><font papago-translate="splitted"><font papago-translate="translated">여기서 우리가 잡은 코드는 어떻습니까 </font></font><code translate="no">ParseError</code><font papago-translate="splitted"><font papago-translate="translated"> 예외?</font><font papago-translate="translated"> 추가 문 유형에 대한 지원을 추가하면 곧 더 나은 구문 분석 오류 처리가 가능해질 것입니다.</font></font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">이것은 입력이 끝날 때까지 찾을 수 있는 한 많은 일련의 문장을 구문 분석합니다.</font><font papago-translate="translated"> 이것은 꽤 직접적인 번역입니다 </font></font><code translate="no">program</code><font papago-translate="splitted"><font papago-translate="translated"> 재귀적 하강 스타일로 규칙을 만듭니다.</font><font papago-translate="translated"> 우리는 지금 ArrayList를 사용하고 있기 때문에 자바의 장황한 신들께도 작은 기도를 드려야 합니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">package com.craftinginterpreters.lox;

</pre><div class="source-file"><em>lox/Parser.java</em></div>
<pre class="insert" translate="no"><span class="k">import</span> <span class="i">java.util.ArrayList</span>;
</pre><pre class="insert-after" translate="no">import java.util.List;
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em></div>
<p><font papago-translate="translated">프로그램은 진술 목록이며, 이 방법을 사용하여 그 진술 중 하나를 구문 분석합니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 식<em></em> () 뒤에 추가</font></font></div>
<pre translate="no">  <span class="k">private</span> <span class="t">Stmt</span> <span class="i">statement</span>() {
    <span class="k">if</span> (<span class="i">match</span>(<span class="i">PRINT</span>)) <span class="k">return</span> <span class="i">printStatement</span>();

    <span class="k">return</span> <span class="i">expressionStatement</span>();
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>expression</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">약간의 맨손이지만 나중에 더 많은 문장 유형으로 채워 넣겠습니다.</font><font papago-translate="translated"> 현재 토큰을 보고 일치하는 특정 문 규칙을 결정합니다. A </font></font><code translate="no">print</code><font papago-translate="splitted"><font papago-translate="translated"> 토큰은 분명히 </font></font><code translate="no">print</code><font papago-translate="splitted"><font papago-translate="translated"> 진술.</font></font></p>
<p><font papago-translate="translated">다음 토큰이 알려진 어떤 종류의 문장처럼 보이지 않는다면, 우리는 그것이 표현 문장이어야 한다고 가정합니다.</font><font papago-translate="translated"> 첫 번째 토큰에서 표현식을 사전에 인식하기 어렵기 때문에 문장을 구문 분석할 때 일반적인 최종 오류 사례입니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">각 진술 유형마다 고유한 방법이 있습니다.</font><font papago-translate="translated"> 첫번째 </font></font><code translate="no">print</code><font papago-translate="splitted"><font papago-translate="translated">:</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>문</em> 뒤에 () 추가</font></font></div>
<pre translate="no">  <span class="k">private</span> <span class="t">Stmt</span> <span class="i">printStatement</span>() {
    <span class="t">Expr</span> <span class="i">value</span> = <span class="i">expression</span>();
    <span class="i">consume</span>(<span class="i">SEMICOLON</span>, <span class="s">"Expect ';' after value."</span>);
    <span class="k">return</span> <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">Print</span>(<span class="i">value</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>statement</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">이미 매칭하고 소비했기 때문에 </font></font><code translate="no">print</code><font papago-translate="splitted"><font papago-translate="translated"> 토큰 자체는 여기서 그렇게 할 필요가 없습니다.</font><font papago-translate="translated"> 다음 표현식을 구문 분석하고 종료 세미콜론을 소비한 다음 구문 트리를 방출합니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">일치하지 않는 경우 </font></font><code translate="no">print</code><font papago-translate="splitted"><font papago-translate="translated"> 다음 중 하나가 있어야 합니다:</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>print</em>St<em>atement</em>() 후에 추가</font></font></div>
<pre translate="no">  <span class="k">private</span> <span class="t">Stmt</span> <span class="i">expressionStatement</span>() {
    <span class="t">Expr</span> <span class="i">expr</span> = <span class="i">expression</span>();
    <span class="i">consume</span>(<span class="i">SEMICOLON</span>, <span class="s">"Expect ';' after expression."</span>);
    <span class="k">return</span> <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">Expression</span>(<span class="i">expr</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>printStatement</em>()</div>
<p><font papago-translate="translated">이전 방법과 유사하게, 우리는 표현식 뒤에 세미콜론을 구문 분석합니다.</font><font papago-translate="translated"> 우리는 Expr을 올바른 유형의 Stmt에 포장하여 반환합니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/statements-and-state.html#executing-statements" id="executing-statements"><small><font papago-translate="translated">8 . 1 . 3</font></small><font papago-translate="splitted"><font papago-translate="translated">진술 실행</font></font></a></h3>
<p><font papago-translate="translated">우리는 마이크로코즘의 이전 몇 장의 장들을 살펴보고 있으며, 앞으로 나아가기 위해 노력하고 있습니다.</font><font papago-translate="translated"> 이제 파서는 문 구문 트리를 생성할 수 있으므로 다음이자 마지막 단계는 구문 트리를 해석하는 것입니다.</font><font papago-translate="translated"> 표현식에서와 같이 방문자 패턴을 사용하지만, 새로운 방문자 인터페이스인 Stmt가 있습니다.</font><font papago-translate="translated">방문자, 문에 고유한 기본 클래스가 있으므로 구현합니다.</font></p>
<p><font papago-translate="translated">인터프리터 구현 인터페이스 목록에 이를 추가합니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Interpreter.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no"><span class="k">class</span> <span class="t">Interpreter</span> <span class="k">implements</span> <span class="t">Expr</span>.<span class="t">Visitor</span>&lt;<span class="t">Object</span>&gt;,
                             <span class="t">Stmt</span>.<span class="t">Visitor</span>&lt;<span class="t">Void</span>&gt; {
</pre><pre class="insert-after" translate="no">  void interpret(Expr expression) {<span name="void"> </span>
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, replace 1 line</div>
<aside name="void" style="top: 4681.5px;">
<p><font papago-translate="translated">Java는 타입 삭제 및 스택과 관련된 모호한 이유로 소문자 "void"를 일반적인 타입 인수로 사용할 수 없도록 합니다.</font><font papago-translate="translated"> 대신, 이 용도를 위해 특별히 별도의 "Void" 유형이 있습니다.</font><font papago-translate="translated"> 일종의 "상자형 공허", 예를 들어 "정수"는 "int"를 의미합니다.</font></p>
</aside>
<p><font papago-translate="translated">표현과 달리, 문장은 값을 생성하지 않으므로 방문 방법의 반환 유형은 객체가 아닌 공허입니다.</font><font papago-translate="translated"> 저희는 두 가지 진술 유형이 있으며, 각각에 대한 방문 방법이 필요합니다.</font><font papago-translate="translated"> 가장 쉬운 것은 표현 문입니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Interpreter.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> ()<em>을 평가</em>한 후 추가</font></font></div>
<pre translate="no">  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitExpressionStmt</span>(<span class="t">Stmt</span>.<span class="t">Expression</span> <span class="i">stmt</span>) {
    <span class="i">evaluate</span>(<span class="i">stmt</span>.<span class="i">expression</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>evaluate</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">우리는 기존 표현을 사용하여 내부 표현을 평가합니다 </font></font><code translate="no">evaluate()</code><font papago-translate="splitted"><font papago-translate="translated"> 방법을 사용하고 값<span name="discard">을 버립니다</span>.</font><font papago-translate="translated"> 그리고 우리는 돌아옵니다 </font></font><code translate="no">null</code><font papago-translate="splitted"><font papago-translate="translated">. Java는 특수 대문자 보이드 반환 유형을 만족시키기 위해 이를 요구합니다.</font><font papago-translate="translated"> 이상하지만, 어떻게 할 수 있나요?</font></font></p>
<aside name="discard" style="top: 4970.5px;">
<p><font papago-translate="splitted"><font papago-translate="translated">적절하게, 우리는 반환된 값을 버립니다 </font></font><code translate="no">evaluate()</code><font papago-translate="splitted"><font papago-translate="translated"> Java 표현<em></em> 문 안에 그 호출을 넣음으로써.</font></font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">그 </font></font><code translate="no">print</code><font papago-translate="splitted"><font papago-translate="translated"> 성명서의 방문 방법도 크게 다르지 않습니다.</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Interpreter.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>방문</em> 후 추가Ex<em>pressionStmt</em>()</font></font></div>
<pre translate="no">  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitPrintStmt</span>(<span class="t">Stmt</span>.<span class="t">Print</span> <span class="i">stmt</span>) {
    <span class="t">Object</span> <span class="i">value</span> = <span class="i">evaluate</span>(<span class="i">stmt</span>.<span class="i">expression</span>);
    <span class="t">System</span>.<span class="i">out</span>.<span class="i">println</span>(<span class="i">stringify</span>(<span class="i">value</span>));
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>visitExpressionStmt</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">식의 값을 버리기 전에 다음을 사용하여 문자열로 변환합니다 </font></font><code translate="no">stringify()</code><font papago-translate="splitted"><font papago-translate="translated"> 지난 장에서 소개한 방법을 stdout에 덤프합니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">통역사가 이제 명세서를 방문할 수 있지만, 이를 전달하기 위해 해야 할 일이 몇 가지 있습니다.</font><font papago-translate="translated"> 먼저, 이전 것을 수정합니다 </font></font><code translate="no">interpret()</code><font papago-translate="splitted"><font papago-translate="translated"> 인터프리터 클래스에서 문 목록, 즉<span class="em"></span> 프로그램을 수락하는 방법.</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Interpreter.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 메서드<em> 해석</em> ()</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 8줄 교체</font></font></div>
<pre translate="no">  <span class="t">void</span> <span class="i">interpret</span>(<span class="t">List</span>&lt;<span class="t">Stmt</span>&gt; <span class="i">statements</span>) {
    <span class="k">try</span> {
      <span class="k">for</span> (<span class="t">Stmt</span> <span class="i">statement</span> : <span class="i">statements</span>) {
        <span class="i">execute</span>(<span class="i">statement</span>);
      }
    } <span class="k">catch</span> (<span class="t">RuntimeError</span> <span class="i">error</span>) {
      <span class="t">Lox</span>.<span class="i">runtimeError</span>(<span class="i">error</span>);
    }
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, method <em>interpret</em>(), replace 8 lines</div>
<p><font papago-translate="translated">이것은 단일 표현식을 사용했던 기존 코드를 대체합니다.</font><font papago-translate="translated"> 새로운 코드는 이 작은 도우미 방법에 의존합니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Interpreter.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> ()<em>을 평가</em>한 후 추가</font></font></div>
<pre translate="no">  <span class="k">private</span> <span class="t">void</span> <span class="i">execute</span>(<span class="t">Stmt</span> <span class="i">stmt</span>) {
    <span class="i">stmt</span>.<span class="i">accept</span>(<span class="k">this</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>evaluate</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">그것은 다음과 같은 진술 유사체입니다 </font></font><code translate="no">evaluate()</code><font papago-translate="splitted"><font papago-translate="translated"> 우리가 가진 표현 방법.</font><font papago-translate="translated"> 지금 목록 작업 중이므로 Java에 알려야 합니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">package com.craftinginterpreters.lox;
</pre><div class="source-file"><em>lox/Interpreter.java</em></div>
<pre class="insert" translate="no">
<span class="k">import</span> <span class="i">java.util.List</span>;
</pre><pre class="insert-after" translate="no">
class Interpreter implements Expr.Visitor&lt;Object&gt;,
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em></div>
<p><font papago-translate="translated">메인 Lox 클래스는 여전히 단일 표현식을 구문 분석하여 인터프리터에게 전달하려고 합니다.</font><font papago-translate="translated"> 파싱 라인을 이렇게 고정합니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    Parser parser = new Parser(tokens);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Lox.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">    <span class="t">List</span>&lt;<span class="t">Stmt</span>&gt; <span class="i">statements</span> = <span class="i">parser</span>.<span class="i">parse</span>();
</pre><pre class="insert-after" translate="no">
    // Stop if there was a syntax error.
</pre></div>
<div class="source-file-narrow"><em>lox/Lox.java</em>, in <em>run</em>(), replace 1 line</div>
<p><font papago-translate="translated">그리고 나서 통역사와의 통화를 다음과 같이 대체합니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    if (hadError) return;

</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Lox.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">    <span class="i">interpreter</span>.<span class="i">interpret</span>(<span class="i">statements</span>);
</pre><pre class="insert-after" translate="no">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Lox.java</em>, in <em>run</em>(), replace 1 line</div>
<p><font papago-translate="translated">기본적으로 새로운 구문을 주입하는 것뿐입니다.</font><font papago-translate="translated"> 알겠습니다, 통역사를 불러와서 한 번 시도해 보세요.</font><font papago-translate="translated"> 이 시점에서 스크립트로 실행하기 위해 텍스트 파일에 작은 Lox 프로그램을 스케치할 가치가 있습니다.</font><font papago-translate="translated"> 비슷한 것:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">print</span> <span class="s">"one"</span>;
<span class="k">print</span> <span class="k">true</span>;
<span class="k">print</span> <span class="n">2</span> + <span class="n">1</span>;
</pre></div>
<p><font papago-translate="translated">거의 실제 프로그램처럼 보입니다!</font><font papago-translate="translated"> 이제 REPL에서도 간단한 표현 대신 전체 문장을 입력해야 합니다.</font><font papago-translate="translated"> 세미콜론을 잊지 마세요.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/statements-and-state.html#global-variables" id="global-variables"><small><font papago-translate="translated">8 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">글로벌 변수</font></font></a></h2>
<p><font papago-translate="translated">이제 진술이 나왔으니 상태 작업을 시작할 수 있습니다.</font><font papago-translate="translated"> 어휘 범위의 모든 복잡성에 들어가기 전에, 가장 쉬운 종류의 변수<span name="globals">인</span><span class="em"></span><span name="globals"> 전역</span> 변수부터 시작하겠습니다.</font><font papago-translate="translated"> 우리는 두 개의 새로운 구조물이 필요합니다.</font></p>
<ol>
<li>
<p><font papago-translate="translated"><strong>변수 선언</strong>문은 새로운 변수를 세상에 가져옵니다.</font></p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="i">beverage</span> = <span class="s">"espresso"</span>;
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">이렇게 하면 이름(여기서 "음료수")과 값(여기서 문자열)을 연결하는 새로운 바인딩이 생성됩니다 </font></font><code translate="no">"espresso"</code><font papago-translate="splitted"><font papago-translate="translated">).</font></font></p>
</li>
<li>
<p><font papago-translate="translated">이 작업이 완료되면<strong> 변수 표현식</strong>이 해당 바인딩에 접근합니다.</font><font papago-translate="translated"> "음료"라는 식별자가 표현으로 사용될 때, 그 이름에 묶인 값을 찾아서 반환합니다.</font></p>
<div class="codehilite"><pre translate="no"><span class="k">print</span> <span class="i">beverage</span>; <span class="c">// "espresso".</span>
</pre></div>
</li>
</ol>
<p><font papago-translate="translated">나중에 과제와 블록 범위를 추가하겠지만, 이 정도면 충분합니다.</font></p>
<aside name="globals" style="top: 6706.5px;">
<p><font papago-translate="translated">글로벌 국가는 나쁜 평가를 받습니다.</font><font papago-translate="translated"> 물론, 많은 글로벌 국가들, 특히<em> 변이</em> 가능한 국가들은 대규모<span class="em"></span><span class="em"></span> 프로그램을 유지하기 어렵게 만듭니다.</font><font papago-translate="translated"> 사용하는 양을 최소화하는 것은 좋은 소프트웨어 엔지니어링입니다.</font></p>
<p><font papago-translate="translated">하지만 간단한 프로그래밍 언어를 함께 사용하거나 모국어를 배울 때는 글로벌 변수의 단순함이 도움이 됩니다.</font><font papago-translate="translated"> 제 모국어는 베이직이었고, 결국에는 더 발전했지만 컴퓨터가 재미있는 일을 하기 전에 범위 지정 규칙에 얽매이지 않아도 된다는 점이 좋았습니다.</font></p>
</aside>
<h3><a href="https://youhogeon-meritz.github.io/statements-and-state.html#variable-syntax" id="variable-syntax"><small><font papago-translate="translated">8 . 2 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">변수 구문</font></font></a></h3>
<p><font papago-translate="translated">이전과 마찬가지로 구문부터 시작하여 앞에서 뒤로 구현하는 과정을 살펴보겠습니다.</font><font papago-translate="translated"> 변수 선언은 진술이지만 다른 진술과는 다르며, 이를 처리하기 위해 진술 문법을 두 부분으로 나누겠습니다.</font><font papago-translate="translated"> 그것은 문법이 어떤 종류의 진술이 허용되는 곳을 제한하기 때문입니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">제어 흐름 문의 절—당시<span class="em"></span>와 다른 분기를 생각해 보세요 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 문장 또는 본문 </font></font><code translate="no">while</code><font papago-translate="splitted"><font papago-translate="translated"><span class="em">-</span>각각 하나의 문장입니다<span class="em">.</span></font><font papago-translate="translated"> 하지만 그 진술은 이름을 선언하는 것이 허용되지 않습니다.</font><font papago-translate="translated"> 괜찮습니다:</font></font></p>
<div class="codehilite"><pre translate="no"><span class="k">if</span> (<span class="i">monday</span>) <span class="k">print</span> <span class="s">"Ugh, already?"</span>;
</pre></div>
<p><font papago-translate="translated">하지만 이것은 아닙니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">if</span> (<span class="i">monday</span>) <span class="k">var</span> <span class="i">beverage</span> = <span class="s">"espresso"</span>;
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">후자를 허용<em>할 수는 있지만</em> 혼란스럽습니다.</font><font papago-translate="translated"> 그 범위는 무엇입니까 </font></font><code translate="no">beverage</code><font papago-translate="splitted"><font papago-translate="translated"> 변수?</font><font papago-translate="translated"> 그 후에도 지속되나요 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 진술?</font><font papago-translate="translated"> 그렇다면 월요일을 제외한 다른 날의 가치는 무엇인가요?</font><font papago-translate="translated"> 그 날들에 변수가 전혀 존재하지 않나요?</font></font></p>
<p><font papago-translate="translated">이와 같은 코드는 이상해서 C, Java, 그리고 친구들 모두가 이를 허용하지 않습니다.</font><font papago-translate="translated"> 마치 진술에 두 가지 수준<span name="brace">의 "우선순위"</span>가 있는 것 같습니다.</font><font papago-translate="translated"> 블록 내부나 최상위 수준과 같이 진술이 허용되는 일부 장소에서는<span class="em"></span><span class="em"></span> 선언을 포함한 모든 종류의 진술이 허용됩니다.</font><font papago-translate="translated"> 다른 것들은 이름을 선언하지 않는 "상위" 우선 문장만 허용합니다.</font></p>
<aside name="brace" style="top: 7698.5px;">
<p><font papago-translate="splitted"><font papago-translate="translated">이 비유에서 블록 명제는 표현식에 괄호가 작용하는 것과 비슷합니다.</font><font papago-translate="translated"> 블록은 그 자체로 "더 높은" 우선순위 수준에 있으며, 다음과 같은 절에서와 같이 어디서나 사용할 수 있습니다 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 진술.</font><font papago-translate="translated"> 하지만<em> 포함된</em> 진술은 낮은 우선순위일 수 있습니다.</font><font papago-translate="translated"> 블록 내에서 변수 및 기타 이름을 선언할 수 있습니다.</font><font papago-translate="translated"> 커리는 일부 문장만 허용되는 곳에서 전체 문장 문법으로 돌아갈 수 있게 해줍니다.</font></font></p>
</aside>
<p><font papago-translate="translated">이러한 구분을 수용하기 위해 이름을 선언하는 진술의 종류에 대한 또 다른 규칙을 추가합니다.</font></p>
<div class="codehilite"><pre translate="no"><span class="i">program</span>        → <span class="i">declaration</span>* <span class="t">EOF</span> ;

<span class="i">declaration</span>    → <span class="i">varDecl</span>
               | <span class="i">statement</span> ;

<span class="i">statement</span>      → <span class="i">exprStmt</span>
               | <span class="i">printStmt</span> ;
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">선언문은 다음과 같습니다 </font></font><code translate="no">declaration</code><font papago-translate="splitted"><font papago-translate="translated"> 규칙. 지금은 변수만 있지만 나중에는 함수와 클래스가 포함될 것입니다.</font><font papago-translate="translated"> 선언이 허용되는 모든 장소는 선언하지 않는 진술도 허용하므로 </font></font><code translate="no">declaration</code><font papago-translate="splitted"><font papago-translate="translated"> 규칙은 다음과 같습니다 </font></font><code translate="no">statement</code><font papago-translate="splitted"><font papago-translate="translated">. 물론 스크립트의 최상위 단계에서 무언가를 선언할 수 있으므로 </font></font><code translate="no">program</code><font papago-translate="splitted"><font papago-translate="translated"> 새 규칙으로 가는 경로.</font></font></p>
<p><font papago-translate="translated">변수를 선언하는 규칙은 다음과 같습니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="i">varDecl</span>        → <span class="s">"var"</span> <span class="t">IDENTIFIER</span> ( <span class="s">"="</span> <span class="i">expression</span> )? <span class="s">";"</span> ;
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">대부분의 진술과 마찬가지로, 주요 키워드로 시작합니다.</font><font papago-translate="translated"> 이 경우, </font></font><code translate="no">var</code><font papago-translate="splitted"><font papago-translate="translated">. 그런 다음 선언할 변수 이름에 대한 식별자 토큰과 선택적인 초기화 표현식이 이어집니다.</font><font papago-translate="translated"> 마지막으로 세미콜론으로 활을 놓습니다.</font></font></p>
<p><font papago-translate="translated">변수에 접근하기 위해 우리는 새로운 종류의 기본 표현식을 정의합니다.</font></p>
<div class="codehilite"><pre translate="no"><span class="i">primary</span>        → <span class="s">"true"</span> | <span class="s">"false"</span> | <span class="s">"nil"</span>
               | <span class="t">NUMBER</span> | <span class="t">STRING</span>
               | <span class="s">"("</span> <span class="i">expression</span> <span class="s">")"</span>
               | <span class="t">IDENTIFIER</span> ;
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">그거 </font></font><code translate="no">IDENTIFIER</code><font papago-translate="splitted"><font papago-translate="translated"> 절은 접근 중인 변수의 이름으로 이해되는 단일 식별자 토큰과 일치합니다.</font></font></p>
<p><font papago-translate="translated">이 새로운 문법 규칙들은 해당 구문 트리를 얻습니다.</font><font papago-translate="translated"> AST 생성기에서 변수 선언을 위한<span name="var-stmt-ast"> 새로운 문</span> 노드를 추가합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      "Expression : Expr expression",
</pre><pre class="insert-before" translate="no">      <span class="s">"Print      : Expr expression"</span><span class="insert-comma">,</span>
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">도구/GenerateAst.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>메인</em> ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 이전 줄에<em> ","</em>를 추가합니다</font></font></div>
<pre class="insert" translate="no">      <span class="s">"Var        : Token name, Expr initializer"</span>
</pre><pre class="insert-after" translate="no">    ));
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>main</em>(), add <em>“,”</em> to previous line</div>
<aside name="var-stmt-ast" style="top: 8634.5px;">
<p><font papago-translate="translated">새 노드에 대한 생성된 코드는 부록<a href="https://youhogeon-meritz.github.io/appendix-ii.html#variable-statement"> II</a>에 있습니다.</font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">이름 토큰을 저장하여 초기화 표현식과 함께 선언하는 내용을 알 수 있습니다. (초기화가 없는 경우 해당 필드는 </font></font><code translate="no">null</code><font papago-translate="splitted"><font papago-translate="translated">.)</font></font></p>
<p><font papago-translate="translated">그런 다음 변수에 접근하기 위한 표현 노드를 추가합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      "Literal  : Object value",
</pre><pre class="insert-before" translate="no">      <span class="s">"Unary    : Token operator, Expr right"</span><span class="insert-comma">,</span>
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">도구/GenerateAst.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>메인</em> ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 이전 줄에<em> ","</em>를 추가합니다</font></font></div>
<pre class="insert" translate="no">      <span class="s">"Variable : Token name"</span>
</pre><pre class="insert-after" translate="no">    ));
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>main</em>(), add <em>“,”</em> to previous line</div>
<p><font papago-translate="translated">그것<span name="var-expr-ast">은</span> 단순히 변수 이름에 대한 토큰 주위의 포장지일 뿐<span name="var-expr-ast">입니다.</span></font><font papago-translate="translated"> 그게 다입니다.</font><font papago-translate="translated"> 항상 그렇듯이 AST 생성기 스크립트를 실행하여 "Expr.java" 및 "Stmt.java" 파일을 업데이트하는 것을 잊지 마세요.</font></p>
<aside name="var-expr-ast" style="top: 9010.5px;">
<p><font papago-translate="translated">새 노드에 대한 생성된 코드는 부록<a href="https://youhogeon-meritz.github.io/appendix-ii.html#variable-expression"> II</a>에 있습니다.</font></p>
</aside>
<h3><a href="https://youhogeon-meritz.github.io/statements-and-state.html#parsing-variables" id="parsing-variables"><small><font papago-translate="translated">8 . 2 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">변수 구문 분석</font></font></a></h3>
<p><font papago-translate="splitted"><font papago-translate="translated">변수 문을 구문 분석하기 전에 새로운 문을 위한 공간을 확보하기 위해 코드를 전환해야 합니다 </font></font><code translate="no">declaration</code><font papago-translate="splitted"><font papago-translate="translated"> 문법에 따라 규칙을 정합니다.</font><font papago-translate="translated"> 프로그램의 최상위 레벨이 이제 선언 목록이 되었으므로 파서의 진입 방법이 변경됩니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  List&lt;Stmt&gt; parse() {
    List&lt;Stmt&gt; statements = new ArrayList&lt;&gt;();
    while (!isAtEnd()) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>파싱</em> ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">      <span class="i">statements</span>.<span class="i">add</span>(<span class="i">declaration</span>());
</pre><pre class="insert-after" translate="no">    }

    return statements;<span name="parse-error-handling"> </span>
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>parse</em>(), replace 1 line</div>
<p><font papago-translate="translated">이를 새로운 방법이라고 합니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 식<em></em> () 뒤에 추가</font></font></div>
<pre translate="no">  <span class="k">private</span> <span class="t">Stmt</span> <span class="i">declaration</span>() {
    <span class="k">try</span> {
      <span class="k">if</span> (<span class="i">match</span>(<span class="i">VAR</span>)) <span class="k">return</span> <span class="i">varDeclaration</span>();

      <span class="k">return</span> <span class="i">statement</span>();
    } <span class="k">catch</span> (<span class="t">ParseError</span> <span class="i">error</span>) {
      <span class="i">synchronize</span>();
      <span class="k">return</span> <span class="k">null</span>;
    }
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>expression</em>()</div>
<p><font papago-translate="translated">안녕하세요, 그<a href="https://youhogeon-meritz.github.io/parsing-expressions.html"> 이전 장에서</a> 오류 복구를 위해 인프라를 구축했을 때를 기억하시나요?</font><font papago-translate="translated"> 드디어 연결할 준비가 되었습니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">이것. </font></font><code translate="no">declaration()</code><font papago-translate="splitted"><font papago-translate="translated"> 메서드는 블록이나 스크립트에서 일련의 문을 구문 분석할 때 반복적으로 호출하는 메서드이므로 파서가 패닉 모드에 들어갈 때 동기화하기에 적합한 위치입니다.</font><font papago-translate="translated"> 이 방법의 전체는 파서가 오류 복구를 시작할 때 발생하는 예외를 잡기 위해 시도 블록으로 둘러싸여 있습니다.</font><font papago-translate="translated"> 이렇게 하면 다음 문장이나 선언의 시작 부분을 다시 분석하려고 합니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">실제 구문 분석은 시도 블록 내부에서 이루어집니다.</font><font papago-translate="translated"> 먼저, 선도자를 찾아서 변수 선언에 도달했는지 확인합니다 </font></font><code translate="no">var</code><font papago-translate="splitted"><font papago-translate="translated"> 키워드.</font><font papago-translate="translated"> 그렇지 않으면 기존 항목으로 넘어갑니다 </font></font><code translate="no">statement()</code><font papago-translate="splitted"><font papago-translate="translated"> 구문 분석 방법 </font></font><code translate="no">print</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고 표현 문.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">어떻게 기억하세요 </font></font><code translate="no">statement()</code><font papago-translate="splitted"><font papago-translate="translated"> 다른 문장이 일치하지 않으면 표현식 문장을 구문 분석하려고 하나요?</font><font papago-translate="translated"> 그리고. </font></font><code translate="no">expression()</code><font papago-translate="splitted"><font papago-translate="translated"> 현재 토큰에서 표현식을 구문 분석할 수 없는 경우 구문 오류를 보고합니까?</font><font papago-translate="translated"> 그 일련의 통화는 유효한 선언이나 진술이 해석되지 않을 경우 오류를 보고하도록 보장합니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">파서가 일치할 때 </font></font><code translate="no">var</code><font papago-translate="splitted"><font papago-translate="translated"> 토큰, 분기 대상:</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>print</em>St<em>atement</em>() 후에 추가</font></font></div>
<pre translate="no">  <span class="k">private</span> <span class="t">Stmt</span> <span class="i">varDeclaration</span>() {
    <span class="t">Token</span> <span class="i">name</span> = <span class="i">consume</span>(<span class="i">IDENTIFIER</span>, <span class="s">"Expect variable name."</span>);

    <span class="t">Expr</span> <span class="i">initializer</span> = <span class="k">null</span>;
    <span class="k">if</span> (<span class="i">match</span>(<span class="i">EQUAL</span>)) {
      <span class="i">initializer</span> = <span class="i">expression</span>();
    }

    <span class="i">consume</span>(<span class="i">SEMICOLON</span>, <span class="s">"Expect ';' after variable declaration."</span>);
    <span class="k">return</span> <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">Var</span>(<span class="i">name</span>, <span class="i">initializer</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>printStatement</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">항상 그렇듯이, 재귀적 하강 코드는 문법 규칙을 따릅니다.</font><font papago-translate="translated"> 파서는 이미 다음과 일치합니다 </font></font><code translate="no">var</code><font papago-translate="splitted"><font papago-translate="translated"> 토큰, 따라서 다음으로 변수 이름에 대한 식별자 토큰이 필요하고 소비됩니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">그러면, 만약 그것이 본다면 </font></font><code translate="no">=</code><font papago-translate="splitted"><font papago-translate="translated"> 토큰은 이니셜라이저 표현식이 있다는 것을 알고 이를 구문 분석합니다.</font><font papago-translate="translated"> 그렇지 않으면 초기화자를 남깁니다 </font></font><code translate="no">null</code><font papago-translate="splitted"><font papago-translate="translated">. 마지막으로, 문 끝에 필요한 세미콜론을 소비합니다.</font><font papago-translate="translated"> 이 모든 것이 성역으로 포장됩니다.</font><font papago-translate="translated">var 구문 트리 노드와 우리는 그루비합니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">변수 표현식을 구문 분석하는 것은 훨씬 더 쉽습니다 </font></font><code translate="no">primary()</code><font papago-translate="splitted"><font papago-translate="translated">, 식별자 토큰을 찾습니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      return new Expr.Literal(previous().literal);
    }
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>일차</em> ()에서</font></font></div>
<pre class="insert" translate="no">
    <span class="k">if</span> (<span class="i">match</span>(<span class="i">IDENTIFIER</span>)) {
      <span class="k">return</span> <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Variable</span>(<span class="i">previous</span>());
    }
</pre><pre class="insert-after" translate="no">
    if (match(LEFT_PAREN)) {
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>primary</em>()</div>
<p><font papago-translate="translated">이를 통해 변수를 선언하고 사용할 수 있는 프론트엔드를 확보할 수 있습니다.</font><font papago-translate="translated"> 남은 것은 그것을 통역사에게 전달하는 것뿐입니다.</font><font papago-translate="translated"> 그 전에 변수가 기억 속에서 어디에 존재하는지에 대해 이야기해야 합니다.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/statements-and-state.html#environments" id="environments"><small><font papago-translate="translated">8 . 3</font></small><font papago-translate="splitted"><font papago-translate="translated">환경</font></font></a></h2>
<p><font papago-translate="translated">변수를 값과 연결하는 바인딩은 어딘가에 저장해야 합니다.</font><font papago-translate="translated"> 리스프 사람들이 괄호를 발명한 이후로, 이 데이터 구조는<span name="env"><strong> 환경</strong></span>이라고 불립니다.</font></p><img alt="An environment containing two bindings." src="https://youhogeon-meritz.github.io/image/statements-and-state/environment.png">
<aside name="env" style="top: 11214.5px;">
<p><font papago-translate="translated">저는 환경을 말 그대로 변수와 가치가 흔들리는 실반 원더랜드로 상상하는 것을 좋아합니다.</font></p>
</aside>
<p><font papago-translate="translated">키가 변수 이름이고 값이 변수의 값인<span name="map"> 지도</span>처럼 생각할 수 있습니다.</font><font papago-translate="translated"> 사실, 우리는 그것을 자바에서 그렇게 구현할 것입니다.</font><font papago-translate="translated"> 해당 맵과 코드를 인터프리터에 입력하여 관리할 수 있지만, 잘 정의된 개념을 형성하기 때문에 자체 클래스로 가져올 것입니다.</font></p>
<p><font papago-translate="translated">새 파일을 시작하고 추가합니다:</font></p>
<aside name="map" style="top: 11413.5px;">
<p><font papago-translate="translated">자바에서는<strong> 이</strong>를<strong> 맵</strong> 또는<strong> 해시맵</strong>이라고 부릅니다.</font><font papago-translate="translated"> 다른 언어에서는<strong> 해시 테이블</strong><strong>, 사전</strong>(Python 및 C#),<strong> 해시</strong>(Ruby 및 Perl),<strong> 테이블</strong>(Lua) 또는<strong> 연관 배열</strong>(<strong>AP</strong>H)이라고 부릅니다.</font><font papago-translate="translated"> 아주 오래 전에는<strong> 산포도 테이블</strong>로 알려져 있었습니다.</font></p>
</aside>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Environment.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 새 파일 만들기</font></font></div>
<pre translate="no"><span class="k">package</span> <span class="i">com.craftinginterpreters.lox</span>;

<span class="k">import</span> <span class="i">java.util.HashMap</span>;
<span class="k">import</span> <span class="i">java.util.Map</span>;

<span class="k">class</span> <span class="t">Environment</span> {
  <span class="k">private</span> <span class="k">final</span> <span class="t">Map</span>&lt;<span class="t">String</span>, <span class="t">Object</span>&gt; <span class="i">values</span> = <span class="k">new</span> <span class="t">HashMap</span>&lt;&gt;();
}
</pre></div>
<div class="source-file-narrow"><em>lox/Environment.java</em>, create new file</div>
<p><font papago-translate="translated">바인딩을 저장할 수 있는 Java 지도가 있습니다.</font><font papago-translate="translated"> 키에는 토큰이 아닌 베어 스트링을 사용합니다.</font><font papago-translate="translated"> 토큰은 소스 텍스트의 특정 위치에 있는 코드 단위를 나타내지만, 변수를 찾을 때는 동일한 이름을 가진 모든 식별자 토큰이 동일한 변수를 참조해야 합니다(현재로서는 범위 무시).</font><font papago-translate="translated"> 원시 문자열을 사용하면 모든 토큰이 동일한 맵 키를 참조할 수 있습니다.</font></p>
<p><font papago-translate="translated">지원해야 할 두 가지 작업이 있습니다.</font><font papago-translate="translated"> 먼저, 변수 정의는 새로운 이름을 값에 바인딩합니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Environment.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em></em>수업 환경에서</font></font></div>
<pre translate="no">  <span class="t">void</span> <span class="i">define</span>(<span class="t">String</span> <span class="i">name</span>, <span class="t">Object</span> <span class="i">value</span>) {
    <span class="i">values</span>.<span class="i">put</span>(<span class="i">name</span>, <span class="i">value</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Environment.java</em>, in class <em>Environment</em></div>
<p><font papago-translate="translated">정확히 뇌 수술은 아니지만, 우리는 흥미로운 의미론적 선택을 하나 했습니다.</font><font papago-translate="translated"> 우리가 지도에 키를 추가할 때, 그것이 이미 있는지 확인하지 않습니다.</font><font papago-translate="translated"> 즉, 이 프로그램이 작동한다는 뜻입니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="i">a</span> = <span class="s">"before"</span>;
<span class="k">print</span> <span class="i">a</span>; <span class="c">// "before".</span>
<span class="k">var</span> <span class="i">a</span> = <span class="s">"after"</span>;
<span class="k">print</span> <span class="i">a</span>; <span class="c">// "after".</span>
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">변수 문장은<em> 단순히 새로운</em> 변수를 정의하는 것뿐만 아니라 기존 변수<em>를 재정의</em>하는 데에도 사용할 수 있습니다.</font><font papago-translate="translated"> 대신 이것을 오류로<span name="scheme"> 만들 수 있습니다</span>.</font><font papago-translate="translated"> 사용자는 기존 변수를 재정의할 의도가 없을 수 있습니다.</font><font papago-translate="translated"> (만약 그들이 의도했다면, 아마도 과제를 사용했을 것입니다 </font></font><code translate="no">var</code><font papago-translate="splitted"><font papago-translate="translated">.) 재정의를 오류로 만들면 해당 버그를 찾는 데 도움이 될 것입니다.</font></font></p>
<p><font papago-translate="translated">그러나 그렇게 하면 REPL과 상호작용이 잘 되지 않습니다.</font><font papago-translate="translated"> REPL 세션 중에는 이미 정의한 변수를 정신적으로 추적할 필요가 없는 것이 좋습니다.</font><font papago-translate="translated"> 우리는 REPL에서 재정의를 허용할 수 있지만, 스크립트에서는 허용되지 않습니다. 그러면 사용자들은 두 가지 규칙을 배워야 하고, 한 양식에서 다른 양식으로 복사하여 붙여넣은 코드가 작동하지 않을 수도 있습니다.</font></p>
<aside name="scheme" style="top: 12289.5px;">
<p><font papago-translate="translated">변수와 범위에 대한 제 규칙은 "의심스러울 때는 스킴이 하는 일을 하세요"입니다.</font><font papago-translate="translated"> Scheme의 주요 목표 중 하나는 어휘 범위를 세상에 소개하는 것이었기 때문에, Scheme 사람들은 아마도 우리보다 가변적인 범위에 대해 더 많은 시간을 할애했을 것입니다. 따라서 그들<span class="em"></span><span class="em"></span>의 발자취를 따른다면 잘못되기 어려울 것입니다.</font></p>
<p><font papago-translate="translated">스킴은 최상위 수준에서 변수를 재정의할 수 있게 해줍니다.</font></p>
</aside>
<p><font papago-translate="translated">따라서 두 가지 모드를 일관되게 유지하기 위해 적어도 전역<span class="em"></span> 변수에 대해서는 허용하겠습니다.</font><font papago-translate="translated"> 변수가 존재하면, 우리는 그것을 찾아볼 방법이 필요합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">class Environment {
  private final Map&lt;String, Object&gt; values = new HashMap&lt;&gt;();
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Environment.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em></em>수업 환경에서</font></font></div>
<pre class="insert" translate="no">
  <span class="t">Object</span> <span class="i">get</span>(<span class="t">Token</span> <span class="i">name</span>) {
    <span class="k">if</span> (<span class="i">values</span>.<span class="i">containsKey</span>(<span class="i">name</span>.<span class="i">lexeme</span>)) {
      <span class="k">return</span> <span class="i">values</span>.<span class="i">get</span>(<span class="i">name</span>.<span class="i">lexeme</span>);
    }

    <span class="k">throw</span> <span class="k">new</span> <span class="t">RuntimeError</span>(<span class="i">name</span>,
        <span class="s">"Undefined variable '"</span> + <span class="i">name</span>.<span class="i">lexeme</span> + <span class="s">"'."</span>);
  }

</pre><pre class="insert-after" translate="no">  void define(String name, Object value) {
</pre></div>
<div class="source-file-narrow"><em>lox/Environment.java</em>, in class <em>Environment</em></div>
<p><font papago-translate="translated">이것은 조금 더 의미적으로 흥미롭습니다.</font><font papago-translate="translated"> 변수가 발견되면, 단순히 그 변수에 대한 값을 반환합니다.</font><font papago-translate="translated"> 하지만 그렇지 않다면 어떻게 하나요?</font><font papago-translate="translated"> 다시 한 번 선택의 여지가 있습니다:</font></p>
<ul>
<li>
<p><font papago-translate="translated">구문 오류로 만드세요.</font></p>
</li>
<li>
<p><font papago-translate="translated">런타임 오류로 만듭니다.</font></p>
</li>
<li>
<p><font papago-translate="splitted"><font papago-translate="translated">허용하고 다음과 같은 기본값을 반환합니다 </font></font><code translate="no">nil</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p>
</li>
</ul>
<p><font papago-translate="translated">Lox는 꽤 느슨하지만 마지막 옵션은 저에게<em> 너무</em> 관대합니다.</font><font papago-translate="translated"> 구문 오류, 즉 컴파일 타임 오류로 만드는 것은 현명<span class="em"></span><span class="em"></span>한 선택인 것 같습니다.</font><font papago-translate="translated"> 정의되지 않은 변수를 사용하는 것은 버그이며, 실수를 빨리 발견할수록 좋습니다.</font></p>
<p><font papago-translate="translated">문제는 변수<em>를 사용하는</em> 것이 그것을<em> 참조</em>하는 것과 다르다는 것입니다.</font><font papago-translate="translated"> 코드 덩어리가 함수 안에 감겨 있으면 즉시 평가하지 않고 코드 덩어리의 변수를 참조할 수 있습니다.</font><font papago-translate="translated"> 변수가 선언되기 전<em>에 언급</em>하는 것을 정적 오류로 만들면, 재귀 함수를 정의하는 것이 훨씬 더 어려워집니다.</font></p>
<p><font papago-translate="translated"><span class="em"></span><span class="em"></span>우리는 함수의 본체를 살펴보기 전에 함수의 이름을 선언함으로써 단일 재귀(스스로를 부르는 함수)를 수용할 수 있습니다.</font><font papago-translate="translated"> 하지만 그것은 서로를 호출하는 상호 재귀적 절차에는 도움이 되지 않습니다.</font><font papago-translate="translated"> 고려:</font></p>
<p><span name="contrived"></span></p>
<div class="codehilite"><pre translate="no"><span class="k">fun</span> <span class="i">isOdd</span>(<span class="i">n</span>) {
  <span class="k">if</span> (<span class="i">n</span> == <span class="n">0</span>) <span class="k">return</span> <span class="k">false</span>;
  <span class="k">return</span> <span class="i">isEven</span>(<span class="i">n</span> - <span class="n">1</span>);
}

<span class="k">fun</span> <span class="i">isEven</span>(<span class="i">n</span>) {
  <span class="k">if</span> (<span class="i">n</span> == <span class="n">0</span>) <span class="k">return</span> <span class="k">true</span>;
  <span class="k">return</span> <span class="i">isOdd</span>(<span class="i">n</span> - <span class="n">1</span>);
}
</pre></div>
<aside name="contrived" style="top: 13459.5px;">
<p><font papago-translate="translated">물론, 어떤 숫자가 짝수인지 홀수인지 구분하는 가장 효율적인 방법은 아닐 것입니다 (비정수 또는 음수를 전달할 때 발생하는 나쁜 일들은 말할 것도 없고요).</font><font papago-translate="translated"> 참아주세요.</font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">그 </font></font><code translate="no">isEven()</code><font papago-translate="splitted"><font papago-translate="translated"> 함수는 우리가 본문을 볼<span name="declare"> 때</span> 정의되지 않습니다 </font></font><code translate="no">isOdd()</code><font papago-translate="splitted"><font papago-translate="translated"> 그것이 불리는 곳.</font><font papago-translate="translated"> 두 함수의 순서를 바꾸면 </font></font><code translate="no">isOdd()</code><font papago-translate="splitted"><font papago-translate="translated"> 우리가 보고 있을 때 정의되지 않았습니다 </font></font><code translate="no">isEven()</code><font papago-translate="splitted"><font papago-translate="translated">의 몸.</font></font></p>
<aside name="declare" style="top: 13665.5px;">
<p><font papago-translate="translated">Java와 C#와 같은 일부 정적으로 입력된 언어는 프로그램의 최상위 단계가 명령문의 시퀀스가 아님을 지정하여 이 문제를 해결합니다.</font><font papago-translate="translated"> 대신, 프로그램은 모든 선언이 동시에 이루어지는 일련의 선언입니다.</font><font papago-translate="translated"> 구현은<em></em> 함수의 본문을 보기 전에<em> 모든</em> 이름을 선언합니다.</font></p>
<p><font papago-translate="translated">C와 파스칼 같은 오래된 언어는 이렇게 작동하지 않습니다.</font><font papago-translate="translated"> 대신, 이름이 완전히 정의되기 전에 명시<em>적인 전달 선언</em>을 추가하도록 강제합니다.</font><font papago-translate="translated"> 그것은 당시의 제한된 컴퓨팅 능력에 대한 양보였습니다.</font><font papago-translate="translated"> 그들은 텍스트를 한 번에 하나의 패스로 소스 파일을 컴파일할 수 있기를 원했기 때문에, 컴파일러들이 함수체를 처리하기 전에 먼저 모든 선언문을 수집할 수 없었습니다.</font></p>
</aside>
<p><font papago-translate="translated"><em>정적</em> 오류로 만들면 재귀적 선언이 너무 어렵기 때문에 오류를 런타임으로 연기하겠습니다.</font><font papago-translate="translated"> 변수를 정의하기 전에 참조하는 것은 참조<em>를 평가하지</em> 않는 한 괜찮습니다.</font><font papago-translate="translated"> 이렇게 하면 짝수와 홀수에 대한 프로그램이 작동하지만 런타임 오류가 발생할 수 있습니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">print</span> <span class="i">a</span>;
<span class="k">var</span> <span class="i">a</span> = <span class="s">"too late!"</span>;
</pre></div>
<p><font papago-translate="translated">표현 평가 코드의 유형 오류와 마찬가지로 예외를 적용하여 런타임 오류를 보고합니다.</font><font papago-translate="translated"> 예외에는 변수의 토큰이 포함되어 있으므로 사용자가 코드에서 어디를 잘못했는지 알 수 있습니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/statements-and-state.html#interpreting-global-variables" id="interpreting-global-variables"><small><font papago-translate="translated">8 . 3 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">전역 변수 해석</font></font></a></h3>
<p><font papago-translate="translated">인터프리터 클래스는 새로운 환경 클래스의 인스턴스를 가져옵니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">class Interpreter implements Expr.Visitor&lt;Object&gt;,
                             Stmt.Visitor&lt;Void&gt; {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Interpreter.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 클래스<em> 인터프리터</em>에서</font></font></div>
<pre class="insert" translate="no">  <span class="k">private</span> <span class="t">Environment</span> <span class="i">environment</span> = <span class="k">new</span> <span class="t">Environment</span>();

</pre><pre class="insert-after" translate="no">  void interpret(List&lt;Stmt&gt; statements) {
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in class <em>Interpreter</em></div>
<p><font papago-translate="translated">인터프리터에서 직접 필드로 저장하여 인터프리터가 실행되는 동안 변수가 메모리에 유지되도록 합니다.</font></p>
<p><font papago-translate="translated">우리는 두 개의 새로운 구문 트리를 가지고 있어서, 그것이 두 가지 새로운 방문 방법입니다.</font><font papago-translate="translated"> 첫 번째는 선언문을 위한 것입니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Interpreter.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>방문</em> 후 추가<em>PrintStmt</em>()</font></font></div>
<pre translate="no">  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitVarStmt</span>(<span class="t">Stmt</span>.<span class="t">Var</span> <span class="i">stmt</span>) {
    <span class="t">Object</span> <span class="i">value</span> = <span class="k">null</span>;
    <span class="k">if</span> (<span class="i">stmt</span>.<span class="i">initializer</span> != <span class="k">null</span>) {
      <span class="i">value</span> = <span class="i">evaluate</span>(<span class="i">stmt</span>.<span class="i">initializer</span>);
    }

    <span class="i">environment</span>.<span class="i">define</span>(<span class="i">stmt</span>.<span class="i">name</span>.<span class="i">lexeme</span>, <span class="i">value</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>visitPrintStmt</em>()</div>
<p><font papago-translate="translated">변수에 초기화자가 있는 경우 평가합니다.</font><font papago-translate="translated"> 그렇지 않다면, 우리는 또 다른 선택을 할 수 있습니다.</font><font papago-translate="translated"> 우리는 이것을 구문 오류로 만들 수 있었습니다. 초기화기<em>를 필요로</em> 했기 때문입니다.</font><font papago-translate="translated"> 하지만 대부분의 언어는 그렇지 않기 때문에 Lox에서는 그렇게 하는 것이 조금 가혹하게 느껴집니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">런타임 오류로 만들 수 있습니다.</font><font papago-translate="translated"> 초기화되지 않은 변수를 정의할 수 있지만, 할당하기 전에 해당 변수에 접근하면 런타임 오류가 발생할 수 있습니다.</font><font papago-translate="translated"> 나쁜 생각은 아니지만, 대부분의 동적으로 입력된 언어는 그렇게 하지 않습니다.</font><font papago-translate="translated"> 대신, 우리는 단순하게 유지하고 Lox가 다음과 같은 변수를 설정한다고 말할 것입니다 </font></font><code translate="no">nil</code><font papago-translate="splitted"><font papago-translate="translated"> 명시적으로 초기화되지 않은 경우.</font></font></p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="i">a</span>;
<span class="k">print</span> <span class="i">a</span>; <span class="c">// "nil".</span>
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">따라서 초기화자가 없는 경우 다음과 같이 값을 설정합니다 </font></font><code translate="no">null</code><font papago-translate="splitted"><font papago-translate="translated">, Lox의 자바 표현입니다 </font></font><code translate="no">nil</code><font papago-translate="splitted"><font papago-translate="translated"> 가치.</font><font papago-translate="translated"> 그런 다음 환경에 변수를 해당 값에 바인딩하라고 지시합니다.</font></font></p>
<p><font papago-translate="translated">다음으로, 변수 표현식을 평가합니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Interpreter.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>방문</em> 후 추가</font><font papago-translate="translated"><em>유니리익스프</em>레스(<em>)</em></font></font></div>
<pre translate="no">  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Object</span> <span class="i">visitVariableExpr</span>(<span class="t">Expr</span>.<span class="t">Variable</span> <span class="i">expr</span>) {
    <span class="k">return</span> <span class="i">environment</span>.<span class="i">get</span>(<span class="i">expr</span>.<span class="i">name</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>visitUnaryExpr</em>()</div>
<p><font papago-translate="translated">이는 변수가 정의되었는지 확인하기 위해 무거운 리프팅을 수행하는 환경으로 간단히 전달됩니다.</font><font papago-translate="translated"> 이를 통해 기본 변수가 작동하고 있습니다.</font><font papago-translate="translated"> 이것을 시도해 보세요:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="i">a</span> = <span class="n">1</span>;
<span class="k">var</span> <span class="i">b</span> = <span class="n">2</span>;
<span class="k">print</span> <span class="i">a</span> + <span class="i">b</span>;
</pre></div>
<p><font papago-translate="translated"><em>아직 코드</em>를 재사용할 수는 없지만<em>, 데이터</em>를 재사용하는 프로그램을 구축할 수 있습니다.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/statements-and-state.html#assignment" id="assignment"><small><font papago-translate="translated">8 . 4</font></small><font papago-translate="splitted"><font papago-translate="translated">과제</font></font></a></h2>
<p><font papago-translate="splitted"><font papago-translate="translated">변수는 있지만 재할당하거나<span class="em"></span><span class="em"></span><strong> 돌연변이</strong>를 일으키지 않는 언어를 만들 수 있습니다.</font><font papago-translate="translated"> 해스켈이 한 예입니다.</font><font papago-translate="translated"> SML은 변경 가능한 참조 및 배열만 지원하므로 변수를 재<span class="em"></span>할당할 수 없습니다.</font><font papago-translate="translated"> 녹은 다음을 필요로 하여 돌연변이로부터 멀어지게 합니다 </font></font><code translate="no">mut</code><font papago-translate="splitted"><font papago-translate="translated"> 할당을 가능하게 하는 수정자.</font></font></p>
<p><font papago-translate="translated">변수를 돌연변이시키는 것은 부작용이며, 이름에서 알 수 있듯이 일부 언어 사용자들은 부작용이<span name="pure"> 더럽</span>거나 우아하지 않다고 생각합니다.</font><font papago-translate="translated"> 코드는 신성<span class="em"></span><span class="em"></span>한 창조 행위처럼 결정적이고 변하지 않는 가치를 만들어내는 순수한 수학이어야 합니다.</font><font papago-translate="translated"> 데이터 덩어리를 물리치고 모양을 만드는 지저분한 오토마타가 아니라, 한 번에 하나씩 필수적인 투덜거림입니다.</font></p>
<aside name="pure" style="top: 15673.5px;">
<p><font papago-translate="translated">저는 불친절한 논리에 자부심을 느끼는 같은 그룹의 사람들이 감정적으로 가득 찬 작업 조건을 거부할 수 없는 사람들이라는 점이 기쁩니다: "순수함", "부작용", "느슨함", "지속적", "일등급", "고차원".</font></p>
</aside>
<p><font papago-translate="translated">록스는 그렇게 엄격하지 않습니다.</font><font papago-translate="translated"> Lox는 명령형 언어이며, 돌연변이는 영역과 함께 나타납니다.</font><font papago-translate="translated"> 과제 지원을 추가하는 데 많은 노력이 필요하지 않습니다.</font><font papago-translate="translated"> 글로벌 변수는 이미 재정의를 지원하므로 대부분의 기계가 현재 존재합니다.</font><font papago-translate="translated"> 주로 명시적인 할당 표기법이 누락되어 있습니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/statements-and-state.html#assignment-syntax" id="assignment-syntax"><small><font papago-translate="translated">8 . 4 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">할당 구문</font></font></a></h3>
<p><font papago-translate="splitted"><font papago-translate="translated">그 작은 </font></font><code translate="no">=</code><font papago-translate="splitted"><font papago-translate="translated"> 구문은 생각보다 복잡합니다.</font><font papago-translate="translated"> 대부분의 C 파생 언어와 마찬가지로 할당도 문장이 아닌<span name="assign"> 표현</span>입니다.</font><font papago-translate="translated"> C에서와 같이, 이것은 가장 낮은 우선순위 표현 형식입니다.</font><font papago-translate="translated"> 즉, 규칙 슬롯은 다음과 같습니다 </font></font><code translate="no">expression</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">equality</code><font papago-translate="splitted"><font papago-translate="translated"> (다음으로 낮은 우선순위 표현식).</font></font></p>
<aside name="assign" style="top: 16033.5px;">
<p><font papago-translate="translated">파스칼, 파이썬, 바둑과 같은 다른 언어에서는 할당이 문장입니다.</font></p>
</aside>
<div class="codehilite"><pre translate="no"><span class="i">expression</span>     → <span class="i">assignment</span> ;
<span class="i">assignment</span>     → <span class="t">IDENTIFIER</span> <span class="s">"="</span> <span class="i">assignment</span>
               | <span class="i">equality</span> ;
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">이것은 다음과 같습니다 </font></font><code translate="no">assignment</code><font papago-translate="splitted"><font papago-translate="translated"> 식별자 뒤에 오는 식별자는 다음과 같습니다 </font></font><code translate="no">=</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고 값에 대한 표현, 또는 </font></font><code translate="no">equality</code><font papago-translate="splitted"><font papago-translate="translated"> (따라서 다른 모든) 표현.</font><font papago-translate="translated"> 이따가, </font></font><code translate="no">assignment</code><font papago-translate="splitted"><font papago-translate="translated"> 객체에 속성 설정기를 추가하면 다음과 같이 더 복잡해집니다:</font></font></p>
<div class="codehilite"><pre translate="no"><span class="i">instance</span>.<span class="i">field</span> = <span class="s">"value"</span>;
</pre></div>
<p><font papago-translate="translated">쉬운 부분은<span name="assign-ast"> 새로운 구문 트리 노드</span>를 추가하는 것입니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    defineAst(outputDir, "Expr", Arrays.asList(
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">도구/GenerateAst.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>메인</em> ()에서</font></font></div>
<pre class="insert" translate="no">      <span class="s">"Assign   : Token name, Expr value"</span>,
</pre><pre class="insert-after" translate="no">      "Binary   : Expr left, Token operator, Expr right",
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>main</em>()</div>
<aside name="assign-ast" style="top: 16353.5px;">
<p><font papago-translate="translated">새 노드에 대한 생성된 코드는 부록<a href="https://youhogeon-meritz.github.io/appendix-ii.html#assign-expression"> II</a>에 있습니다.</font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">할당된 변수에 대한 토큰과 새로운 값에 대한 표현식이 있습니다.</font><font papago-translate="translated"> AstGenerator를 실행하여 새로운 Exper를 얻은 후.</font><font papago-translate="translated">클래스를 할당하고 파서의 기존 본문을 교체합니다 </font></font><code translate="no">expression()</code><font papago-translate="splitted"><font papago-translate="translated"> 업데이트된 규칙을 일치시키는 방법.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  private Expr expression() {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>표현</em>식 ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">    <span class="k">return</span> <span class="i">assignment</span>();
</pre><pre class="insert-after" translate="no">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>expression</em>(), replace 1 line</div>
<p><font papago-translate="splitted"><font papago-translate="translated">여기서부터 까다로워집니다.</font><font papago-translate="translated"> 하나의 토큰 룩어헤드 재귀 하강 파서는 왼쪽을 통과하여 다음과 같은 작업에 도달한<em> 후</em>에야 해당 작업이 파싱되고 있음을 알 수 있을 만큼 멀리 볼 수 있습니다 </font></font><code translate="no">=</code><font papago-translate="splitted"><font papago-translate="translated">. 왜 그렇게 해야 하는지 궁금할 수도 있습니다.</font><font papago-translate="translated"> 결국, 우리는 우리가 파싱하고 있다는 것을 모릅니다 </font></font><code translate="no">+</code><font papago-translate="splitted"><font papago-translate="translated"> 왼쪽 피연산자 구문 분석을 완료한 후까지의 표현식.</font></font></p>
<p><font papago-translate="translated">차이점은 과제의 왼쪽이 가치를 평가하는 표현이 아니라는 점입니다.</font><font papago-translate="translated"> 그것은 당신이 할당할 수 있는 "물건"을 평가하는 일종의 가짜 표현입니다.</font><font papago-translate="translated"> 고려:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="i">a</span> = <span class="s">"before"</span>;
<span class="i">a</span> = <span class="s">"value"</span>;
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">두 번째 줄에서는<em> 평가하지</em> 않습니다</font></font> <code translate="no">a</code><font papago-translate="splitted"><font papago-translate="translated"> 문자열을 "이전"으로 반환합니다.</font><font papago-translate="translated"> 우리는 어떤 변수를 계산합니다 </font></font><code translate="no">a</code><font papago-translate="splitted"><font papago-translate="translated"> 를 참조하여 오른쪽 표현식의 값을 저장할 위치를 알 수 있습니다.</font><font papago-translate="translated"> 이 두<span name="l-value"> 구성 요소</span>의<a href="https://en.wikipedia.org/wiki/Value_(computer_science)#lrvalue"> 고전적인 용어</a>는<strong> l-값</strong>과<strong> r-값</strong>입니다.</font><font papago-translate="translated"> 지금까지 본 모든 값을 나타내는 표현은 r-값입니다.</font><font papago-translate="translated"> l-값은 할당할 수 있는 저장 위치를 "평가"합니다.</font></font></p>
<aside name="l-value" style="top: 17017.5px;">
<p><font papago-translate="splitted"><font papago-translate="translated">사실, 이 이름들은 할당 표현식에서 유래<em>했습니다: l</em>-값은<em></em> 왼쪽에 나타납니다 </font></font><code translate="no">=</code><font papago-translate="splitted"><font papago-translate="translated"> 과제에서<em> 오른쪽</em><em>에 있는 r</em>-값.</font></font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">구문 트리가 l-값이 정규 표현식처럼 평가되지 않는다는 것을 반영하기를 원합니다.</font><font papago-translate="translated"> 그래서 엑스퍼.</font><font papago-translate="translated">할당 노드에는 Expr이 아닌 왼쪽에<em> 대한 토큰</em>이 있습니다.</font><font papago-translate="translated"> 문제는 파서가 l-값을 파싱하고 있다는 것을 알아채지 못한다는 것입니다 </font></font><code translate="no">=</code><font papago-translate="splitted"><font papago-translate="translated">. 복잡한 l-값에서는 나중에<span name="many"> 많은</span> 토큰이 발생할 수 있습니다.</font></font></p>
<div class="codehilite"><pre translate="no"><span class="i">makeList</span>().<span class="i">head</span>.<span class="i">next</span> = <span class="i">node</span>;
</pre></div>
<aside name="many" style="top: 17185.5px;">
<p><font papago-translate="splitted"><font papago-translate="translated">필드 할당의 수신자는 어떤 식이든 될 수 있고, 식을 만들고자 하는 만큼 길 수 있으므로, 다음을 찾는 데<em> 무한</em>한 수의 토큰이 필요할 수 있습니다 </font></font><code translate="no">=</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p>
</aside>
<p><font papago-translate="translated">우리는 앞으로의 전망 토큰이 하나밖에 없는데, 어떻게 해야 할까요?</font><font papago-translate="translated"> 우리는 약간의 트릭을 사용하는데, 이렇게 생겼습니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>식</em> 뒤에 추가St<em>atement</em>()</font></font></div>
<pre translate="no">  <span class="k">private</span> <span class="t">Expr</span> <span class="i">assignment</span>() {
    <span class="t">Expr</span> <span class="i">expr</span> = <span class="i">equality</span>();

    <span class="k">if</span> (<span class="i">match</span>(<span class="i">EQUAL</span>)) {
      <span class="t">Token</span> <span class="i">equals</span> = <span class="i">previous</span>();
      <span class="t">Expr</span> <span class="i">value</span> = <span class="i">assignment</span>();

      <span class="k">if</span> (<span class="i">expr</span> <span class="k">instanceof</span> <span class="t">Expr</span>.<span class="t">Variable</span>) {
        <span class="t">Token</span> <span class="i">name</span> = ((<span class="t">Expr</span>.<span class="t">Variable</span>)<span class="i">expr</span>).<span class="i">name</span>;
        <span class="k">return</span> <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Assign</span>(<span class="i">name</span>, <span class="i">value</span>);
      }

      <span class="i">error</span>(<span class="i">equals</span>, <span class="s">"Invalid assignment target."</span>);<span name="no-throw"> </span>
    }

    <span class="k">return</span> <span class="i">expr</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>expressionStatement</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">할당 표현식을 구문 분석하는 대부분의 코드는 다음과 같은 다른 이진 연산자와 유사하게 보입니다 </font></font><code translate="no">+</code><font papago-translate="splitted"><font papago-translate="translated">. 우리는 더 높은 우선순위를 나타내는 모든 표현이 될 수 있는 왼쪽을 분석합니다.</font><font papago-translate="translated"> 만약 우리가 </font></font><code translate="no">=</code><font papago-translate="splitted"><font papago-translate="translated">, 오른쪽을 파싱한 다음 모든 것을 할당 표현 트리 노드로 마무리합니다.</font></font></p>
<aside name="no-throw" style="top: 17588.5px;">
<p><font papago-translate="translated">왼쪽이 유효한 할당 대상이 아닌 경우 오류<em>를 보고하지만</em>, 파서가 패닉 모드로 전환하고 동기화해야 하는 혼란스러운 상태가 아니기 때문<em>에 이</em>를<em> 버리지</em> 않습니다.</font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">이진 연산자와의 약간의 차이점은 동일한 연산자의 시퀀스를 구축하기 위해 루프하지 않는다는 것입니다.</font><font papago-translate="translated"> 할당은 오른쪽 연관성이므로 대신 재귀적으로 호출합니다 </font></font><code translate="no">assignment()</code><font papago-translate="splitted"><font papago-translate="translated"> 오른쪽을 구문 분석합니다.</font></font></p>
<p><font papago-translate="translated">요령은 할당 표현식 노드를 만들기 직전에 왼쪽 표현식을 보고 그것이 어떤 종류의 할당 대상인지 알아내는 것입니다.</font><font papago-translate="translated"> 우리는 r-값 표현 노드를 l-값 표현으로 변환합니다.</font></p>
<p><font papago-translate="translated">이 변환은 모든 유효한 할당 대상이 정상 표현식으로서<span name="converse"> 유효한 구문</span>임이 밝혀졌기 때문에 작동합니다.</font><font papago-translate="translated"> 다음과 같은 복잡한 필드 할당을 고려해 보겠습니다:</font></p>
<aside name="converse" style="top: 18049.5px;">
<p><font papago-translate="splitted"><font papago-translate="translated">할당 대상이 유효하지 않은 표현이 있더라도 이 트릭을 계속 사용할 수 있습니다.</font><font papago-translate="translated"> <strong>모든</strong> 유효한 표현<em>과</em> 할당 대상 구문을 수용하는<strong> 느슨한</strong> 문법<strong>인 커버 문법</strong>을 정의합니다.</font><font papago-translate="translated"> 당신이 다음을 칠 때 </font></font><code translate="no">=</code><font papago-translate="splitted"><font papago-translate="translated">, 왼쪽이 올바른 할당 목표 문법에 맞지 않으면 오류를 보고합니다.</font><font papago-translate="translated"> 반대로<em></em>, 만약 당신이 </font></font><code translate="no">=</code><font papago-translate="splitted"><font papago-translate="translated">, 왼쪽이 올바른<em> 표현이</em> 아닌 경우 오류를 보고합니다.</font></font></p>
</aside>
<div class="codehilite"><pre translate="no"><span class="i">newPoint</span>(<span class="i">x</span> + <span class="n">2</span>, <span class="n">0</span>).<span class="i">y</span> = <span class="n">3</span>;
</pre></div>
<p><font papago-translate="translated">그 과제의 왼쪽 부분도 유효한 표현으로 작용할 수 있습니다.</font></p>
<div class="codehilite"><pre translate="no"><span class="i">newPoint</span>(<span class="i">x</span> + <span class="n">2</span>, <span class="n">0</span>).<span class="i">y</span>;
</pre></div>
<p><font papago-translate="translated">첫 번째 예제는 필드를 설정하고, 두 번째 예제는 필드를 얻습니다.</font></p>
<p><font papago-translate="translated">즉, 왼쪽을 표현<em>식처럼</em> 구문 분석한 다음 할당 대상으로 변환하는 구문 트리를 생성할 수 있습니다.</font><font papago-translate="translated"> 왼쪽 표현식이<span name="paren"> 올바른</span> 할당 대상이 아닌 경우 구문 오류로 실패합니다.</font><font papago-translate="translated"> 이를 통해 다음과 같은 코드에 오류가 발생했음을 보고합니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="i">a</span> + <span class="i">b</span> = <span class="i">c</span>;
</pre></div>
<aside name="paren" style="top: 18353.5px;">
<p><font papago-translate="translated">구문 분석 장에서 나중에 필요하기 때문에 구문 트리에서 괄호로 묶은 표현을 표현한다고 말씀드렸습니다.</font><font papago-translate="translated"> 이것이 바로 이유입니다.</font><font papago-translate="translated"> 우리는 이러한 경우들을 구별할 수 있어야 합니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="i">a</span> = <span class="n">3</span>;   <span class="c">// OK.</span>
(<span class="i">a</span>) = <span class="n">3</span>; <span class="c">// Error.</span>
</pre></div>
</aside>
<p><font papago-translate="translated">현재 유효한 대상은 단순 변수 표현식뿐이지만, 나중에 필드를 추가할 예정입니다.</font><font papago-translate="translated"> 이 트릭의 최종 결과는 할당되는 값을 알고 있고 할당되는 값에 대한 표현식 하위 트리가 있는 할당 표현식 트리 노드입니다.</font><font papago-translate="translated"> 모두 한 번의 전방 주시 토큰만 있고 역추적은 없습니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/statements-and-state.html#assignment-semantics" id="assignment-semantics"><small><font papago-translate="translated">8 . 4 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">할당 의미론</font></font></a></h3>
<p><font papago-translate="translated">새로운 구문 트리 노드가 생겨서 통역사가 새로운 방문 방법을 얻게 되었습니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Interpreter.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>visit</em>V<em>arStmt</em>() 방문 후 추가</font></font></div>
<pre translate="no">  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Object</span> <span class="i">visitAssignExpr</span>(<span class="t">Expr</span>.<span class="t">Assign</span> <span class="i">expr</span>) {
    <span class="t">Object</span> <span class="i">value</span> = <span class="i">evaluate</span>(<span class="i">expr</span>.<span class="i">value</span>);
    <span class="i">environment</span>.<span class="i">assign</span>(<span class="i">expr</span>.<span class="i">name</span>, <span class="i">value</span>);
    <span class="k">return</span> <span class="i">value</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>visitVarStmt</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">명백한 이유로, 그것은 변수 선언과 유사합니다.</font><font papago-translate="translated"> 오른쪽을 평가하여 값을 구한 다음 명명된 변수에 저장합니다.</font><font papago-translate="translated"> 사용하는 대신 </font></font><code translate="no">define()</code><font papago-translate="splitted"><font papago-translate="translated"> 환경에서는 이를 새로운 방법이라고 부릅니다:</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Environment.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>()</em>를<em> 얻은</em> 후에 추가하기</font></font></div>
<pre translate="no">  <span class="t">void</span> <span class="i">assign</span>(<span class="t">Token</span> <span class="i">name</span>, <span class="t">Object</span> <span class="i">value</span>) {
    <span class="k">if</span> (<span class="i">values</span>.<span class="i">containsKey</span>(<span class="i">name</span>.<span class="i">lexeme</span>)) {
      <span class="i">values</span>.<span class="i">put</span>(<span class="i">name</span>.<span class="i">lexeme</span>, <span class="i">value</span>);
      <span class="k">return</span>;
    }

    <span class="k">throw</span> <span class="k">new</span> <span class="t">RuntimeError</span>(<span class="i">name</span>,
        <span class="s">"Undefined variable '"</span> + <span class="i">name</span>.<span class="i">lexeme</span> + <span class="s">"'."</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Environment.java</em>, add after <em>get</em>()</div>
<p><font papago-translate="translated">할당과 정의의 주요 차이점은 할당이<em> 새</em> 변수를 생성<span name="new">할 수 없다는</span> 점입니다.</font><font papago-translate="translated"> 우리의 구현 측면에서 보면, 키가 환경의 변수 맵에 아직 존재하지 않는다면 런타임 오류입니다.</font></p>
<aside name="new" style="top: 19201.5px;">
<p><font papago-translate="translated">Python과 Ruby와 달리 Lox는<a href="https://youhogeon-meritz.github.io/statements-and-state.html#design-note"> 암묵적 변수 선언</a>을 하지 않습니다.</font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">마지막으로 </font></font><code translate="no">visit()</code><font papago-translate="splitted"><font papago-translate="translated"> 메서드는 할당된 값을 반환합니다.</font><font papago-translate="translated"> 그것은 할당이 다른 표현식 안에 중첩될 수 있는 표현이기 때문입니다:</font></font></p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="i">a</span> = <span class="n">1</span>;
<span class="k">print</span> <span class="i">a</span> = <span class="n">2</span>; <span class="c">// "2".</span>
</pre></div>
<p><font papago-translate="translated">이제 저희 통역사는 변수를 생성하고, 읽고, 수정할 수 있습니다.</font><font papago-translate="translated"> 초기<span name="basic"> 베이직</span>만큼이나 정교합니다.</font><font papago-translate="translated"> 글로벌 변수는 간단하지만, 두 개의 코드 덩어리가 실수로 서로의 상태를 밟을 수 있을 때 큰 프로그램을 작성하는 것은 재미가 없습니다.</font><font papago-translate="translated"> <em>우리는 지역</em> 변수를 원합니다.<em> 이</em>는<em> 범위</em>를 설정할 때가 되었음을 의미합니다.</font></p>
<aside name="basic" style="top: 19457.5px;">
<p><font papago-translate="translated">그보다 조금 더 나을 수도 있습니다.</font><font papago-translate="translated"> 일부 오래된 베이직과 달리, Lox는 두 글자 이상의 변수 이름을 처리할 수 있습니다.</font></p>
</aside>
<h2><a href="https://youhogeon-meritz.github.io/statements-and-state.html#scope" id="scope"><small><font papago-translate="translated">8 . 5</font></small><font papago-translate="splitted"><font papago-translate="translated">범위</font></font></a></h2>
<p><font papago-translate="translated"><strong>스코프</strong>는 이름이 특정 엔티티에 매핑되는 영역을 정의합니다.</font><font papago-translate="translated"> 여러 개의 스코프는 동일한 이름이 서로 다른 맥락에서 서로 다른 것을 지칭할 수 있게 합니다.</font><font papago-translate="translated"> 우리 집에서는 보통 "밥"이 저를 가리킵니다.</font><font papago-translate="translated"> 하지만 당신의 마을에서는 다른 밥을 알고 있을지도 모릅니다.</font><font papago-translate="translated"> 같은 이름이지만 말하는 위치에 따라 다른 친구들이 있습니다.</font></p>
<p><font papago-translate="translated"><span name="lexical"><strong>어휘 범위</strong></span>(또는 덜 일반적으로 들리는<strong> 정적 범위)</strong>는 프로그램의 텍스트 자체가 범위의 시작과 끝을 보여주는 특정한 범위 유형입니다<span name="lexical"><strong>.</strong></span></font><font papago-translate="translated"> Lox에서는 대부분의 현대 언어와 마찬가지로 변수가 사전적으로 범위가 정해집니다.</font><font papago-translate="translated"> 어떤 변수를 사용하는 표현을 보면, 코드를 정적으로 읽기만 하면 어떤 변수 선언을 의미하는지 알아낼 수 있습니다.</font></p>
<aside name="lexical" style="top: 19769.5px;">
<p><font papago-translate="translated">"Lexical"은 그리스어 "lexikos"에서 유래했으며, 이는 "단어와 관련된"을 의미합니다.</font><font papago-translate="translated"> 프로그래밍 언어에서 이를 사용할 때는 보통 소스 코드 자체에서 아무것도 실행하지 않고도 알아낼 수 있는 것을 의미합니다.</font></p>
<p><font papago-translate="translated">어휘 범위는 ALGOL을 사용하여 등장했습니다. 이전 언어들은 종종 동적으로 범위가 정해졌습니다.</font><font papago-translate="translated"> 당시 컴퓨터 과학자들은 동적 스코프를 실행하는 것이 더 빠르다고 믿었습니다.</font><font papago-translate="translated"> 오늘날 초기 스킴 해커들 덕분에 우리는 그것이 사실이 아니라는 것을 알고 있습니다.</font><font papago-translate="translated"> 오히려 그 반대입니다.</font></p>
<p><font papago-translate="translated">변수의 동적 범위는 일부 모서리에 존재합니다.</font><font papago-translate="translated"> Emacs Lisp는 변수의 동적 범위로 기본 설정됩니다.</font><font papago-translate="translated"> 클로저의<a href="http://clojuredocs.org/clojure.core/binding"> 매크로</a>가 이를 제공합니다.</font><font papago-translate="translated"> JavaScript<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with">에서</a> 널리 사용되지 않는<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with"> 문장</a>은 객체의 속성을 동적으로 범위가 지정된 변수로 바꿉니다.</font></p>
</aside>
<p><font papago-translate="translated">예를 들어:</font></p>
<div class="codehilite"><pre translate="no">{
  <span class="k">var</span> <span class="i">a</span> = <span class="s">"first"</span>;
  <span class="k">print</span> <span class="i">a</span>; <span class="c">// "first".</span>
}

{
  <span class="k">var</span> <span class="i">a</span> = <span class="s">"second"</span>;
  <span class="k">print</span> <span class="i">a</span>; <span class="c">// "second".</span>
}
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">여기 변수가 있는 두 블록이 있습니다 </font></font><code translate="no">a</code><font papago-translate="splitted"><font papago-translate="translated"> 각각 선언되었습니다.</font><font papago-translate="translated"> 코드만 봐도 다음과 같은 용도를 알 수 있습니다 </font></font><code translate="no">a</code><font papago-translate="splitted"><font papago-translate="translated"> 처음에 </font></font><code translate="no">print</code><font papago-translate="splitted"><font papago-translate="translated"> 문장은 첫 번째를 참조합니다 </font></font><code translate="no">a</code><font papago-translate="splitted"><font papago-translate="translated">, 그리고 두 번째는 두 번째를 가리킵니다.</font></font></p><img alt="An environment for each 'a'." src="https://youhogeon-meritz.github.io/image/statements-and-state/blocks.png">
<p><font papago-translate="translated">이것은 코드를 실행할 때까지 이름이 무엇을 의미하는지 모르는<strong> 동적 범위와는</strong> 대조적입니다.</font><font papago-translate="translated"> Lox에는 동적으로 범위<em>가</em> 지정<em>된 변수가</em> 없지만, 객체의 메서드와 필드는 동적으로 범위가 지정됩니다.</font></p>
<div class="codehilite"><pre translate="no"><span class="k">class</span> <span class="t">Saxophone</span> {
  <span class="i">play</span>() {
    <span class="k">print</span> <span class="s">"Careless Whisper"</span>;
  }
}

<span class="k">class</span> <span class="t">GolfClub</span> {
  <span class="i">play</span>() {
    <span class="k">print</span> <span class="s">"Fore!"</span>;
  }
}

<span class="k">fun</span> <span class="i">playIt</span>(<span class="i">thing</span>) {
  <span class="i">thing</span>.<span class="i">play</span>();
}
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">언제 </font></font><code translate="no">playIt()</code><font papago-translate="splitted"><font papago-translate="translated"> 호출 </font></font><code translate="no">thing.play()</code><font papago-translate="splitted"><font papago-translate="translated">, 우리가 "무관심 속삭임"을 듣게 될지 "Fore!"를 듣게 될지 모르겠습니다</font><font papago-translate="translated"> 색소폰을 기능에 전달하느냐 골프클럽을 전달하느냐에 따라 다르며, 실행 시간이 지나야 알 수 있습니다.</font></font></p>
<p><font papago-translate="translated">범위와 환경은 밀접한 관련이 있습니다.</font><font papago-translate="translated"> 전자는 이론적 개념이고, 후자는 이를 구현하는 기계입니다.</font><font papago-translate="translated"> 우리의 인터프리터가 코드를 처리하는 과정에서 범위에 영향을 미치는 구문 트리 노드는 환경을 변화시킬 것입니다.</font><font papago-translate="translated"> Lox와 같은 C-ish 구문에서는 범위가 컬리브레이스 블록에 의해 제어됩니다. (그래서<strong> 우리</strong>는<strong> 그것</strong>을<strong> 블록 범위라고</strong> 부릅니다.)</font></p>
<div class="codehilite"><pre translate="no">{
  <span class="k">var</span> <span class="i">a</span> = <span class="s">"in block"</span>;
}
<span class="k">print</span> <span class="i">a</span>; <span class="c">// Error! No more "a".</span>
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">블록의 시작은 새로운 로컬 범위를 도입하며, 실행이 종료를 통과할 때 해당 범위가 종료됩니다 </font></font><code translate="no">}</code><font papago-translate="splitted"><font papago-translate="translated">. 블록 내부에 선언된 모든 변수가 사라집니다.</font></font></p>
<h3><a href="https://youhogeon-meritz.github.io/statements-and-state.html#nesting-and-shadowing" id="nesting-and-shadowing"><small><font papago-translate="translated">8 . 5 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">둥지 짓기 및 그림자 그리기</font></font></a></h3>
<p><font papago-translate="translated">블록 범위를 구현할 때 첫 번째 컷은 다음과 같이 작동할 수 있습니다:</font></p>
<ol>
<li>
<p><font papago-translate="translated">블록 내부의 각 문을 방문할 때는 선언된 변수를 추적하세요.</font></p>
</li>
<li>
<p><font papago-translate="translated">마지막 문장이 실행된 후, 환경에 모든 변수를 삭제하라고 지시하세요.</font></p>
</li>
</ol>
<p><font papago-translate="translated">그것은 이전 예시에서 효과가 있을 것입니다.</font><font papago-translate="translated"> 하지만 기억하세요, 로컬 범위의 동기 중 하나는 캡슐화입니다. 프로그램의 한쪽 구석에 있는 코드 블록이 다른<span class="em"></span> 블록을 방해해서는 안 됩니다.</font><font papago-translate="translated"> 이것을 확인하세요:</font></p>
<div class="codehilite"><pre translate="no"><span class="c">// How loud?</span>
<span class="k">var</span> <span class="i">volume</span> = <span class="n">11</span>;

<span class="c">// Silence.</span>
<span class="i">volume</span> = <span class="n">0</span>;

<span class="c">// Calculate size of 3x4x5 cuboid.</span>
{
  <span class="k">var</span> <span class="i">volume</span> = <span class="n">3</span> * <span class="n">4</span> * <span class="n">5</span>;
  <span class="k">print</span> <span class="i">volume</span>;
}
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">다음과 같은 국소 선언을 사용하여 직육면체의 부피를 계산하는 블록을 보세요 </font></font><code translate="no">volume</code><font papago-translate="splitted"><font papago-translate="translated">. 블록이 종료된 후, 인터프리터는<em> 전역</em>을 삭제할 것입니다</font></font> <code translate="no">volume</code><font papago-translate="splitted"><font papago-translate="translated"> 변수.</font><font papago-translate="translated"> 그렇지 않습니다.</font><font papago-translate="translated"> 블록을 종료할 때 블록 내부에 선언된 변수를 제거해야 하지만, 블록 외부에 동일한 이름의 변수가 선언되어 있다면<em> 그것은 다른 변수입니다</em>.</font><font papago-translate="translated"> 만지지 말아야 합니다.</font></font></p>
<p><font papago-translate="translated">로컬 변수가 주변 범위의 변수와 이름이 같으면 외부 변수<strong>를 흐리게 합니다</strong>.</font><font papago-translate="translated"> 블록 내부의 코드는 더 이상 그것을 볼 수 없습니다. 내부 코드에 의해 "그림자"에 숨겨져 있지만, 여전히<span class="em"></span><span class="em"></span> 존재합니다.</font></p>
<p><font papago-translate="translated">새로운 블록 범위에 들어갈 때는 외부 범위에 정의된 변수를 보존하여 내부 블록을 종료할 때에도 여전히 존재하도록 해야 합니다.</font><font papago-translate="translated"> 각 블록에 정의된 변수만 포함된 새로운 환경을 정의함으로써 이를 수행합니다.</font><font papago-translate="translated"> 블록을 종료하면 해당 환경을 버리고 이전 환경을 복원합니다.</font></p>
<p><font papago-translate="translated">우리는 또한 음영<em> 처리되지</em> 않은 변수들을 처리해야 합니다.</font></p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="i">global</span> = <span class="s">"outside"</span>;
{
  <span class="k">var</span> <span class="i">local</span> = <span class="s">"inside"</span>;
  <span class="k">print</span> <span class="i">global</span> + <span class="i">local</span>;
}
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">여기서, </font></font><code translate="no">global</code><font papago-translate="splitted"><font papago-translate="translated"> 외부 지구 환경에 살고 있습니다 </font></font><code translate="no">local</code><font papago-translate="splitted"><font papago-translate="translated"> 는 블록의 환경 내에서 정의됩니다.</font><font papago-translate="translated"> 그 점에서 </font></font><code translate="no">print</code><font papago-translate="splitted"><font papago-translate="translated"> 두 변수 모두 범위 내에 있습니다.</font><font papago-translate="translated"> 이를 찾기 위해 통역사는 현재 가장 안쪽 환경뿐만 아니라 주변 환경도 검색해야 합니다.</font></font></p>
<p><font papago-translate="translated">우리는 환경을 서로<span name="cactus"> 연결</span>하여 이를 구현합니다.</font><font papago-translate="translated"> 각 환경은 즉시 둘러싸인 범위의 환경에 대한 참조를 가지고 있습니다.</font><font papago-translate="translated"> 변수를 찾을 때, 우리는 변수를 찾을 때까지 그 사슬을 가장 안쪽에서 끝까지 걷습니다.</font><font papago-translate="translated"> 내부 범위에서 시작하여 지역 변수를 외부 변수로 그림자를 만드는 방법입니다.</font></p><img alt="Environments for each scope, linked together." src="https://youhogeon-meritz.github.io/image/statements-and-state/chaining.png">
<aside name="cactus" style="top: 22495px;">
<p><font papago-translate="translated">인터프리터가 실행되는 동안 환경은 객체의 선형 목록을 형성하지만, 전체 실행 중에 생성된 전체 환경 집합을 고려합니다.</font><font papago-translate="translated"> 외부 스코프에는 여러 개의 블록이 중첩되어 있을 수 있으며, 각 블록은 외부 블록을 가리키며 트리와 같은 구조를 제공합니다. 하지만 트리를 통과하는 경로는 한 번에 하나만 존재합니다.</font></p>
<p><font papago-translate="translated">지루한 이름은<a href="https://en.wikipedia.org/wiki/Parent_pointer_tree"><strong> 부모-포인트 트리이지만</strong></a>, 저는 감성<strong>적인 선인장 스택을</strong> 훨씬 선호합니다.</font></p><img alt="Each branch points to its parent. The root is global scope." class="above" src="https://youhogeon-meritz.github.io/image/statements-and-state/cactus.png">
</aside>
<p><font papago-translate="translated">문법에 블록 구문을 추가하기 전에, 이 네스팅을 지원하여 환경 클래스를 강화할 것입니다.</font><font papago-translate="translated"> 먼저, 각 환경에 그 주변 환경에 대한 참조를 제공합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">class Environment {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Environment.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em></em>수업 환경에서</font></font></div>
<pre class="insert" translate="no">  <span class="k">final</span> <span class="t">Environment</span> <span class="i">enclosing</span>;
</pre><pre class="insert-after" translate="no">  private final Map&lt;String, Object&gt; values = new HashMap&lt;&gt;();
</pre></div>
<div class="source-file-narrow"><em>lox/Environment.java</em>, in class <em>Environment</em></div>
<p><font papago-translate="translated">이 필드를 초기화해야 하므로 몇 가지 생성자를 추가합니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Environment.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em></em>수업 환경에서</font></font></div>
<pre translate="no">  <span class="t">Environment</span>() {
    <span class="i">enclosing</span> = <span class="k">null</span>;
  }

  <span class="t">Environment</span>(<span class="t">Environment</span> <span class="i">enclosing</span>) {
    <span class="k">this</span>.<span class="i">enclosing</span> = <span class="i">enclosing</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Environment.java</em>, in class <em>Environment</em></div>
<p><font papago-translate="translated">무논쟁 생성자는 체인을 종료하는 글로벌 스코프의 환경을 위한 것입니다.</font><font papago-translate="translated"> 다른 생성자는 주어진 외부 범위 내에 중첩된 새로운 로컬 범위를 생성합니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">우리는 만질 필요가 없습니다 </font></font><code translate="no">define()</code><font papago-translate="splitted"><font papago-translate="translated"> 메서드—현재 가장 안쪽<span class="em"></span> 범위에서 항상 새로운 변수가 선언됩니다.</font><font papago-translate="translated"> 하지만 변수 조회와 할당은 기존 변수와 함께 작동하며, 변수를 찾기 위해 체인을 걸어야 합니다.</font><font papago-translate="translated"> 먼저, 조회:</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      return values.get(name.lexeme);
    }
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Environment.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>겟</em> ()에서</font></font></div>
<pre class="insert" translate="no">
    <span class="k">if</span> (<span class="i">enclosing</span> != <span class="k">null</span>) <span class="k">return</span> <span class="i">enclosing</span>.<span class="i">get</span>(<span class="i">name</span>);
</pre><pre class="insert-after" translate="no">
    throw new RuntimeError(name,
        "Undefined variable '" + name.lexeme + "'.");
</pre></div>
<div class="source-file-narrow"><em>lox/Environment.java</em>, in <em>get</em>()</div>
<p><font papago-translate="translated">이 환경에서 변수가 발견되지 않으면, 우리는 단순히 둘러싸는 변수를 시도해 봅니다.</font><font papago-translate="translated"> 그러면<span name="recurse"> 같은</span> 일이<span name="recurse"> 반복적으로</span> 일어나므로 궁극적으로 전체 체인을 걷게 됩니다.</font><font papago-translate="translated"> 환경을 둘러싸고 있지 않은 환경에 도달했지만 여전히 변수를 찾지 못하면 포기하고 이전과 같이 오류를 보고합니다.</font></p>
<p><font papago-translate="translated">과제도 같은 방식으로 작동합니다.</font></p>
<aside name="recurse" style="top: 23606px;">
<p><font papago-translate="translated">체인을 반복적으로 걷는 것이 더 빠를 수 있지만, 재귀적인 해결책이 더 예쁘다고 생각합니다.</font><font papago-translate="translated"> 우리는 클록스에서<em> 훨씬</em> 더 빠른 작업을 수행할 것입니다.</font></p>
</aside>
<div class="codehilite"><pre class="insert-before" translate="no">      values.put(name.lexeme, value);
      return;
    }

</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Environment.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>할당</em>된 ()에서</font></font></div>
<pre class="insert" translate="no">    <span class="k">if</span> (<span class="i">enclosing</span> != <span class="k">null</span>) {
      <span class="i">enclosing</span>.<span class="i">assign</span>(<span class="i">name</span>, <span class="i">value</span>);
      <span class="k">return</span>;
    }

</pre><pre class="insert-after" translate="no">    throw new RuntimeError(name,
</pre></div>
<div class="source-file-narrow"><em>lox/Environment.java</em>, in <em>assign</em>()</div>
<p><font papago-translate="translated">다시 말하지만, 변수가 이 환경에 있지 않으면 외부 변수를 재귀적으로 확인합니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/statements-and-state.html#block-syntax-and-semantics" id="block-syntax-and-semantics"><small><font papago-translate="translated">8 . 5 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">블록 구문 및 의미론</font></font></a></h3>
<p><font papago-translate="translated">이제 환경이 자리 잡았으니 언어에 블록을 추가할 준비가 되었습니다.</font><font papago-translate="translated"> 문법을 보세요:</font></p>
<div class="codehilite"><pre translate="no"><span class="i">statement</span>      → <span class="i">exprStmt</span>
               | <span class="i">printStmt</span>
               | <span class="i">block</span> ;

<span class="i">block</span>          → <span class="s">"{"</span> <span class="i">declaration</span>* <span class="s">"}"</span> ;
</pre></div>
<p><font papago-translate="translated">블록은 곱슬곱슬한 괄호로 둘러싸인 (아마도 비어 있을 수도 있는) 일련의 진술 또는 선언입니다.</font><font papago-translate="translated"> 블록은 그 자체로 문장이며, 문장이 허용되는 모든 곳에 나타날 수 있습니다.</font><font papago-translate="translated"> <span name="block-ast">구문 트리</span> 노드는 다음과 같습니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    defineAst(outputDir, "Stmt", Arrays.asList(
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">도구/GenerateAst.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>메인</em> ()에서</font></font></div>
<pre class="insert" translate="no">      <span class="s">"Block      : List&lt;Stmt&gt; statements"</span>,
</pre><pre class="insert-after" translate="no">      "Expression : Expr expression",
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>main</em>()</div>
<aside name="block-ast" style="top: 24386px;">
<p><font papago-translate="translated">새 노드에 대한 생성된 코드는 부록<a href="https://youhogeon-meritz.github.io/appendix-ii.html#block-statement"> II</a>에 있습니다.</font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">블록 안에 있는 진술 목록이 포함되어<span name="generate"> 있습니다.</span></font><font papago-translate="translated"> 구문 분석은 간단합니다.</font><font papago-translate="translated"> 다른 진술과 마찬가지로, 우리는 블록의 시작을 선행 토큰으로 감지합니다. 이 경우<span class="em"></span>에는 </font></font><code translate="no">{</code><font papago-translate="splitted"><font papago-translate="translated">.에서 </font></font><code translate="no">statement()</code><font papago-translate="splitted"><font papago-translate="translated"> 방법을 추가합니다:</font></font></p>
<aside name="generate" style="top: 24518px;">
<p><font papago-translate="translated">언제나 그렇듯이 "GenerateAst.java"를 실행하는 것을 잊지 마세요.</font></p>
</aside>
<div class="codehilite"><pre class="insert-before" translate="no">    if (match(PRINT)) return printStatement();
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>성명</em>서 ()에서</font></font></div>
<pre class="insert" translate="no">    <span class="k">if</span> (<span class="i">match</span>(<span class="i">LEFT_BRACE</span>)) <span class="k">return</span> <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">Block</span>(<span class="i">block</span>());
</pre><pre class="insert-after" translate="no">
    return expressionStatement();
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>statement</em>()</div>
<p><font papago-translate="translated">모든 실제 작업은 여기서 이루어집니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Parser.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>식</em> 뒤에 추가St<em>atement</em>()</font></font></div>
<pre translate="no">  <span class="k">private</span> <span class="t">List</span>&lt;<span class="t">Stmt</span>&gt; <span class="i">block</span>() {
    <span class="t">List</span>&lt;<span class="t">Stmt</span>&gt; <span class="i">statements</span> = <span class="k">new</span> <span class="t">ArrayList</span>&lt;&gt;();

    <span class="k">while</span> (!<span class="i">check</span>(<span class="i">RIGHT_BRACE</span>) &amp;&amp; !<span class="i">isAtEnd</span>()) {
      <span class="i">statements</span>.<span class="i">add</span>(<span class="i">declaration</span>());
    }

    <span class="i">consume</span>(<span class="i">RIGHT_BRACE</span>, <span class="s">"Expect '}' after block."</span>);
    <span class="k">return</span> <span class="i">statements</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, add after <em>expressionStatement</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">빈 목록을<span name="list"> 만든</span> 다음 구문을 구문 분석하여 블록의 끝에 도달할 때까지 목록에 추가합니다. 끝은 클로징으로 표시됩니다 </font></font><code translate="no">}</code><font papago-translate="splitted"><font papago-translate="translated">. 루프에는 다음 항목에 대한 명시적인 검사도 있습니다 </font></font><code translate="no">isAtEnd()</code><font papago-translate="splitted"><font papago-translate="translated">. 잘못된 코드를 구문 분석할 때에도 무한 루프를 피하도록 주의해야 합니다.</font><font papago-translate="translated"> 사용자가 마감을 잊어버린 경우 </font></font><code translate="no">}</code><font papago-translate="splitted"><font papago-translate="translated">, 파서가 막히지 않아야 합니다.</font></font></p>
<aside name="list" style="top: 24990px;">
<p><font papago-translate="splitted"><font papago-translate="translated">하고 있다 </font></font><code translate="no">block()</code><font papago-translate="splitted"><font papago-translate="translated"> 원시 진술 목록을 반환하고 다음에 남깁니다 </font></font><code translate="no">statement()</code><font papago-translate="splitted"><font papago-translate="translated"> 목록을 Stmt로 마무리합니다.</font><font papago-translate="translated">블록이 조금 이상해 보입니다.</font><font papago-translate="translated"> 재사용할 수 있기 때문에 그렇게 했습니다 </font></font><code translate="no">block()</code><font papago-translate="splitted"><font papago-translate="translated"> 나중에 함수 본문을 구문 분석하기 위해, 그리고 그 본문을 Stmt로 감싸지 않기를 원합니다.</font><font papago-translate="translated">차단.</font></font></p>
</aside>
<p><font papago-translate="translated">구문은 여기까지입니다.</font><font papago-translate="translated"> 의미론을 위해 인터프리터에 또 다른 방문 방법을 추가합니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Interpreter.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>실행</em> 후 () 추가</font></font></div>
<pre translate="no">  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitBlockStmt</span>(<span class="t">Stmt</span>.<span class="t">Block</span> <span class="i">stmt</span>) {
    <span class="i">executeBlock</span>(<span class="i">stmt</span>.<span class="i">statements</span>, <span class="k">new</span> <span class="t">Environment</span>(<span class="i">environment</span>));
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>execute</em>()</div>
<p><font papago-translate="translated">블록을 실행하려면 블록의 범위에 맞는 새로운 환경을 만들고 이를 다른 방법으로 전달합니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Interpreter.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>실행</em> 후 () 추가</font></font></div>
<pre translate="no">  <span class="t">void</span> <span class="i">executeBlock</span>(<span class="t">List</span>&lt;<span class="t">Stmt</span>&gt; <span class="i">statements</span>,
                    <span class="t">Environment</span> <span class="i">environment</span>) {
    <span class="t">Environment</span> <span class="i">previous</span> = <span class="k">this</span>.<span class="i">environment</span>;
    <span class="k">try</span> {
      <span class="k">this</span>.<span class="i">environment</span> = <span class="i">environment</span>;

      <span class="k">for</span> (<span class="t">Stmt</span> <span class="i">statement</span> : <span class="i">statements</span>) {
        <span class="i">execute</span>(<span class="i">statement</span>);
      }
    } <span class="k">finally</span> {
      <span class="k">this</span>.<span class="i">environment</span> = <span class="i">previous</span>;
    }
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>execute</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">이 새로운 방법은 주어진<span name="param"> 환경</span>의 맥락에서 진술 목록을 실행합니다.</font><font papago-translate="translated"> 지금까지 </font></font><code translate="no">environment</code><font papago-translate="splitted"><font papago-translate="translated"> 인터프리터의 필드는 항상 동일한 환경, 즉 글로벌<span class="em"></span> 환경을 가리켰습니다.</font><font papago-translate="translated"> 이제 그 필드는<em> 현재</em> 환경을 나타냅니다.</font><font papago-translate="translated"> 실행할 코드를 포함하는 가장 안쪽 범위에 해당하는 환경입니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">주어진 범위 내에서 코드를 실행하기 위해 이 메서드는 인터프리터의 </font></font><code translate="no">environment</code><font papago-translate="splitted"><font papago-translate="translated"> 필드는 모든 문을 방문한 다음 이전 값을 복원합니다.</font><font papago-translate="translated"> Java에서 항상 좋은 관행처럼, 마지막 절을 사용하여 이전 환경을 복원합니다.</font><font papago-translate="translated"> 그렇게 하면 예외가 발생하더라도 복원됩니다.</font></font></p>
<aside name="param" style="top: 25662px;">
<p><font papago-translate="splitted"><font papago-translate="translated">수동으로 변경 및 복원하기 </font></font><code translate="no">environment</code><font papago-translate="splitted"><font papago-translate="translated"> 들판은 우아하지 않게 느껴집니다.</font><font papago-translate="translated"> 또 다른 고전적인 접근 방식은 환경을 각 방문 방법의 매개변수로 명시적으로 전달하는 것입니다.</font><font papago-translate="translated"> 환경을 "변화"하려면 나무 아래로 반복하면서 다른 환경을 지나가야 합니다.</font><font papago-translate="translated"> 이전 것을 복원할 필요는 없습니다. 새로운 것은 Java 스택에 저장되어 있으며, 인터프리터가 블록의 방문 방법에서 돌아올 때 암묵적으로 폐기되기 때문입니다.</font></font></p>
<p><font papago-translate="translated">저는 Jlox에 대해 그것을 고려했지만, 모든 방문 방법에 환경 매개변수를 추가하는 것은 다소 지루하고 장황합니다.</font><font papago-translate="translated"> 책을 조금 더 간단하게 만들기 위해 돌연변이 필드를 선택했습니다.</font></p>
</aside>
<p><font papago-translate="translated">놀랍게도, 지역 변수, 중첩, 그리고 음영을 완전히 지원하기 위해 우리가 해야 할 일은 그것뿐입니다.</font><font papago-translate="translated"> 한번 시도해 보세요:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="i">a</span> = <span class="s">"global a"</span>;
<span class="k">var</span> <span class="i">b</span> = <span class="s">"global b"</span>;
<span class="k">var</span> <span class="i">c</span> = <span class="s">"global c"</span>;
{
  <span class="k">var</span> <span class="i">a</span> = <span class="s">"outer a"</span>;
  <span class="k">var</span> <span class="i">b</span> = <span class="s">"outer b"</span>;
  {
    <span class="k">var</span> <span class="i">a</span> = <span class="s">"inner a"</span>;
    <span class="k">print</span> <span class="i">a</span>;
    <span class="k">print</span> <span class="i">b</span>;
    <span class="k">print</span> <span class="i">c</span>;
  }
  <span class="k">print</span> <span class="i">a</span>;
  <span class="k">print</span> <span class="i">b</span>;
  <span class="k">print</span> <span class="i">c</span>;
}
<span class="k">print</span> <span class="i">a</span>;
<span class="k">print</span> <span class="i">b</span>;
<span class="k">print</span> <span class="i">c</span>;
</pre></div>
<p><font papago-translate="translated">우리 작은 통역사는 이제 무언가를 기억할 수 있습니다.</font><font papago-translate="translated"> 우리는 완전한 기능을 갖춘 프로그래밍 언어와 비슷한 무언가에 점점 더 가까워지고 있습니다.</font></p>
<div class="challenges">
<h2><a href="https://youhogeon-meritz.github.io/statements-and-state.html#challenges" id="challenges"><font papago-translate="translated">과제들</font></a></h2>
<ol>
<li>
<p><font papago-translate="translated">REPL은 더 이상 단일 식을 입력하고 결과 값을 자동으로 출력하는 것을 지원하지 않습니다.</font><font papago-translate="translated"> 그건 정말 힘든 일입니다.</font><font papago-translate="translated"> 사용자가 문과 표현식을 모두 입력할 수 있도록 REPL에 지원을 추가합니다.</font><font papago-translate="translated"> 그들이 진술을 입력하면, 실행하세요.</font><font papago-translate="translated"> 식을 입력하면 평가하고 결과 값을 표시합니다.</font></p>
</li>
<li>
<p><font papago-translate="splitted"><font papago-translate="translated">아마도 Lox가 변수 초기화에 대해 좀 더 명확하게 설명하기를 원할 수도 있습니다.</font><font papago-translate="translated"> 변수를 암묵적으로 초기화하는 대신 </font></font><code translate="no">nil</code><font papago-translate="splitted"><font papago-translate="translated">, 초기화되거나 할당되지 않은 변수에 접근하는 것을 런타임 오류로 만듭니다:</font></font></p>
<div class="codehilite"><pre translate="no"><span class="c">// No initializers.</span>
<span class="k">var</span> <span class="i">a</span>;
<span class="k">var</span> <span class="i">b</span>;

<span class="i">a</span> = <span class="s">"assigned"</span>;
<span class="k">print</span> <span class="i">a</span>; <span class="c">// OK, was assigned first.</span>

<span class="k">print</span> <span class="i">b</span>; <span class="c">// Error!</span>
</pre></div>
</li>
<li>
<p><font papago-translate="translated">다음 프로그램은 무엇을 하나요?</font></p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="i">a</span> = <span class="n">1</span>;
{
  <span class="k">var</span> <span class="i">a</span> = <span class="i">a</span> + <span class="n">2</span>;
  <span class="k">print</span> <span class="i">a</span>;
}
</pre></div>
<p><font papago-translate="translated">어떻게 할<em> 것이라고 예상</em>하셨나요?</font><font papago-translate="translated"> 그렇게 해야 한다고 생각하시나요?</font><font papago-translate="translated"> 당신이 익숙한 다른 언어의 유사한 코드는 무엇을 하나요?</font><font papago-translate="translated"> 사용자들이 이것이 무엇을 할 것이라고 기대할 것 같나요?</font></p>
</li>
</ol>
</div>
<div class="design-note">
<h2><a href="https://youhogeon-meritz.github.io/statements-and-state.html#design-note" id="design-note"><font papago-translate="translated">디자인 노트:</font><font papago-translate="translated"> 암묵적 변수 선언</font></a></h2>
<p><font papago-translate="translated">Lox는 새로운 변수를 선언하고 기존 변수에 할당하는 고유한 구문을 가지고 있습니다.</font><font papago-translate="translated"> 일부 언어는 그것들을 할당 구문으로만 축소합니다.</font><font papago-translate="translated"> 존재하지 않는 변수에 할당하면 자동으로 변수가 생성됩니다.</font><font papago-translate="translated"> <strong>이</strong>를<strong> 암묵적 변수 선언</strong>이라고 하며 Python, Ruby, CoffeeScript 등에 존재합니다.</font><font papago-translate="translated"> JavaScript는 변수를 선언하는 명시적인 구문을 가지고 있지만, 할당 시 새로운 변수를 생성할 수도 있습니다.</font><font papago-translate="translated"> Visual Basic에는<a href="https://msdn.microsoft.com/en-us/library/xe53dz5w(v=vs.100).aspx"> 암시적 변수를 활성화하거나 비활성화할 수 있는 옵션</a>이 있습니다.</font></p>
<p><font papago-translate="translated">동일한 구문이 변수를 할당하거나 생성할 수 있을 때, 각 언어는 사용자가 의도한 행동이 명확하지 않을 때 어떤 일이 일어나는지 결정해야 합니다.</font><font papago-translate="translated"> 특히, 각 언어는 암묵적 선언이 그림자와 어떻게 상호작용하는지, 암묵적으로 선언된 변수가 어떤 범위로 들어가는지 선택해야 합니다.</font></p>
<ul>
<li>
<p><font papago-translate="translated">Python에서는 할당이 항상 현재 함수의 범위에 변수를 생성합니다. 비록 함수 외부에 동일한 이름을 가진 변수가 선언되어 있더라도 마찬가지입니다.</font></p>
</li>
<li>
<p><font papago-translate="translated">Ruby는 로컬 변수와 글로벌 변수에 대해 서로 다른 명명 규칙을 사용하여 약간의 모호성을 피합니다.</font><font papago-translate="translated"> 그러나 Ruby의 블록(C의 "블록"이라기보다는 폐쇄에 가깝습니다)은 고유한 범위를 가지고 있기 때문에 여전히 문제가 있습니다.</font><font papago-translate="translated"> Ruby 할당은 현재 블록 외부에 동일한 이름을 가진 변수가 있는 경우 기존 변수에 할당합니다.</font><font papago-translate="translated"> 그렇지 않으면 현재 블록의 범위에 새 변수가 생성됩니다.</font></p>
</li>
<li>
<p><font papago-translate="translated">여러 면에서 루비를 닮은 CoffeeScript도 비슷합니다.</font><font papago-translate="translated"> 외부 범위에 변수가 있는 경우 항상 가장 바깥쪽 글로벌 범위까지 할당한다고 명시적으로 말하며 그림자를 허용하지 않습니다.</font><font papago-translate="translated"> 그렇지 않으면 현재 함수 범위에 변수가 생성됩니다.</font></p>
</li>
<li>
<p><font papago-translate="translated">JavaScript에서는 할당이 발견되면 모든 범위에서 기존 변수를 수정합니다.</font><font papago-translate="translated"> 그렇지 않으면<em> 암묵</em>적으로<em> 글로벌</em> 범위에 새로운 변수를 생성합니다.</font></p>
</li>
</ul>
<p><font papago-translate="translated">암묵적 선언의 주요 장점은 단순성입니다.</font><font papago-translate="translated"> 문법이 적고 "선언" 개념도 배울 필요가 없습니다.</font><font papago-translate="translated"> 사용자는 물건을 할당하기 시작하면 언어가 이를 파악할 수 있습니다.</font></p>
<p><font papago-translate="translated">C와 같이 정적으로 입력된 오래된 언어들은 명시적 선언의 이점을 누릴 수 있습니다. 이는 각 변수가 어떤 유형을 가지고 있는지와 얼마나 많은 저장 공간을 컴파일러에 할당할지를 사용자에게 알려주기 때문입니다.</font><font papago-translate="translated"> 동적으로 입력된 쓰레기 수집 언어에서는 그다지 필요하지 않으므로 선언을 암시하는 것에서 벗어날 수 있습니다.</font><font papago-translate="translated"> 조금 더 "서사로운" 느낌이 들고, 더 "무슨 말인지 아시죠?"라는 느낌이 듭니다.</font></p>
<p><font papago-translate="translated">하지만 좋은 생각인가요?</font><font papago-translate="translated"> 암묵적 선언에는 몇 가지 문제가 있습니다.</font></p>
<ul>
<li>
<p><font papago-translate="translated">사용자가 기존 변수에 할당하려고 할 수도 있지만, 철자를 잘못 썼을 수도 있습니다.</font><font papago-translate="translated"> 통역사는 그것을 모르기 때문에 조용히 새로운 변수를 생성하고 사용자가 할당하고자 했던 변수는 여전히 이전 값을 유지합니다.</font><font papago-translate="translated"> 이는 특히 JavaScript에서 매우 심각하며, 오타가<em> 전역</em> 변수를 생성하여 다른 코드를 방해할 수 있습니다.</font></p>
</li>
<li>
<p><font papago-translate="translated">JS, Ruby, 그리고 CoffeeScript는 동일한 이름을 가진 기존 변수의 존재를 사용하여 할당이 새로운 변수를 생성하는지 아니면<span class="em"></span><span class="em"></span> 기존 변수에 할당하는지 여부를 결정합니다.</font><font papago-translate="translated"> 즉, 주변 범위에 새로운 변수를 추가하면 기존 코드의 의미가 바뀔 수 있습니다.</font><font papago-translate="translated"> 한때 지역 변수였던 것이 조용히 그 새로운 외부 변수에 할당될 수 있습니다.</font></p>
</li>
<li>
<p><font papago-translate="translated">Python에서는 현재 함수에 새로운 변수를 생성하는 대신 현재 함수 외부의 변수에 할당<em>할</em> 수 있지만, 그렇게 할 수는 없습니다.</font></p>
</li>
</ul>
<p><font papago-translate="translated">시간이 지나면서 내가 아는 암묵적 변수 선언 언어들은 이러한 문제들을 해결하기 위해 더 많은 기능과 복잡성을 추가하게 되었습니다.</font></p>
<ul>
<li>
<p><font papago-translate="translated">JavaScript에서 전역 변수를 암묵적으로 선언하는 것은 오늘날 보편적으로 실수로 간주됩니다.</font><font papago-translate="translated"> "엄격 모드"는 이를 비활성화하고 컴파일 오류로 만듭니다.</font></p>
</li>
<li>
<p><font papago-translate="splitted"><font papago-translate="translated">파이썬이 a를 추가했습니다 </font></font><code translate="no">global</code><font papago-translate="splitted"><font papago-translate="translated"> 함수 내에서 전역 변수에 명시적으로 할당할 수 있는 문장.</font><font papago-translate="translated"> 나중에 기능 프로그래밍과 중첩 함수가 인기를 끌면서 유사한 기능을 추가했습니다 </font></font><code translate="no">nonlocal</code><font papago-translate="splitted"><font papago-translate="translated"> 함수를 둘러싸는 변수에 할당하는 문장.</font></font></p>
</li>
<li>
<p><font papago-translate="translated">루비는 블록 구문을 확장하여 동일한 이름이 외부 범위에 존재하더라도 특정 변수를 블록에 명시적으로 로컬로 선언할 수 있도록 했습니다.</font></p>
</li>
</ul>
<p><font papago-translate="translated">그 점을 고려할 때, 단순성 논쟁은 대부분 사라졌다고 생각합니다.</font><font papago-translate="translated"> 암묵적인 선언이<em> 올바른 기본 원칙이라는</em> 주장이 있지만, 저는 개인적으로 그것이 덜 설득력이 있다고 생각합니다.</font></p>
<p><font papago-translate="translated">제 생각에는 대부분의 스크립팅 언어가 매우 필수적이고 코드가 꽤 평탄했던 지난 몇 년 동안 암묵적인 선언이 합리적이었다고 생각합니다.</font><font papago-translate="translated"> 프로그래머들이 딥 네스팅, 함수형 프로그래밍, 그리고 클로저에 더 익숙해지면서, 외부 범위의 변수에 접근하는 것이 훨씬 더 일반화되었습니다.</font><font papago-translate="translated"> 이로 인해 사용자는 새로운 변수를 생성할 것인지, 아니면 주변 변수를 재사용할 것인지 명확하지 않은 까다로운 경우에 직면할 가능성이 높아집니다.</font></p>
<p><font papago-translate="translated">그래서 저는 변수를 명시적으로 선언하는 것을 선호합니다. 그래서 Lox는 변수를 요구합니다.</font></p>
</div>
<footer>
<a class="next" href="https://youhogeon-meritz.github.io/control-flow.html"><font papago-translate="translated"> 다음 장: "제어 흐름" → </font></a><font papago-translate="splitted"><font papago-translate="translated"> 로버트 니스트롬이 수작업으로 제작한 -<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE"> © 2015 ~ 2021</a></font></font>
</footer>
</article>
</div>


<div id="papagoTooltip" margin="5" style="display: none;">
        <h1 id="tooltipTitle">원문</h1>
        <p id="tooltipText"></p>
      </div>
      </body></html>