<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link rel="stylesheet" type="text/css" href="cid:css-5d9ed374-fe5a-42cb-9ec3-2dc9eb100840@mhtml.blink" />

<title>Resolving and Binding · Crafting Interpreters</title>
<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta content="width=device-width, initial-scale=1" name="viewport">
<link href="https://youhogeon-meritz.github.io/style.css" rel="stylesheet" type="text/css">
<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600" rel="stylesheet" type="text/css">
<link href="https://youhogeon-meritz.github.io/image/favicon.png" rel="icon" type="image/png">


<!-- Google analytics -->

</head>
<body id="top">
<!-- <div class="scrim"></div> -->
<nav class="wide">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<div class="contents">
<h3><a href="https://youhogeon-meritz.github.io/resolving-and-binding.html#top"><font papago-translate="splitted"><font papago-translate="translated">해결 및 바인딩</font></font><small>11</small></a></h3>
<ul>
<li><a href="https://youhogeon-meritz.github.io/resolving-and-binding.html#static-scope"><small>11.1</small><font papago-translate="splitted"><font papago-translate="translated"> 정적 범위</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/resolving-and-binding.html#semantic-analysis"><small>11.2</small><font papago-translate="splitted"><font papago-translate="translated"> 의미 분석</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/resolving-and-binding.html#a-resolver-class"><small>11.3</small><font papago-translate="splitted"><font papago-translate="translated"> 해결사 클래스</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/resolving-and-binding.html#interpreting-resolved-variables"><small>11.4</small><font papago-translate="splitted"><font papago-translate="translated"> 해결된 변수 해석</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/resolving-and-binding.html#resolution-errors"><small>11.5</small><font papago-translate="splitted"><font papago-translate="translated"> 해상도 오류</font></font></a></li>
<li class="divider"></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/resolving-and-binding.html#challenges"><font papago-translate="translated">과제들</font></a></li>
</ul>
<div class="prev-next">
<a class="left" href="https://youhogeon-meritz.github.io/functions.html" title="기능들" papago-attr-id="1"><font papago-translate="translated">← 이전</font></a>
<a href="https://youhogeon-meritz.github.io/a-tree-walk-interpreter.html" title="나무 산책 통역사" papago-attr-id="2"><font papago-translate="translated">↑ 위로</font></a>
<a class="right" href="https://youhogeon-meritz.github.io/classes.html" title="반" papago-attr-id="3"><font papago-translate="translated">다음 →</font></a>
</div> </div>
</nav>
<nav class="narrow">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<a class="prev" href="https://youhogeon-meritz.github.io/functions.html" title="Functions">←</a>
<a class="next" href="https://youhogeon-meritz.github.io/classes.html" title="Classes">→</a>
</nav>
<div class="page">
<div class="nav-wrapper">
<nav class="floating">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<div class="expandable">
<h3><a href="https://youhogeon-meritz.github.io/resolving-and-binding.html#top"><font papago-translate="splitted"><font papago-translate="translated">해결 및 바인딩</font></font><small>11</small></a></h3>
<ul>
<li><a href="https://youhogeon-meritz.github.io/resolving-and-binding.html#static-scope"><small>11.1</small><font papago-translate="splitted"><font papago-translate="translated"> 정적 범위</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/resolving-and-binding.html#semantic-analysis"><small>11.2</small><font papago-translate="splitted"><font papago-translate="translated"> 의미 분석</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/resolving-and-binding.html#a-resolver-class"><small>11.3</small><font papago-translate="splitted"><font papago-translate="translated"> 해결사 클래스</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/resolving-and-binding.html#interpreting-resolved-variables"><small>11.4</small><font papago-translate="splitted"><font papago-translate="translated"> 해결된 변수 해석</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/resolving-and-binding.html#resolution-errors"><small>11.5</small><font papago-translate="splitted"><font papago-translate="translated"> 해상도 오류</font></font></a></li>
<li class="divider"></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/resolving-and-binding.html#challenges">Challenges</a></li>
</ul>
<div class="prev-next">
<a class="left" href="https://youhogeon-meritz.github.io/functions.html" title="Functions">←&nbsp;Previous</a>
<a href="https://youhogeon-meritz.github.io/a-tree-walk-interpreter.html" title="A Tree-Walk Interpreter">↑&nbsp;Up</a>
<a class="right" href="https://youhogeon-meritz.github.io/classes.html" title="Classes">Next&nbsp;→</a>
</div> </div>
<a id="expand-nav">≡</a>
</nav>
</div>
<article class="chapter">
<div class="number">11</div>
<h1><font papago-translate="translated">해결 및 바인딩</font></h1>
<blockquote>
<p><font papago-translate="translated" class="">가끔씩 당신은 이상한 상황에 처하게 됩니다.</font><font papago-translate="translated"> 점점 더 자연스럽게 들어가지만, 그 한가운데에 있을 때 갑자기 놀라면서 어떻게 이런 일이 일어났는지 스스로에게 묻습니다.</font></p>
<p><cite>Thor Heyerdahl, <em>Kon-Tiki</em></cite></p>
</blockquote>
<p><font papago-translate="translated">저런!</font><font papago-translate="translated"> 우리의 언어 구현이 물타기를 하고 있습니다!</font><font papago-translate="translated"> <a href="https://youhogeon-meritz.github.io/statements-and-state.html">아주</a> 오래 전<a href="https://youhogeon-meritz.github.io/statements-and-state.html">에 변수와 블록을 추가</a>했을 때, 우리는 범위를 아주 정확하게 설정했습니다.</font><font papago-translate="translated" class=""> 하지만<a href="https://youhogeon-meritz.github.io/functions.html"> 나중에 클로저를 추가</a>했을 때, 이전 방수 통역사에 구멍이 뚫렸습니다.</font><font papago-translate="translated" class=""> 대부분의 실제 프로그램은 이 구멍을 통과하지 못할 가능성이 높지만, 언어 구현자로서 우리는 의미론의 가장 깊고 습한 구석에서도 정확성에 신경 쓰겠다는 신성한 맹세를 합니다.</font></p>
<p><font papago-translate="translated">우리는 이 장 전체를 통해 그 유출을 탐구한 다음, 신중하게 수정할 것입니다.</font><font papago-translate="translated"> 그 과정에서 우리는 Lox와 C 전통의 다른 언어들이 사용하는 어휘 범위에 대해 더 엄밀하게 이해하게 될 것입니다.</font><font papago-translate="translated"> <em>사용</em>자의 소스 코드<span class="em"></span>를 실행하지 않고도 의미를 추출할 수 있는 강력한 기술<em>인 의미 분석에</em> 대해서도 배울 수 있는 기회를 얻게 될 것입니다.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/resolving-and-binding.html#static-scope" id="static-scope"><small><font papago-translate="translated">11 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">정적 범위</font></font></a></h2>
<p><font papago-translate="translated">간단한 업데이트: Lox는 대부분의 현대 언어와 마찬가지로<em> 어휘</em> 범위를 사용합니다.</font><font papago-translate="translated"> 즉, 프로그램의 텍스트를 읽기만 하면 변수 이름이 어떤 선언을 의미하는지 파악할 수 있습니다.</font><font papago-translate="translated"> 예를 들어:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="i">a</span> = <span class="s">"outer"</span>;
{
  <span class="k">var</span> <span class="i">a</span> = <span class="s">"inner"</span>;
  <span class="k">print</span> <span class="i">a</span>;
}
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">여기서 우리는 다음을 알고 있습니다 </font></font><code translate="no">a</code><font papago-translate="splitted"><font papago-translate="translated"> 인쇄되는 변수는 이전 줄에 선언된 변수이며, 글로벌 변수는 아닙니다.</font><font papago-translate="translated"> 프로그램을 실행하는 것은<span class="em"></span><span class="em"></span> 이에 영향을<em> 미치지 않습니다.</em></font><font papago-translate="translated"> 범위 규칙은 언어<em>의 정적</em> 의미론의 일부이기 때문에<em> 정적 범위</em>라고도 합니다.</font></font></p>
<p><font papago-translate="translated">저는 그 범위 규칙들을 명확히 설명하지 않았지만, 지금<span name="precise">이 바로 정확성</span>이 필요한 때입니다:</font></p>
<aside name="precise" style="top: 1112px;">
<p><font papago-translate="translated">이것은 여전히 실제 언어 사양만큼 정확하지 않습니다.</font><font papago-translate="translated"> 이러한 문서는 매우 명확해야 하므로 화성인이나 노골적인 악의적인 프로그래머라도 사양의 문자를 따랐다면 올바른 의미를 구현해야 할 것입니다.</font></p>
<p><font papago-translate="translated" class="">이러한 정확성은 경쟁사가 자사 제품이 다른 제품과 호환되지 않도록 고객을 플랫폼에 가두기 위해 언어를 구현할 때 중요합니다.</font><font papago-translate="translated"> 이 책에서는 다행히도 그런 수상한 속임수들을 무시할 수 있습니다.</font></p>
</aside>
<p><strong><font papago-translate="translated">변수 사용은 변수가 사용되는 표현을 둘러싸고 있는 가장 안쪽 범위에서 동일한 이름을 가진 이전 선언을 의미합니다.</font></strong></p>
<p><font papago-translate="translated">그 안에는 풀어야 할 것이 많습니다:</font></p>
<ul>
<li>
<p><font papago-translate="translated">저는 변수 표현과 과제를 모두 다루기 위해 "변수 표현" 대신 "변수 사용"이라고 말합니다.</font><font papago-translate="translated"> 마찬가지로 "변수가 사용되는 표현식"도 마찬가지입니다.</font></p>
</li>
<li>
<p><font papago-translate="translated">"선행"은<em> 프로그램 텍스트</em>에 이전에 나타나는 것을 의미합니다.</font></p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="i">a</span> = <span class="s">"outer"</span>;
{
  <span class="k">print</span> <span class="i">a</span>;
  <span class="k">var</span> <span class="i">a</span> = <span class="s">"inner"</span>;
}
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">여기 </font></font><code translate="no">a</code><font papago-translate="splitted"><font papago-translate="translated"> 인쇄되는 것이 외부 인쇄물<span name="hoisting">입니다</span> </font></font><code translate="no">print</code><font papago-translate="splitted"><font papago-translate="translated"> 그것을 사용하는 진술.</font><font papago-translate="translated"> 대부분의 경우, 직선 코드에서는<em> 텍스트</em>에서 앞에 오는 선언문이<em> 시간</em> 내에 사용되기도 합니다.</font><font papago-translate="translated"> 하지만 항상 그런 것은 아닙니다.</font><font papago-translate="translated"> 보시다시피 함수는 코드의 동적<em> 시간</em> 실행이<em> 더</em> 이상<em> 정적 텍스트</em> 순서를 반영하지 않도록 코드 덩어리를 지연시킬 수 있습니다.</font></font></p>
<aside name="hoisting" style="top: 1548px;">
<p><font papago-translate="splitted"><font papago-translate="translated">JavaScript에서 선언된 변수는 다음과 같습니다 </font></font><code translate="no">var</code><font papago-translate="splitted"><font papago-translate="translated"> 은 암묵적으로 블록의 시작 부분에 "호스팅"됩니다.</font><font papago-translate="translated"> 블록에서 해당 이름의 사용은 선언문 앞에 사용이 나타나더라도 해당 변수를 의미합니다.</font><font papago-translate="translated"> 이것을 JavaScript로 작성할 때:</font></font></p>
<div class="codehilite"><pre translate="no">{
  <span class="i">console</span>.<span class="i">log</span>(<span class="i">a</span>);
  <span class="k">var</span> <span class="i">a</span> = <span class="s">"value"</span>;
}
</pre></div>
<p><font papago-translate="translated">다음과 같이 작동합니다:</font></p>
<div class="codehilite"><pre translate="no">{
  <span class="k">var</span> <span class="i">a</span>; <span class="c">// Hoist.</span>
  <span class="i">console</span>.<span class="i">log</span>(<span class="i">a</span>);
  <span class="i">a</span> = <span class="s">"value"</span>;
}
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">즉, 어떤 경우에는 변수의 초기화가 실행되기 전에 변수를 읽을 수 있는데, 이는 성가신<span class="em"></span> 버그의 원인입니다.</font><font papago-translate="translated"> 대안 </font></font><code translate="no">let</code><font papago-translate="splitted"><font papago-translate="translated"> 변수 선언 구문은 이 문제를 해결하기 위해 나중에 추가되었습니다.</font></font></p>
</aside></li>
<li>
<p><font papago-translate="translated">"가장 안쪽"은 우리의 좋은 친구가 그림자를 드리우고 있기 때문에 존재합니다.</font><font papago-translate="translated"> 범위를 둘러싸는 데에는 주어진 이름을 가진 변수가 여러 개 있을 수 있습니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="i">a</span> = <span class="s">"outer"</span>;
{
  <span class="k">var</span> <span class="i">a</span> = <span class="s">"inner"</span>;
  <span class="k">print</span> <span class="i">a</span>;
}
</pre></div>
<p><font papago-translate="translated">우리의 규칙은 가장 안쪽 범위가 승리한다고 함으로써 이 경우를 명확히 합니다.</font></p>
</li>
</ul>
<p><font papago-translate="translated">이 규칙은 런타임 동작에 대해 언급하지 않기 때문에, 변수 표현식이 프로그램의 전체 실행 동안 항상 동일한 선언을 의미한다는 것을 의미합니다.</font><font papago-translate="translated"> 지금까지 저희 통역사<em>는 대부분</em> 규칙을 올바르게 구현했습니다.</font><font papago-translate="translated"> 하지만 클로저를 추가했을 때 오류가 발생했습니다.</font></p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="i">a</span> = <span class="s">"global"</span>;
{
  <span class="k">fun</span> <span class="i">showA</span>() {
    <span class="k">print</span> <span class="i">a</span>;
  }

  <span class="i">showA</span>();
  <span class="k">var</span> <span class="i">a</span> = <span class="s">"block"</span>;
  <span class="i">showA</span>();
}
</pre></div>
<p><font papago-translate="translated">이것을 입력하고 실행<span name="tricky">하기 전</span>에<em></em> 인쇄할 내용을 결정하세요<span name="tricky">.</span></font></p>
<aside name="tricky" style="top: 2304px;">
<p><font papago-translate="translated">완전히 병적이고 인위적인 프로그램이라는 것을 알고 있습니다.</font><font papago-translate="translated"> 그냥<em> 이상</em>해요.</font><font papago-translate="translated"> 합리적인 사람이라면 이런 코드를 쓸 수 없을 것입니다.</font><font papago-translate="translated"> 안타깝게도 프로그래밍 언어 게임에 오래 머무르면 예상보다 더 많은 시간이 이런 비사로 코드 조각을 다루는 데 할애될 것입니다.</font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">알겠어<span class="ellipse">요...</span> 알겠어요<span class="ellipse">?</span></font><font papago-translate="translated"> 다른 언어로 된 폐쇄에 익숙하다면 "글로벌"이 두 번 인쇄될 것으로 예상할 수 있습니다.</font><font papago-translate="translated"> 첫 번째 호출 </font></font><code translate="no">showA()</code><font papago-translate="splitted"><font papago-translate="translated"> 내부 선언에 도달하지 못했기 때문에 "글로벌"을 반드시 인쇄해야 합니다 </font></font><code translate="no">a</code><font papago-translate="splitted"><font papago-translate="translated"> 하지만 변수 표현식은 항상 동일한 변수로 분해되며, 이는 두 번째 호출을 의미합니다 </font></font><code translate="no">showA()</code><font papago-translate="splitted"><font papago-translate="translated"> 같은 내용을 인쇄해야 합니다.</font></font></p>
<p><font papago-translate="translated">아, 인쇄됩니다:</font></p>
<div class="codehilite"><pre translate="no">global
block
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">이 프로그램은 변수를 재할당하지 않으며 단 하나의 변수만 포함한다는 점을 강조하고 싶습니다 </font></font><code translate="no">print</code><font papago-translate="splitted"><font papago-translate="translated"> 진술.</font><font papago-translate="translated"> 하지만, 어떻게든, 그것은 </font></font><code translate="no">print</code><font papago-translate="splitted"><font papago-translate="translated"> assigned가 없는 변수에 대한 문장은 서로 다른 시점에 두 가지 다른 값을 출력합니다.</font><font papago-translate="translated"> 우리는 분명히 어딘가에서 무언가를 깨뜨렸습니다.</font></font></p>
<h3><a href="https://youhogeon-meritz.github.io/resolving-and-binding.html#scopes-and-mutable-environments" id="scopes-and-mutable-environments"><small><font papago-translate="translated">11 . 1 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">범위 및 변이 가능한 환경</font></font></a></h3>
<p><font papago-translate="translated">우리 통역사에서 환경은 정적 범위의 동적 표현입니다.</font><font papago-translate="translated"> 두 가지는 대부분 서로 동기화되어 있습니다—우리는 새로운 범위에 들어갈 때 새로운 환경을 만들고<span class="em"></span>, 범위를 벗어날 때 그것을 버립니다.</font><font papago-translate="translated"> 환경에서 수행하는 또 다른 작업 중 하나는 변수를 하나로 묶는 것입니다.</font><font papago-translate="translated"> 이것이 바로 우리의 버그가 있는 곳입니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">그 문제적인 예를 살펴보고 각 단계에서 환경이 어떻게 생겼는지 살펴보겠습니다.</font><font papago-translate="translated"> 먼저, 다음과 같이 선언합니다 </font></font><code translate="no">a</code><font papago-translate="splitted"><font papago-translate="translated"> 글로벌 범위에서.</font></font></p><img alt="The global environment with 'a' defined in it." src="https://youhogeon-meritz.github.io/image/resolving-and-binding/environment-1.png">
<p><font papago-translate="splitted"><font papago-translate="translated">그것은 단일 변수가 포함된 단일 환경을 제공합니다.</font><font papago-translate="translated"> 그런 다음 블록에 들어가서 다음과 같은 선언을 실행합니다 </font></font><code translate="no">showA()</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p><img alt="A block environment linking to the global one." src="https://youhogeon-meritz.github.io/image/resolving-and-binding/environment-2.png">
<p><font papago-translate="splitted"><font papago-translate="translated">우리는 블록을 위한 새로운 환경을 확보했습니다.</font><font papago-translate="translated"> 그 안에서 우리는 하나의 이름을 선언합니다, </font></font><code translate="no">showA</code><font papago-translate="splitted"><font papago-translate="translated">, 함수를 나타내기 위해 생성하는 LoxFunction 객체에 바인딩됩니다.</font><font papago-translate="translated"> 그 객체는 다음과 같습니다 </font></font><code translate="no">closure</code><font papago-translate="splitted"><font papago-translate="translated"> 함수가 선언된 환경을 캡처하는 필드로, 블록의 환경에 대한 참조를 다시 제공합니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">이제 우리는 전화합니다 </font></font><code translate="no">showA()</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p><img alt="An empty environment for showA()'s body linking to the previous two. 'a' is resolved in the global environment." src="https://youhogeon-meritz.github.io/image/resolving-and-binding/environment-3.png">
<p><font papago-translate="splitted"><font papago-translate="translated">통역사는 다음과 같은 기능 본문을 위한 새로운 환경을 동적으로 생성합니다 </font></font><code translate="no">showA()</code><font papago-translate="splitted"><font papago-translate="translated">. 그 함수는 변수를 선언하지 않기 때문에 비어 있습니다.</font><font papago-translate="translated"> 그 환경의 모체는 기능의 폐쇄, 즉 외부 블록<span class="em"></span> 환경입니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">본문 내부 </font></font><code translate="no">showA()</code><font papago-translate="splitted"><font papago-translate="translated">, 우리는 다음과 같은 가치를 인쇄합니다 </font></font><code translate="no">a</code><font papago-translate="splitted"><font papago-translate="translated">. 통역사는 환경의 사슬을 걸으며 이 값을 찾습니다.</font><font papago-translate="translated"> 그것은 전 세계 환경까지 도달한 후 그곳에서 찾아내고 인쇄합니다 </font></font><code translate="no">"global"</code><font papago-translate="splitted"><font papago-translate="translated">.좋아요.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">다음으로, 우리는 두 번째를 선언합니다 </font></font><code translate="no">a</code><font papago-translate="splitted"><font papago-translate="translated">, 이번에는 블록 안에서.</font></font></p><img alt="The block environment has both 'a' and 'showA' now." src="https://youhogeon-meritz.github.io/image/resolving-and-binding/environment-4.png">
<p><font papago-translate="splitted"><font papago-translate="translated"><span class="em"></span><span class="em"></span>다음과 같은 블록, 즉 동일한 범위에 있습니다 </font></font><code translate="no">showA()</code><font papago-translate="splitted"><font papago-translate="translated">, 그래서 그것은 같은 환경으로 들어갑니다. 그것은 또한 같은 환경이기도 합니다 </font></font><code translate="no">showA()</code><font papago-translate="splitted"><font papago-translate="translated">의 폐쇄는 다음을 의미합니다.</font><font papago-translate="translated"> 여기서부터 흥미로워집니다.</font><font papago-translate="translated"> 우리는 전화합니다 </font></font><code translate="no">showA()</code><font papago-translate="splitted"><font papago-translate="translated"> 다시.</font></font></p><img alt="An empty environment for showA()'s body linking to the previous two. 'a' is resolved in the block environment." src="https://youhogeon-meritz.github.io/image/resolving-and-binding/environment-5.png">
<p><font papago-translate="splitted"><font papago-translate="translated">우리는 다음과 같은 신체를 위한 새로운 빈 환경을 만듭니다 </font></font><code translate="no">showA()</code><font papago-translate="splitted"><font papago-translate="translated"> 다시 한 번, 그 잠금장치에 연결하고 본체를 작동시킵니다.</font><font papago-translate="translated"> 통역사가 환경의 사슬을 걸어 다니며 </font></font><code translate="no">a</code><font papago-translate="splitted"><font papago-translate="translated">, 이제<em> 새로운</em> 것을 발견합니다</font></font> <code translate="no">a</code><font papago-translate="splitted"><font papago-translate="translated"> 블록 환경에서.</font><font papago-translate="translated"> 부.</font></font></p>
<p><font papago-translate="translated">저는 당신의 비공식적인 직관에 동의하기를 바라며 환경을 구현하기로 선택했습니다.</font><font papago-translate="translated"> 우리는 블록 내의 모든 코드가 동일한 범위 내에 있다고 생각하는 경향이 있으므로, 우리의 통역사는 이를 표현하기 위해 단일 환경을 사용합니다.</font><font papago-translate="translated"> 각 환경은 변경 가능한 해시 테이블입니다.</font><font papago-translate="translated"> 새로운 로컬 변수가 선언되면 해당 범위에 대한 기존 환경에 추가됩니다.</font></p>
<p><font papago-translate="translated">그 직관은 인생의 많은 사람들처럼 옳지 않습니다.</font><font papago-translate="translated"> 블록이 반드시 같은 범위인 것은 아닙니다.</font><font papago-translate="translated"> 고려:</font></p>
<div class="codehilite"><pre translate="no">{
  <span class="k">var</span> <span class="i">a</span>;
  <span class="c">// 1.</span>
  <span class="k">var</span> <span class="i">b</span>;
  <span class="c">// 2.</span>
}
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">첫 번째 표시된 선에서만 </font></font><code translate="no">a</code><font papago-translate="splitted"><font papago-translate="translated"> 범위 내에 있습니다.</font><font papago-translate="translated"> 두 번째 줄에서, 둘 다 </font></font><code translate="no">a</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">b</code><font papago-translate="splitted"><font papago-translate="translated"> "범위"를 선언의 집합으로 정의하면, 그것들은 분명히 동일한 범위가 아닙니다. 즉, 동일<span class="em"></span>한 선언을 포함하지 않습니다.</font><font papago-translate="translated"> 각각과 같습니다 </font></font><code translate="no">var</code><font papago-translate="splitted"><font papago-translate="translated"> 문은 블록을 두 개의 개별 범위로<span name="split"> 나눕니다</span>. 변수가 선언되기 전의 범위와 새로운 변수가 포함된 이후의 범위입니다.</font></font></p>
<aside name="split" style="top: 4883.5px;">
<p><font papago-translate="splitted"><font papago-translate="translated">일부 언어는 이 분할을 명확하게 설명합니다.</font><font papago-translate="translated"> 스킴 및 ML에서 로컬 변수를 선언할 때 </font></font><code translate="no">let</code><font papago-translate="splitted"><font papago-translate="translated">, 또한 새 변수가 범위 내에 있는 후속 코드를 설명합니다.</font><font papago-translate="translated"> 암묵적인 "블록의 나머지 부분"은 없습니다.</font></font></p>
</aside>
<p><font papago-translate="translated">하지만 우리의 구현에서 환경은 전체 블록이 하나의 범위인 것처럼 작용하며, 시간이 지남에 따라 변하는 범위일 뿐입니다.</font><font papago-translate="translated"> 폐쇄는 그것을 좋아하지 않습니다.</font><font papago-translate="translated"> 함수가 선언되면 현재 환경에 대한 참조를 캡처합니다.</font><font papago-translate="translated"> 함수<em>는 함수가 선언된 순간 존재했던</em> 환경의 정지된 스냅샷을 캡처<em>해야 합니다</em>.</font><font papago-translate="translated"> 하지만 대신 Java 코드에서는 실제 변경 가능한 환경 객체에 대한 참조가 있습니다.</font><font papago-translate="translated"> 나중에 환경이 해당하는 범위에서 변수가 선언되면, 선언이<em></em> 함수 앞에 있지 않더라도 폐쇄는 새로운 변수를 보게 됩니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/resolving-and-binding.html#persistent-environments" id="persistent-environments"><small><font papago-translate="translated">11 . 1 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">지속적인 환경</font></font></a></h3>
<p><font papago-translate="translated"><strong>지속적인 데이터 구조</strong>라고 불리는 것을 사용하는 프로그래밍 스타일이 있습니다.</font><font papago-translate="translated"> 명령형 프로그래밍에서 익숙한 흐릿한 데이터 구조와 달리, 지속적인 데이터 구조는 절대 직접 수정할 수 없습니다.</font><font papago-translate="translated"> 대신 기존 구조에 대한 모든 "수정"은 원본 데이터와 새로운 수정 사항을 모두 포함하는<span name="copy"> 새로운</span> 객체를 생성합니다.</font><font papago-translate="translated"> 원본은 변경되지 않은 채로 남아 있습니다.</font></p>
<aside name="copy" style="top: 5315.5px;">
<p><font papago-translate="translated">이것은 각 작업의 구조를 복사하는 데 엄청난 메모리와 시간을 낭비할 수 있다는 것처럼 들립니다.</font><font papago-translate="translated"> 실제로 지속적인 데이터 구조는 대부분의 데이터를 서로 다른 "복사본" 사이에 공유합니다.</font></p>
</aside>
<p><font papago-translate="translated">그 기술을 환경에 적용한다면, 변수를 선언할 때마다 이전에 선언된 모든 변수와 하나의 새로운 이름을 포함하는<em> 새로운</em> 환경이 반환될 것입니다.</font><font papago-translate="translated"> 변수를 선언하면 변수가 선언되기 전과 그 후에 환경이 존재하는 암묵적인 "분할"이 이루어집니다:</font></p><img alt="Separate environments before and after the variable is declared." src="https://youhogeon-meritz.github.io/image/resolving-and-binding/split.png">
<p><font papago-translate="translated">폐쇄는 함수가 선언되었을 때 실행 중인 환경 인스턴스에 대한 참조를 유지합니다.</font><font papago-translate="translated"> 해당 블록에서 나중에 선언하면 새로운 환경 객체가 생성되므로, 폐쇄 시 새로운 변수가 표시되지 않고 버그가 수정될 것입니다.</font></p>
<p><font papago-translate="translated">이것은 문제를 해결하는 합법적인 방법이며, 스키마 인터프리터에서 환경을 구현하는 고전적인 방법입니다.</font><font papago-translate="translated"> 우리는 Lox를 위해 그렇게 할 수 있지만, 그것은 돌아가서 기존 코드 더미를 변경하는 것을 의미할 것입니다.</font></p>
<p><font papago-translate="translated">그 부분은 제가 끌고 가지 않겠습니다.</font><font papago-translate="translated"> 우리는 환경을 표현하는 방식을 그대로 유지할 것입니다.</font><font papago-translate="translated"> 데이터를 더 정적으로 구조화하는 대신, 우리는 정적 해상도를 액세스<em> 작업</em> 자체에 적용할 것입니다.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/resolving-and-binding.html#semantic-analysis" id="semantic-analysis"><small><font papago-translate="translated">11 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">의미 분석</font></font></a></h2>
<p><font papago-translate="translated">우리의 통역사는 변수 표현식<span class="em"></span><span class="em"></span>이 평가될 때마다 어떤 선언을 참조하는지 추적<strong>하여 변수를 해결합니다</strong>.</font><font papago-translate="translated"> 그 변수가 천 번 반복되는 루프 안에 흩어져 있다면, 그 변수는 천 번 다시 해결됩니다.</font></p>
<p><font papago-translate="translated">정적 범위는 변수 사용이 항상 동일한 선언으로 해결된다는 것을 의미하며, 이는 텍스트만 봐도 알 수 있습니다.</font><font papago-translate="translated"> 그렇다면 왜 매번 역동적으로 하고 있을까요?</font><font papago-translate="translated"> 그렇게 하면 성가신 버그로 이어지는 구멍이 열릴 뿐만 아니라 불필요하게 느려집니다.</font></p>
<p><font papago-translate="translated">더 나은 해결책은 각 변수 사용을<em> 한 번</em>씩 해결하는 것입니다.</font><font papago-translate="translated"> 사용자의 프로그램을 검사하고, 언급된 모든 변수를 찾아내고, 각각 어떤 선언을 의미하는지 알아내는 코드 조각을 작성합니다.</font><font papago-translate="translated"> 이 과정은<strong> 의미 분석</strong>의 한 예입니다.</font><font papago-translate="translated"> 구문 분석기가 프로그램이 문법적으로 올바른지 여부만 알려주는 경우(<em>통사</em> 분석<em>)</em>, 의미 분석은 더 나아가 프로그램의 일부가 실제로 무엇을 의미하는지 파악하기 시작합니다.</font><font papago-translate="translated"> 이 경우, 우리의 분석은 변수 결합을 해결할 것입니다.</font><font papago-translate="translated"> 표현식<em>이</em> 변수라는 것뿐만 아니라<em> 어떤</em> 변수인지 알게 될 것입니다.</font></p>
<p><font papago-translate="translated">변수와 그 선언 사이의 바인딩을 저장할 수 있는 방법은 여러 가지가 있습니다.</font><font papago-translate="translated"> Lox용 C 인터프리터에 도달하면 로컬<em></em> 변수를 훨씬 더 효율적으로 저장하고 액세스할 수 있는 방법이 제공됩니다.</font><font papago-translate="translated"> 하지만 Jlox의 경우 기존 코드베이스에 가해지는 부수적인 피해를 최소화하고 싶습니다.</font><font papago-translate="translated"> 대부분 고급 코드를 많이 버리고 싶지 않습니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">대신 기존 환경 클래스를 최대한 활용하는 방식으로 해상도를 저장합니다.</font><font papago-translate="translated"> 액세스 방법 기억하기 </font></font><code translate="no">a</code><font papago-translate="splitted"><font papago-translate="translated"> 문제가 있는 예제에서 해석됩니다.</font></font></p><img alt="An empty environment for showA()'s body linking to the previous two. 'a' is resolved in the global environment." src="https://youhogeon-meritz.github.io/image/resolving-and-binding/environment-3.png">
<p><font papago-translate="splitted"><font papago-translate="translated">첫 번째(정확한) 평가에서는 글로벌 선언을 찾기 전에 체인 내 세 가지 환경을 살펴봅니다 </font></font><code translate="no">a</code><font papago-translate="splitted"><font papago-translate="translated">. 그러면, 내면이 </font></font><code translate="no">a</code><font papago-translate="splitted"><font papago-translate="translated"> 나중에 블록 범위로 선언되며, 글로벌 범위를 흐리게 합니다.</font></font></p><img alt="An empty environment for showA()'s body linking to the previous two. 'a' is resolved in the block environment." src="https://youhogeon-meritz.github.io/image/resolving-and-binding/environment-5.png">
<p><font papago-translate="splitted"><font papago-translate="translated">다음 조회는 체인을 따라 진행되며 </font></font><code translate="no">a</code><font papago-translate="splitted"><font papago-translate="translated"> <em>두 번째</em> 환경에서 멈추고 거기서 멈춥니다.</font><font papago-translate="translated"> 각 환경은 변수가 선언되는 단일 어휘 범위에 해당합니다.</font><font papago-translate="translated"> 변수 조회가 환경 체인에서 항상<em> 동일</em>한 수의 링크를 걸도록 보장할 수 있다면, 매번 동일한 범위에서 동일한 변수를 찾을 수 있을 것입니다.</font></font></p>
<p><font papago-translate="translated">변수 사용을 "해결"하려면 선언된 변수가 환경 체인에서 얼마나 "홉" 떨어져 있는지만 계산하면 됩니다.</font><font papago-translate="translated"> 흥미로운 질문은 이 계산<em>을 언제</em> 해야 할지, 아니면 다르게 말하면 통역사의 구현에서<span class="em"></span> 코드를 어디에 입력해야 할지입니다?</font></p>
<p><font papago-translate="translated">소스 코드의 구조를 기반으로 정적 속성을 계산하기 때문에 명확한 답은 파서에 있습니다.</font><font papago-translate="translated"> 그것이 전통적인 집이며, 나중에 클록스에 넣을 곳입니다.</font><font papago-translate="translated"> 여기서도 작동하겠지만, 다른 기술을 보여드리기 위해 변명의 여지를 드리고 싶습니다.</font><font papago-translate="translated"> 우리는 해결사를 별도의 패스로 작성할 것입니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/resolving-and-binding.html#a-variable-resolution-pass" id="a-variable-resolution-pass"><small><font papago-translate="translated">11 . 2 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">가변 해상도 패스</font></font></a></h3>
<p><font papago-translate="translated">구문 분석기가 구문 트리를 생성한 후, 인터프리터가 구문 트리를 실행하기 전에 트리에 포함된 모든 변수를 해결하기 위해 한 번의 워크를 수행합니다.</font><font papago-translate="translated"> 구문 분석과 실행 사이에는 추가적인 패스가 일반적입니다.</font><font papago-translate="translated"> Lox에 정적 유형이 있다면, 우리는 그 안에 타입 체커를 넣을 수 있을 것입니다.</font><font papago-translate="translated"> 최적화는 종종 이렇게 별도의 패스로 구현됩니다.</font><font papago-translate="translated"> 기본적으로 런타임에만 사용할 수 있는 상태에 의존하지 않는 모든 작업은 이러한 방식으로 수행할 수 있습니다.</font></p>
<p><font papago-translate="translated">우리의 가변 해상도 패스는 일종의 미니 인터프리터처럼 작동합니다.</font><font papago-translate="translated"> 트리를 걸어 각 노드를 방문하지만 정적 분석은 동적 실행과는 다릅니다:</font></p>
<ul>
<li>
<p><font papago-translate="translated"><strong>부작용이 없습니다.</strong></font><font papago-translate="translated"> 정적 분석이 인쇄 문을 방문하면 실제로 아무것도 인쇄하지 않습니다.</font><font papago-translate="translated"> 네이티브 함수나 외부에 도달하는 다른 연산에 대한 호출은 중단되며 아무런 효과가 없습니다.</font></p>
</li>
<li>
<p><font papago-translate="splitted"><font papago-translate="translated"><strong>제어 흐름이 없습니다.</strong></font><font papago-translate="translated"> 루프는<span name="fix"> 한 번</span>만 방문됩니다.</font><font papago-translate="translated"> 두 지점 모두 방문됩니다 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 진술들.</font><font papago-translate="translated"> 논리 연산자는 단락되지 않습니다.</font></font></p>
</li>
</ul>
<aside name="fix" style="top: 7883.5px;">
<p><font papago-translate="translated">변수 해상도는 각 노드에 한 번씩 닿기 때문에 성능은 O<em>(n</em>)이며<em>, 여기서 n</em>은 구문 트리 노드의 수입니다.</font><font papago-translate="translated"> 더 정교한 분석은 더 복잡할 수 있지만, 대부분은 선형적이거나 멀지 않은 곳에서 신중하게 설계되었습니다.</font><font papago-translate="translated"> 사용자의 프로그램이 증가함에 따라 컴파일러의 속도가 기하급수적으로 느려지면 당황스러운 가짜 패스가 됩니다.</font></p>
</aside>
<h2><a href="https://youhogeon-meritz.github.io/resolving-and-binding.html#a-resolver-class" id="a-resolver-class"><small><font papago-translate="translated">11 . 3</font></small><font papago-translate="splitted"><font papago-translate="translated">해결사 클래스</font></font></a></h2>
<p><font papago-translate="translated">자바의 모든 것과 마찬가지로, 우리의 가변 해상도 패스는 클래스로 구현됩니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 새 파일 만들기</font></font></div>
<pre translate="no"><span class="k">package</span> <span class="i">com.craftinginterpreters.lox</span>;

<span class="k">import</span> <span class="i">java.util.HashMap</span>;
<span class="k">import</span> <span class="i">java.util.List</span>;
<span class="k">import</span> <span class="i">java.util.Map</span>;
<span class="k">import</span> <span class="i">java.util.Stack</span>;

<span class="k">class</span> <span class="t">Resolver</span> <span class="k">implements</span> <span class="t">Expr</span>.<span class="t">Visitor</span>&lt;<span class="t">Void</span>&gt;, <span class="t">Stmt</span>.<span class="t">Visitor</span>&lt;<span class="t">Void</span>&gt; {
  <span class="k">private</span> <span class="k">final</span> <span class="t">Interpreter</span> <span class="i">interpreter</span>;

  <span class="t">Resolver</span>(<span class="t">Interpreter</span> <span class="i">interpreter</span>) {
    <span class="k">this</span>.<span class="i">interpreter</span> = <span class="i">interpreter</span>;
  }
}
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, create new file</div>
<p><font papago-translate="translated">해결사는 구문 트리의 모든 노드를 방문해야 하므로, 우리가 이미 가지고 있는 방문자 추상화를 구현합니다.</font><font papago-translate="translated"> 변수를 해결할 때 흥미로운 노드는 몇 가지 종류에 불과합니다:</font></p>
<ul>
<li>
<p><font papago-translate="translated">블록 문은 포함된 문에 대한 새로운 범위를 도입합니다.</font></p>
</li>
<li>
<p><font papago-translate="translated">함수 선언은 자신의 몸에 새로운 범위를 도입하고 그 범위 내에서 매개변수를 묶습니다.</font></p>
</li>
<li>
<p><font papago-translate="translated">변수 선언은 현재 범위에 새로운 변수를 추가합니다.</font></p>
</li>
<li>
<p><font papago-translate="translated">변수와 할당 표현식은 변수를 해결해야 합니다.</font></p>
</li>
</ul>
<p><font papago-translate="splitted"><font papago-translate="translated">나머지 노드들은 특별한 일을 하지 않지만, 여전히 하위 트리로 이동하는 방문 방법을 구현해야 합니다.</font><font papago-translate="translated"> 비록 </font></font><code translate="no">+</code><font papago-translate="splitted"><font papago-translate="translated"> 식<em> 자체에는</em> 해결할 변수가 없으며, 그 피연산자 중 어느 쪽이든 해결할 수 있습니다.</font></font></p>
<h3><a href="https://youhogeon-meritz.github.io/resolving-and-binding.html#resolving-blocks" id="resolving-blocks"><small><font papago-translate="translated">11 . 3 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">블록 해결</font></font></a></h3>
<p><font papago-translate="translated">블록은 모든 마법이 일어나는 지역 범위를 만들기 때문에 블록부터 시작합니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> Res<em>olver</em>() 다음에 추가</font></font></div>
<pre translate="no">  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitBlockStmt</span>(<span class="t">Stmt</span>.<span class="t">Block</span> <span class="i">stmt</span>) {
    <span class="i">beginScope</span>();
    <span class="i">resolve</span>(<span class="i">stmt</span>.<span class="i">statements</span>);
    <span class="i">endScope</span>();
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>Resolver</em>()</div>
<p><font papago-translate="translated">이것은 새로운 범위를 시작하고, 블록 내부의 문장들을 탐색한 다음, 범위를 버립니다.</font><font papago-translate="translated"> 재미있는 것은 그 도우미 방법들에 있습니다.</font><font papago-translate="translated"> 간단한 것부터 시작합니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> Res<em>olver</em>() 다음에 추가</font></font></div>
<pre translate="no">  <span class="t">void</span> <span class="i">resolve</span>(<span class="t">List</span>&lt;<span class="t">Stmt</span>&gt; <span class="i">statements</span>) {
    <span class="k">for</span> (<span class="t">Stmt</span> <span class="i">statement</span> : <span class="i">statements</span>) {
      <span class="i">resolve</span>(<span class="i">statement</span>);
    }
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>Resolver</em>()</div>
<p><font papago-translate="translated">이렇게 하면 문장 목록이 표시되고 각 문장이 해결됩니다.</font><font papago-translate="translated"> 차례로 호출됩니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>방문</em> 후 추가 Bl<em>ockStmt</em>()</font></font></div>
<pre translate="no">  <span class="k">private</span> <span class="t">void</span> <span class="i">resolve</span>(<span class="t">Stmt</span> <span class="i">stmt</span>) {
    <span class="i">stmt</span>.<span class="i">accept</span>(<span class="k">this</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>visitBlockStmt</em>()</div>
<p><font papago-translate="translated">우리가 그것을 하는 동안, 나중에 식을 해결하기 위해 필요한 또 다른 과부하를 추가해 보겠습니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>해결</em> 후 추가(Stmt stmt)</font></font></div>
<pre translate="no">  <span class="k">private</span> <span class="t">void</span> <span class="i">resolve</span>(<span class="t">Expr</span> <span class="i">expr</span>) {
    <span class="i">expr</span>.<span class="i">accept</span>(<span class="k">this</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>resolve</em>(Stmt stmt)</div>
<p><font papago-translate="splitted"><font papago-translate="translated">이 방법들은 다음과 유사합니다 </font></font><code translate="no">evaluate()</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">execute()</code><font papago-translate="splitted"><font papago-translate="translated"> 인터프리터 메서드—그 메서드들은 주어진 구문 트리<span class="em"></span> 노드에 방문자 패턴을 적용합니다.</font></font></p>
<p><font papago-translate="translated">정말 흥미로운 행동은 스코프 주변에 있습니다.</font><font papago-translate="translated"> 새 블록 범위가 이렇게 생성됩니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>해결</em> 후 () 추가</font></font></div>
<pre translate="no">  <span class="k">private</span> <span class="t">void</span> <span class="i">beginScope</span>() {
    <span class="i">scopes</span>.<span class="i">push</span>(<span class="k">new</span> <span class="t">HashMap</span>&lt;<span class="t">String</span>, <span class="t">Boolean</span>&gt;());
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>resolve</em>()</div>
<p><font papago-translate="translated">어휘 범위는 해석자와 해석자 모두에 위치합니다.</font><font papago-translate="translated"> 그들은 마치 더미처럼 행동합니다.</font><font papago-translate="translated"> 인터프리터는 연결된 목록인 환경<span class="em"></span> 객체 체인을 사용하여 스택을 구현합니다.</font><font papago-translate="translated"> 해결사에서는 실제 Java 스택을 사용합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  private final Interpreter interpreter;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 클래스 리<em>졸버</em>에서</font></font></div>
<pre class="insert" translate="no">  <span class="k">private</span> <span class="k">final</span> <span class="t">Stack</span>&lt;<span class="t">Map</span>&lt;<span class="t">String</span>, <span class="t">Boolean</span>&gt;&gt; <span class="i">scopes</span> = <span class="k">new</span> <span class="t">Stack</span>&lt;&gt;();
</pre><pre class="insert-after" translate="no">
  Resolver(Interpreter interpreter) {
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in class <em>Resolver</em></div>
<p><font papago-translate="translated">이 필드는 현재 범위 내의 스코프 스택을 추적합니다.</font><font papago-translate="translated"> 스택의 각 요소는 단일 블록 범위를 나타내는 맵입니다.</font><font papago-translate="translated"> 키는 환경에서와 같이 변수 이름입니다.</font><font papago-translate="translated"> 값들은 불리언(Booleans)입니다. 그 이유는 곧 설명드리겠습니다.</font></p>
<p><font papago-translate="translated">스코프 스택은 로컬 블록 스코프에만 사용됩니다.</font><font papago-translate="translated"> 글로벌 범위에서 최상위 수준으로 선언된 변수는 Lox에서 더 동적이기 때문에 해결사가 추적하지 않습니다.</font><font papago-translate="translated"> 변수를 해결할 때 로컬 스코프 스택에서 변수를 찾을 수 없다면 전역 변수여야 한다고 가정합니다.</font></p>
<p><font papago-translate="translated">스코프는 명시적인 스택에 저장되므로 하나를 나가는 것이 간단합니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated" class=""> <em>beginScope</em>() 다음에 추가</font></font></div>
<pre translate="no">  <span class="k">private</span> <span class="t">void</span> <span class="i">endScope</span>() {
    <span class="i">scopes</span>.<span class="i">pop</span>();
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>beginScope</em>()</div>
<p><font papago-translate="translated">이제 빈 스코프 스택을 밀어서 터뜨릴 수 있습니다.</font><font papago-translate="translated"> 몇 가지를 넣겠습니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/resolving-and-binding.html#resolving-variable-declarations" id="resolving-variable-declarations"><small><font papago-translate="translated">11 . 3 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">변수 선언 해결</font></font></a></h3>
<p><font papago-translate="translated">변수 선언을 해결하면 현재 가장 안쪽 스코프의 맵에 새 항목이 추가됩니다.</font><font papago-translate="translated"> 간단해 보이지만, 우리가 해야 할 작은 춤이 있습니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>방문</em> 후 추가 Bl<em>ockStmt</em>()</font></font></div>
<pre translate="no">  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitVarStmt</span>(<span class="t">Stmt</span>.<span class="t">Var</span> <span class="i">stmt</span>) {
    <span class="i">declare</span>(<span class="i">stmt</span>.<span class="i">name</span>);
    <span class="k">if</span> (<span class="i">stmt</span>.<span class="i">initializer</span> != <span class="k">null</span>) {
      <span class="i">resolve</span>(<span class="i">stmt</span>.<span class="i">initializer</span>);
    }
    <span class="i">define</span>(<span class="i">stmt</span>.<span class="i">name</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>visitBlockStmt</em>()</div>
<p><font papago-translate="translated">다음과 같은 재미있는 엣지 케이스를 처리하기 위해 바인딩을 두 단계로 나누고 선언한 다음 정의합니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="i">a</span> = <span class="s">"outer"</span>;
{
  <span class="k">var</span> <span class="i">a</span> = <span class="i">a</span>;
}
</pre></div>
<p><font papago-translate="translated">로컬 변수의 초기화자가 선언되는 변수와 이름이 같은 변수를 참조하면 어떻게 되나요?</font><font papago-translate="translated"> 몇 가지 옵션이 있습니다:</font></p>
<ol>
<li>
<p><font papago-translate="splitted"><font papago-translate="translated"><strong>초기화기를 실행한 다음 새 변수를 범위에 넣습니다.</strong></font><font papago-translate="translated"> 여기, 새로운 지역 </font></font><code translate="no">a</code><font papago-translate="splitted"><font papago-translate="translated"> <em>글로벌</em> 값인 "outer"로 초기화됩니다.</font><font papago-translate="translated"> 다시 말해, 이전 선언은 다음과 같은 것으로 간주될 것입니다:</font></font></p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="i">temp</span> = <span class="i">a</span>; <span class="c">// Run the initializer.</span>
<span class="k">var</span> <span class="i">a</span>;        <span class="c">// Declare the variable.</span>
<span class="i">a</span> = <span class="i">temp</span>;     <span class="c">// Initialize it.</span>
</pre></div>
</li>
<li>
<p><font papago-translate="splitted"><font papago-translate="translated"><strong>새 변수를 범위에 넣은 다음 초기화기를 실행합니다.</strong></font><font papago-translate="translated"> 즉, 변수가 초기화되기 전에 관찰할 수 있으므로 어떤 값을 가질지 파악해야 합니다.</font><font papago-translate="translated"> 아마도 </font></font><code translate="no">nil</code><font papago-translate="splitted"><font papago-translate="translated">. 즉, 새로운 지역을 의미합니다 </font></font><code translate="no">a</code><font papago-translate="splitted"><font papago-translate="translated"> 암묵적으로 초기화된 값으로 다시 initial화될 것입니다, </font></font><code translate="no">nil</code><font papago-translate="splitted"><font papago-translate="translated">. 이제 분리수거는 다음과 같이 보일 것입니다:</font></font></p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="i">a</span>; <span class="c">// Define the variable.</span>
<span class="i">a</span> = <span class="i">a</span>; <span class="c">// Run the initializer.</span>
</pre></div>
</li>
<li>
<p><font papago-translate="translated"><strong>변수를 초기화할 때 참조하는 것을 오류로 만드세요.</strong></font><font papago-translate="translated"> 초기화자가 변수를 초기화 중이라고 언급할 경우 컴파일 시간이나 런타임에 인터프리터가 실패하도록 합니다.</font></p>
</li>
</ol>
<p><font papago-translate="translated">처음 두 가지 옵션 중 하나가 실제로 사용자<em>가 원하는</em> 것처럼 보이나요?</font><font papago-translate="translated"> 섀도잉은 드물고 종종 오류가 발생하기 때문에 섀도잉 변수의 값을 기준으로 섀도잉 변수를 초기화하는 것은 의도적이지 않은 것 같습니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">두 번째 옵션은 훨씬 덜 유용합니다.</font><font papago-translate="translated"> 새 변수<em>는 항상</em> 값을 갖습니다 </font></font><code translate="no">nil</code><font papago-translate="splitted"><font papago-translate="translated">. 이름으로 언급하는 것은 의미가 없습니다.</font><font papago-translate="translated"> 명시적으로 사용할 수 있습니다 </font></font><code translate="no">nil</code><font papago-translate="splitted"><font papago-translate="translated"> 대신.</font></font></p>
<p><font papago-translate="translated">처음 두 가지 옵션은 사용자 오류를 가릴 가능성이 높기 때문에, 세 번째 옵션을 선택하겠습니다.</font><font papago-translate="translated"> 또한 런타임 오류가 아닌 컴파일 오류로 만들겠습니다.</font><font papago-translate="translated"> 그렇게 하면 코드가 실행되기 전에 사용자에게 문제를 알릴 수 있습니다.</font></p>
<p><font papago-translate="translated">이를 위해서는 식을 방문할 때 어떤 변수에 대한 초기화기 내부에 있는지 알아야 합니다.</font><font papago-translate="translated"> 바인딩을 두 단계로 나누어 수행합니다.</font><font papago-translate="translated"> 첫 번째는<strong> 선언</strong>하는 것입니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>endScope</em>() 뒤에 추가</font></font></div>
<pre translate="no">  <span class="k">private</span> <span class="t">void</span> <span class="i">declare</span>(<span class="t">Token</span> <span class="i">name</span>) {
    <span class="k">if</span> (<span class="i">scopes</span>.<span class="i">isEmpty</span>()) <span class="k">return</span>;

    <span class="t">Map</span>&lt;<span class="t">String</span>, <span class="t">Boolean</span>&gt; <span class="i">scope</span> = <span class="i">scopes</span>.<span class="i">peek</span>();
    <span class="i">scope</span>.<span class="i">put</span>(<span class="i">name</span>.<span class="i">lexeme</span>, <span class="k">false</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>endScope</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">선언은 변수를 가장 안쪽 범위에 추가하여 외부 변수를 가리고 변수가 존재한다는 것을 알 수 있도록 합니다.</font><font papago-translate="translated"> 이름을 바인딩하여 "아직 준비되지 않음"으로 표시합니다 </font></font><code translate="no">false</code><font papago-translate="splitted"><font papago-translate="translated"> 스코프 맵에서.</font><font papago-translate="translated"> 스코프 맵에서 키와 관련된 값은 해당 변수의 초기화를 완료했는지 여부를 나타냅니다.</font></font></p>
<p><font papago-translate="translated">변수를 선언한 후, 새로운 변수가 현재 존재하지만 사용할 수 없는 동일한 범위에서 초기화 표현식을 해결합니다.</font><font papago-translate="translated"> 초기화 표현식이 완료되면 변수는 프라임 타임에 사용할 준비가 됩니다.</font><font papago-translate="translated"> <strong>우리</strong>는<strong> 그것을 정의</strong>함으로써 그렇게 합니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> ()<em> 선언</em> 후 추가</font></font></div>
<pre translate="no">  <span class="k">private</span> <span class="t">void</span> <span class="i">define</span>(<span class="t">Token</span> <span class="i">name</span>) {
    <span class="k">if</span> (<span class="i">scopes</span>.<span class="i">isEmpty</span>()) <span class="k">return</span>;
    <span class="i">scopes</span>.<span class="i">peek</span>().<span class="i">put</span>(<span class="i">name</span>.<span class="i">lexeme</span>, <span class="k">true</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>declare</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">스코프 맵에서 변수 값을 다음과 같이 설정합니다 </font></font><code translate="no">true</code><font papago-translate="splitted"><font papago-translate="translated"> 완전히 초기화되어 사용 가능하도록 표시합니다.</font><font papago-translate="translated"> 살아 있습니다! </font></font></p>
<h3><a href="https://youhogeon-meritz.github.io/resolving-and-binding.html#resolving-variable-expressions" id="resolving-variable-expressions"><small><font papago-translate="translated">11 . 3 . 3</font></small><font papago-translate="splitted"><font papago-translate="translated">변수 표현식 해결</font></font></a></h3>
<p><font papago-translate="translated">변수 선언과 함수 선언은 이제 범위<span class="em"></span><span class="em"></span> 맵에 씁니다.</font><font papago-translate="translated"> 그 지도들은 변수 표현식을 풀 때 읽힙니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>visit</em>V<em>arStmt</em>() 방문 후 추가</font></font></div>
<pre translate="no">  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitVariableExpr</span>(<span class="t">Expr</span>.<span class="t">Variable</span> <span class="i">expr</span>) {
    <span class="k">if</span> (!<span class="i">scopes</span>.<span class="i">isEmpty</span>() &amp;&amp;
        <span class="i">scopes</span>.<span class="i">peek</span>().<span class="i">get</span>(<span class="i">expr</span>.<span class="i">name</span>.<span class="i">lexeme</span>) == <span class="t">Boolean</span>.<span class="i">FALSE</span>) {
      <span class="t">Lox</span>.<span class="i">error</span>(<span class="i">expr</span>.<span class="i">name</span>,
          <span class="s">"Can't read local variable in its own initializer."</span>);
    }

    <span class="i">resolveLocal</span>(<span class="i">expr</span>, <span class="i">expr</span>.<span class="i">name</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>visitVarStmt</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">먼저, 변수가 자체 초기화기 내부에서 접근되고 있는지 확인합니다.</font><font papago-translate="translated"> 이것이 바로 스코프 맵의 값들이 작용하는 지점입니다.</font><font papago-translate="translated"> 변수가 현재 범위에 존재하지만 그 값이 다음과 같은 경우 </font></font><code translate="no">false</code><font papago-translate="splitted"><font papago-translate="translated">, 그것은 우리가 그것을 선언했지만 아직 정의하지 않았다는 것을 의미합니다.</font><font papago-translate="translated"> 우리는 그 오류를 보고합니다.</font></font></p>
<p><font papago-translate="translated">그 확인 후에, 우리는 실제로 이 도우미를 사용하여 변수 자체를 해결합니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>정의</em>된 () 후에 추가</font></font></div>
<pre translate="no">  <span class="k">private</span> <span class="t">void</span> <span class="i">resolveLocal</span>(<span class="t">Expr</span> <span class="i">expr</span>, <span class="t">Token</span> <span class="i">name</span>) {
    <span class="k">for</span> (<span class="t">int</span> <span class="i">i</span> = <span class="i">scopes</span>.<span class="i">size</span>() - <span class="n">1</span>; <span class="i">i</span> &gt;= <span class="n">0</span>; <span class="i">i</span>--) {
      <span class="k">if</span> (<span class="i">scopes</span>.<span class="i">get</span>(<span class="i">i</span>).<span class="i">containsKey</span>(<span class="i">name</span>.<span class="i">lexeme</span>)) {
        <span class="i">interpreter</span>.<span class="i">resolve</span>(<span class="i">expr</span>, <span class="i">scopes</span>.<span class="i">size</span>() - <span class="n">1</span> - <span class="i">i</span>);
        <span class="k">return</span>;
      }
    }
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>define</em>()</div>
<p><font papago-translate="translated">이것은 타당한 이유로 변수를 평가하기 위한 환경의 코드와 매우 유사해 보입니다.</font><font papago-translate="translated"> 우리는 가장 안쪽 범위에서 시작하여 각 지도에서 일치하는 이름을 찾아 바깥쪽으로 나아갑니다.</font><font papago-translate="translated"> 변수를 찾으면 현재 가장 안쪽 범위와 변수가 발견된 범위 사이의 범위 수를 넘겨 해결합니다.</font><font papago-translate="translated"> 따라서 현재 범위에서 변수가 발견되면 0으로 넘어갑니다.</font><font papago-translate="translated"> 만약 그것이 즉시 둘러싸이는 범위에 있다면, 1.</font><font papago-translate="translated"> 이해했습니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">모든 블록 범위를 통과하고 변수를 찾지 못하면 해결되지 않은 상태로 두고 전역적이라고 가정합니다.</font><font papago-translate="translated"> 우리는 그것을 구현할 것입니다 </font></font><code translate="no">resolve()</code><font papago-translate="splitted"><font papago-translate="translated"> 조금 후에 방법.</font><font papago-translate="translated"> 지금은 다른 구문 노드들을 계속 살펴봅시다.</font></font></p>
<h3><a href="https://youhogeon-meritz.github.io/resolving-and-binding.html#resolving-assignment-expressions" id="resolving-assignment-expressions"><small><font papago-translate="translated">11 . 3 . 4</font></small><font papago-translate="splitted"><font papago-translate="translated">과제 표현식 해결하기</font></font></a></h3>
<p><font papago-translate="translated">변수를 참조하는 또 다른 표현은 할당입니다.</font><font papago-translate="translated"> 하나를 해결하는 것은 다음과 같습니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>visit</em>V<em>arStmt</em>() 방문 후 추가</font></font></div>
<pre translate="no">  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitAssignExpr</span>(<span class="t">Expr</span>.<span class="t">Assign</span> <span class="i">expr</span>) {
    <span class="i">resolve</span>(<span class="i">expr</span>.<span class="i">value</span>);
    <span class="i">resolveLocal</span>(<span class="i">expr</span>, <span class="i">expr</span>.<span class="i">name</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>visitVarStmt</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">먼저, 할당된 값에 다른 변수에 대한 참조가 포함된 경우 해당 값의 식을 해결합니다.</font><font papago-translate="translated"> 그런 다음 기존 기능을 사용합니다 </font></font><code translate="no">resolveLocal()</code><font papago-translate="splitted"><font papago-translate="translated"> 할당된 변수를 해결하는 방법.</font></font></p>
<h3><a href="https://youhogeon-meritz.github.io/resolving-and-binding.html#resolving-function-declarations" id="resolving-function-declarations"><small><font papago-translate="translated">11 . 3 . 5</font></small><font papago-translate="splitted"><font papago-translate="translated">함수 선언 해결</font></font></a></h3>
<p><font papago-translate="translated">마지막으로, 기능들.</font><font papago-translate="translated"> 함수는 이름을 묶고 범위를 도입합니다.</font><font papago-translate="translated"> 함수 자체의 이름은 함수가 선언되는 주변 범위에 속합니다.</font><font papago-translate="translated"> 함수의 본문에 들어갈 때, 우리는 또한 그 매개변수를 그 내부 함수 범위에 묶습니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>방문</em> 후 추가 Bl<em>ockStmt</em>()</font></font></div>
<pre translate="no">  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitFunctionStmt</span>(<span class="t">Stmt</span>.<span class="t">Function</span> <span class="i">stmt</span>) {
    <span class="i">declare</span>(<span class="i">stmt</span>.<span class="i">name</span>);
    <span class="i">define</span>(<span class="i">stmt</span>.<span class="i">name</span>);

    <span class="i">resolveFunction</span>(<span class="i">stmt</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>visitBlockStmt</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">유사하게 </font></font><code translate="no">visitVariableStmt()</code><font papago-translate="splitted"><font papago-translate="translated">, 현재 범위에서 함수의 이름을 선언하고 정의합니다.</font><font papago-translate="translated"> 변수와 달리 함수의 본문을 해결하기 전에 이름을 열심히 정의합니다.</font><font papago-translate="translated"> 이를 통해 함수는 자신의 몸 안에서 자신을 재귀적으로 지칭할 수 있습니다.</font></font></p>
<p><font papago-translate="translated">그런 다음 이를 사용하여 함수의 본문을 해결합니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>해결</em> 후 () 추가</font></font></div>
<pre translate="no">  <span class="k">private</span> <span class="t">void</span> <span class="i">resolveFunction</span>(<span class="t">Stmt</span>.<span class="t">Function</span> <span class="i">function</span>) {
    <span class="i">beginScope</span>();
    <span class="k">for</span> (<span class="t">Token</span> <span class="i">param</span> : <span class="i">function</span>.<span class="i">params</span>) {
      <span class="i">declare</span>(<span class="i">param</span>);
      <span class="i">define</span>(<span class="i">param</span>);
    }
    <span class="i">resolve</span>(<span class="i">function</span>.<span class="i">body</span>);
    <span class="i">endScope</span>();
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>resolve</em>()</div>
<p><font papago-translate="translated">나중에 수업을 추가할 때 Lox 메서드를 해결하는 데도 사용할 예정이므로 별도의 메서드입니다.</font><font papago-translate="translated"> 그것은 신체에 대한 새로운 범위를 생성한 다음 각 기능 매개변수에 대한 변수를 결합합니다.</font></p>
<p><font papago-translate="translated">준비가 되면 해당 범위의 기능 본체를 해결합니다.</font><font papago-translate="translated"> 이것은 통역사가 함수 선언을 처리하는 방식과는 다릅니다.</font><font papago-translate="translated"> <em>런타임</em> 시 함수를 선언하는 것은 함수의 본문에 아무런 영향을 미치지 않습니다.</font><font papago-translate="translated"> 기능이 호출될 때까지 신체는 접촉하지 않습니다.</font><font papago-translate="translated"> <em>정적</em> 분석에서는 즉시 몸속으로 이동합니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/resolving-and-binding.html#resolving-the-other-syntax-tree-nodes" id="resolving-the-other-syntax-tree-nodes"><small><font papago-translate="translated">11 . 3 . 6</font></small><font papago-translate="splitted"><font papago-translate="translated">다른 구문 트리 노드 해결하기</font></font></a></h3>
<p><font papago-translate="translated">그것은 문법의 흥미로운 부분을 다룹니다.</font><font papago-translate="translated"> 우리는 변수가 선언되거나 읽히거나 작성되는 모든 장소와 범위가 생성되거나 파괴되는 모든 장소를 다룹니다.</font><font papago-translate="translated"> 변수 해상도의 영향을 받지 않더라도, 다른 모든 구문 트리 노드의 하위 트리로 반복하기 위해서는 방문 방법도 필요합니다.</font><font papago-translate="translated"> 지루해서<span name="boring"> 죄송하지만</span>, 조금만 참아<span name="boring">주세요.</span></font><font papago-translate="translated"> 우리는 "위에서 아래로" 가서 진술부터 시작할 것입니다.</font></p>
<aside name="boring" style="top: 14875.5px;">
<p><font papago-translate="translated">책에는 이 통역사들을 위한 모든 코드 라인이 포함될 것이라고 말씀드렸습니다.</font><font papago-translate="translated"> 모두 흥미진진할 거라고는 말하지 않았습니다.</font></p>
</aside>
<p><font papago-translate="translated">표현식 문에는 횡단할 단일 표현식이 포함되어 있습니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>방문</em> 후 추가 Bl<em>ockStmt</em>()</font></font></div>
<pre translate="no">  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitExpressionStmt</span>(<span class="t">Stmt</span>.<span class="t">Expression</span> <span class="i">stmt</span>) {
    <span class="i">resolve</span>(<span class="i">stmt</span>.<span class="i">expression</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>visitBlockStmt</em>()</div>
<p><font papago-translate="translated">if 문에는 조건에 대한 표현이 있고 분기에 대한 한두 개의 문장이 있습니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>방문</em> 후 추가</font><font papago-translate="translated"><em>FunctionStmt</em>()</font></font></div>
<pre translate="no">  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitIfStmt</span>(<span class="t">Stmt</span>.<span class="t">If</span> <span class="i">stmt</span>) {
    <span class="i">resolve</span>(<span class="i">stmt</span>.<span class="i">condition</span>);
    <span class="i">resolve</span>(<span class="i">stmt</span>.<span class="i">thenBranch</span>);
    <span class="k">if</span> (<span class="i">stmt</span>.<span class="i">elseBranch</span> != <span class="k">null</span>) <span class="i">resolve</span>(<span class="i">stmt</span>.<span class="i">elseBranch</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>visitFunctionStmt</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">여기에서는 해상도가 해석과 어떻게 다른지 확인할 수 있습니다.</font><font papago-translate="translated"> 해결할 때 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 문, 제어 흐름이 없습니다.</font><font papago-translate="translated"> 우리는 조건과<em> 두</em> 가지를 모두 해결합니다.</font><font papago-translate="translated"> 동적 실행이 실행 중인 분기에만 들어가는 경우, 정적 분석은 실행<span class="em"></span><em></em><em> 가능</em>한 모든 분기를 분석하는 보수적인 분석입니다.</font><font papago-translate="translated"> 런타임에 둘 중 하나에 도달할 수 있으므로 둘 다 해결합니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">표현 문처럼, a </font></font><code translate="no">print</code><font papago-translate="splitted"><font papago-translate="translated"> 문에는 단일 하위 표현식이 포함되어 있습니다.</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>방문</em> 후 추가<em>IfStmt</em>()</font></font></div>
<pre translate="no">  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitPrintStmt</span>(<span class="t">Stmt</span>.<span class="t">Print</span> <span class="i">stmt</span>) {
    <span class="i">resolve</span>(<span class="i">stmt</span>.<span class="i">expression</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>visitIfStmt</em>()</div>
<p><font papago-translate="translated">반품도 마찬가지입니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>방문</em> 후 추가<em>PrintStmt</em>()</font></font></div>
<pre translate="no">  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitReturnStmt</span>(<span class="t">Stmt</span>.<span class="t">Return</span> <span class="i">stmt</span>) {
    <span class="k">if</span> (<span class="i">stmt</span>.<span class="i">value</span> != <span class="k">null</span>) {
      <span class="i">resolve</span>(<span class="i">stmt</span>.<span class="i">value</span>);
    }

    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>visitPrintStmt</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">에서와 같이 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 진술, a와 함께 </font></font><code translate="no">while</code><font papago-translate="splitted"><font papago-translate="translated"> 진술: 우리는 그것의 상태를 해결하고 몸을 정확히 한 번 해결합니다.</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>visit</em>V<em>arStmt</em>() 방문 후 추가</font></font></div>
<pre translate="no">  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitWhileStmt</span>(<span class="t">Stmt</span>.<span class="t">While</span> <span class="i">stmt</span>) {
    <span class="i">resolve</span>(<span class="i">stmt</span>.<span class="i">condition</span>);
    <span class="i">resolve</span>(<span class="i">stmt</span>.<span class="i">body</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>visitVarStmt</em>()</div>
<p><font papago-translate="translated">그것은 모든 진술을 포함합니다.</font><font papago-translate="translated"> 표현으로 넘어<span class="ellipse">갑니다 . . .</span></font></p>
<p><font papago-translate="translated">우리의 오랜 친구 이진 표현.</font><font papago-translate="translated"> 우리는 두 피연산자를 모두 탐색하고 해결합니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>방문</em> 후 추가A<em>ssignEx</em>pr()</font></font></div>
<pre translate="no">  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitBinaryExpr</span>(<span class="t">Expr</span>.<span class="t">Binary</span> <span class="i">expr</span>) {
    <span class="i">resolve</span>(<span class="i">expr</span>.<span class="i">left</span>);
    <span class="i">resolve</span>(<span class="i">expr</span>.<span class="i">right</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>visitAssignExpr</em>()</div>
<p><font papago-translate="translated">통화 내용은 비슷합니다. 우리는 인수 목록을 작성하고<span class="em"></span> 모든 것을 해결합니다.</font><font papago-translate="translated"> 호출되는 것도 표현식(보통 변수 표현식)이므로 그것도 해결됩니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>BinaryExp</em>r<em>() 방문</em> 후 추가</font></font></div>
<pre translate="no">  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitCallExpr</span>(<span class="t">Expr</span>.<span class="t">Call</span> <span class="i">expr</span>) {
    <span class="i">resolve</span>(<span class="i">expr</span>.<span class="i">callee</span>);

    <span class="k">for</span> (<span class="t">Expr</span> <span class="i">argument</span> : <span class="i">expr</span>.<span class="i">arguments</span>) {
      <span class="i">resolve</span>(<span class="i">argument</span>);
    }

    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>visitBinaryExpr</em>()</div>
<p><font papago-translate="translated">괄호는 쉽습니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>방문</em> 후 추가C<em>allEx</em>pr()</font></font></div>
<pre translate="no">  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitGroupingExpr</span>(<span class="t">Expr</span>.<span class="t">Grouping</span> <span class="i">expr</span>) {
    <span class="i">resolve</span>(<span class="i">expr</span>.<span class="i">expression</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>visitCallExpr</em>()</div>
<p><font papago-translate="translated">리터럴이 가장 쉽습니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>방문</em> 후 추가<em>GroupingEx</em>pr()</font></font></div>
<pre translate="no">  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitLiteralExpr</span>(<span class="t">Expr</span>.<span class="t">Literal</span> <span class="i">expr</span>) {
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>visitGroupingExpr</em>()</div>
<p><font papago-translate="translated">문자 그대로의 표현은 변수를 언급하지 않으며 하위 표현식을 포함하지 않으므로 할 일이 없습니다.</font></p>
<p><font papago-translate="translated">정적 분석은 흐름이나 단락을 제어하지 않기 때문에 논리식은 다른 이진 연산자와 정확히 동일합니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>방문</em> 후 추가L<em>iteralEx</em>pr()</font></font></div>
<pre translate="no">  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitLogicalExpr</span>(<span class="t">Expr</span>.<span class="t">Logical</span> <span class="i">expr</span>) {
    <span class="i">resolve</span>(<span class="i">expr</span>.<span class="i">left</span>);
    <span class="i">resolve</span>(<span class="i">expr</span>.<span class="i">right</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>visitLiteralExpr</em>()</div>
<p><font papago-translate="translated">그리고 마지막으로, 마지막 노드.</font><font papago-translate="translated"> 우리는 그것의 하나의 피연산자를 해결합니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>방문</em> 후 Log<em>icalEx</em>pr() 추가</font></font></div>
<pre translate="no">  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitUnaryExpr</span>(<span class="t">Expr</span>.<span class="t">Unary</span> <span class="i">expr</span>) {
    <span class="i">resolve</span>(<span class="i">expr</span>.<span class="i">right</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>visitLogicalExpr</em>()</div>
<p><font papago-translate="translated">이 모든 방문 방법을 사용하면 Java 컴파일러는 Resolver가 Stmt를 완전히 구현한 것에 만족해야 합니다.</font><font papago-translate="translated">방문자와 탐험가.</font><font papago-translate="translated">방문자.</font><font papago-translate="translated"> 지금은 휴식을 취하고, 간식을 먹거나, 낮잠을 잘 수 있는 좋은 시간입니다.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/resolving-and-binding.html#interpreting-resolved-variables" id="interpreting-resolved-variables"><small><font papago-translate="translated">11 . 4</font></small><font papago-translate="splitted"><font papago-translate="translated">해결된 변수 해석</font></font></a></h2>
<p><font papago-translate="translated">우리의 해결책이 무엇에 좋은지 한번 봅시다.</font><font papago-translate="translated"> 변수를 방문할 때마다 현재 범위와 변수가 정의된 범위 사이에 몇 개의 범위가 있는지 통역사에게 알려줍니다.</font><font papago-translate="translated"> 런타임 시, 이는 현재 환경과 인터프리터가 변수<em></em>의 값을 찾을 수 있는 주변 환경 사이의 수에 정확히 해당합니다.</font><font papago-translate="translated"> 해결사는 다음과 같이 호출하여 해당 번호를 통역사에게 넘깁니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Interpreter.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>실행</em> 후 () 추가</font></font></div>
<pre translate="no">  <span class="t">void</span> <span class="i">resolve</span>(<span class="t">Expr</span> <span class="i">expr</span>, <span class="t">int</span> <span class="i">depth</span>) {
    <span class="i">locals</span>.<span class="i">put</span>(<span class="i">expr</span>, <span class="i">depth</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>execute</em>()</div>
<p><font papago-translate="translated">나중에 변수나 할당 표현식이 실행될 때 사용할 수 있도록 해상도 정보를 어딘가에 저장하고 싶은데, 어디에 있을까요?</font><font papago-translate="translated"> 한 가지 분명한 위치는 구문 트리 노드 자체에 있습니다.</font><font papago-translate="translated"> 이는 훌륭한 접근 방식이며, 많은 컴파일러가 이러한 분석 결과를 저장합니다.</font></p>
<p><font papago-translate="translated">그렇게 할 수는 있지만 구문 트리 생성기를 사용해야 합니다.</font><font papago-translate="translated"> 대신, 우리는 또 다른 일반적인 접근 방식을 사용하여 각 구문 트리 노드와 해결된 데이터를 연결하는 맵의<span name="side"> 측면</span>에 저장할 것입니다.</font></p>
<aside name="side" style="top: 18003.5px;">
<p><font papago-translate="translated">"사이드 테이블"이라는 지도는 관련된 객체와 데이터를 따로 저장하는 표 형식의 데이터 구조이기 때문에 들어본<em> 적</em>이<em> 있는</em> 것<em> 같습니다</em>.</font><font papago-translate="translated"> 하지만 그 용어를 검색하려고 할 때마다 가구에 관한 페이지가 나옵니다.</font></p>
</aside>
<p><font papago-translate="translated">IDE와 같은 대화형 도구는 종종 사용자 프로그램의 일부를 점진적으로 재분석하고 재해결합니다.</font><font papago-translate="translated"> 구문 트리의 잎사귀에 숨어 있을 때 다시 계산해야 하는 모든 상태 비트를 찾는 것은 어려울 수 있습니다.</font><font papago-translate="translated"> 이 데이터를 노드 외부에 저장하면<span class="em"></span> 쉽게<em> 폐기</em>할 수 있고, 단순히 지도를 지울 수 있다는 장점이 있습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  private Environment environment = globals;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Interpreter.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 클래스<em> 인터프리터</em>에서</font></font></div>
<pre class="insert" translate="no">  <span class="k">private</span> <span class="k">final</span> <span class="t">Map</span>&lt;<span class="t">Expr</span>, <span class="t">Integer</span>&gt; <span class="i">locals</span> = <span class="k">new</span> <span class="t">HashMap</span>&lt;&gt;();
</pre><pre class="insert-after" translate="no">
  Interpreter() {
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in class <em>Interpreter</em></div>
<p><font papago-translate="translated">같은 변수를 참조하는 여러 개의 표현식이 있을 때 혼동을 피하기 위해 일종의 중첩 트리 구조가 필요하다고 생각할 수 있지만, 각 표현식 노드는 고유한 정체성을 가진 자체 Java 객체입니다.</font><font papago-translate="translated"> 단일 단일 모놀리식 지도는 그것들을 분리하는 데 아무런 문제가 없습니다.</font></p>
<p><font papago-translate="translated">평소처럼 컬렉션을 사용하려면 몇 가지 이름을 가져와야 합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">import java.util.ArrayList;
</pre><div class="source-file"><em>lox/Interpreter.java</em></div>
<pre class="insert" translate="no"><span class="k">import</span> <span class="i">java.util.HashMap</span>;
</pre><pre class="insert-after" translate="no">import java.util.List;
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em></div>
<p><font papago-translate="translated">그리고:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">import java.util.List;
</pre><div class="source-file"><em>lox/Interpreter.java</em></div>
<pre class="insert" translate="no"><span class="k">import</span> <span class="i">java.util.Map</span>;
</pre><pre class="insert-after" translate="no">
class Interpreter implements Expr.Visitor&lt;Object&gt;,
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em></div>
<h3><a href="https://youhogeon-meritz.github.io/resolving-and-binding.html#accessing-a-resolved-variable" id="accessing-a-resolved-variable"><small><font papago-translate="translated">11 . 4 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">해결된 변수 접근하기</font></font></a></h3>
<p><font papago-translate="translated">이제 통역사가 각 변수의 해결된 위치에 접근할 수 있습니다.</font><font papago-translate="translated"> 마침내 우리는 그것을 활용할 수 있게 되었습니다.</font><font papago-translate="translated"> 변수 표현을 위한 방문 방법을 다음과 같이 대체합니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  public Object visitVariableExpr(Expr.Variable expr) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Interpreter.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>visitVariableExpr</em>()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">    <span class="k">return</span> <span class="i">lookUpVariable</span>(<span class="i">expr</span>.<span class="i">name</span>, <span class="i">expr</span>);
</pre><pre class="insert-after" translate="no">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in <em>visitVariableExpr</em>(), replace 1 line</div>
<p><font papago-translate="translated">이는 다음과 같습니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Interpreter.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>visit</em>V<em>ariableEx</em>pr() 방문 후 추가</font></font></div>
<pre translate="no">  <span class="k">private</span> <span class="t">Object</span> <span class="i">lookUpVariable</span>(<span class="t">Token</span> <span class="i">name</span>, <span class="t">Expr</span> <span class="i">expr</span>) {
    <span class="t">Integer</span> <span class="i">distance</span> = <span class="i">locals</span>.<span class="i">get</span>(<span class="i">expr</span>);
    <span class="k">if</span> (<span class="i">distance</span> != <span class="k">null</span>) {
      <span class="k">return</span> <span class="i">environment</span>.<span class="i">getAt</span>(<span class="i">distance</span>, <span class="i">name</span>.<span class="i">lexeme</span>);
    } <span class="k">else</span> {
      <span class="k">return</span> <span class="i">globals</span>.<span class="i">get</span>(<span class="i">name</span>);
    }
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>visitVariableExpr</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">여기에는 몇 가지 일이 일어나고 있습니다.</font><font papago-translate="translated"> 먼저, 지도에서 해상된 거리를 확인합니다.</font><font papago-translate="translated"> <em>우리</em>는<em> 지역</em> 변수만 해결했다는 점을 기억하세요.</font><font papago-translate="translated"> 글로벌은 특별한 대우를 받으며 맵에 포함되지 않습니다 (따라서 이름은 </font></font><code translate="no">locals</code><font papago-translate="splitted"><font papago-translate="translated">). 따라서 지도에서 거리를 찾지 못하면 전역이어야 합니다.</font><font papago-translate="translated"> 그렇다면, 우리는 그것을 동적으로, 글로벌 환경에서 직접 찾아봅니다.</font><font papago-translate="translated"> 변수가 정의되지 않으면 런타임 오류가 발생합니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">거리를 구<em>하면</em> 지역 변수가 생기고 정적 분석 결과를 활용할 수 있습니다.</font><font papago-translate="translated"> 전화 대신 </font></font><code translate="no">get()</code><font papago-translate="splitted"><font papago-translate="translated">, 우리는 이 새로운 환경 방법을 환경에 관한 방법이라고 부릅니다:</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Environment.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>정의</em>된 () 후에 추가</font></font></div>
<pre translate="no">  <span class="t">Object</span> <span class="i">getAt</span>(<span class="t">int</span> <span class="i">distance</span>, <span class="t">String</span> <span class="i">name</span>) {
    <span class="k">return</span> <span class="i">ancestor</span>(<span class="i">distance</span>).<span class="i">values</span>.<span class="i">get</span>(<span class="i">name</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Environment.java</em>, add after <em>define</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">옛것 </font></font><code translate="no">get()</code><font papago-translate="splitted"><font papago-translate="translated"> 메서드는 주변 환경의 체인을 동적으로 걸어가며 변수가 어딘가에 숨겨져 있는지 확인하기 위해 각 환경을 샅샅이 뒤집니다.</font><font papago-translate="translated"> 하지만 이제 우리는 체인의 어떤 환경에서 변수가 발생할지 정확히 알고 있습니다.</font><font papago-translate="translated"> 우리는 이 도우미 방법을 사용하여 그것에 도달합니다:</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Environment.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>정의</em>된 () 후에 추가</font></font></div>
<pre translate="no">  <span class="t">Environment</span> <span class="i">ancestor</span>(<span class="t">int</span> <span class="i">distance</span>) {
    <span class="t">Environment</span> <span class="i">environment</span> = <span class="k">this</span>;
    <span class="k">for</span> (<span class="t">int</span> <span class="i">i</span> = <span class="n">0</span>; <span class="i">i</span> &lt; <span class="i">distance</span>; <span class="i">i</span>++) {
      <span class="i">environment</span> = <span class="i">environment</span>.<span class="i">enclosing</span>;<span name="coupled"> </span>
    }

    <span class="k">return</span> <span class="i">environment</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Environment.java</em>, add after <em>define</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">이것은 고정된 수의 홉을 부모 사슬 위로 걸어 올라가 그곳의 환경을 반환합니다.</font><font papago-translate="translated"> 일단 우리가 그것을 가지게 되면, </font></font><code translate="no">getAt()</code><font papago-translate="splitted"><font papago-translate="translated"> 단순히 해당 환경의 지도에서 변수 값을 반환합니다.</font><font papago-translate="translated"> 변수가 있는지 확인할 필요도 없습니다. 해결사가<span class="em"></span> 이미 변수를 찾았기 때문에 변수가 있는지 확인할 필요도 없습니다.</font></font></p>
<aside name="coupled" style="top: 19666.5px;">
<p><font papago-translate="translated">통역사가 그 지도에 변수가 있다고 가정하는 방식은 마치 맹목적으로 날아가는 것처럼 느껴집니다.</font><font papago-translate="translated"> 인터프리터 코드는 해결사가 제 역할을 수행하고 변수를 올바르게 해결했다고 신뢰합니다.</font><font papago-translate="translated"> 이는 이 두 클래스 간의 깊은 연관성을 의미합니다.</font><font papago-translate="translated"> 해결사에서 범위를 터치하는 각 코드 라인은 환경을 수정하기 위해 인터프리터에서 정확히 일치해야 합니다.</font></p>
<p><font papago-translate="translated">책의 코드를 작성할 때 리졸버와 인터프리터 코드가 약간 맞지 않는 미묘한 버그를 발견했기 때문에 직접 그 연결고리를 느꼈습니다.</font><font papago-translate="translated"> 그것들을 추적하는 것은 어려웠습니다.</font><font papago-translate="translated"> 이를 더 쉽게 만드는 한 가지 도구는 해석자가 Java의 assert 문 또는 기타 검증 도구를 사용하여 해결사가 이미<span class="em"></span><span class="em"></span> 유지했을 것으로 예상하는 계약을 명시적으로 주장하도록 하는 것입니다.</font></p>
</aside>
<h3><a href="https://youhogeon-meritz.github.io/resolving-and-binding.html#assigning-to-a-resolved-variable" id="assigning-to-a-resolved-variable"><small><font papago-translate="translated">11 . 4 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">해결된 변수에 할당하기</font></font></a></h3>
<p><font papago-translate="translated">변수를 할당하여 사용할 수도 있습니다.</font><font papago-translate="translated"> 과제 표현식 방문의 변경 사항도 비슷합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  public Object visitAssignExpr(Expr.Assign expr) {
    Object value = evaluate(expr.value);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Interpreter.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>visit</em>A<em>ssignEx</em>pr()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">
    <span class="t">Integer</span> <span class="i">distance</span> = <span class="i">locals</span>.<span class="i">get</span>(<span class="i">expr</span>);
    <span class="k">if</span> (<span class="i">distance</span> != <span class="k">null</span>) {
      <span class="i">environment</span>.<span class="i">assignAt</span>(<span class="i">distance</span>, <span class="i">expr</span>.<span class="i">name</span>, <span class="i">value</span>);
    } <span class="k">else</span> {
      <span class="i">globals</span>.<span class="i">assign</span>(<span class="i">expr</span>.<span class="i">name</span>, <span class="i">value</span>);
    }

</pre><pre class="insert-after" translate="no">    return value;
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in <em>visitAssignExpr</em>(), replace 1 line</div>
<p><font papago-translate="translated">다시 한 번 변수의 범위 거리를 확인합니다.</font><font papago-translate="translated"> 발견되지 않으면, 우리는 그것이 글로벌하다고 가정하고 이전과 동일한 방식으로 처리합니다.</font><font papago-translate="translated"> 그렇지 않으면, 우리는 이 새로운 방법을 부릅니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated" class="">lox/Environment.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> g<em>etAt</em>() 후에 추가</font></font></div>
<pre translate="no">  <span class="t">void</span> <span class="i">assignAt</span>(<span class="t">int</span> <span class="i">distance</span>, <span class="t">Token</span> <span class="i">name</span>, <span class="t">Object</span> <span class="i">value</span>) {
    <span class="i">ancestor</span>(<span class="i">distance</span>).<span class="i">values</span>.<span class="i">put</span>(<span class="i">name</span>.<span class="i">lexeme</span>, <span class="i">value</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Environment.java</em>, add after <em>getAt</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">~하듯이 </font></font><code translate="no">getAt()</code><font papago-translate="splitted"><font papago-translate="translated"> ~에게 </font></font><code translate="no">get()</code><font papago-translate="splitted"><font papago-translate="translated">, </font></font><code translate="no">assignAt()</code><font papago-translate="splitted"><font papago-translate="translated"> ~에게 </font></font><code translate="no">assign()</code><font papago-translate="splitted"><font papago-translate="translated">. 고정된 수의 환경을 걷고 나서 그 지도에 새로운 값을 입력합니다.</font></font></p>
<p><font papago-translate="translated">이것이 인터프리터의 유일한 변경 사항입니다.</font><font papago-translate="translated"> 이것이 바로 제가 우리의 해결된 데이터를 최소한의 침습적으로 표현한 이유입니다.</font><font papago-translate="translated"> 나머지 모든 노드는 이전과 마찬가지로 계속 작동합니다.</font><font papago-translate="translated"> 환경을 수정하는 코드조차도 변하지 않습니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/resolving-and-binding.html#running-the-resolver" id="running-the-resolver"><small><font papago-translate="translated">11 . 4 . 3</font></small><font papago-translate="splitted"><font papago-translate="translated">해결사 실행하기</font></font></a></h3>
<p><font papago-translate="translated">하지만 실제로 리졸버<em>를 실행</em>해야 합니다.</font><font papago-translate="translated"> 파서가 마법을 부린 후 새 패스를 삽입합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    // Stop if there was a syntax error.
    if (hadError) return;

</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Lox.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font></div>
<pre class="insert" translate="no">    <span class="t">Resolver</span> <span class="i">resolver</span> = <span class="k">new</span> <span class="t">Resolver</span>(<span class="i">interpreter</span>);
    <span class="i">resolver</span>.<span class="i">resolve</span>(<span class="i">statements</span>);

</pre><pre class="insert-after" translate="no">    interpreter.interpret(statements);
</pre></div>
<div class="source-file-narrow"><em>lox/Lox.java</em>, in <em>run</em>()</div>
<p><font papago-translate="translated">구문 분석 오류가 있는 경우 해결사를 실행하지 않습니다.</font><font papago-translate="translated"> 코드에 구문 오류가 있으면 실행되지 않으므로 해결할 가치가 거의 없습니다.</font><font papago-translate="translated"> 구문이 깨끗하다면, 우리는 해결사에게 그 일을 하라고 지시합니다.</font><font papago-translate="translated"> 해결사는 인터프리터에 대한 참조를 가지고 있으며 변수를 통과할 때 해상도 데이터를 직접 입력합니다.</font><font papago-translate="translated"> 통역사가 다음에 실행되면 필요한 모든 것을 갖추게 됩니다.</font></p>
<p><font papago-translate="translated">적어도 해결사<em>가 성공</em>한다면, 그것은 사실입니다.</font><font papago-translate="translated"> 하지만 해결 중 오류는 어떻게 되나요?</font></p>
<h2><a href="https://youhogeon-meritz.github.io/resolving-and-binding.html#resolution-errors" id="resolution-errors"><small><font papago-translate="translated">11 . 5</font></small><font papago-translate="splitted"><font papago-translate="translated">해상도 오류</font></font></a></h2>
<p><font papago-translate="translated">의미 분석 패스를 수행하고 있기 때문에 Lox의 의미를 더 정확하게 만들고 사용자가 코드를 실행하기 전에 버그를 조기에 발견할 수 있도록 도울 수 있는 기회가 있습니다.</font><font papago-translate="translated"> 이 나쁜 소년을 한번 보세요:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">fun</span> <span class="i">bad</span>() {
  <span class="k">var</span> <span class="i">a</span> = <span class="s">"first"</span>;
  <span class="k">var</span> <span class="i">a</span> = <span class="s">"second"</span>;
}
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated"><em>우리</em>는<em> 글로벌</em> 범위에서 동일한 이름을 가진 여러 변수를 선언하는 것을 허용하지만, 로컬 범위에서 그렇게 하는 것은 아마도 실수일 것입니다.</font><font papago-translate="translated"> 변수가 이미 존재한다는 것을 알았다면 다음을 사용하는 대신 변수에 할당했을 것입니다 </font></font><code translate="no">var</code><font papago-translate="splitted"><font papago-translate="translated">. 그리고 만약 그들이 그것이 존재한다는 것을 몰랐다면, 아마도 이전<em></em> 것을 덮어쓸 의도는 없었을 것입니다.</font></font></p>
<p><font papago-translate="translated">이 실수를 해결하는 동안 정적으로 감지할 수 있습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    Map&lt;String, Boolean&gt; scope = scopes.peek();
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> ()<em> 선언</em>에서</font></font></div>
<pre class="insert" translate="no">    <span class="k">if</span> (<span class="i">scope</span>.<span class="i">containsKey</span>(<span class="i">name</span>.<span class="i">lexeme</span>)) {
      <span class="t">Lox</span>.<span class="i">error</span>(<span class="i">name</span>,
          <span class="s">"Already a variable with this name in this scope."</span>);
    }

</pre><pre class="insert-after" translate="no">    scope.put(name.lexeme, false);
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in <em>declare</em>()</div>
<p><font papago-translate="translated">로컬 범위에서 변수를 선언할 때, 우리는 이미 동일한 범위에서 이전에 선언된 모든 변수의 이름을 알고 있습니다.</font><font papago-translate="translated"> 충돌이 발생하면 오류를 보고합니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/resolving-and-binding.html#invalid-return-errors" id="invalid-return-errors"><small><font papago-translate="translated">11 . 5 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">잘못된 반품 오류</font></font></a></h3>
<p><font papago-translate="translated">또 다른 지저분한 작은 대본이 있습니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">return</span> <span class="s">"at top level"</span>;
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">이것은 다음을 실행합니다 </font></font><code translate="no">return</code><font papago-translate="splitted"><font papago-translate="translated"> 진술하지만, 그것은 전혀 함수 내부에 있지 않습니다.</font><font papago-translate="translated"> 최상위 코드입니다.</font><font papago-translate="translated"> 사용자<em>가 어떻게 생각하는지</em> 모르겠지만 Lox가 이를 허용하지 않기를 바란다고 생각합니다.</font></font></p>
<p><font papago-translate="translated">우리는 이것을 정적으로 감지하기 위해 해결사를 확장할 수 있습니다.</font><font papago-translate="translated"> 우리가 나무를 걸으면서 스코프를 추적하는 것과 마찬가지로, 현재 방문 중인 코드가 함수 선언 안에 있는지 여부를 추적할 수 있습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  private final Stack&lt;Map&lt;String, Boolean&gt;&gt; scopes = new Stack&lt;&gt;();
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 클래스 리<em>졸버</em>에서</font></font></div>
<pre class="insert" translate="no">  <span class="k">private</span> <span class="t">FunctionType</span> <span class="i">currentFunction</span> = <span class="t">FunctionType</span>.<span class="i">NONE</span>;
</pre><pre class="insert-after" translate="no">
  Resolver(Interpreter interpreter) {
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in class <em>Resolver</em></div>
<p><font papago-translate="translated">우리는 맨 불리언 대신에 이 재미있는 열거를 사용합니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> Res<em>olver</em>() 다음에 추가</font></font></div>
<pre translate="no">  <span class="k">private</span> <span class="k">enum</span> <span class="t">FunctionType</span> {
    <span class="i">NONE</span>,
    <span class="i">FUNCTION</span>
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>Resolver</em>()</div>
<p><font papago-translate="translated">지금은 좀 멍청해 보이지만, 나중에 몇 가지 사례를 더 추가하면 더 이해가 될 것입니다.</font><font papago-translate="translated"> 함수 선언을 해결할 때, 우리는 그것을 전달합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    define(stmt.name);

</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>방문</em> 중에</font><font papago-translate="translated"><em>FunctionStmt</em>()</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">    <span class="i">resolveFunction</span>(<span class="i">stmt</span>, <span class="t">FunctionType</span>.<span class="i">FUNCTION</span>);
</pre><pre class="insert-after" translate="no">    return null;
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in <em>visitFunctionStmt</em>(), replace 1 line</div>
<p><font papago-translate="splitted"><font papago-translate="translated">오버 인 </font></font><code translate="no">resolveFunction()</code><font papago-translate="splitted"><font papago-translate="translated">, 우리는 그 매개변수를 가져와서 몸을 해결하기 전에 필드에 저장합니다.</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 메서드<em> resolveFunction</em>()</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">  <span class="k">private</span> <span class="t">void</span> <span class="i">resolveFunction</span>(
      <span class="t">Stmt</span>.<span class="t">Function</span> <span class="i">function</span>, <span class="t">FunctionType</span> <span class="i">type</span>) {
    <span class="t">FunctionType</span> <span class="i">enclosingFunction</span> = <span class="i">currentFunction</span>;
    <span class="i">currentFunction</span> = <span class="i">type</span>;

</pre><pre class="insert-after" translate="no">    beginScope();
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, method <em>resolveFunction</em>(), replace 1 line</div>
<p><font papago-translate="translated">필드의 이전 값을 먼저 로컬 변수에 저장합니다.</font><font papago-translate="translated"> 기억하세요, Lox에는 로컬 함수가 있으므로 함수 선언을 임의의 깊이로 중첩할 수 있습니다.</font><font papago-translate="translated"> 우리는 단순히 함수 안에 있다는 것뿐만 아니라<em>, 얼마나 많은</em> 함수 안에 있는지 추적해야 합니다.</font></p>
<p><font papago-translate="translated">명시적인 함수 스택을 사용할 수 있습니다</font><font papago-translate="translated">값을 입력하면 대신 JVM을 다시 사용할 수 있습니다.</font><font papago-translate="translated"> 이전 값을 Java 스택의 로컬에 저장합니다.</font><font papago-translate="translated"> 함수체를 다 해결하면 필드를 해당 값으로 복원합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    endScope();
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>resolveFunction</em>()에서</font></font></div>
<pre class="insert" translate="no">    <span class="i">currentFunction</span> = <span class="i">enclosingFunction</span>;
</pre><pre class="insert-after" translate="no">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in <em>resolveFunction</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">이제 함수 선언에 포함되어 있는지 여부를 항상 알 수 있으므로, 함수 선언을 해결할 때 다음 사항을 확인합니다 </font></font><code translate="no">return</code><font papago-translate="splitted"><font papago-translate="translated"> 진술.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  public Void visitReturnStmt(Stmt.Return stmt) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Resolver.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>visitReturnStmt</em>()</font></font></div>
<pre class="insert" translate="no">    <span class="k">if</span> (<span class="i">currentFunction</span> == <span class="t">FunctionType</span>.<span class="i">NONE</span>) {
      <span class="t">Lox</span>.<span class="i">error</span>(<span class="i">stmt</span>.<span class="i">keyword</span>, <span class="s">"Can't return from top-level code."</span>);
    }

</pre><pre class="insert-after" translate="no">    if (stmt.value != null) {
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in <em>visitReturnStmt</em>()</div>
<p><font papago-translate="translated">멋지지 않나요?</font></p>
<p><font papago-translate="translated">한 조각 더 있습니다.</font><font papago-translate="translated"> 모든 것을 하나로 묶는 메인 Lox 클래스로 돌아가서, 구문 분석 오류가 발생하면 인터프리터를 실행하지 않도록 주의합니다.</font><font papago-translate="translated"> 해당 검사는 구문적으로 유효하지 않은 코드를 해결하려고 하지 않도록 해결기<em> 앞</em>에서 실행됩니다.</font></p>
<p><font papago-translate="translated">하지만 해상도 오류가 있는 경우 인터프리터를 건너뛰어야 하므로<em> 다른</em> 확인을 추가합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    resolver.resolve(statements);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">lox/Lox.java</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font></div>
<pre class="insert" translate="no">
    <span class="c">// Stop if there was a resolution error.</span>
    <span class="k">if</span> (<span class="i">hadError</span>) <span class="k">return</span>;
</pre><pre class="insert-after" translate="no">
    interpreter.interpret(statements);
</pre></div>
<div class="source-file-narrow"><em>lox/Lox.java</em>, in <em>run</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">여기서 다른 많은 분석을 하는 것을 상상할 수 있습니다.</font><font papago-translate="translated"> 예를 들어, 우리가 추가한 경우 </font></font><code translate="no">break</code><font papago-translate="splitted"><font papago-translate="translated"> Lox에 대한 진술은 아마도 루프 내부에서만 사용되도록 하고 싶을 것입니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">더 멀리 가서 반드시<em> 틀리지</em>는 않지만 유용하지는 않은 코드에 대한 경고를 보고할 수 있습니다.</font><font papago-translate="translated"> 예를 들어, 많은 IDE는 다음과 같은 코드가 도달할 수 없는 경우 경고합니다 </font></font><code translate="no">return</code><font papago-translate="splitted"><font papago-translate="translated"> 문 또는 값이 절대 읽히지 않는 로컬 변수.</font><font papago-translate="translated"> 이 모든 것을 고정 방문 패스에 추가하거나<span name="separate"> 별도</span>의 패스로 추가하는 것은 꽤 쉬울 것입니다.</font></font></p>
<aside name="separate" style="top: 23991.5px;">
<p><font papago-translate="translated">하나의 패스로 묶을 다양한 분석의 수를 선택하는 것은 어렵습니다.</font><font papago-translate="translated"> 각자의 책임이 있는 많은 작은 고립 패스는 구현 및 유지 관리가 더 간단합니다.</font><font papago-translate="translated"> 그러나 구문 트리 자체를 탐색하는 데는 실제 런타임 비용이 들기 때문에 여러 분석을 하나의 패스로 묶는 것이 일반적으로 더 빠릅니다.</font></p>
</aside>
<p><font papago-translate="translated">하지만 지금은 그 제한된 양의 분석을 고수하겠습니다.</font><font papago-translate="translated"> 중요한 부분은 우리가 그 이상하고 성가신 엣지 케이스 버그를 하나 수정했다는 점입니다. 하지만 이 작업을 하는 데 이렇게 많은 노력이 필요했다는 것은 놀랄 만한 일입니다.</font></p>
<div class="challenges">
<h2><a href="https://youhogeon-meritz.github.io/resolving-and-binding.html#challenges" id="challenges"><font papago-translate="translated">과제들</font></a></h2>
<ol>
<li>
<p><font papago-translate="translated">다른 변수들이 초기화된 후에야 사용할 수 있는데, 왜 함수의 이름에 묶인 변수를 열심히 정의하는 것이 안전한가요?</font></p>
</li>
<li>
<p><font papago-translate="translated">다른 언어들은 이니셜라이저에서 같은 이름을 참조하는 로컬 변수를 어떻게 처리하나요:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="i">a</span> = <span class="s">"outer"</span>;
{
  <span class="k">var</span> <span class="i">a</span> = <span class="i">a</span>;
}
</pre></div>
<p><font papago-translate="translated">런타임 오류인가요?</font><font papago-translate="translated"> 컴파일 오류?</font><font papago-translate="translated"> 허용되나요?</font><font papago-translate="translated"> 글로벌 변수를 다르게 취급하나요?</font><font papago-translate="translated"> 그들의 선택에 동의하십니까?</font><font papago-translate="translated"> 답변을 정당화하세요.</font></p>
</li>
<li>
<p><font papago-translate="translated">로컬 변수를 사용하지 않는 경우 오류를 보고하도록 해결사를 확장합니다.</font></p>
</li>
<li>
<p><font papago-translate="translated">우리의 해결사는 변수가<em> 어떤</em> 환경에 있는지 계산하지만, 여전히 그 지도에서 이름으로 조회됩니다.</font><font papago-translate="translated"> 더 효율적인 환경 표현은 로컬 변수를 배열로 저장하고 인덱스별로 찾아보는 것입니다.</font></p>
<p><font papago-translate="translated">범위에 선언된 각 지역 변수에 대해 고유한 인덱스를 연결하도록 해결사를 확장합니다.</font><font papago-translate="translated"> 변수 접근을 해결할 때 변수의 범위와 인덱스를 모두 찾아 저장합니다.</font><font papago-translate="translated"> 인터프리터에서 이를 사용하여 맵을 사용하는 대신 인덱스를 기준으로 변수에 빠르게 접근합니다.</font></p>
</li>
</ol>
</div>
<footer>
<a class="next" href="https://youhogeon-meritz.github.io/classes.html"><font papago-translate="translated"> 다음 장: "수업" → </font></a><font papago-translate="splitted"><font papago-translate="translated"> 로버트 니스트롬이 수작업으로 제작한 -<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE"> © 2015 ~ 2021</a></font></font>
</footer>
</article>
</div>


<div id="papagoTooltip" margin="5" style="display: none;">
        <h1 id="tooltipTitle">원문</h1>
        <p id="tooltipText"></p>
      </div>
      </body></html>