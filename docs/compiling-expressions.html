<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link rel="stylesheet" type="text/css" href="cid:css-5210407b-bc33-48f2-b3c4-392e24e24ad9@mhtml.blink" />

<title>Compiling Expressions · Crafting Interpreters</title>
<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta content="width=device-width, initial-scale=1" name="viewport">
<link href="https://youhogeon-meritz.github.io/style.css" rel="stylesheet" type="text/css">
<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600" rel="stylesheet" type="text/css">
<link href="https://youhogeon-meritz.github.io/image/favicon.png" rel="icon" type="image/png">


<!-- Google analytics -->

</head>
<body id="top">
<!-- <div class="scrim"></div> -->
<nav class="wide">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<div class="contents">
<h3><a href="https://youhogeon-meritz.github.io/compiling-expressions.html#top"><font papago-translate="splitted"><font papago-translate="translated">표현식 컴파일하기</font></font><small>17</small></a></h3>
<ul>
<li><a href="https://youhogeon-meritz.github.io/compiling-expressions.html#single-pass-compilation"><small>17.1</small><font papago-translate="splitted"><font papago-translate="translated"> 단일 패스 컴파일</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/compiling-expressions.html#parsing-tokens"><small>17.2</small><font papago-translate="splitted"><font papago-translate="translated"> 토큰 구문 분석</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/compiling-expressions.html#emitting-bytecode"><small>17.3</small><font papago-translate="splitted"><font papago-translate="translated"> 바이트코드 방출</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/compiling-expressions.html#parsing-prefix-expressions"><small>17.4</small><font papago-translate="splitted"><font papago-translate="translated"> 접두사 표현식 구문 분석</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/compiling-expressions.html#parsing-infix-expressions"><small>17.5</small><font papago-translate="splitted"><font papago-translate="translated"> 구문 분석 Infix 식</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/compiling-expressions.html#a-pratt-parser"><small>17.6</small><font papago-translate="splitted"><font papago-translate="translated"> 프랫 파서</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/compiling-expressions.html#dumping-chunks"><small>17.7</small><font papago-translate="splitted"><font papago-translate="translated"> 덤핑 청크</font></font></a></li>
<li class="divider"></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/compiling-expressions.html#challenges"><font papago-translate="translated">과제들</font></a></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/compiling-expressions.html#design-note"><small><font papago-translate="translated">메모</font></small><font papago-translate="splitted"><font papago-translate="translated">파싱일 뿐입니다</font></font></a></li>
</ul>
<div class="prev-next">
<a class="left" href="https://youhogeon-meritz.github.io/scanning-on-demand.html" title="온디맨드 스캔" papago-attr-id="1"><font papago-translate="translated">← 이전</font></a>
<a href="https://youhogeon-meritz.github.io/a-bytecode-virtual-machine.html" title="바이트코드 가상 머신" papago-attr-id="2"><font papago-translate="translated">↑ 위로</font></a>
<a class="right" href="https://youhogeon-meritz.github.io/types-of-values.html" title="가치 유형" papago-attr-id="3"><font papago-translate="translated">다음 →</font></a>
</div> </div>
</nav>
<nav class="narrow">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<a class="prev" href="https://youhogeon-meritz.github.io/scanning-on-demand.html" title="Scanning on Demand">←</a>
<a class="next" href="https://youhogeon-meritz.github.io/types-of-values.html" title="Types of Values">→</a>
</nav>
<div class="page">
<div class="nav-wrapper">
<nav class="floating">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<div class="expandable">
<h3><a href="https://youhogeon-meritz.github.io/compiling-expressions.html#top"><font papago-translate="splitted"><font papago-translate="translated">표현식 컴파일하기</font></font><small>17</small></a></h3>
<ul>
<li><a href="https://youhogeon-meritz.github.io/compiling-expressions.html#single-pass-compilation"><small>17.1</small><font papago-translate="splitted"><font papago-translate="translated"> 단일 패스 컴파일</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/compiling-expressions.html#parsing-tokens"><small>17.2</small><font papago-translate="splitted"><font papago-translate="translated"> 토큰 구문 분석</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/compiling-expressions.html#emitting-bytecode"><small>17.3</small><font papago-translate="splitted"><font papago-translate="translated"> 바이트코드 방출</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/compiling-expressions.html#parsing-prefix-expressions"><small>17.4</small><font papago-translate="splitted"><font papago-translate="translated"> 접두사 표현식 구문 분석</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/compiling-expressions.html#parsing-infix-expressions"><small>17.5</small><font papago-translate="splitted"><font papago-translate="translated"> 구문 분석 Infix 식</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/compiling-expressions.html#a-pratt-parser"><small>17.6</small><font papago-translate="splitted"><font papago-translate="translated"> 프랫 파서</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/compiling-expressions.html#dumping-chunks"><small>17.7</small><font papago-translate="splitted"><font papago-translate="translated"> 덤핑 청크</font></font></a></li>
<li class="divider"></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/compiling-expressions.html#challenges">Challenges</a></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/compiling-expressions.html#design-note"><small>note</small><font papago-translate="splitted"><font papago-translate="translated">파싱일 뿐입니다</font></font></a></li>
</ul>
<div class="prev-next">
<a class="left" href="https://youhogeon-meritz.github.io/scanning-on-demand.html" title="Scanning on Demand">←&nbsp;Previous</a>
<a href="https://youhogeon-meritz.github.io/a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">↑&nbsp;Up</a>
<a class="right" href="https://youhogeon-meritz.github.io/types-of-values.html" title="Types of Values">Next&nbsp;→</a>
</div> </div>
<a id="expand-nav">≡</a>
</nav>
</div>
<article class="chapter">
<div class="number">17</div>
<h1><font papago-translate="translated">표현식 컴파일하기</font></h1>
<blockquote>
<p><font papago-translate="translated">우리 삶의 여정 한가운데서 나는 직진 길을 잃은 어두운 숲 속에 있는 나 자신을 발견했습니다.</font></p>
<p><cite>Dante Alighieri, <em>Inferno</em></cite></p>
</blockquote>
<p><font papago-translate="translated">이 장은 하나도 아니고, 둘도 아닌<em> 세</em> 가지 이유로 흥미진진합니다.</font><font papago-translate="translated"> 먼저, VM 실행 파이프라인의 마지막 세그먼트를 제공합니다.</font><font papago-translate="translated"> 일단 자리를 잡으면, 사용자의 소스 코드를 스캔부터 실행까지 모두 확인할 수 있습니다.</font></p><img alt="Lowering the 'compiler' section of pipe between 'scanner' and 'VM'." src="https://youhogeon-meritz.github.io/image/compiling-expressions/pipeline.png">
<p><font papago-translate="translated">둘째, 우리는 실제 정직<em>한 컴파일러</em>를 작성할 수 있습니다.</font><font papago-translate="translated"> 소스 코드를 구문 분석하고 낮은 수준의 이진 명령어 시리즈를 출력합니다.</font><font papago-translate="translated"> <span name="wirth">물론 바이트코드</span>이며 일부 칩의 기본 명령어 세트는 아니지만, Jlox보다 금속에 훨씬 더 가깝습니다.</font><font papago-translate="translated"> 우리는 곧 진짜 언어 해커가 될 것입니다.</font></p>
<aside name="wirth" style="top: 878px;">
<p><font papago-translate="translated">바이트코드는 니클라우스 워스에게 충분히 좋았고, 아무도 그의 거리 신용에 의문을 제기하지 않았습니다.</font></p>
</aside>
<p><font papago-translate="translated"><span name="pratt">셋째</span>로, 마지막으로 제가 가장 좋아하는 알고리즘 중 하나를 보여드리겠습니다: 본 프랫의 "탑다운 연산자 우선순위 구문 분석"입니다.</font><font papago-translate="translated"> 제가 아는 가장 우아한 표현 방식입니다.</font><font papago-translate="translated"> 접두사 연산자, 접두사, 접두사, infix<em>, mixfix</em> 등 모든<em> 종류의 -fix</em>를 우아하게 처리합니다.</font><font papago-translate="translated"> 땀 한 방울 흘리지 않고 우선순위와 연상성을 다룹니다.</font><font papago-translate="translated"> 난 그것을 좋아해.</font></p>
<aside name="pratt" style="top: 974px;">
<p><font papago-translate="translated">프랫 파서는 업계에서 구전 전통의 일종입니다.</font><font papago-translate="translated"> 제가 읽은 컴파일러나 언어 책은 그들을 가르치지 않습니다.</font><font papago-translate="translated"> 학계에서는 생성된 파서에 매우 집중하고 있으며, 프랫의 기법은 손으로 쓴 파서를 위한 것이기 때문에 간과되고 있습니다.</font></p>
<p><font papago-translate="translated">하지만 핸드롤 파서가 흔한 프로덕션 컴파일러에서는 얼마나 많은 사람들이 알고 있는지 놀랄 것입니다.</font><font papago-translate="translated"> 어디서 배웠는지 물어보면 항상 "아, 몇 년 전에 이 컴파일러를 작업했는데 동료가 이 오래된 프론트엔드에서 가져왔다고 하더군<span class="ellipse">요. .</span>"라고 말합니다</font></p>
</aside>
<p><font papago-translate="translated">평소처럼 재미있는 이야기를 시작하기 전에 몇 가지 사전 준비가 되어 있습니다.</font><font papago-translate="translated"> 디저트를 먹기 전에 채소를 먹어야 합니다.</font><font papago-translate="translated"> 먼저, 스캐너 테스트를 위해 작성한 임시 비계를 버리고 더 유용한 것으로 교체해 보겠습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">InterpretResult interpret(const char* source) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>해석</em>상 ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 두 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">  <span class="t">Chunk</span> <span class="i">chunk</span>;
  <span class="i">initChunk</span>(&amp;<span class="i">chunk</span>);

  <span class="k">if</span> (!<span class="i">compile</span>(<span class="i">source</span>, &amp;<span class="i">chunk</span>)) {
    <span class="i">freeChunk</span>(&amp;<span class="i">chunk</span>);
    <span class="k">return</span> <span class="a">INTERPRET_COMPILE_ERROR</span>;
  }

  <span class="i">vm</span>.<span class="i">chunk</span> = &amp;<span class="i">chunk</span>;
  <span class="i">vm</span>.<span class="i">ip</span> = <span class="i">vm</span>.<span class="i">chunk</span>-&gt;<span class="i">code</span>;

  <span class="t">InterpretResult</span> <span class="i">result</span> = <span class="i">run</span>();

  <span class="i">freeChunk</span>(&amp;<span class="i">chunk</span>);
  <span class="k">return</span> <span class="i">result</span>;
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>interpret</em>(), replace 2 lines</div>
<p><font papago-translate="splitted"><font papago-translate="translated">우리는 새로운 빈 청크를 생성하여 컴파일러에게 전달합니다.</font><font papago-translate="translated"> 컴파일러는 사용자의 프로그램을 가져와서 바이트코드로 청크를 채울 것입니다.</font><font papago-translate="translated"> 적어도 프로그램에 컴파일 오류가 없다면 그렇게 할 것입니다.</font><font papago-translate="translated"> 오류가 발생하면, </font></font><code translate="no">compile()</code><font papago-translate="splitted"><font papago-translate="translated"> 돌아온다 </font></font><code translate="no">false</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고 우리는 사용할 수 없는 덩어리를 버립니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">그렇지 않으면 완료된 청크를 실행할 VM으로 보냅니다.</font><font papago-translate="translated"> VM이 끝나면 청크를 해제하면 끝입니다.</font><font papago-translate="translated"> 보시다시피, 서명은 다음과 같습니다 </font></font><code translate="no">compile()</code><font papago-translate="splitted"><font papago-translate="translated"> 지금은 다릅니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#define clox_compiler_h

</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no"><span class="a">#include "vm.h"</span>

<span class="t">bool</span> <span class="i">compile</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">source</span>, <span class="t">Chunk</span>* <span class="i">chunk</span>);
</pre><pre class="insert-after" translate="no">
#endif
</pre></div>
<div class="source-file-narrow"><em>compiler.h</em>, replace 1 line</div>
<p><font papago-translate="splitted"><font papago-translate="translated">컴파일러가 코드를 작성할 청크를 통과한 다음 </font></font><code translate="no">compile()</code><font papago-translate="splitted"><font papago-translate="translated"> 컴파일 성공 여부를 반환합니다.</font><font papago-translate="translated"> 구현 시 서명에 동일한 변경을 가합니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#include "scanner.h"

</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 함수<em> 컴파일</em> ()</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no"><span class="t">bool</span> <span class="i">compile</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">source</span>, <span class="t">Chunk</span>* <span class="i">chunk</span>) {
</pre><pre class="insert-after" translate="no">  initScanner(source);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, function <em>compile</em>(), replace 1 line</div>
<p><font papago-translate="splitted"><font papago-translate="translated">그 부름은 </font></font><code translate="no">initScanner()</code><font papago-translate="splitted"><font papago-translate="translated"> 이 장의 유일한 행입니다.</font><font papago-translate="translated"> 스캐너를 테스트하기 위해 작성한 임시 코드를 찢고 다음 세 줄로 교체하세요:</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  initScanner(source);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>컴파일</em> ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 13줄 교체</font></font></div>
<pre class="insert" translate="no">  <span class="i">advance</span>();
  <span class="i">expression</span>();
  <span class="i">consume</span>(<span class="a">TOKEN_EOF</span>, <span class="s">"Expect end of expression."</span>);
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>compile</em>(), replace 13 lines</div>
<p><font papago-translate="splitted"><font papago-translate="translated">로의 부름 </font></font><code translate="no">advance()</code><font papago-translate="splitted"><font papago-translate="translated"> 스캐너에서 "펌프를 소수화"합니다.</font><font papago-translate="translated"> 곧 어떤 효과가 있는지 확인해 보겠습니다.</font><font papago-translate="translated"> 그런 다음 단일 표현식을 구문 분석합니다.</font><font papago-translate="translated"> 우리는 아직 진술을 하지 않을 것이므로, 그것이 우리가 지원하는 문법의 유일한 부분입니다.</font><font papago-translate="translated"> <a href="https://youhogeon-meritz.github.io/global-variables.html">몇 장에서 문장을 추가</a>할 때 다시 살펴보겠습니다.</font><font papago-translate="translated"> 표현식을 컴파일한 후 소스 코드의 끝에 있어야 하므로 센티널 EOF 토큰을 확인합니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">우리는 이 함수를 작동시키기 위해 남은 장에서 특히 작은 시간을 보낼 것입니다 </font></font><code translate="no">expression()</code><font papago-translate="splitted"><font papago-translate="translated"> 호출. 일반적으로 우리는 함수 정의에 대해 바로 설명하고 위에서 아래로 구현하는 과정을 진행합니다.</font></font></p>
<p><font papago-translate="translated">이 장은<span name="blog"> 다릅니다</span>.</font><font papago-translate="translated"> 프랫의 파싱 기법은 머릿속에 가득 차 있으면 놀라울 정도로 간단하지만, 한 입 크기로 쪼개기는 조금 까다롭습니다.</font><font papago-translate="translated"> 물론 재귀적인 문제이기도 합니다.</font><font papago-translate="translated"> 하지만 그것은 또한 큰 데이터 테이블에 의존합니다.</font><font papago-translate="translated"> 알고리즘을 구축하면 해당 테이블에 추가 열이 생깁니다.</font></p>
<aside name="blog" style="top: 2570px;">
<p><font papago-translate="translated">이 장에서 클릭하지 않고 개념에 대한 또 다른 해석을 원하신다면, 저는 같은 알고리즘을 가르치되 Java와 객체 지향적인 스타일<a href="http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/">을</a> 사용하는 기사를 작성했습니다<a href="http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/">: "프랫 파싱: 표현 파싱</a>이<a href="http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/"> 쉬워졌다</a>".</font></p>
</aside>
<p><font papago-translate="translated">테이블을 확장할 때마다 40줄의 코드를 다시 살펴보고 싶지 않습니다.</font><font papago-translate="translated"> 그래서 우리는 외부에서 파서의 중심으로 들어가서 주변의 모든 부분을 덮고 나서 육즙이 풍부한 중심에 도달할 것입니다.</font><font papago-translate="translated"> 이것은 대부분의 챕터보다 조금 더 인내심과 정신적인 스크래치 공간이 필요하겠지만, 제가 할 수 있는 최선의 방법입니다.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/compiling-expressions.html#single-pass-compilation" id="single-pass-compilation"><small><font papago-translate="translated">17 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">단일 패스 컴파일</font></font></a></h2>
<p><font papago-translate="translated">컴파일러는 대략 두 가지 작업이 있습니다.</font><font papago-translate="translated"> 사용자의 소스 코드를 구문 분석하여 의미를 이해합니다.</font><font papago-translate="translated"> 그런 다음 해당 지식을 사용하여 동일한 의미를 생성하는 저수준 명령을 출력합니다.</font><font papago-translate="translated"> 많은 언어들이 구현 과정에서 이 두 가지 역할을 두<span name="passes"> 개</span>의 별도<span name="passes"> 패스로</span> 나눕니다.</font><font papago-translate="translated"> 파서는 jlox와 마찬가지로 AST를 생성한 다음 코드 생성기가 AST를 통과하여 대상<span class="em"></span><span class="em"></span> 코드를 출력합니다.</font></p>
<aside name="passes" style="top: 2954px;">
<p><font papago-translate="translated">사실, 대부분의 정교한 최적화 컴파일러는 두 번 이상의 패스를 받습니다.</font><font papago-translate="translated"> 최적<span class="em"></span><span class="em"></span><em></em>화가 어떤 최적화를 거치는지뿐만 아니라, 최적화가 종종 복잡한 방식으로 상호작용하기 때문에 컴파일러에서 가장 많은 성능을 압축하도록 명령하는 방법을 결정하는 것은 "연구의 열린 영역"과 "암흑 예술" 사이의 어딘가에 있습니다.</font></p>
</aside>
<p><font papago-translate="translated">clox에서는 구식 접근 방식을 취하고 이 두 패스를 하나로 통합하고 있습니다.</font><font papago-translate="translated"> 예전에는 언어 해커들이 이렇게 했습니다. 왜냐하면 컴퓨터가 전체 소스 파일의 AST를 저장할 만큼 충분한 메모리를 가지고 있지 않았기 때문입니다.</font><font papago-translate="translated"> 우리가 그것을 하는 이유는 컴파일러를 더 간단하게 유지하기 때문입니다. 이는 C에서 프로그래밍할 때 중요한 요소입니다.</font></p>
<p><font papago-translate="translated">우리가 구축할 단일 패스 컴파일러는 모든 언어에서 잘 작동하지 않습니다.</font><font papago-translate="translated"> 컴파일러는 코드를 생성할 때 사용자의 프로그램을 들여다볼 수 있을 뿐이므로 구문을 이해하는 데 주변 문맥이 많이 필요하지 않도록 언어를 설계해야 합니다.</font><font papago-translate="translated"> 다행히도 작고 역동적으로 타이핑된 Lox가 그에<span name="lox"> 잘 어울</span>립니다.</font></p>
<aside name="lox" style="top: 3266px;">
<p><font papago-translate="translated">이것이 그렇게 놀라운 일은 아닙니다.</font><font papago-translate="translated"> 결국 저는 이 책을 위해 언어를 특별히 디자인했습니다.</font></p><img alt="Peering through a keyhole at 'var x;'" src="https://youhogeon-meritz.github.io/image/compiling-expressions/keyhole.png">
</aside>
<p><font papago-translate="translated">이것이 실질적으로 의미하는 바는 우리의 "컴파일러" C 모듈이 jlox에서 인식할 수 있는 기능을 가지고 있다는 것입니다. 예를 들어, 토큰 소모, 예상 토큰 유형 일치<span class="em"></span> 등을 분석할 수 있습니다.</font><font papago-translate="translated"> 또한 바이트코드를 방출하고 대상 청크에 상수를 추가하는 코드 생성 기능도 있습니다. (이<span class="em"></span>는 이 장과 이후 장에서 "파싱"과 "컴파일"을 번갈아 사용한다는 것을 의미합니다.)</font></p>
<p><font papago-translate="translated">파싱과 코드 생성의 절반을 먼저 구축하겠습니다.</font><font papago-translate="translated"> 그런 다음 프랫의 기법을 사용하여 Lox의 특정 문법을 구문 분석하고 올바른 바이트코드를 출력하는 코드와 함께 그들을 연결할 것입니다.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/compiling-expressions.html#parsing-tokens" id="parsing-tokens"><small><font papago-translate="translated">17 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">토큰 구문 분석</font></font></a></h2>
<p><font papago-translate="translated">먼저 컴파일러의 앞부분입니다.</font><font papago-translate="translated"> 이 함수의 이름은 익숙하게 들릴 것입니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#include "scanner.h"
</pre><div class="source-file"><em><font papago-translate="translated">컴파일러.c</font></em></div>
<pre class="insert" translate="no">
<span class="k">static</span> <span class="t">void</span> <span class="i">advance</span>() {
  <span class="i">parser</span>.<span class="i">previous</span> = <span class="i">parser</span>.<span class="i">current</span>;

  <span class="k">for</span> (;;) {
    <span class="i">parser</span>.<span class="i">current</span> = <span class="i">scanToken</span>();
    <span class="k">if</span> (<span class="i">parser</span>.<span class="i">current</span>.<span class="i">type</span> != <span class="a">TOKEN_ERROR</span>) <span class="k">break</span>;

    <span class="i">errorAtCurrent</span>(<span class="i">parser</span>.<span class="i">current</span>.<span class="i">start</span>);
  }
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em></div>
<p><font papago-translate="splitted"><font papago-translate="translated">Jlox에서와 마찬가지로 토큰 스트림을 통해 앞으로 나아갑니다.</font><font papago-translate="translated"> 스캐너에 다음 토큰을 요청하고 나중에 사용할 수 있도록 저장합니다.</font><font papago-translate="translated"> 그 전에 이전 것이 필요합니다 </font></font><code translate="no">current</code><font papago-translate="splitted"><font papago-translate="translated"> 토큰을 주고 저장합니다 </font></font><code translate="no">previous</code><font papago-translate="splitted"><font papago-translate="translated"> 들판.</font><font papago-translate="translated"> 나중에 토큰을 맞춘 후 어휘소에 도착할 수 있도록 도움이 될 것입니다.</font></font></p>
<p><font papago-translate="translated">다음 토큰을 읽을 코드는 루프로 둘러싸여 있습니다.</font><font papago-translate="translated"> 기억하세요, clox의 스캐너는 어휘 오류를 보고하지 않습니다.</font><font papago-translate="translated"> 대신, 특별<em> 오류 토큰</em>을 생성하고 이<em>를</em> 파서에게 보고하도록 맡깁니다.</font><font papago-translate="translated"> 여기서 그렇게 합니다.</font></p>
<p><font papago-translate="translated">우리는 오류가 없는 토큰에 도달하거나 끝에 도달할 때까지 계속해서 반복하고, 토큰을 읽고, 오류를 보고합니다.</font><font papago-translate="translated"> 그렇게 하면 나머지 파서는 유효한 토큰만 볼 수 있습니다.</font><font papago-translate="translated"> 현재 및 이전 토큰은 다음 구조에 저장됩니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#include "scanner.h"
</pre><div class="source-file"><em><font papago-translate="translated">컴파일러.c</font></em></div>
<pre class="insert" translate="no">
<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">Token</span> <span class="i">current</span>;
  <span class="t">Token</span> <span class="i">previous</span>;
} <span class="t">Parser</span>;

<span class="t">Parser</span> <span class="i">parser</span>;
</pre><pre class="insert-after" translate="no">
static void advance() {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em></div>
<p><font papago-translate="translated">다른 모듈에서와 마찬가지로, 우리는 이 구조 유형의 단일 전역 변수를 가지고 있어서 컴파일러에서 함수 간 상태를 전달할 필요가 없습니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/compiling-expressions.html#handling-syntax-errors" id="handling-syntax-errors"><small><font papago-translate="translated">17 . 2 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">구문 오류 처리</font></font></a></h3>
<p><font papago-translate="translated">스캐너가 오류 토큰을 건네주면 실제로 사용자에게 알려야 합니다.</font><font papago-translate="translated"> 이것을 사용하면 이런 일이 일어납니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 변수<em> 파서</em> 뒤에 추가하기</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">errorAtCurrent</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">message</span>) {
  <span class="i">errorAt</span>(&amp;<span class="i">parser</span>.<span class="i">current</span>, <span class="i">message</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after variable <em>parser</em></div>
<p><font papago-translate="splitted"><font papago-translate="translated">현재 토큰에서 위치를 제거하여 사용자에게 오류가 발생한 위치를 알리고 전달합니다 </font></font><code translate="no">errorAt()</code><font papago-translate="splitted"><font papago-translate="translated">. 더 자주 방금 소비한 토큰의 위치에서 오류를 보고하므로 이 다른 함수에 더 짧은 이름을 붙입니다:</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 변수<em> 파서</em> 뒤에 추가하기</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">error</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">message</span>) {
  <span class="i">errorAt</span>(&amp;<span class="i">parser</span>.<span class="i">previous</span>, <span class="i">message</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after variable <em>parser</em></div>
<p><font papago-translate="translated">실제 작업은 여기에서 이루어집니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 변수<em> 파서</em> 뒤에 추가하기</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">errorAt</span>(<span class="t">Token</span>* <span class="i">token</span>, <span class="k">const</span> <span class="t">char</span>* <span class="i">message</span>) {
  <span class="i">fprintf</span>(<span class="i">stderr</span>, <span class="s">"[line %d] Error"</span>, <span class="i">token</span>-&gt;<span class="i">line</span>);

  <span class="k">if</span> (<span class="i">token</span>-&gt;<span class="i">type</span> == <span class="a">TOKEN_EOF</span>) {
    <span class="i">fprintf</span>(<span class="i">stderr</span>, <span class="s">" at end"</span>);
  } <span class="k">else</span> <span class="k">if</span> (<span class="i">token</span>-&gt;<span class="i">type</span> == <span class="a">TOKEN_ERROR</span>) {
    <span class="c">// Nothing.</span>
  } <span class="k">else</span> {
    <span class="i">fprintf</span>(<span class="i">stderr</span>, <span class="s">" at '%.*s'"</span>, <span class="i">token</span>-&gt;<span class="i">length</span>, <span class="i">token</span>-&gt;<span class="i">start</span>);
  }

  <span class="i">fprintf</span>(<span class="i">stderr</span>, <span class="s">": %s</span><span class="e">\n</span><span class="s">"</span>, <span class="i">message</span>);
  <span class="i">parser</span>.<span class="i">hadError</span> = <span class="k">true</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after variable <em>parser</em></div>
<p><font papago-translate="splitted"><font papago-translate="translated">먼저 오류가 발생한 위치를 인쇄합니다.</font><font papago-translate="translated"> 우리는 어휘가 사람이 읽을 수 있는지 보여주려고 합니다.</font><font papago-translate="translated"> 그런 다음 오류 메시지를 직접 인쇄합니다.</font><font papago-translate="translated"> 그 후에, 우리는 이것을 설정합니다 </font></font><code translate="no">hadError</code><font papago-translate="splitted"><font papago-translate="translated"> 플래그. 컴파일 중 오류가 발생했는지 여부를 기록합니다.</font><font papago-translate="translated"> 이 필드는 파서 구조에도 존재합니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  Token previous;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 구조<em> 파서</em>에서</font></font></div>
<pre class="insert" translate="no">  <span class="t">bool</span> <span class="i">hadError</span>;
</pre><pre class="insert-after" translate="no">} Parser;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in struct <em>Parser</em></div>
<p><font papago-translate="splitted"><font papago-translate="translated">아까 말씀드렸습니다 </font></font><code translate="no">compile()</code><font papago-translate="splitted"><font papago-translate="translated"> 반환해야 합니다 </font></font><code translate="no">false</code><font papago-translate="splitted"><font papago-translate="translated"> 오류가 발생한 경우.</font><font papago-translate="translated"> 이제 그렇게 할 수 있습니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  consume(TOKEN_EOF, "Expect end of expression.");
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>컴파일</em> ()에서</font></font></div>
<pre class="insert" translate="no">  <span class="k">return</span> !<span class="i">parser</span>.<span class="i">hadError</span>;
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>compile</em>()</div>
<p><font papago-translate="translated">오류 처리를 위해 도입할 플래그가 하나 더 있습니다.</font><font papago-translate="translated"> 우리는 오류 연쇄를 피하고 싶습니다.</font><font papago-translate="translated"> 사용자가 코드에 실수가 있고 구문 분석자가 문법에서 코드의 위치를 혼동하는 경우, 첫 번째 코드 이후에 의미 없는 노크온 오류가 쏟아져 나오는 것을 원하지 않습니다.</font></p>
<p><font papago-translate="translated">우리는 패닉 모드 오류 복구를 사용하여 이를 Jlox로 수정했습니다.</font><font papago-translate="translated"> Java 인터프리터에서는 예외를 적용하여 모든 파서 코드에서 벗어나 토큰을 건너뛰고 다시 동기화할 수 있도록 했습니다.</font><font papago-translate="translated"> C에는<span name="setjmp"> 예외</span>가 없습니다.</font><font papago-translate="translated"> 대신에, 우리는 약간의 연기와 거울을 사용할 것입니다.</font><font papago-translate="translated"> 현재 패닉 모드에 있는지 추적하기 위해 플래그를 추가합니다.</font></p>
<aside name="setjmp" style="top: 5882px;">
<p><font papago-translate="splitted"><font papago-translate="translated">있어 </font></font><code translate="no">setjmp()</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">longjmp()</code><font papago-translate="splitted"><font papago-translate="translated">, 하지만 저는 거기에 가고 싶지 않아요.</font><font papago-translate="translated"> 이로 인해 기억이 너무 쉽게 유출되거나, 불변량을 유지하는 것을 잊어버리거나, 그렇지 않으면 매우 나쁜 날을 보내게 됩니다.</font></font></p>
</aside>
<div class="codehilite"><pre class="insert-before" translate="no">  bool hadError;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 구조<em> 파서</em>에서</font></font></div>
<pre class="insert" translate="no">  <span class="t">bool</span> <span class="i">panicMode</span>;
</pre><pre class="insert-after" translate="no">} Parser;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in struct <em>Parser</em></div>
<p><font papago-translate="translated">오류가 발생하면 설정합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">static void errorAt(Token* token, const char* message) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>error</em>A<em>t</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="i">parser</span>.<span class="i">panicMode</span> = <span class="k">true</span>;
</pre><pre class="insert-after" translate="no">  fprintf(stderr, "[line %d] Error", token-&gt;line);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>errorAt</em>()</div>
<p><font papago-translate="translated">그 후에는 오류가 발생하지 않은 것처럼 정상적으로 컴파일을 계속합니다.</font><font papago-translate="translated"> 바이트코드는 절대 실행되지 않으므로 트럭 운송을 계속하는 것은 무해합니다.</font><font papago-translate="translated"> 요령은 패닉 모드 플래그가 설정되어 있는 동안 감지되는 다른 오류를 간단히 억제한다는 것입니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">static void errorAt(Token* token, const char* message) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>error</em>A<em>t</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="k">if</span> (<span class="i">parser</span>.<span class="i">panicMode</span>) <span class="k">return</span>;
</pre><pre class="insert-after" translate="no">  parser.panicMode = true;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>errorAt</em>()</div>
<p><font papago-translate="translated">파서가 잡초 속에서 꺼질 가능성이 높지만, 오류가 모두 삼켜지기 때문에 사용자는 알 수 없습니다.</font><font papago-translate="translated"> 패닉 모드는 파서가 동기화 지점에 도달하면 종료됩니다.</font><font papago-translate="translated"> Lox의 경우 문 경계를 선택했기 때문에 나중에 컴파일러에 추가할 때 플래그를 지웁니다.</font></p>
<p><font papago-translate="translated">이 새로운 분야들을 초기화해야 합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  initScanner(source);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>컴파일</em> ()에서</font></font></div>
<pre class="insert" translate="no">
  <span class="i">parser</span>.<span class="i">hadError</span> = <span class="k">false</span>;
  <span class="i">parser</span>.<span class="i">panicMode</span> = <span class="k">false</span>;

</pre><pre class="insert-after" translate="no">  advance();
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>compile</em>()</div>
<p><font papago-translate="translated">그리고 오류를 표시하려면 표준 헤더가 필요합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#include &lt;stdio.h&gt;
</pre><div class="source-file"><em><font papago-translate="translated">컴파일러.c</font></em></div>
<pre class="insert" translate="no"><span class="a">#include &lt;stdlib.h&gt;</span>
</pre><pre class="insert-after" translate="no">
#include "common.h"
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em></div>
<p><font papago-translate="translated">마지막으로 구문 분석 기능이 하나 더 있습니다. 또 다른 오래된 친구는 jlox입니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>사전</em> () 후 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">consume</span>(<span class="t">TokenType</span> <span class="i">type</span>, <span class="k">const</span> <span class="t">char</span>* <span class="i">message</span>) {
  <span class="k">if</span> (<span class="i">parser</span>.<span class="i">current</span>.<span class="i">type</span> == <span class="i">type</span>) {
    <span class="i">advance</span>();
    <span class="k">return</span>;
  }

  <span class="i">errorAtCurrent</span>(<span class="i">message</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>advance</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">다음과 유사합니다 </font></font><code translate="no">advance()</code><font papago-translate="splitted"><font papago-translate="translated"> 다음 토큰을 읽는다는 점에서.</font><font papago-translate="translated"> 하지만 토큰이 예상되는 유형을 가지고 있다는 것도 확인할 수 있습니다.</font><font papago-translate="translated"> 그렇지 않으면 오류를 보고합니다.</font><font papago-translate="translated"> 이 함수는 컴파일러에서 대부분의 구문 오류의 기초가 됩니다.</font></font></p>
<p><font papago-translate="translated">좋아요, 지금은 프론트엔드에 대한 설명은 여기까지입니다.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/compiling-expressions.html#emitting-bytecode" id="emitting-bytecode"><small><font papago-translate="translated">17 . 3</font></small><font papago-translate="splitted"><font papago-translate="translated">바이트코드 방출</font></font></a></h2>
<p><font papago-translate="translated">사용자 프로그램의 일부를 구문 분석하고 이해한 후, 다음 단계는 이를 일련의 바이트코드 명령어로 변환하는 것입니다.</font><font papago-translate="translated"> 가장 쉬운 단계로 시작합니다: 청크에 단일 바이트를 추가하는 것입니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>소비</em> 후 () 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">emitByte</span>(<span class="t">uint8_t</span> <span class="i">byte</span>) {
  <span class="i">writeChunk</span>(<span class="i">currentChunk</span>(), <span class="i">byte</span>, <span class="i">parser</span>.<span class="i">previous</span>.<span class="i">line</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>consume</em>()</div>
<p><font papago-translate="translated">훌륭한 일들이 이렇게 간단한 기능을 통해 흘러갈 것이라고 믿기 어렵습니다.</font><font papago-translate="translated"> 주어진 바이트를 작성하는데, 이 바이트는 명령어에 대한 연산 코드 또는 피연산자일 수 있습니다.</font><font papago-translate="translated"> 이전 토큰의 라인 정보를 전송하여 런타임 오류가 해당 라인과 연관되도록 합니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">우리가 쓰고 있는 부분은 다음과 같이 전달됩니다 </font></font><code translate="no">compile()</code><font papago-translate="splitted"><font papago-translate="translated">, 하지만 다음과 같은 방식으로 나아가야 합니다 </font></font><code translate="no">emitByte()</code><font papago-translate="splitted"><font papago-translate="translated">. 이를 위해 우리는 이 매개 함수에 의존합니다:</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">Parser parser;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 변수<em> 파서</em> 뒤에 추가하기</font></font></div>
<pre class="insert" translate="no"><span class="t">Chunk</span>* <span class="i">compilingChunk</span>;

<span class="k">static</span> <span class="t">Chunk</span>* <span class="i">currentChunk</span>() {
  <span class="k">return</span> <span class="i">compilingChunk</span>;
}

</pre><pre class="insert-after" translate="no">static void errorAt(Token* token, const char* message) {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after variable <em>parser</em></div>
<p><font papago-translate="splitted"><font papago-translate="translated">현재 청크 포인터는 다른 글로벌 상태를 저장하는 것처럼 모듈 수준 변수에 저장되어 있습니다.</font><font papago-translate="translated"> 나중에 사용자 정의 함수를 컴파일하기 시작하면 "현재 청크"라는 개념이 더 복잡해집니다.</font><font papago-translate="translated"> 돌아가서 많은 코드를 변경할 필요를 피하기 위해, 저는 그 논리를 다음과 같이 캡슐화합니다 </font></font><code translate="no">currentChunk()</code><font papago-translate="splitted"><font papago-translate="translated"> 기능.</font></font></p>
<p><font papago-translate="translated">바이트코드를 작성하기 전에 이 새로운 모듈 변수를 초기화합니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">bool compile(const char* source, Chunk* chunk) {
  initScanner(source);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>컴파일</em> ()에서</font></font></div>
<pre class="insert" translate="no">  <span class="i">compilingChunk</span> = <span class="i">chunk</span>;
</pre><pre class="insert-after" translate="no">
  parser.hadError = false;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>compile</em>()</div>
<p><font papago-translate="translated">그런 다음 맨 마지막에 청크를 완성하면 정리를 마무리합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  consume(TOKEN_EOF, "Expect end of expression.");
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>컴파일</em> ()에서</font></font></div>
<pre class="insert" translate="no">  <span class="i">endCompiler</span>();
</pre><pre class="insert-after" translate="no">  return !parser.hadError;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>compile</em>()</div>
<p><font papago-translate="translated">이를 이렇게 부릅니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>emitByte</em>() 후에 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">endCompiler</span>() {
  <span class="i">emitReturn</span>();
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>emitByte</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">이 장에서는 VM이 표현식만 다룹니다.</font><font papago-translate="translated"> clox를 실행하면 단일 표현식을 구문 분석, 컴파일 및 실행한 다음 결과를 출력합니다.</font><font papago-translate="translated"> 그 값을 출력하기 위해 우리는 일시적으로 </font></font><code translate="no">OP_RETURN</code><font papago-translate="splitted"><font papago-translate="translated"> 설명.</font><font papago-translate="translated"> 그래서 우리는 컴파일러가 그것들 중 하나를 청크 끝에 추가하도록 했습니다.</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>emitByte</em>() 후에 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">emitReturn</span>() {
  <span class="i">emitByte</span>(<span class="a">OP_RETURN</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>emitByte</em>()</div>
<p><font papago-translate="translated">우리가 여기 뒷골목에 있는 동안, 우리의 삶을 더 편하게 만드는 것이 좋을 것 같습니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>emitByte</em>() 후에 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">emitBytes</span>(<span class="t">uint8_t</span> <span class="i">byte1</span>, <span class="t">uint8_t</span> <span class="i">byte2</span>) {
  <span class="i">emitByte</span>(<span class="i">byte1</span>);
  <span class="i">emitByte</span>(<span class="i">byte2</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>emitByte</em>()</div>
<p><font papago-translate="translated">시간이 지남에 따라, 우리는 이 편리함 함수를 정의할 가치가 있는 1바이트 피연산자 뒤에 오피코드를 작성해야 하는 충분한 경우를 갖게 될 것입니다.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/compiling-expressions.html#parsing-prefix-expressions" id="parsing-prefix-expressions"><small><font papago-translate="translated">17 . 4</font></small><font papago-translate="splitted"><font papago-translate="translated">접두사 표현식 구문 분석</font></font></a></h2>
<p><font papago-translate="translated">우리는 구문 분석 및 코드 생성 유틸리티 기능을 조립했습니다.</font><font papago-translate="translated"> 누락된 부분은 그것들을 서로 연결하는 중간 코드입니다.</font></p><img alt="Parsing functions on the left, bytecode emitting functions on the right. What goes in the middle?" src="https://youhogeon-meritz.github.io/image/compiling-expressions/mystery.png">
<p><font papago-translate="splitted"><font papago-translate="translated">유일한 단계 </font></font><code translate="no">compile()</code><font papago-translate="splitted"><font papago-translate="translated"> 우리가 구현해야 할 것은 이 함수입니다:</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>endCompiler</em>() 뒤에 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">expression</span>() {
  <span class="c">// What goes here?</span>
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>endCompiler</em>()</div>
<p><font papago-translate="translated">우리는 아직 Lox에서 모든 종류의 표현을 구현할 준비가 되어 있지 않습니다.</font><font papago-translate="translated"> 불리언도 없습니다.</font><font papago-translate="translated"> 이 장에서는 네 가지에 대해서만 걱정하겠습니다:</font></p>
<ul>
<li><font papago-translate="splitted"><font papago-translate="translated">숫자 리터럴: </font></font><code translate="no">123</code></li>
<li><font papago-translate="splitted"><font papago-translate="translated">그룹화 괄호: </font></font><code translate="no">(123)</code></li>
<li><font papago-translate="splitted"><font papago-translate="translated">단항 부정: </font></font><code translate="no">-123</code></li>
<li><font papago-translate="splitted"><font papago-translate="translated">산수의 네 기수: </font></font><code translate="no">+</code><font papago-translate="splitted"><font papago-translate="translated">, </font></font><code translate="no">-</code><font papago-translate="splitted"><font papago-translate="translated">, </font></font><code translate="no">*</code><font papago-translate="splitted"><font papago-translate="translated">, </font></font><code translate="no">/</code></li>
</ul>
<p><font papago-translate="translated">함수들을 통해 각 종류의 표현식을 컴파일할 때, 이를 호출하는 테이블 기반 파서의 요구 사항도 조립할 것입니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/compiling-expressions.html#parsers-for-tokens" id="parsers-for-tokens"><small><font papago-translate="translated">17 . 4 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">토큰 파서</font></font></a></h3>
<p><font papago-translate="translated">지금은 각각 단일 토큰인 Lox 표현식에 집중해 보겠습니다.</font><font papago-translate="translated"> 이 장에서는 숫자 리터럴에 불과하지만 나중에 더 많은 내용이 있을 것입니다.</font><font papago-translate="translated"> 다음은 우리가 그것들을 컴파일하는 방법입니다:</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">각 토큰 유형을 다른 종류의 표현으로 매핑합니다.</font><font papago-translate="translated"> 각 표현식에 적합한 바이트코드를 출력하는 함수를 정의합니다.</font><font papago-translate="translated"> 그런 다음 함수 포인터 배열을 만듭니다.</font><font papago-translate="translated"> 배열의 인덱스는 다음과 같습니다 </font></font><code translate="no">TokenType</code><font papago-translate="splitted"><font papago-translate="translated"> 값을 열거하고 각 인덱스의 함수는 해당 토큰 유형의 표현식을 컴파일하는 코드입니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">숫자 리터럴을 컴파일하려면 다음 함수에 대한 포인터를 저장합니다 </font></font><code translate="no">TOKEN_NUMBER</code><font papago-translate="splitted"><font papago-translate="translated"> 배열의 인덱스.</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>endCompiler</em>() 뒤에 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">number</span>() {
  <span class="t">double</span> <span class="i">value</span> = <span class="i">strtod</span>(<span class="i">parser</span>.<span class="i">previous</span>.<span class="i">start</span>, <span class="a">NULL</span>);
  <span class="i">emitConstant</span>(<span class="i">value</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>endCompiler</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">숫자 리터럴에 대한 토큰이 이미 소비되어 저장되어 있다고 가정합니다 </font></font><code translate="no">previous</code><font papago-translate="splitted"><font papago-translate="translated">. 우리는 그 어휘소를 가져와서 C 표준 라이브러리를 사용하여 두 배의 값으로 변환합니다.</font><font papago-translate="translated"> 그런 다음 이 함수를 사용하여 해당 값을 로드할 코드를 생성합니다:</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>emit</em>R<em>eturn</em>() 후 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">emitConstant</span>(<span class="t">Value</span> <span class="i">value</span>) {
  <span class="i">emitBytes</span>(<span class="a">OP_CONSTANT</span>, <span class="i">makeConstant</span>(<span class="i">value</span>));
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>emitReturn</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">먼저 상수 테이블에 값을 더한 다음 다음 다음을 방출합니다 </font></font><code translate="no">OP_CONSTANT</code><font papago-translate="splitted"><font papago-translate="translated"> 런타임 시 스택으로 푸시하는 명령어.</font><font papago-translate="translated"> 상수 테이블에 항목을 삽입하려면 다음에 의존합니다:</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>emit</em>R<em>eturn</em>() 후 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">uint8_t</span> <span class="i">makeConstant</span>(<span class="t">Value</span> <span class="i">value</span>) {
  <span class="t">int</span> <span class="i">constant</span> = <span class="i">addConstant</span>(<span class="i">currentChunk</span>(), <span class="i">value</span>);
  <span class="k">if</span> (<span class="i">constant</span> &gt; <span class="a">UINT8_MAX</span>) {
    <span class="i">error</span>(<span class="s">"Too many constants in one chunk."</span>);
    <span class="k">return</span> <span class="n">0</span>;
  }

  <span class="k">return</span> (<span class="t">uint8_t</span>)<span class="i">constant</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>emitReturn</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">대부분의 작업은 다음에서 이루어집니다 </font></font><code translate="no">addConstant()</code><font papago-translate="splitted"><font papago-translate="translated">, <a href="https://youhogeon-meritz.github.io/chunks-of-bytecode.html">이전 장</a>에서 정의한 내용입니다.</font><font papago-translate="translated"> 그러면 주어진 값이 청크의 상수 테이블 끝에 추가되고 인덱스가 반환됩니다.</font><font papago-translate="translated"> 새로운 함수의 역할은 대부분 상수가 너무 많지 않은지 확인하는 것입니다.</font><font papago-translate="translated"> 그 이후로 </font></font><code translate="no">OP_CONSTANT</code><font papago-translate="splitted"><font papago-translate="translated"> 명령어는 인덱스 피연산자에 단일 바이트를 사용하며, 청크에 최대<span name="256"> 256</span>개의 상수만 저장하고 로드할 수 있습니다.</font></font></p>
<aside name="256" style="top: 10771.5px;">
<p><font papago-translate="splitted"><font papago-translate="translated">네, 그 한도는 꽤 낮습니다.</font><font papago-translate="translated"> 이것이 실제 크기의 언어 구현이라면, 우리는 다음과 같은 또 다른 지침을 추가하고 싶습니다 </font></font><code translate="no">OP_CONSTANT_16</code><font papago-translate="splitted"><font papago-translate="translated"> 인덱스를 2바이트 피연산자로 저장하여 필요할 때 더 많은 상수를 처리할 수 있도록 합니다.</font></font></p>
<p><font papago-translate="translated">이를 지원하는 코드는 특별히 밝지 않아서 clox에서 생략했지만 VM이 더 큰 프로그램으로 확장되기를 원할 것입니다.</font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">기본적으로 그게 전부입니다.</font><font papago-translate="translated"> 다음을 소비하는 적절한 코드가 있는 경우 </font></font><code translate="no">TOKEN_NUMBER</code><font papago-translate="splitted"><font papago-translate="translated"> 토큰, 조회하기 </font></font><code translate="no">number()</code><font papago-translate="splitted"><font papago-translate="translated"> 함수 포인터 배열에서 숫자 리터럴을 바이트코드로 컴파일할 수 있습니다.</font></font></p>
<h3><a href="https://youhogeon-meritz.github.io/compiling-expressions.html#parentheses-for-grouping" id="parentheses-for-grouping"><small><font papago-translate="translated">17 . 4 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">그룹화 괄호</font></font></a></h3>
<p><font papago-translate="splitted"><font papago-translate="translated">우리의 아직 상상하지 못한 파싱 함수 포인터 배열은 모든 표현식이 하나의 토큰 길이에 불과하다면 정말 좋을 것입니다.</font><font papago-translate="translated"> 아, 대부분은 더 깁니다.</font><font papago-translate="translated"> 그러나 많은 표현은 특정 토큰으로<em> 시작합니다</em>.</font><font papago-translate="translated"> <em>우리</em>는<em> 이러한 접두사</em> 표현식을 부릅니다.</font><font papago-translate="translated"> 예를 들어, 표현식을 구문 분석할 때 현재 토큰은 다음과 같습니다 </font></font><code translate="no">(</code><font papago-translate="splitted"><font papago-translate="translated">, 괄호로 묶은 그룹 표현식을 살펴봐야 한다는 것을 알고 있습니다.</font></font></p>
<p><font papago-translate="translated">알고 보니 우리 함수 포인터 배열도 그것들을 처리합니다.</font><font papago-translate="translated"> 표현형의 구문 분석 기능은 일반적인 재귀적 하강 파서처럼 원하는 추가 토큰을 사용할 수 있습니다.</font><font papago-translate="translated"> 괄호의 작동 방식은 다음과 같습니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>endCompiler</em>() 뒤에 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">grouping</span>() {
  <span class="i">expression</span>();
  <span class="i">consume</span>(<span class="a">TOKEN_RIGHT_PAREN</span>, <span class="s">"Expect ')' after expression."</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>endCompiler</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">다시 말하지만, 우리는 초기를 가정합니다 </font></font><code translate="no">(</code><font papago-translate="splitted"><font papago-translate="translated"> 이미 소비되었습니다.</font><font papago-translate="translated"> <span name="recursive">우리</span>는<span name="recursive"> 재귀</span>적으로 다시 호출합니다 </font></font><code translate="no">expression()</code><font papago-translate="splitted"><font papago-translate="translated"> 괄호 사이의 표현식을 컴파일한 다음 마무리를 구문 분석합니다 </font></font><code translate="no">)</code><font papago-translate="splitted"><font papago-translate="translated"> 마지막에.</font></font></p>
<aside name="recursive" style="top: 11355.5px;">
<p><font papago-translate="translated">프랫 파서는 재귀<em>적 하강</em> 파서가 아니지만 여전히 재귀적입니다.</font><font papago-translate="translated"> 문법 자체가 재귀적이기 때문에 예상할 수 있는 일입니다.</font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">백엔드에 관한 한, 그룹화 표현에는 말 그대로 아무것도 없습니다.</font><font papago-translate="translated"> 유일한 기능은 구문입니다. 더 높은 우선순위가<span class="em"></span> 예상되는 낮은 우선순위 표현식을 삽입할 수 있습니다.</font><font papago-translate="translated"> 따라서 자체적으로 런타임 의미가 없으므로 바이트코드를 방출하지 않습니다.</font><font papago-translate="translated"> 내면의 부름 </font></font><code translate="no">expression()</code><font papago-translate="splitted"><font papago-translate="translated"> 괄호 안의 표현식에 대한 바이트코드 생성을 담당합니다.</font></font></p>
<h3><a href="https://youhogeon-meritz.github.io/compiling-expressions.html#unary-negation" id="unary-negation"><small><font papago-translate="translated">17 . 4 . 3</font></small><font papago-translate="splitted"><font papago-translate="translated">단항 부정</font></font></a></h3>
<p><font papago-translate="translated">유니리 마이너스는 접두사 표현이기도 하므로 우리 모델에서도 작동합니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>숫자</em> () 뒤에 추가하기</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">unary</span>() {
  <span class="t">TokenType</span> <span class="i">operatorType</span> = <span class="i">parser</span>.<span class="i">previous</span>.<span class="i">type</span>;

  <span class="c">// Compile the operand.</span>
  <span class="i">expression</span>();

  <span class="c">// Emit the operator instruction.</span>
  <span class="k">switch</span> (<span class="i">operatorType</span>) {
    <span class="k">case</span> <span class="a">TOKEN_MINUS</span>: <span class="i">emitByte</span>(<span class="a">OP_NEGATE</span>); <span class="k">break</span>;
    <span class="k">default</span>: <span class="k">return</span>; <span class="c">// Unreachable.</span>
  }
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>number</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">선도자 </font></font><code translate="no">-</code><font papago-translate="splitted"><font papago-translate="translated"> 토큰이 소비되어 현재 사용 중입니다 </font></font><code translate="no">parser.previous</code><font papago-translate="splitted"><font papago-translate="translated">. 토큰 유형을 가져와 어떤 단항 연산자를 다루고 있는지 확인합니다.</font><font papago-translate="translated"> 지금 당장은 불필요하지만, 이 동일한 함수를 사용하여 컴파일할 때 더 이해가 될 것입니다 </font></font><code translate="no">!</code><font papago-translate="splitted"><font papago-translate="translated"> 다음<a href="https://youhogeon-meritz.github.io/types-of-values.html"> 장</a>의 연산자.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">에서와 같이 </font></font><code translate="no">grouping()</code><font papago-translate="splitted"><font papago-translate="translated">, 우리는 재귀적으로 호출합니다 </font></font><code translate="no">expression()</code><font papago-translate="splitted"><font papago-translate="translated"> 피연산자를 컴파일합니다.</font><font papago-translate="translated"> 그 후, 우리는 부정을 수행하기 위해 바이트코드를 방출합니다.</font><font papago-translate="translated"> 피연산자의 바이트코드<em> 뒤에</em> 부정 명령어를 쓰는 것이 조금 이상하게 보일 수 있습니다 </font></font><code translate="no">-</code><font papago-translate="splitted"><font papago-translate="translated"> 왼쪽에 나타나지만 실행 순서에 따라 생각해 보세요:</font></font></p>
<ol>
<li>
<p><font papago-translate="translated">먼저 스택에 값을 남기는 피연산자를 평가합니다.</font></p>
</li>
<li>
<p><font papago-translate="translated">그런 다음 해당 값을 팝업하고 무효화한 다음 결과를 푸시합니다.</font></p>
</li>
</ol>
<p><font papago-translate="splitted"><font papago-translate="translated">그래서 </font></font><code translate="no">OP_NEGATE</code><font papago-translate="splitted"><font papago-translate="translated"> 지시<span name="line"> 사항은 마지막</span>으로 제출되어야 합니다.</font><font papago-translate="translated"> 이것은 컴파일러의 작업의 일부입니다. 소스 코드에 표시되는 순서대로 프로그램을 파싱하고 실행<span class="em"></span>이 이루어지는 순서대로 재배열합니다.</font></font></p>
<aside name="line" style="top: 12339.5px;">
<p><font papago-translate="splitted"><font papago-translate="translated">방출 </font></font><code translate="no">OP_NEGATE</code><font papago-translate="splitted"><font papago-translate="translated"> 피연산자 뒤에 오는 명령은 바이트코드가 작성될 때 현재 토큰이 다음과<em> 같다는</em> 것을 의미합니다 </font></font><code translate="no">-</code><font papago-translate="splitted"><font papago-translate="translated"> 상품권.</font><font papago-translate="translated"> 그것은 대부분 중요하지 않지만, 우리는 그 지시와 연관시키기 위해 줄 번호에 그 토큰을 사용합니다.</font></font></p>
<p><font papago-translate="translated">이는 다중 줄 부정 표현이 있다는 것을 의미합니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">print</span> -
  <span class="k">true</span>;
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">그러면 런타임 오류가 잘못된 줄에 보고될 것입니다.</font><font papago-translate="translated"> 여기에서는 2번 줄에 오류가 표시되지만 </font></font><code translate="no">-</code><font papago-translate="splitted"><font papago-translate="translated"> 1호선에 있습니다.</font><font papago-translate="translated"> 더 강력한 접근 방식은 피연산자를 컴파일하기 전에 토큰의 행을 저장한 다음 이를 전달하는 것입니다 </font></font><code translate="no">emitByte()</code><font papago-translate="splitted"><font papago-translate="translated">, 하지만 책을 위해 간단하게 정리하고 싶었습니다.</font></font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">하지만 이 코드에는 한 가지 문제가 있습니다.</font><font papago-translate="translated"> 그 </font></font><code translate="no">expression()</code><font papago-translate="splitted"><font papago-translate="translated"> 호출하는 함수는 우선순위에 관계없이 피연산자에 대한 모든 표현식을 구문 분석합니다.</font><font papago-translate="translated"> 이진 연산자와 다른 구문을 추가하면 잘못된 작업을 수행할 수 있습니다.</font><font papago-translate="translated"> 고려:</font></font></p>
<div class="codehilite"><pre translate="no">-<span class="i">a</span>.<span class="i">b</span> + <span class="i">c</span>;
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">여기서 피연산자는 </font></font><code translate="no">-</code><font papago-translate="splitted"><font papago-translate="translated"> 다음과 같이 해야 합니다 </font></font><code translate="no">a.b</code><font papago-translate="splitted"><font papago-translate="translated"> 전체가 아닌 표현 </font></font><code translate="no">a.b + c</code><font papago-translate="splitted"><font papago-translate="translated">. 하지만 만약 </font></font><code translate="no">unary()</code><font papago-translate="splitted"><font papago-translate="translated"> 호출 </font></font><code translate="no">expression()</code><font papago-translate="splitted"><font papago-translate="translated">, 후자는 다음을 포함한 나머지 모든 코드를 기꺼이 씹을 것입니다 </font></font><code translate="no">+</code><font papago-translate="splitted"><font papago-translate="translated">. 잘못 처리할 것입니다 </font></font><code translate="no">-</code><font papago-translate="splitted"><font papago-translate="translated"> 이전보다 낮은 우선순위로 </font></font><code translate="no">+</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">피연산자를 단항으로 구문 분석할 때 </font></font><code translate="no">-</code><font papago-translate="splitted"><font papago-translate="translated">, 특정 우선순위 수준 이상의 표현식만 컴파일해야 합니다.</font><font papago-translate="translated"> Jlox의 재귀적 하강 파서에서 우리는 허용하고자 했던 최저 우선순위 표현에 대한 파싱 방법을 호출함으로써 이를 달성했습니다 (이 경우, </font></font><code translate="no">call()</code><font papago-translate="splitted"><font papago-translate="translated">). 특정 표현식을 구문 분석하는 각 방법은 더 높은 우선순위의 표현식도 구문 분석하여 나머지 우선순위 표를 포함시켰습니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">구문 분석 기능은 다음과 같습니다 </font></font><code translate="no">number()</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">unary()</code><font papago-translate="splitted"><font papago-translate="translated"> 여기서 clox는 다릅니다.</font><font papago-translate="translated"> 각각은 정확히 한 가지 유형의 표현만을 구문 분석합니다.</font><font papago-translate="translated"> 그들은 더 높은 우선순위의 표현 유형도 포함하지 않습니다.</font><font papago-translate="translated"> 우리는 다른 해결책이 필요하며, 이렇게 보입니다:</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>단항</em> () 후에 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">parsePrecedence</span>(<span class="t">Precedence</span> <span class="i">precedence</span>) {
  <span class="c">// What goes here?</span>
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>unary</em>()</div>
<p><font papago-translate="translated">이 함수는 일단 구현하면 현재 토큰에서 시작하여 주어진 우선순위 수준<span class="em"></span><span class="em"></span> 이상에서 모든 표현식을 구문 분석합니다.</font><font papago-translate="translated"> 이 함수의 본문을 작성하기 전에 해결해야 할 다른 설정이 있지만, 제가 말씀드린 구문 분석 함수 포인터 표를 사용할 것이라고 추측할 수 있을 것입니다.</font><font papago-translate="translated"> 지금은 작동 방식에 대해 너무 걱정하지 마세요.</font><font papago-translate="translated"> "우선순위"를 매개변수로 삼기 위해, 우리는 그것을 수치적으로 정의합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">} Parser;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 구조 파<em>서</em> 뒤에 추가</font></font></div>
<pre class="insert" translate="no">
<span class="k">typedef</span> <span class="k">enum</span> {
  <span class="a">PREC_NONE</span>,
  <span class="a">PREC_ASSIGNMENT</span>,  <span class="c">// =</span>
  <span class="a">PREC_OR</span>,          <span class="c">// or</span>
  <span class="a">PREC_AND</span>,         <span class="c">// and</span>
  <span class="a">PREC_EQUALITY</span>,    <span class="c">// == !=</span>
  <span class="a">PREC_COMPARISON</span>,  <span class="c">// &lt; &gt; &lt;= &gt;=</span>
  <span class="a">PREC_TERM</span>,        <span class="c">// + -</span>
  <span class="a">PREC_FACTOR</span>,      <span class="c">// * /</span>
  <span class="a">PREC_UNARY</span>,       <span class="c">// ! -</span>
  <span class="a">PREC_CALL</span>,        <span class="c">// . ()</span>
  <span class="a">PREC_PRIMARY</span>
} <span class="t">Precedence</span>;
</pre><pre class="insert-after" translate="no">
Parser parser;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after struct <em>Parser</em></div>
<p><font papago-translate="splitted"><font papago-translate="translated">이것들은 모두 Lox의 가장 낮은 우선순위부터 가장 높은 우선순위까지입니다.</font><font papago-translate="translated"> C는 암시적으로 에넘에 대해 연속적으로 더 큰 숫자를 제공하므로, 이는 다음을 의미합니다 </font></font><code translate="no">PREC_CALL</code><font papago-translate="splitted"><font papago-translate="translated"> 수치적으로 다음보다 큽니다 </font></font><code translate="no">PREC_UNARY</code><font papago-translate="splitted"><font papago-translate="translated">. 예를 들어, 컴파일러가 코드 덩어리 위에 있다고 가정해 보겠습니다:</font></font></p>
<div class="codehilite"><pre translate="no">-<span class="i">a</span>.<span class="i">b</span> + <span class="i">c</span>
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">전화하면 </font></font><code translate="no">parsePrecedence(PREC_ASSIGNMENT)</code><font papago-translate="splitted"><font papago-translate="translated">, 그러면 다음과 같은 이유로 전체 표현식을 구문 분석합니다 </font></font><code translate="no">+</code><font papago-translate="splitted"><font papago-translate="translated"> 할당보다 우선순위가 더 높습니다.</font><font papago-translate="translated"> 대신 전화하면 </font></font><code translate="no">parsePrecedence(PREC_UNARY)</code><font papago-translate="splitted"><font papago-translate="translated">, 그것은 다음을 컴파일할 것입니다 </font></font><code translate="no">-a.b</code><font papago-translate="splitted"><font papago-translate="translated"> 거기서 멈추세요.</font><font papago-translate="translated"> 계속 통과하지 않습니다 </font></font><code translate="no">+</code><font papago-translate="splitted"><font papago-translate="translated"> 왜냐하면 덧셈이 단항 연산자보다 우선순위가 낮기 때문입니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">이 기능을 손에 쥐고 있으면 누락된 신체를 채워주는 스냅입니다 </font></font><code translate="no">expression()</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">static void expression() {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>표현</em>식 ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">  <span class="i">parsePrecedence</span>(<span class="a">PREC_ASSIGNMENT</span>);
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>expression</em>(), replace 1 line</div>
<p><font papago-translate="translated">우리는 단순히 가장 낮은 우선순위 수준을 분석하며, 이는 모든 상위 우선순위 표현들도 포함합니다.</font><font papago-translate="translated"> 이제 단항식의 피연산자를 컴파일하기 위해 이 새로운 함수를 호출하고 적절한 수준으로 제한합니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  // Compile the operand.
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>단항</em> ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">  <span class="i">parsePrecedence</span>(<span class="a">PREC_UNARY</span>);
</pre><pre class="insert-after" translate="no">
  // Emit the operator instruction.
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>unary</em>(), replace 1 line</div>
<p><font papago-translate="splitted"><font papago-translate="translated">우리는 단항 연산자 자체를 사용합니다 </font></font><code translate="no">PREC_UNARY</code><font papago-translate="splitted"><font papago-translate="translated"> <span name="useful">다음</span>과 같이<span name="useful"> 중첩</span>된 단항식을 허용하는 우선순위 </font></font><code translate="no">!!doubleNegative</code><font papago-translate="splitted"><font papago-translate="translated">. 단항 연산자는 매우 높은 우선순위를 가지고 있기 때문에 이진 연산자와 같은 것들은 정확하게 제외됩니다.</font><font papago-translate="translated"> 말이 나와서 말인데<span class="ellipse">, . . .</span></font></font></p>
<aside name="useful" style="top: 14191.5px;">
<p><font papago-translate="translated">Lox에서 단항식이 특히 유용한 것은 아닙니다.</font><font papago-translate="translated"> 하지만 다른 언어에서도 할 수 있기 때문에 저희도 할 수 있습니다.</font></p>
</aside>
<h2><a href="https://youhogeon-meritz.github.io/compiling-expressions.html#parsing-infix-expressions" id="parsing-infix-expressions"><small><font papago-translate="translated">17 . 5</font></small><font papago-translate="splitted"><font papago-translate="translated">구문 분석 Infix 식</font></font></a></h2>
<p><font papago-translate="translated">이진 연산자는<em> 고정</em>되어 있기 때문에 이전 표현식과 다릅니다.</font><font papago-translate="translated"> 다른 표현들을 사용하면, 우리는 첫 번째 토큰에서 무엇을 파싱하고 있는지 알 수 있습니다.</font><font papago-translate="translated"> infix 표현식을 사용하면 이진 연산자의 왼쪽 피연산자를 구문 분석한 후 중간에 연산<em></em>자 토큰을 발견하기 전까지는 이진 연산자의 중간에 있다는 것을 알 수 없습니다.</font></p>
<p><font papago-translate="translated">다음은 예시입니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="n">1</span> + <span class="n">2</span>
</pre></div>
<p><font papago-translate="translated">지금까지 알고 있는 내용으로 정리해 보겠습니다:</font></p>
<ol>
<li>
<p><font papago-translate="splitted"><font papago-translate="translated">우리는 전화합니다 </font></font><code translate="no">expression()</code><font papago-translate="splitted"><font papago-translate="translated">. 그것은 결국 다음과 같습니다 </font></font><code translate="no">parsePrecedence(PREC_ASSIGNMENT)</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p>
</li>
<li>
<p><font papago-translate="splitted"><font papago-translate="translated">그 함수는 (우리가 그것을 구현하면) 선두 숫자 토큰을 보고 숫자 리터럴을 파싱하고 있다는 것을 인식합니다.</font><font papago-translate="translated"> 통제 불능 상태에서 다음으로 넘어갑니다 </font></font><code translate="no">number()</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p>
</li>
<li>
<p><code translate="no">number()</code><font papago-translate="splitted"><font papago-translate="translated"> 상수를 생성하고 다음을 방출합니다 </font></font><code translate="no">OP_CONSTANT</code><font papago-translate="splitted"><font papago-translate="translated">, 그리고 다시 돌아옵니다 </font></font><code translate="no">parsePrecedence()</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p>
</li>
</ol>
<p><font papago-translate="splitted"><font papago-translate="translated">자 이제는 뭐죠?</font><font papago-translate="translated"> 로의 부름 </font></font><code translate="no">parsePrecedence()</code><font papago-translate="splitted"><font papago-translate="translated"> 전체 덧셈 표현식을 사용해야 하므로 어떻게든 계속 진행해야 합니다.</font><font papago-translate="translated"> 다행히도 파서는 우리가 필요한 곳에 바로 있습니다.</font><font papago-translate="translated"> 이제 선도 숫자 표현식을 정리했으니, 다음 토큰은 다음과 같습니다 </font></font><code translate="no">+</code><font papago-translate="splitted"><font papago-translate="translated">. 그것이 바로 그 토큰입니다 </font></font><code translate="no">parsePrecedence()</code><font papago-translate="splitted"><font papago-translate="translated"> 우리가 infix 표현식의 중간에 있다는 것을 감지하고, 우리가 이미 작성한 표현식이 실제로 그것에 대한 피연산자임을 깨달아야 합니다.</font></font></p>
<p><font papago-translate="translated">따라서 이 가상의 함수 포인터 배열은 주어진 토큰으로 시작하는 표현식을 구문 분석하는 함수만 나열하는 것이 아닙니다.</font><font papago-translate="translated"> 대신, 그것은 함수 포인터<em>의 표</em>입니다.</font><font papago-translate="translated"> 하나의 열은 접두사 파서 함수를 토큰 유형과 연결합니다.</font><font papago-translate="translated"> 두 번째 열은 인픽스 파서 함수를 토큰 유형과 연관시킵니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">우리가 infix 파서로 사용할 함수 </font></font><code translate="no">TOKEN_PLUS</code><font papago-translate="splitted"><font papago-translate="translated">, </font></font><code translate="no">TOKEN_MINUS</code><font papago-translate="splitted"><font papago-translate="translated">, </font></font><code translate="no">TOKEN_STAR</code><font papago-translate="splitted"><font papago-translate="translated">,그리고. </font></font><code translate="no">TOKEN_SLASH</code><font papago-translate="splitted"><font papago-translate="translated"> 이것은:</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>endCompiler</em>() 뒤에 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">binary</span>() {
  <span class="t">TokenType</span> <span class="i">operatorType</span> = <span class="i">parser</span>.<span class="i">previous</span>.<span class="i">type</span>;
  <span class="t">ParseRule</span>* <span class="i">rule</span> = <span class="i">getRule</span>(<span class="i">operatorType</span>);
  <span class="i">parsePrecedence</span>((<span class="t">Precedence</span>)(<span class="i">rule</span>-&gt;<span class="i">precedence</span> + <span class="n">1</span>));

  <span class="k">switch</span> (<span class="i">operatorType</span>) {
    <span class="k">case</span> <span class="a">TOKEN_PLUS</span>:          <span class="i">emitByte</span>(<span class="a">OP_ADD</span>); <span class="k">break</span>;
    <span class="k">case</span> <span class="a">TOKEN_MINUS</span>:         <span class="i">emitByte</span>(<span class="a">OP_SUBTRACT</span>); <span class="k">break</span>;
    <span class="k">case</span> <span class="a">TOKEN_STAR</span>:          <span class="i">emitByte</span>(<span class="a">OP_MULTIPLY</span>); <span class="k">break</span>;
    <span class="k">case</span> <span class="a">TOKEN_SLASH</span>:         <span class="i">emitByte</span>(<span class="a">OP_DIVIDE</span>); <span class="k">break</span>;
    <span class="k">default</span>: <span class="k">return</span>; <span class="c">// Unreachable.</span>
  }
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>endCompiler</em>()</div>
<p><font papago-translate="translated">접두사 파서 함수가 호출될 때, 선두 토큰은 이미 소비되었습니다.</font><font papago-translate="translated"> 인픽스 파서 함수는<em> 미디어 레스에서</em> 더 많이 사용됩니다. 전체 왼쪽 피연산자 표현식이 이미 컴파일되었고 이후 인픽스 연산자<span class="em"></span>가 사용되었습니다.</font></p>
<p><font papago-translate="translated">왼쪽 피연산자가 먼저 컴파일된다는 사실은 잘 작동합니다.</font><font papago-translate="translated"> 런타임 시 해당 코드가 먼저 실행된다는 의미입니다.</font><font papago-translate="translated"> 실행되면 생성되는 가치는 결국 스택에 남게 됩니다.</font><font papago-translate="translated"> 바로 그 지점에서 인픽스 연산자가 그것을 필요로 하게 될 것입니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">그리고 나서 우리는 여기에 왔습니다 </font></font><code translate="no">binary()</code><font papago-translate="splitted"><font papago-translate="translated"> 나머지 산술 연산자를 처리합니다.</font><font papago-translate="translated"> 이 함수는 다음과 같이 올바른 피연산자를 컴파일합니다 </font></font><code translate="no">unary()</code><font papago-translate="splitted"><font papago-translate="translated"> 자체 후행 피연산자를 컴파일합니다.</font><font papago-translate="translated"> 마지막으로 바이너리 연산을 수행하는 바이트코드 명령어를 방출합니다.</font></font></p>
<p><font papago-translate="translated">실행되면 VM은 왼쪽 및 오른쪽 피연산자 코드를 순서대로 실행하여 그 값을 스택에 남깁니다.</font><font papago-translate="translated"> 그런 다음 운영자의 지시를 실행합니다.</font><font papago-translate="translated"> 그것은 두 값을 터뜨리고 연산을 계산한 다음 결과를 밀어냅니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">여기서 아마도 당신의 눈길을 사로잡은 코드는 다음과 같습니다 </font></font><code translate="no">getRule()</code><font papago-translate="splitted"><font papago-translate="translated"> 줄. 오른쪽 피연산자를 구문 분석할 때, 우리는 다시 한 번 우선순위에 대해 걱정해야 합니다.</font><font papago-translate="translated"> 다음과 같은 표현을 취하세요:</font></font></p>
<div class="codehilite"><pre translate="no"><span class="n">2</span> * <span class="n">3</span> + <span class="n">4</span>
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">올바른 피연산자를 구문 분석할 때 </font></font><code translate="no">*</code><font papago-translate="splitted"><font papago-translate="translated"> 표현, 우리는 그냥 캡처해야 합니다 </font></font><code translate="no">3</code><font papago-translate="splitted"><font papago-translate="translated">, 그리고 </font></font><code translate="no">3 + 4</code><font papago-translate="splitted"><font papago-translate="translated">,왜냐면 </font></font><code translate="no">+</code><font papago-translate="splitted"><font papago-translate="translated"> 는 다음보다 낮은 우선순위입니다 </font></font><code translate="no">*</code><font papago-translate="splitted"><font papago-translate="translated">. 각 이진 연산자에 대해 별도의 함수를 정의할 수 있습니다.</font><font papago-translate="translated"> 각자가 부를 것입니다 </font></font><code translate="no">parsePrecedence()</code><font papago-translate="splitted"><font papago-translate="translated"> 피연산자에 대한 올바른 우선순위를 전달합니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">하지만 그건 좀 지루하네요.</font><font papago-translate="translated"> 각 이진 연산자의 오른쪽 피연산자 우선순위는 자신의 피연산자 우선순위보다 한 단계<span name="higher"> 높습니다</span>.</font><font papago-translate="translated"> 이것으로 동적으로 확인할 수 있습니다 </font></font><code translate="no">getRule()</code><font papago-translate="splitted"><font papago-translate="translated"> 곧 도달할 것입니다.</font><font papago-translate="translated"> 이를 사용하여 다음과 같이 전화합니다 </font></font><code translate="no">parsePrecedence()</code><font papago-translate="splitted"><font papago-translate="translated"> 이 운영자의 레벨보다 한 단계 높은.</font></font></p>
<aside name="higher" style="top: 16243.5px;">
<p><font papago-translate="translated">이진 연산자는 왼쪽 연관 연산자이기 때문에 오른쪽 피연산자에 대해 한<em> 가지 더 높은</em> 수준의 우선순위를 사용합니다.</font><font papago-translate="translated"> <em>동일</em>한 연산자의 급수가 주어졌을 때, 예를 들어:</font></p>
<div class="codehilite"><pre translate="no"><span class="n">1</span> + <span class="n">2</span> + <span class="n">3</span> + <span class="n">4</span>
</pre></div>
<p><font papago-translate="translated">우리는 그것을 다음과 같이 분석하고 싶습니다:</font></p>
<div class="codehilite"><pre translate="no">((<span class="n">1</span> + <span class="n">2</span>) + <span class="n">3</span>) + <span class="n">4</span>
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">따라서 오른쪽 피연산자를 첫 번째 피연산자로 구문 분석할 때 </font></font><code translate="no">+</code><font papago-translate="splitted"><font papago-translate="translated">, 우리는 소비하고 싶습니다 </font></font><code translate="no">2</code><font papago-translate="splitted"><font papago-translate="translated">, 하지만 나머지는 아니기 때문에 위의 한 레벨을 사용합니다 </font></font><code translate="no">+</code><font papago-translate="splitted"><font papago-translate="translated">의 우선순위.</font><font papago-translate="translated"> 하지만 만약 우리 운영자가<em> 올바른</em> 연상이라면, 이것은 잘못된 것입니다.</font><font papago-translate="translated"> 주어진:</font></font></p>
<div class="codehilite"><pre translate="no"><span class="i">a</span> = <span class="i">b</span> = <span class="i">c</span> = <span class="i">d</span>
</pre></div>
<p><font papago-translate="translated">할당은 오른쪽 연관성이 있으므로 다음과 같이 구문 분석하고자 합니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="i">a</span> = (<span class="i">b</span> = (<span class="i">c</span> = <span class="i">d</span>))
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">이를 위해 다음과 같이 전화합니다 </font></font><code translate="no">parsePrecedence()</code><font papago-translate="splitted"><font papago-translate="translated"> 현재 운영자와<em> 동일</em>한 우선순위로.</font></font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">이렇게 하면 싱글을 사용할 수 있습니다 </font></font><code translate="no">binary()</code><font papago-translate="splitted"><font papago-translate="translated"> 모든 이진 연산자에 대해 서로 다른 우선순위를 가지더라도 함수.</font></font></p>
<h2><a href="https://youhogeon-meritz.github.io/compiling-expressions.html#a-pratt-parser" id="a-pratt-parser"><small><font papago-translate="translated">17 . 6</font></small><font papago-translate="splitted"><font papago-translate="translated">프랫 파서</font></font></a></h2>
<p><font papago-translate="splitted"><font papago-translate="translated">이제 컴파일러의 모든 조각과 부품이 배치되었습니다.</font><font papago-translate="translated"> 각 문법 제작에 대한 기능이 있습니다: </font></font><code translate="no">number()</code><font papago-translate="splitted"><font papago-translate="translated">, </font></font><code translate="no">grouping()</code><font papago-translate="splitted"><font papago-translate="translated">, </font></font><code translate="no">unary()</code><font papago-translate="splitted"><font papago-translate="translated">,그리고. </font></font><code translate="no">binary()</code><font papago-translate="splitted"><font papago-translate="translated">. 우리는 여전히 구현해야 합니다 </font></font><code translate="no">parsePrecedence()</code><font papago-translate="splitted"><font papago-translate="translated">,그리고. </font></font><code translate="no">getRule()</code><font papago-translate="splitted"><font papago-translate="translated">. 또한 토큰 유형이 주어지면 다음을 찾을 수 있는 테이블이 필요하다는 것도 알고 있습니다</font></font></p>
<ul>
<li>
<p><font papago-translate="translated">해당 유형의 토큰으로 시작하는 접두사 표현식을 컴파일하는 함수,</font></p>
</li>
<li>
<p><font papago-translate="translated">왼쪽 피연산자 뒤에 해당 유형의 토큰이 오는 인픽스 표현식을 컴파일하는 함수, 그리고</font></p>
</li>
<li>
<p><font papago-translate="translated">해당 토큰을 연산자로 사용하는<span name="prefix"> infix</span> 표현식의 우선순위.</font></p>
</li>
</ul>
<aside name="prefix" style="top: 16747.5px;">
<p><font papago-translate="translated">Lox의 모든 접두사 연산자는 동일한 우선순위를 가지고 있기 때문에 주어진 토큰으로 시작하는<em> 접두사</em> 표현식의 우선순위를 추적할 필요가 없습니다.</font></p>
</aside>
<p><font papago-translate="translated">우리는 이 세 가지 속성을 파서 테이블의 단일 행을 나타내는 작은 구조로 포장합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">} Precedence;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> enum<em> Precedence</em> 뒤에 추가</font></font></div>
<pre class="insert" translate="no">
<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">ParseFn</span> <span class="i">prefix</span>;
  <span class="t">ParseFn</span> <span class="i">infix</span>;
  <span class="t">Precedence</span> <span class="i">precedence</span>;
} <span class="t">ParseRule</span>;
</pre><pre class="insert-after" translate="no">
Parser parser;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after enum <em>Precedence</em></div>
<p><font papago-translate="translated">그 ParseFn 유형은 인수를 사용하지 않고 아무것도 반환하지 않는 함수 유형에 대한 간단한<span name="typedef"> typedef</span>입니다.</font></p>
<aside class="bottom" name="typedef" style="top: 17016.5px;">
<p><font papago-translate="translated">함수 포인터 유형에 대한 C의 구문이 너무 나빠서 항상 typedef 뒤에 숨깁니다.</font><font papago-translate="translated"> 구문의 의도는 이해하지만, 전체 "선언문은 사용을 반영한다"는 것입니다. 하지만 저는 그것이 실패한 구문<span class="em"></span><span class="em"></span> 실험이었다고 생각합니다.</font></p>
</aside>
<div class="codehilite"><pre class="insert-before" translate="no">} Precedence;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> enum<em> Precedence</em> 뒤에 추가</font></font></div>
<pre class="insert" translate="no">
<span class="k">typedef</span> <span class="t">void</span> (*<span class="t">ParseFn</span>)();
</pre><pre class="insert-after" translate="no">
typedef struct {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after enum <em>Precedence</em></div>
<p><font papago-translate="translated">우리 전체 파서를 구동하는 테이블은 ParseRules 배열입니다.</font><font papago-translate="translated"> 우리는 그것에 대해 오랫동안 이야기해왔고, 마침내 그것을 보게 되었습니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>단항</em> () 후에 추가</font></font></div>
<pre translate="no"><span class="t">ParseRule</span> <span class="i">rules</span>[] = {
  [<span class="a">TOKEN_LEFT_PAREN</span>]    = {<span class="i">grouping</span>, <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_RIGHT_PAREN</span>]   = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_LEFT_BRACE</span>]    = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},<span name="big"> </span>
  [<span class="a">TOKEN_RIGHT_BRACE</span>]   = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_COMMA</span>]         = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_DOT</span>]           = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_MINUS</span>]         = {<span class="i">unary</span>,    <span class="i">binary</span>, <span class="a">PREC_TERM</span>},
  [<span class="a">TOKEN_PLUS</span>]          = {<span class="a">NULL</span>,     <span class="i">binary</span>, <span class="a">PREC_TERM</span>},
  [<span class="a">TOKEN_SEMICOLON</span>]     = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_SLASH</span>]         = {<span class="a">NULL</span>,     <span class="i">binary</span>, <span class="a">PREC_FACTOR</span>},
  [<span class="a">TOKEN_STAR</span>]          = {<span class="a">NULL</span>,     <span class="i">binary</span>, <span class="a">PREC_FACTOR</span>},
  [<span class="a">TOKEN_BANG</span>]          = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_BANG_EQUAL</span>]    = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_EQUAL</span>]         = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_EQUAL_EQUAL</span>]   = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_GREATER</span>]       = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_GREATER_EQUAL</span>] = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_LESS</span>]          = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_LESS_EQUAL</span>]    = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_IDENTIFIER</span>]    = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_STRING</span>]        = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_NUMBER</span>]        = {<span class="i">number</span>,   <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_AND</span>]           = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_CLASS</span>]         = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_ELSE</span>]          = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_FALSE</span>]         = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_FOR</span>]           = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_FUN</span>]           = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_IF</span>]            = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_NIL</span>]           = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_OR</span>]            = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_PRINT</span>]         = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_RETURN</span>]        = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_SUPER</span>]         = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_THIS</span>]          = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_TRUE</span>]          = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_VAR</span>]           = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_WHILE</span>]         = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_ERROR</span>]         = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
  [<span class="a">TOKEN_EOF</span>]           = {<span class="a">NULL</span>,     <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
};
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>unary</em>()</div>
<aside name="big" style="top: 17398.5px;">
<p><font papago-translate="translated">새 칼럼이 필요할 때마다 테이블을 다시 방문하고 싶지 않다는 게 무슨 뜻인지 아시겠죠?</font><font papago-translate="translated"> 짐승입니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">아직 보지 않으셨다면 </font></font><code translate="no">[TOKEN_DOT] =</code><font papago-translate="splitted"><font papago-translate="translated"> C 배열 리터럴의 구문, 즉 C99의 지정된 이니셜라이저 구문입니다.</font><font papago-translate="translated"> 배열 인덱스를 손으로 셀 필요 없이 더 명확합니다.</font></font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">어떻게 하는지 볼 수 있습니다 </font></font><code translate="no">grouping</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">unary</code><font papago-translate="splitted"><font papago-translate="translated"> 각 토큰 유형에 대한 접두사 파서 열에 슬롯이 있습니다.</font><font papago-translate="translated"> 다음 열에서, </font></font><code translate="no">binary</code><font papago-translate="splitted"><font papago-translate="translated"> 는 네 개의 산술 인픽스 연산자에 연결되어 있습니다.</font><font papago-translate="translated"> 해당 infix 연산자들도 마지막 열에 우선순위가 설정되어 있습니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">그 외에도 테이블의 나머지 부분은 다음과 같습니다 </font></font><code translate="no">NULL</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">PREC_NONE</code><font papago-translate="splitted"><font papago-translate="translated">. 대부분의 빈 셀은 해당 토큰과 관련된 표현이 없기 때문입니다.</font><font papago-translate="translated"> 예를 들어 표현을 시작할 수는 없습니다, </font></font><code translate="no">else</code><font papago-translate="splitted"><font papago-translate="translated">,그리고. </font></font><code translate="no">}</code><font papago-translate="splitted"><font papago-translate="translated"> 꽤 혼란스러운 infix 연산자를 만들 수 있습니다.</font></font></p>
<p><font papago-translate="translated">하지만, 또한, 우리는 아직 전체 문법을 다 채우지 못했습니다.</font><font papago-translate="translated"> 이후 장에서는 새로운 표현형을 추가할 때 이러한 슬롯 중 일부에 함수가 포함될 것입니다.</font><font papago-translate="translated"> 이 구문 분석 접근 방식에서 제가 좋아하는 점 중 하나는 문법에서 사용 중인 토큰과 사용 가능한 토큰을 매우 쉽게 확인할 수 있다는 점입니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">이제 테이블을 확보했으니, 드디어 이를 사용하는 코드를 작성할 준비가 되었습니다.</font><font papago-translate="translated"> 이것이 바로 우리 프랫 파서가 살아나는 곳입니다.</font><font papago-translate="translated"> 정의하기 가장 쉬운 함수는 다음과 같습니다 </font></font><code translate="no">getRule()</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>parse</em>P<em>recedence</em>() 다음에 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">ParseRule</span>* <span class="i">getRule</span>(<span class="t">TokenType</span> <span class="i">type</span>) {
  <span class="k">return</span> &amp;<span class="i">rules</span>[<span class="i">type</span>];
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>parsePrecedence</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">주어진 인덱스에서 규칙을 반환하기만 하면 됩니다.</font><font papago-translate="translated"> 다음에 의해 호출됩니다 </font></font><code translate="no">binary()</code><font papago-translate="splitted"><font papago-translate="translated"> 현재 운영자의 우선순위를 조회합니다.</font><font papago-translate="translated"> 이 함수는 오직 C 코드의 선언 주기를 처리하기 위해 존재합니다. </font></font><code translate="no">binary()</code><font papago-translate="splitted"><font papago-translate="translated"> 테이블<em>이</em> 포인터를 저장할 수 있도록 규칙 테이블<em> 앞에</em> 정의됩니다.</font><font papago-translate="translated"> 이는 다음과 같은 본문을 의미합니다 </font></font><code translate="no">binary()</code><font papago-translate="splitted"><font papago-translate="translated"> 테이블에 직접 액세스할 수 없습니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">대신 조회를 함수로 마무리합니다.</font><font papago-translate="translated"> 이를 통해 다음과 같이 선언할 수 있습니다 </font></font><code translate="no">getRule()</code><font papago-translate="splitted"><font papago-translate="translated"> 정의하기 전에 </font></font><code translate="no">binary()</code> <font papago-translate="splitted"><font papago-translate="translated">, 그리고<span name="forward"></span><em> 나서 정의</em>하기</font></font> <code translate="no">getRule()</code><font papago-translate="splitted"><font papago-translate="translated"> 테이블 뒤에.</font><font papago-translate="translated"> 우리의 문법이 재귀적이라는 사실을 다루기 위해 몇 가지 다른 순방향 선언이 필요할 것이므로, 이를 모두 없애 보겠습니다.</font></font></p>
<aside name="forward" style="top: 18911.5px;">
<p><font papago-translate="translated">이것은 PDP-11에서 컴파일되도록 설계된 언어로 VM을 작성할 때 발생하는 일입니다.</font></p>
</aside>
<div class="codehilite"><pre class="insert-before" translate="no">  emitReturn();
}
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>endCompiler</em>() 뒤에 추가</font></font></div>
<pre class="insert" translate="no">
<span class="k">static</span> <span class="t">void</span> <span class="i">expression</span>();
<span class="k">static</span> <span class="t">ParseRule</span>* <span class="i">getRule</span>(<span class="t">TokenType</span> <span class="i">type</span>);
<span class="k">static</span> <span class="t">void</span> <span class="i">parsePrecedence</span>(<span class="t">Precedence</span> <span class="i">precedence</span>);

</pre><pre class="insert-after" translate="no">static void binary() {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>endCompiler</em>()</div>
<p><font papago-translate="translated">클로크를 직접 팔로우하고 구현하는 경우 코드 조각을 어디에 넣어야 하는지 알려주는 작은 주석에 주의를 기울이세요.</font><font papago-translate="translated"> 하지만 틀리면 C 컴파일러가 기꺼이 알려드릴 테니 걱정하지 마세요.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/compiling-expressions.html#parsing-with-precedence" id="parsing-with-precedence"><small><font papago-translate="translated">17 . 6 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">우선순위로 구문 분석하기</font></font></a></h3>
<p><font papago-translate="splitted"><font papago-translate="translated">이제 재미있는 이야기로 넘어가겠습니다.</font><font papago-translate="translated"> 우리가 정의한 모든 파싱 함수를 조율하는 마에스트로는 다음과 같습니다 </font></font><code translate="no">parsePrecedence()</code><font papago-translate="splitted"><font papago-translate="translated">. 접두사 표현식을 구문 분석하는 것부터 시작하겠습니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">static void parsePrecedence(Precedence precedence) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>parse</em>P<em>recedence</em>()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">  <span class="i">advance</span>();
  <span class="t">ParseFn</span> <span class="i">prefixRule</span> = <span class="i">getRule</span>(<span class="i">parser</span>.<span class="i">previous</span>.<span class="i">type</span>)-&gt;<span class="i">prefix</span>;
  <span class="k">if</span> (<span class="i">prefixRule</span> == <span class="a">NULL</span>) {
    <span class="i">error</span>(<span class="s">"Expect expression."</span>);
    <span class="k">return</span>;
  }

  <span class="i">prefixRule</span>();
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>parsePrecedence</em>(), replace 1 line</div>
<p><font papago-translate="translated">다음 토큰을 읽고 해당 ParseRule을 찾습니다.</font><font papago-translate="translated"> 접두사 파서가 없으면 토큰은 구문 오류여야 합니다.</font><font papago-translate="translated"> 우리는 그것을 신고하고 발신자에게 돌아갑니다.</font></p>
<p><font papago-translate="translated">그렇지 않으면, 우리는 그 접두사 구문 분석 함수를 호출하고 그것이 제 역할을 하도록 내버려 둡니다.</font><font papago-translate="translated"> 접두사 파서는 나머지 접두사 표현식을 컴파일하여 필요한 다른 토큰을 소비하고 여기로 돌아갑니다.</font><font papago-translate="translated"> 인픽스 표현은 우선순위가 작용하기 때문에 흥미로워지는 부분입니다.</font><font papago-translate="translated"> 구현은 놀라울 정도로 간단합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  prefixRule();
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>parse</em>P<em>recedence</em>()에서</font></font></div>
<pre class="insert" translate="no">
  <span class="k">while</span> (<span class="i">precedence</span> &lt;= <span class="i">getRule</span>(<span class="i">parser</span>.<span class="i">current</span>.<span class="i">type</span>)-&gt;<span class="i">precedence</span>) {
    <span class="i">advance</span>();
    <span class="t">ParseFn</span> <span class="i">infixRule</span> = <span class="i">getRule</span>(<span class="i">parser</span>.<span class="i">previous</span>.<span class="i">type</span>)-&gt;<span class="i">infix</span>;
    <span class="i">infixRule</span>();
  }
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>parsePrecedence</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">그게 전부입니다.</font><font papago-translate="translated"> 정말로.</font><font papago-translate="translated"> 전체 기능이 작동하는 방식은 다음과 같습니다:</font><font papago-translate="translated"> 시작할 때 </font></font><code translate="no">parsePrecedence()</code><font papago-translate="splitted"><font papago-translate="translated">, 현재 토큰의 접두사 파서를 찾습니다.</font><font papago-translate="translated"> 첫 번째 토큰은<em></em> 정의상 항상 어떤 종류의 접두사 표현식에 속하게 됩니다.</font><font papago-translate="translated"> 하나 이상의 infix 표현식 안에 피연산자로 중첩되어 있을 수 있지만, 코드를 왼쪽에서 오른쪽으로 읽을 때 가장 먼저 치는 토큰은 항상 접두사 표현식에 속합니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">더 많은 토큰을 소비할 수 있는 이를 구문 분석한 후 접두사 표현이 완료됩니다.</font><font papago-translate="translated"> 이제 다음 토큰을 위한 infix 파서를 찾습니다.</font><font papago-translate="translated"> 하나를 찾으면, 우리가 이미 컴파일한 접두사 표현식이 그에 대한 피연산자일 수 있다는 뜻입니다.</font><font papago-translate="translated"> 하지만 오직 다음과 같은 요청이 있을 때만 </font></font><code translate="no">parsePrecedence()</code><font papago-translate="splitted"><font papago-translate="translated"> 을 가지고 있습니다 </font></font><code translate="no">precedence</code><font papago-translate="splitted"><font papago-translate="translated"> 그것은 해당 infix 연산자를 허용할 만큼 충분히 낮습니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">다음 토큰의 우선순위가 너무 낮거나 아예 인픽스 연산자가 아니라면, 우리는 끝입니다.</font><font papago-translate="translated"> 우리는 가능한 한 많은 표현을 분석했습니다.</font><font papago-translate="translated"> 그렇지 않으면 연산자를 소비하고 찾은 인픽스 파서에게 제어권을 넘깁니다.</font><font papago-translate="translated"> 필요한 다른 토큰(보통 적절한 피연산자)을 모두 소비하고 다시 돌아갑니다 </font></font><code translate="no">parsePrecedence()</code><font papago-translate="splitted"><font papago-translate="translated">. 그런 다음 다시 돌아가서<em> 다음</em> 토큰이 앞의 전체 식을 피연산자로 사용할 수 있는 유효한 인픽스 연산자인지 확인합니다.</font><font papago-translate="translated"> 우리는 인픽스 연산자가 아니거나 너무 낮은 우선순위와 중지 상태에 있는 토큰에 도달할 때까지 인픽스 연산자와 그 피연산자들을 통해 계속해서 그렇게 반복합니다.</font></font></p>
<p><font papago-translate="translated">그건 정말 많은 산문이지만, 본 프랫과 섞여서 알고리즘을 완전히 이해하고 싶다면, 디버거의 파서를 통해 몇 가지 표현식을 처리해 보세요.</font><font papago-translate="translated"> 아마도 사진이 도움이 될 것입니다.</font><font papago-translate="translated"> 기능은 몇 가지에 불과하지만 놀랍도록 얽혀 있습니다:</font></p>
<p><span name="connections"></span></p>
<p><img alt="The various parsing
functions and how they call each other." src="https://youhogeon-meritz.github.io/image/compiling-expressions/connections.png"></p>
<aside name="connections" style="top: 20677.5px;">
<p><font papago-translate="splitted"><font papago-translate="translated">그 </font></font><img alt="A solid arrow." class="arrow" src="https://youhogeon-meritz.github.io/image/compiling-expressions/calls.png"><font papago-translate="splitted"><font papago-translate="translated"> 화살표는 함수를 직접 호출하는 다른 함수와 연결합니다.</font><font papago-translate="translated"> 그 </font></font><img alt="An open
arrow." class="arrow" src="https://youhogeon-meritz.github.io/image/compiling-expressions/points-to.png"><font papago-translate="splitted"><font papago-translate="translated"> 화살표는 구문 분석 함수에 대한 표의 포인터를 보여줍니다.</font></font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">나중에 이 장의 코드를 조정하여 과제를 처리해야 합니다.</font><font papago-translate="translated"> 하지만 그렇지 않으면, 우리가 쓴 글은 책의 나머지 부분에 대한 우리의 모든 표현 편집 요구 사항을 다룹니다.</font><font papago-translate="translated"> 새로운 종류의 표현식을 추가할 때 추가 구문 분석 기능을 테이블에 연결할 것입니다 </font></font><code translate="no">parsePrecedence()</code><font papago-translate="splitted"><font papago-translate="translated"> 완료되었습니다.</font></font></p>
<h2><a href="https://youhogeon-meritz.github.io/compiling-expressions.html#dumping-chunks" id="dumping-chunks"><small><font papago-translate="translated">17 . 7</font></small><font papago-translate="splitted"><font papago-translate="translated">덤핑 청크</font></font></a></h2>
<p><font papago-translate="translated">우리가 컴파일러의 핵심에 있는 동안, 우리는 몇 가지 도구를 도입해야 합니다.</font><font papago-translate="translated"> 생성된 바이트코드를 디버깅하기 위해 컴파일러가 완료되면 청크 덤프 지원을 추가할 예정입니다.</font><font papago-translate="translated"> 우리가 청크를 손으로 작성했을 때, 이전에 일시적인 로깅이 있었습니다.</font><font papago-translate="translated"> 이제 원할 때 언제든지 활성화할 수 있도록 실제 코드를 입력하겠습니다.</font></p>
<p><font papago-translate="translated">이것은 최종 사용자를 위한 것이 아니기 때문에 깃발 뒤에 숨깁니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#include &lt;stdint.h&gt;

</pre><div class="source-file"><em><font papago-translate="translated">일반적인.h</font></em></div>
<pre class="insert" translate="no"><span class="a">#define DEBUG_PRINT_CODE</span>
</pre><pre class="insert-after" translate="no">#define DEBUG_TRACE_EXECUTION
</pre></div>
<div class="source-file-narrow"><em>common.h</em></div>
<p><font papago-translate="translated">플래그가 정의되면 기존의 "디버그" 모듈을 사용하여 청크의 바이트코드를 출력합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  emitReturn();
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>endCompiler</em>()에서</font></font></div>
<pre class="insert" translate="no"><span class="a">#ifdef DEBUG_PRINT_CODE</span>
  <span class="k">if</span> (!<span class="i">parser</span>.<span class="i">hadError</span>) {
    <span class="i">disassembleChunk</span>(<span class="i">currentChunk</span>(), <span class="s">"code"</span>);
  }
<span class="a">#endif</span>
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>endCompiler</em>()</div>
<p><font papago-translate="translated">코드에 오류가 없는 경우에만 이 작업을 수행합니다.</font><font papago-translate="translated"> 구문 오류가 발생한 후 컴파일러는 계속 진행되지만 약간 이상한 상태가 되어 코드가 손상될 수 있습니다.</font><font papago-translate="translated"> 실행되지 않기 때문에 무해하지만, 읽으려고 하면 혼란스러울 수 있습니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">마지막으로, 접근하기 위해 </font></font><code translate="no">disassembleChunk()</code><font papago-translate="splitted"><font papago-translate="translated">, 헤더를 포함해야 합니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#include "scanner.h"
</pre><div class="source-file"><em><font papago-translate="translated">컴파일러.c</font></em></div>
<pre class="insert" translate="no">
<span class="a">#ifdef DEBUG_PRINT_CODE</span>
<span class="a">#include "debug.h"</span>
<span class="a">#endif</span>
</pre><pre class="insert-after" translate="no">
typedef struct {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em></div>
<p><font papago-translate="translated">우리가 해냈어!</font><font papago-translate="translated"> 이것은 우리 VM의 컴파일 및 실행 파이프라인에 마지막으로 설치된 주요 섹션이었습니다.</font><font papago-translate="translated"> 우리의 통역사는 별로 비슷해<em> 보이지</em> 않지만, 그 안에는 스캔, 구문 분석, 바이트코드로 컴파일, 실행이 포함되어 있습니다.</font></p>
<p><font papago-translate="translated">VM을 실행하고 식을 입력합니다.</font><font papago-translate="translated"> 우리가 모든 것을 제대로 했다면, 결과를 계산하고 출력해야 합니다.</font><font papago-translate="translated"> 이제 우리는 매우 정교하게 설계된 산술 계산기를 가지고 있습니다.</font><font papago-translate="translated"> 다음 장에 추가할 언어 기능이 많지만, 그 기초는 마련되어 있습니다.</font></p>
<div class="challenges">
<h2><a href="https://youhogeon-meritz.github.io/compiling-expressions.html#challenges" id="challenges"><font papago-translate="translated">과제들</font></a></h2>
<ol>
<li>
<p><font papago-translate="splitted"><font papago-translate="translated">파서를 제대로 이해하려면 실행 스레드가 흥미로운 파싱<span class="em"></span> 기능을 어떻게 처리하는지 확인해야 합니다</font></font><code translate="no">parsePrecedence()</code><font papago-translate="splitted"><font papago-translate="translated"> 테이블에 저장된 파서 함수.</font><font papago-translate="translated"> 이 (이상한) 표현을 사용해 보세요:</font></font></p>
<div class="codehilite"><pre translate="no">(-<span class="n">1</span> + <span class="n">2</span>) * <span class="n">3</span> - -<span class="n">4</span>
</pre></div>
<p><font papago-translate="translated">그 함수들이 어떻게 불리는지 추적해 보세요.</font><font papago-translate="translated"> 그들이 부르는 순서, 부르는 순서, 그리고 그들에게 전달된 논거를 보여줍니다.</font></p>
</li>
<li>
<p><font papago-translate="splitted"><font papago-translate="translated">ParseRule 행 </font></font><code translate="no">TOKEN_MINUS</code><font papago-translate="splitted"><font papago-translate="translated"> 접두사 및 접두사 함수 포인터가 모두 있습니다.</font><font papago-translate="translated"> 그 이유는 </font></font><code translate="no">-</code><font papago-translate="splitted"><font papago-translate="translated"> 는 접두사 연산자(단항 부정)이자 접두사 연산자(subt 분수)입니다.</font></font></p>
<p><font papago-translate="translated" class="">전체 Lox 언어에서 접두사와 접두사 위치 모두에서 사용할 수 있는 다른 토큰은 무엇입니까?</font><font papago-translate="translated" class=""> 당신이 선택한 C 언어나 다른 언어는 어떻습니까?</font></p>
</li>
<li>
<p><font papago-translate="splitted"><font papago-translate="translated" class="">토큰으로 구분된 두 개 이상의 피연산자가 있는 복잡한 "믹스픽스" 표현식에 대해 궁금해할 수 있습니다.</font><font papago-translate="translated"> C의 조건부 또는 "삼차" 연산자, </font></font><code translate="no">?:</code><font papago-translate="splitted"><font papago-translate="translated">, 널리 알려진 것입니다.</font></font></p>
<p><font papago-translate="translated">컴파일러에 해당 연산자에 대한 지원을 추가합니다.</font><font papago-translate="translated" class=""> 바이트코드를 생성할 필요 없이 파서에 연결하고 피연산자를 처리하는 방법을 보여주기만 하면 됩니다.</font></p>
</li>
</ol>
</div>
<div class="design-note">
<h2><a href="https://youhogeon-meritz.github.io/compiling-expressions.html#design-note" id="design-note"><font papago-translate="translated">디자인 노트:</font><font papago-translate="translated"> 파싱일 뿐입니다</font></a></h2>
<p><font papago-translate="translated" class="">여기서는 일부 컴파일러와 언어 사용자들 사이에서 인기가 없을 것이라는 주장을 하려고 합니다.</font><font papago-translate="translated" class=""> 동의하지 않으셔도 괜찮습니다.</font><font papago-translate="translated" class=""> 개인적으로 저는 여러 페이지의 예선과 모호함보다는 제가 동의하지 않는 강한 의견에서 더 많은 것을 배웁니다.</font><font papago-translate="translated"> <em>제</em> 주장은<em> 구문 분석이 중요하지 않다는</em> 것입니다.</font></p>
<p><font papago-translate="translated">수년에 걸쳐 많은 프로그래밍 언어 사용자들, 특히 학계에서 파서에 관심을 갖고 이를<em></em> 매우 진지하게 받아들였습니다.</font><font papago-translate="translated"> 처음<span name="yacc">에는 컴파일</span>러 사람들이<span name="yacc"> 컴파일러-컴파일러</span>, LALR 등 다양한 분야에 뛰어들었습니다.</font><font papago-translate="translated"> 드래곤북의 전반부는 파서 생성자들의 경이로움에 대한 긴 러브레터입니다.</font></p>
<aside name="yacc" style="top: 23153.5px;">
<p><font papago-translate="translated">우리 모두는 "망치만 있으면 모든 것이 못처럼 보인다"는 악습에 시달리지만, 아마도 컴파일러만큼 눈에 띄는 사람은 없을 것입니다.</font><font papago-translate="translated"> 컴파일러 해커에게 도움을 요청하자마자 기적적으로 새로운 작은 언어가 필요한 것처럼 보이는 다양한 소프트웨어 문제를 믿을 수 없을 것입니다.</font></p>
<p><font papago-translate="translated">Yacc와 다른 컴파일러 컴파일러들은 가장 유쾌하게 재귀적인 예입니다.</font><font papago-translate="translated"> "와우, 컴파일러를 쓰는 건 정말 번거롭네요.</font><font papago-translate="translated"> 알아요, 우리를 위해 컴파일러를 작성해 봅시다</font></p>
<p><font papago-translate="translated">참고로, 저는 이 고통에 대한 면책을 주장하지 않습니다.</font></p>
</aside>
<p><font papago-translate="translated" class="">나중에 기능 프로그래밍 전문가들은 파서 조합기, 팩랫 파서 등 다양한 분야에 진출했습니다.</font><font papago-translate="translated" class=""> 왜냐하면, 당연히 함수형 프로그래머에게 문제를 주면, 그들이 가장 먼저 할 일은 고차 함수들을 한 주머니 가득 채우는 것이기 때문입니다.</font></p>
<p><font papago-translate="translated">수학 및 알고리즘 분석 분야에서는 다양한 구문 분석 기법에 대한 시간과 메모리 사용량을 증명하고, 구문 분석 문제를 다른 문제로 변환하며, 다양한 문법에 복잡도 클래스를 할당하는 연구가 오랜 역사를 가지고 있습니다.</font></p>
<p><font papago-translate="translated">어느 정도는 이것이 중요합니다.</font><font papago-translate="translated"> 언어를 구현하는 경우 파서가 기하급수적으로 증가하여 문법에서 이상한 엣지 케이스를 파싱하는 데 7,000년이 걸리지 않는다는 보장이 필요합니다.</font><font papago-translate="translated"> 파서 이론은 그 한계를 제공합니다.</font><font papago-translate="translated"> 지적 연습으로서 파싱 기법에 대해 배우는 것도 재미있고 보람 있는 일입니다.</font></p>
<p><font papago-translate="translated">하지만 목표가 단순히 언어를 구현하여 사용자들 앞에 알리는 것이라면, 거의 모든 것이 중요하지 않습니다.</font><font papago-translate="translated"> 사람들의 열정에 자극받아 프론트엔드에 윙뱅으로 생성된 조합기-파서-팩토리<em></em> 제품<em>이 필요하다고</em> 생각하는 것은 정말 쉽습니다.</font><font papago-translate="translated"> 요즘 핫 라이브러리나 기법을 사용하여 파서를 쓰고 다시 쓰는 데 많은 시간을 소모하는 사람들을 본 적이 있습니다.</font></p>
<p><font papago-translate="translated">그 시간은 사용자의 삶에 아무런 가치를 부여하지 않습니다.</font><font papago-translate="translated"> 파서를 완성하려고 한다면, 표준 기술 중 하나를 선택하여 사용한 후 계속 진행하세요.</font><font papago-translate="translated"> 재귀적 하강법, 프랫 파싱, 그리고 ANTLR이나 Bison과 같은 인기 있는 파서 생성기도 괜찮습니다.</font></p>
<p><font papago-translate="translated">파싱 코드를 다시 작성하지 않고 절약한 여분의 시간을 들여 컴파일러가 사용자에게 보여주는 컴파일 오류 메시지를 개선하는 데 사용하세요.</font><font papago-translate="translated"> 오류를 잘 처리하고 보고하는 것은 프론트엔드에서 시간을 투자할 수 있는 거의 모든 것보다 사용자에게 더 가치가 있습니다.</font></p>
</div>
<footer>
<a class="next" href="https://youhogeon-meritz.github.io/types-of-values.html"><font papago-translate="translated"> 다음 장: "가치의 유형" → </font></a><font papago-translate="splitted"><font papago-translate="translated"> 로버트 니스트롬이 수작업으로 제작한 -<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE"> © 2015 ~ 2021</a></font></font>
</footer>
</article>
</div>


<div id="papagoTooltip" margin="5" style="display: none;">
        <h1 id="tooltipTitle">원문</h1>
        <p id="tooltipText"></p>
      </div>
      </body></html>