<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>Closures · Crafting Interpreters</title>
<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta content="width=device-width, initial-scale=1" name="viewport">
<link href="https://youhogeon-meritz.github.io/style.css" rel="stylesheet" type="text/css">
<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600" rel="stylesheet" type="text/css">
<link href="https://youhogeon-meritz.github.io/image/favicon.png" rel="icon" type="image/png">


<!-- Google analytics -->

</head>
<body id="top">
<!-- <div class="scrim"></div> -->
<nav class="wide">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<div class="contents">
<h3><a href="https://youhogeon-meritz.github.io/closures.html#top"><font papago-translate="splitted"><font papago-translate="translated">폐쇄</font></font><small>25</small></a></h3>
<ul>
<li><a href="https://youhogeon-meritz.github.io/closures.html#closure-objects"><small>25.1</small><font papago-translate="splitted"><font papago-translate="translated"> 개체 닫기</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/closures.html#upvalues"><small>25.2</small><font papago-translate="splitted"><font papago-translate="translated"> 업밸류</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/closures.html#upvalue-objects"><small>25.3</small><font papago-translate="splitted"><font papago-translate="translated"> 업밸류 객체</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/closures.html#closed-upvalues"><small>25.4</small><font papago-translate="splitted"><font papago-translate="translated"> 닫힌 업값</font></font></a></li>
<li class="divider"></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/closures.html#challenges"><font papago-translate="translated">과제들</font></a></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/closures.html#design-note"><small><font papago-translate="translated">메모</font></small><font papago-translate="splitted"><font papago-translate="translated">루프 변수에 대한 클로징</font></font></a></li>
</ul>
<div class="prev-next">
<a class="left" href="https://youhogeon-meritz.github.io/calls-and-functions.html" title="호출 및 기능" papago-attr-id="1"><font papago-translate="translated">← 이전</font></a>
<a href="https://youhogeon-meritz.github.io/a-bytecode-virtual-machine.html" title="바이트코드 가상 머신" papago-attr-id="2"><font papago-translate="translated">↑ 위로</font></a>
<a class="right" href="https://youhogeon-meritz.github.io/garbage-collection.html" title="쓰레기 수거" papago-attr-id="3"><font papago-translate="translated">다음 →</font></a>
</div> </div>
</nav>
<nav class="narrow">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<a class="prev" href="https://youhogeon-meritz.github.io/calls-and-functions.html" title="Calls and Functions">←</a>
<a class="next" href="https://youhogeon-meritz.github.io/garbage-collection.html" title="Garbage Collection">→</a>
</nav>
<div class="page">
<div class="nav-wrapper">
<nav class="floating">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<div class="expandable">
<h3><a href="https://youhogeon-meritz.github.io/closures.html#top"><font papago-translate="splitted"><font papago-translate="translated">폐쇄</font></font><small>25</small></a></h3>
<ul>
<li><a href="https://youhogeon-meritz.github.io/closures.html#closure-objects"><small>25.1</small><font papago-translate="splitted"><font papago-translate="translated"> 개체 닫기</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/closures.html#upvalues"><small>25.2</small><font papago-translate="splitted"><font papago-translate="translated"> 업밸류</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/closures.html#upvalue-objects"><small>25.3</small><font papago-translate="splitted"><font papago-translate="translated"> 업밸류 객체</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/closures.html#closed-upvalues"><small>25.4</small><font papago-translate="splitted"><font papago-translate="translated"> 닫힌 업값</font></font></a></li>
<li class="divider"></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/closures.html#challenges">Challenges</a></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/closures.html#design-note"><small>note</small><font papago-translate="splitted"><font papago-translate="translated">루프 변수에 대한 클로징</font></font></a></li>
</ul>
<div class="prev-next">
<a class="left" href="https://youhogeon-meritz.github.io/calls-and-functions.html" title="Calls and Functions">←&nbsp;Previous</a>
<a href="https://youhogeon-meritz.github.io/a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">↑&nbsp;Up</a>
<a class="right" href="https://youhogeon-meritz.github.io/garbage-collection.html" title="Garbage Collection">Next&nbsp;→</a>
</div> </div>
<a id="expand-nav">≡</a>
</nav>
</div>
<article class="chapter">
<div class="number">25</div>
<h1><font papago-translate="translated">폐쇄</font></h1>
<blockquote>
<p><font papago-translate="translated">남자가 말했듯이, 모든 복잡한 문제에는 간단한 해결책이 있으며, 그것은 잘못되었습니다.</font></p>
<p><cite>Umberto Eco, <em>Foucault’s Pendulum</em></cite></p>
</blockquote>
<p><font papago-translate="translated"><a href="https://youhogeon-meritz.github.io/calls-and-functions.html">지난 장</a>에서 열심히 일한 덕분에, 우리는 작동 기능을 갖춘 가상 머신을 갖게 되었습니다.</font><font papago-translate="translated"> 부족한 것은 폐쇄입니다.</font><font papago-translate="translated"> 고유한 동물 품종인 전역 변수를 제외하고, 함수는 자신의 몸 밖에서 선언된 변수를 참조할 방법이 없습니다.</font></p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="i">x</span> = <span class="s">"global"</span>;
<span class="k">fun</span> <span class="i">outer</span>() {
  <span class="k">var</span> <span class="i">x</span> = <span class="s">"outer"</span>;
  <span class="k">fun</span> <span class="i">inner</span>() {
    <span class="k">print</span> <span class="i">x</span>;
  }
  <span class="i">inner</span>();
}
<span class="i">outer</span>();
</pre></div>
<p><font papago-translate="translated">지금 이 예제를 실행하면 "global"로 출력됩니다.</font><font papago-translate="translated"> "외부"를 인쇄해야 합니다.</font><font papago-translate="translated"> 이 문제를 해결하려면 변수를 해결할 때 모든 주변 함수의 전체 어휘 범위를 포함해야 합니다.</font></p>
<p><font papago-translate="translated">이 문제는 우리 바이트코드 VM이 로컬을 스택에 저장하기 때문에 jlox보다 clox에서 더 어렵습니다.</font><font papago-translate="translated"> 우리는 스택을 사용했습니다. 왜냐하면 로컬들이 스택 의미론을 가지고 있다고 주장했기 때문입니다. 변수들은<span class="em"></span> 생성된 순서와 반대로 버려집니다.</font><font papago-translate="translated"> 하지만 폐업의 경우<em> 대부분</em> 사실입니다.</font></p>
<div class="codehilite"><pre translate="no"><span class="k">fun</span> <span class="i">makeClosure</span>() {
  <span class="k">var</span> <span class="i">local</span> = <span class="s">"local"</span>;
  <span class="k">fun</span> <span class="i">closure</span>() {
    <span class="k">print</span> <span class="i">local</span>;
  }
  <span class="k">return</span> <span class="i">closure</span>;
}

<span class="k">var</span> <span class="i">closure</span> = <span class="i">makeClosure</span>();
<span class="i">closure</span>();
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">외부 함수 </font></font><code translate="no">makeClosure()</code><font papago-translate="splitted"><font papago-translate="translated"> 변수를 선언합니다, </font></font><code translate="no">local</code><font papago-translate="splitted"><font papago-translate="translated">. 그것은 또한 내적 기능을 만듭니다, </font></font><code translate="no">closure()</code><font papago-translate="splitted"><font papago-translate="translated"> 그것은 그 변수를 포착합니다.</font><font papago-translate="translated"> 그리고나서 </font></font><code translate="no">makeClosure()</code><font papago-translate="splitted"><font papago-translate="translated"> 해당 함수에 대한 참조를 반환합니다.</font><font papago-translate="translated"> 폐쇄가 로컬 변수를 붙잡고<span name="flying"> 탈출</span>하기 때문에, </font></font><code translate="no">local</code><font papago-translate="splitted"><font papago-translate="translated"> 함수 호출이 생성된 위치보다 오래 지속되어야 합니다.</font></font></p>
<aside name="flying" style="top: 1176px;"><img alt="A local variable flying away from the stack." class="above" src="https://youhogeon-meritz.github.io/image/closures/flying.png">
<p><font papago-translate="translated">오, 안 돼요. 탈출하고 있어요!</font></p>
</aside>
<p><font papago-translate="translated">우리는 모든 지역 변수에 대해 동적으로 메모리를 할당함으로써 이 문제를 해결할 수 있습니다.</font><font papago-translate="translated"> Jlox는 Java 더미에 떠다니는 환경 객체에 모든 것을 배치하여 그렇게 합니다.</font><font papago-translate="translated"> 하지만 우리는 원하지 않습니다.</font><font papago-translate="translated"> <span name="stack">스택</span>을 사용하는 것은<em> 정말</em> 빠릅니다.</font><font papago-translate="translated"> 대부분의 지역 변수는 폐쇄에 의해 포착<em>되지</em> 않으며 스택 의미론을 가지고 있습니다.</font><font papago-translate="translated"> 포획된 희귀 지역의 이익을 위해 이 모든 것을 느리게 만드는 것은 어리석은 일입니다.</font></p>
<aside name="stack" style="top: 1296px;">
<p><font papago-translate="translated">결국 C와 Java가 로컬 변수에 스택을 사용하는 데에는 이유가 있습니다.</font></p>
</aside>
<p><font papago-translate="translated">이것은 우리가 자바 인터프리터에서 사용했던 것보다 더 복잡한 접근 방식을 의미합니다.</font><font papago-translate="translated"> 일부 지역 주민들의 수명이 매우 다르기 때문에, 우리는 두 가지 실행 전략을 가질 것입니다.</font><font papago-translate="translated"> 폐쇄에 사용되지 않는 지역 주민들을 위해, 우리는 그것들을 그대로 보관할 것입니다.</font><font papago-translate="translated"> 지역 주민이 폐쇄에 의해 포획되면, 필요한 만큼 오래 살 수 있는 다른 해결책을 채택할 것입니다.</font></p>
<p><font papago-translate="translated">폐쇄는 초기 리스프 시대부터 메모리와 CPU 사이클 바이트가 에메랄드보다 더 소중했던 시절부터 존재해 왔습니다.</font><font papago-translate="translated"> 그 사이 수십 년 동안 해커들은 최적화된 런타임 표현을 위해 클로저를 컴파일하는 모든<span name="lambda"> 방법</span>을 고안했습니다.</font><font papago-translate="translated"> 일부는 더 효율적이지만, 우리가 쉽게 클록으로 개조할 수 있는 것보다 더 복잡한 컴파일 과정이 필요합니다.</font></p>
<aside name="lambda" style="top: 1632px;">
<p><font papago-translate="translated">탐색을 시작하려면 "폐쇄 전환" 또는 "람다 리프팅"을 검색하세요.</font></p>
</aside>
<p><font papago-translate="translated">제가 여기서 설명하는 기법은 Lua VM의 설계에서 나온 것입니다.</font><font papago-translate="translated"> 빠르고 메모리가 간결하며 상대적으로 적은 코드로 구현됩니다.</font><font papago-translate="translated"> 더욱 인상적인 것은, 이 기능이 단일 패스 컴파일러인 clox와 Lua에 자연스럽게 적용된다는 점입니다.</font><font papago-translate="translated"> 하지만 다소 복잡합니다.</font><font papago-translate="translated"> 모든 조각들이 마음속에서 하나로 합쳐지기까지는 시간이 좀 걸릴 수 있습니다.</font><font papago-translate="translated"> 우리는 그것들을 한 단계씩 구축할 것이고, 단계별로 개념들을 소개해 보겠습니다.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/closures.html#closure-objects" id="closure-objects"><small><font papago-translate="translated">25 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">개체 닫기</font></font></a></h2>
<p><font papago-translate="translated">우리의 VM은 ObjFunction을 사용하여 런타임 시 함수를 나타냅니다.</font><font papago-translate="translated"> 이 객체들은 컴파일 중에 프론트엔드에 의해 생성됩니다.</font><font papago-translate="translated"> 런타임 시 VM은 함수 객체를 상수 테이블에서 로드하고 이름에 바인딩하는 작업만 수행합니다.</font><font papago-translate="translated"> 런타임 시 함수를 "생성"하는 작업은 없습니다.</font><font papago-translate="translated"> 문자열 및 숫자<span name="literal"> 리터럴</span>과 마찬가지로, 이들은 컴파일 시에만 인스턴스화된 상수입니다.</font></p>
<aside name="literal" style="top: 2088px;">
<p><font papago-translate="translated">다시 말해, L<em>ox</em>의 함수 선언<em>은</em> 일종의 문자 그대로, 내장<span class="em"></span>형 타입의 상수 값을 정의하는 구문의 한 부분<em>입니다</em>.</font></p>
</aside>
<p><font papago-translate="translated">함수를 구성하는 모든 데이터, 즉 함수의 본문에서 컴파일된 바이트코드의 덩어리와 본문에서 사용되는 상수가 컴파일 시점에 알려져 있기 때문에 이는 당연한 결과입니다.</font><font papago-translate="translated"> 하지만 일단 폐쇄를 도입하면 그 표현은 더 이상 충분하지 않습니다.</font><font papago-translate="translated"> 갠더를 살펴보세요:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">fun</span> <span class="i">makeClosure</span>(<span class="i">value</span>) {
  <span class="k">fun</span> <span class="i">closure</span>() {
    <span class="k">print</span> <span class="i">value</span>;
  }
  <span class="k">return</span> <span class="i">closure</span>;
}

<span class="k">var</span> <span class="i">doughnut</span> = <span class="i">makeClosure</span>(<span class="s">"doughnut"</span>);
<span class="k">var</span> <span class="i">bagel</span> = <span class="i">makeClosure</span>(<span class="s">"bagel"</span>);
<span class="i">doughnut</span>();
<span class="i">bagel</span>();
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">그 </font></font><code translate="no">makeClosure()</code><font papago-translate="splitted"><font papago-translate="translated"> 함수는 함수를 정의하고 반환합니다.</font><font papago-translate="translated"> 두 번 호출하면 두 번 종료됩니다.</font><font papago-translate="translated"> 동일한 중첩 함수 선언에 의해 생성됩니다, </font></font><code translate="no">closure</code><font papago-translate="splitted"><font papago-translate="translated">, 하지만 서로 다른 값으로 마무리합니다.</font><font papago-translate="translated"> 두 개의 클로저를 호출하면 각각 다른 문자열이 인쇄됩니다.</font><font papago-translate="translated"> 이는 함수 선언<em>이</em> 컴파일될 때뿐만 아니라 함수 선언<em>이 실행</em>될 때 함수를 둘러싼 로컬 변수를 존재하는 그대로 캡처하는 클로저에 대한 런타임 표현이 필요하다는 것을 의미합니다.</font></font></p>
<p><font papago-translate="translated">변수를 포착하기 위해 노력하겠지만, 좋은 첫 번째 단계는 그 객체 표현을 정의하는 것입니다.</font><font papago-translate="translated"> 우리의 기존 ObjFunction 타입은 함수 선언의<span name="raw"> "원시</span>" 컴파일 타임 상태를 나타냅니다. 왜냐하면 단일 선언에서 생성된 모든 클로저는 동일한 코드와 상수를 공유하기 때문입니다.</font><font papago-translate="translated"> 런타임에 함수 선언을 실행할 때, 우리는 ObjFunction을 새로운 ObjClosure 구조로 감싸줍니다.</font><font papago-translate="translated"> 후자는 함수가 닫히는 변수에 대한 런타임 상태와 함께 기본 베어 함수에 대한 참조를 가지고 있습니다.</font></p>
<aside name="raw" style="top: 2692px;">
<p><font papago-translate="translated">Lua 구현은 바이트코드를 포함하는 원시 함수 객체를 "프로토타입"으로 지칭하며,<a href="https://en.wikipedia.org/wiki/Prototype-based_programming"> 이</a>를 설명하는 데 좋은 단어입니다. 다만<a href="https://en.wikipedia.org/wiki/Prototype-based_programming">, 이</a> 단어는<a href="https://en.wikipedia.org/wiki/Prototype-based_programming"> 프로토타입 상속</a>을 지칭하기 위해 과부하가 걸리기도 합니다.</font></p>
</aside><img alt="An ObjClosure with a reference to an ObjFunction." src="https://youhogeon-meritz.github.io/image/closures/obj-closure.png">
<p><font papago-translate="translated">함수가 실제로 닫히지 않고 주변 지역 변수를 포착하지 않더라도 모든 함수를 ObjClosure로 감싸겠습니다.</font><font papago-translate="translated"> 이것은 약간 낭비적이지만, 우리가 부르는 함수가 항상 ObjClosure라고 가정할 수 있기 때문에 VM을 단순화합니다.</font><font papago-translate="translated"> 그 새로운 구조는 이렇게 시작됩니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 구조 Ob<em>jString</em> 뒤에 추가</font></font></div>
<pre translate="no"><span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">Obj</span> <span class="i">obj</span>;
  <span class="t">ObjFunction</span>* <span class="i">function</span>;
} <span class="t">ObjClosure</span>;
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after struct <em>ObjString</em></div>
<p><font papago-translate="translated">지금은 단순히 ObjFunction을 가리키며 필요한 객체 헤더 항목을 추가합니다.</font><font papago-translate="translated"> clox에 새로운 객체 유형을 추가하는 일반적인 의식을 통해 새로운 폐쇄를 만들기 위해 C 함수를 선언합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">} ObjClosure;

</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 구조 후 Ob<em>jClosure</em> 추가</font></font></div>
<pre class="insert" translate="no"><span class="t">ObjClosure</span>* <span class="i">newClosure</span>(<span class="t">ObjFunction</span>* <span class="i">function</span>);
</pre><pre class="insert-after" translate="no">ObjFunction* newFunction();
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after struct <em>ObjClosure</em></div>
<p><font papago-translate="translated">그런 다음 여기에 구현합니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>할당</em> 후 추가O<em>bject</em>()</font></font></div>
<pre translate="no"><span class="t">ObjClosure</span>* <span class="i">newClosure</span>(<span class="t">ObjFunction</span>* <span class="i">function</span>) {
  <span class="t">ObjClosure</span>* <span class="i">closure</span> = <span class="a">ALLOCATE_OBJ</span>(<span class="t">ObjClosure</span>, <span class="a">OBJ_CLOSURE</span>);
  <span class="i">closure</span>-&gt;<span class="i">function</span> = <span class="i">function</span>;
  <span class="k">return</span> <span class="i">closure</span>;
}
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, add after <em>allocateObject</em>()</div>
<p><font papago-translate="translated">그것은 자신이 감싸고 있는 ObjFunction에 대한 포인터를 가져옵니다.</font><font papago-translate="translated"> 또한 타입 필드를 새로운 타입으로 초기화합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">typedef enum {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> enum Ob<em>jType</em>에서</font></font></div>
<pre class="insert" translate="no">  <span class="a">OBJ_CLOSURE</span>,
</pre><pre class="insert-after" translate="no">  OBJ_FUNCTION,
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, in enum <em>ObjType</em></div>
<p><font papago-translate="translated">그리고 마무리가 끝나면 그 기억을 해제합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  switch (object-&gt;type) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>free</em>O<em>bject</em>()에서</font></font></div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="a">OBJ_CLOSURE</span>: {
      <span class="a">FREE</span>(<span class="t">ObjClosure</span>, <span class="i">object</span>);
      <span class="k">break</span>;
    }
</pre><pre class="insert-after" translate="no">    case OBJ_FUNCTION: {
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>freeObject</em>()</div>
<p><font papago-translate="translated">우리는 ObjClosure 자체만 해제하고 ObjFunction은 해제하지 않습니다.</font><font papago-translate="translated"> 그것은 폐쇄가 그 기능<em>을 소유하지</em> 않기 때문입니다.</font><font papago-translate="translated"> 동일한 기능을 모두 참조하는 여러 폐쇄가 있을 수 있으며, 그 중 어느 것도 특별한 특권을 주장하지 않습니다.</font><font papago-translate="translated"> ObjFunction을 참조<em>하는</em> 모든 객체가 사라질 때까지 자유롭게 할 수 없습니다. 심지어 상수 테이블이<span class="em"></span> 포함된 주변 함수도 마찬가지입니다.</font><font papago-translate="translated"> 추적하는 것은 까다롭게 들리는데, 정말 그렇습니다!</font><font papago-translate="translated"> 그래서 우리는 곧 쓰레기 수거기를 써서 우리를 위해 관리할 것입니다.</font></p>
<p><font papago-translate="translated">값의 유형을 확인하는 일반<span name="macro">적인 매크로</span>도 있습니다.</font></p>
<aside name="macro" style="top: 4152px;">
<p><font papago-translate="translated">아마도 이러한 매크로를 더 쉽게 생성할 수 있도록 매크로를 정의했어야 했을 것입니다.</font><font papago-translate="translated"> 그건 좀 너무 메타적일 수도 있습니다.</font></p>
</aside>
<div class="codehilite"><pre class="insert-before" translate="no">#define OBJ_TYPE(value)        (AS_OBJ(value)-&gt;type)

</pre><div class="source-file"><em><font papago-translate="translated">객체.h</font></em></div>
<pre class="insert" translate="no"><span class="a">#define IS_CLOSURE(value)      isObjType(value, OBJ_CLOSURE)</span>
</pre><pre class="insert-after" translate="no">#define IS_FUNCTION(value)     isObjType(value, OBJ_FUNCTION)
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>
<p><font papago-translate="translated">그리고 가치를 부여하기 위해:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#define IS_STRING(value)       isObjType(value, OBJ_STRING)

</pre><div class="source-file"><em><font papago-translate="translated">객체.h</font></em></div>
<pre class="insert" translate="no"><span class="a">#define AS_CLOSURE(value)      ((ObjClosure*)AS_OBJ(value))</span>
</pre><pre class="insert-after" translate="no">#define AS_FUNCTION(value)     ((ObjFunction*)AS_OBJ(value))
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>
<p><font papago-translate="translated">클로저는 일류 물건이므로 인쇄할 수 있습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  switch (OBJ_TYPE(value)) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>print</em>O<em>bject</em>()에서</font></font></div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="a">OBJ_CLOSURE</span>:
      <span class="i">printFunction</span>(<span class="a">AS_CLOSURE</span>(<span class="i">value</span>)-&gt;<span class="i">function</span>);
      <span class="k">break</span>;
</pre><pre class="insert-after" translate="no">    case OBJ_FUNCTION:
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>printObject</em>()</div>
<p><font papago-translate="translated">ObjFunction과 동일하게 표시됩니다.</font><font papago-translate="translated"> 사용자의 관점에서 ObjFunction과 ObjClosure의 차이점은 순전히 숨겨진 구현 세부 사항입니다.</font><font papago-translate="translated"> 이를 해결하면 폐쇄에 대한 작업 중이지만 비어 있는 표현이 생깁니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/closures.html#compiling-to-closure-objects" id="compiling-to-closure-objects"><small><font papago-translate="translated">25 . 1 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">객체를 닫기 위해 컴파일하기</font></font></a></h3>
<p><font papago-translate="translated">폐쇄 객체는 있지만 VM에서 생성하지 않습니다.</font><font papago-translate="translated"> 다음 단계는 컴파일러가 주어진 ObjFunction을 랩핑할 새로운 ObjClosure를 생성할 시기를 런타임에 알려주는 명령을 실행하도록 하는 것입니다.</font><font papago-translate="translated"> 이것은 함수 선언이 끝날 때 바로 발생합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  ObjFunction* function = endCompiler();
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>함수</em> ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">  <span class="i">emitBytes</span>(<span class="a">OP_CLOSURE</span>, <span class="i">makeConstant</span>(<span class="a">OBJ_VAL</span>(<span class="i">function</span>)));
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>function</em>(), replace 1 line</div>
<p><font papago-translate="splitted"><font papago-translate="translated">이전에는 함수 선언의 최종 바이트코드가 단일 코드였습니다 </font></font><code translate="no">OP_CONSTANT</code><font papago-translate="splitted"><font papago-translate="translated"> 컴파일된 함수를 주변 함수의 상수 테이블에서 불러와 스택에 밀어 넣는 방법.</font><font papago-translate="translated"> 이제 새로운 지침이 생겼습니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  OP_CALL,
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">청크.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> enum O<em>pCode</em>에서</font></font></div>
<pre class="insert" translate="no">  <span class="a">OP_CLOSURE</span>,
</pre><pre class="insert-after" translate="no">  OP_RETURN,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>
<p><font papago-translate="splitted"><font papago-translate="translated">맘에 들다 </font></font><code translate="no">OP_CONSTANT</code><font papago-translate="splitted"><font papago-translate="translated">, 함수의 상수 테이블 인덱스를 나타내는 단일 피연산자가 필요합니다.</font><font papago-translate="translated"> 하지만 런타임 구현으로 넘어가면 더 흥미로운 작업을 수행합니다.</font></font></p>
<p><font papago-translate="translated">먼저, 부지런한 VM 해커가 되어 명령어에 대한 분해자 지원을 제공합시다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    case OP_CALL:
      return byteInstruction("OP_CALL", chunk, offset);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">debug.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>분해</em> 중 지침()</font></font></div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="a">OP_CLOSURE</span>: {
      <span class="i">offset</span>++;
      <span class="t">uint8_t</span> <span class="i">constant</span> = <span class="i">chunk</span>-&gt;<span class="i">code</span>[<span class="i">offset</span>++];
      <span class="i">printf</span>(<span class="s">"%-16s %4d "</span>, <span class="s">"OP_CLOSURE"</span>, <span class="i">constant</span>);
      <span class="i">printValue</span>(<span class="i">chunk</span>-&gt;<span class="i">constants</span>.<span class="i">values</span>[<span class="i">constant</span>]);
      <span class="i">printf</span>(<span class="s">"</span><span class="e">\n</span><span class="s">"</span>);
      <span class="k">return</span> <span class="i">offset</span>;
    }
</pre><pre class="insert-after" translate="no">    case OP_RETURN:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">여기에는 우리가 보통 분해기에서 하는 것보다 더 많은 일이 일어나고 있습니다.</font><font papago-translate="translated"> 이 장이 끝날 때쯤, 당신은 다음과 같은 사실을 알게 될 것입니다 </font></font><code translate="no">OP_CLOSURE</code><font papago-translate="splitted"><font papago-translate="translated"> 매우 이례적인 지침입니다.</font><font papago-translate="translated"> 지금은 간단하지만, 단 하나의 바이트 피연산자만<span class="em"></span><span class="em"></span> 추가할 예정입니다.</font><font papago-translate="translated"> 이 코드는 그 미래를 예측합니다.</font></font></p>
<h3><a href="https://youhogeon-meritz.github.io/closures.html#interpreting-function-declarations" id="interpreting-function-declarations"><small><font papago-translate="translated">25 . 1 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">함수 선언 해석</font></font></a></h3>
<p><font papago-translate="translated">우리가 해야 할 대부분의 작업은 실행 시간에 있습니다.</font><font papago-translate="translated"> 우리는 자연스럽게 새로운 지시를 처리해야 합니다.</font><font papago-translate="translated"> 하지만 우리는 또한 ObjFunction과 함께 작동하는 VM의 모든 코드 조각을 터치하고 대신 ObjClosure를 사용하도록 변경해야 합니다 — 함수 호출, 호출 프레임<span class="em"></span> 등.</font><font papago-translate="translated"> 하지만 지침부터 시작하겠습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      }
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font></div>
<pre class="insert" translate="no">      <span class="k">case</span> <span class="a">OP_CLOSURE</span>: {
        <span class="t">ObjFunction</span>* <span class="i">function</span> = <span class="a">AS_FUNCTION</span>(<span class="a">READ_CONSTANT</span>());
        <span class="t">ObjClosure</span>* <span class="i">closure</span> = <span class="i">newClosure</span>(<span class="i">function</span>);
        <span class="i">push</span>(<span class="a">OBJ_VAL</span>(<span class="i">closure</span>));
        <span class="k">break</span>;
      }
</pre><pre class="insert-after" translate="no">      case OP_RETURN: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">마찬가지로 </font></font><code translate="no">OP_CONSTANT</code><font papago-translate="splitted"><font papago-translate="translated"> 이전에 사용했던 명령어를 먼저 상수 테이블에서 컴파일된 함수를 로드합니다.</font><font papago-translate="translated"> 이제 차이점은 그 함수를 새로운 ObjClosure에 랩핑하고 결과를 스택에 푸시한다는 것입니다.</font></font></p>
<p><font papago-translate="translated">일단 문을 닫으면, 결국 그것을 부르고 싶을 것입니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    switch (OBJ_TYPE(callee)) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>callValue</em>()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 두 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">      <span class="k">case</span> <span class="a">OBJ_CLOSURE</span>:
        <span class="k">return</span> <span class="i">call</span>(<span class="a">AS_CLOSURE</span>(<span class="i">callee</span>), <span class="i">argCount</span>);
</pre><pre class="insert-after" translate="no">      case OBJ_NATIVE: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>callValue</em>(), replace 2 lines</div>
<p><font papago-translate="splitted"><font papago-translate="translated">다음 유형의 객체 호출 코드를 제거합니다 </font></font><code translate="no">OBJ_FUNCTION</code><font papago-translate="splitted"><font papago-translate="translated">. 모든 함수를 ObjClosures로 감싸기 때문에 런타임에서는 더 이상 베어 ObjFunction을 호출하려고 하지 않습니다.</font><font papago-translate="translated"> 그 물체들은 일정한 테이블에만 존재하며, 다른 물체<span name="naked"></span>들이 보기 전에 즉시 닫힙니다.</font></font></p>
<aside name="naked" style="top: 6432px;">
<p><font papago-translate="translated">우리는 VM 주변을 돌아다니는 벌거벗은 기능을 원하지 않습니다!</font><font papago-translate="translated"> 이웃들은 뭐라고 말할까요?</font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">이전 코드를 폐쇄 호출을 위해 매우 유사한 코드로 대체합니다.</font><font papago-translate="translated"> 유일한 차이점은 우리가 전달하는 객체의 유형입니다 </font></font><code translate="no">call()</code><font papago-translate="splitted"><font papago-translate="translated">. 그 기능의 진정한 변화는 끝났습니다.</font><font papago-translate="translated"> 먼저, 서명을 업데이트합니다.</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 함수<em> 호출</em> ()</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no"><span class="k">static</span> <span class="t">bool</span> <span class="i">call</span>(<span class="t">ObjClosure</span>* <span class="i">closure</span>, <span class="t">int</span> <span class="i">argCount</span>) {
</pre><pre class="insert-after" translate="no">  if (argCount != function-&gt;arity) {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, function <em>call</em>(), replace 1 line</div>
<p><font papago-translate="translated">그런 다음, 우리 몸에서 함수를 참조한 모든 것을 수정하여 우리가 간접적인 층을 도입했다는 사실을 처리해야 합니다.</font><font papago-translate="translated"> 우리는 아티시티 검사부터 시작합니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">static bool call(ObjClosure* closure, int argCount) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>콜</em> ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 3줄 교체</font></font></div>
<pre class="insert" translate="no">  <span class="k">if</span> (<span class="i">argCount</span> != <span class="i">closure</span>-&gt;<span class="i">function</span>-&gt;<span class="i">arity</span>) {
    <span class="i">runtimeError</span>(<span class="s">"Expected %d arguments but got %d."</span>,
        <span class="i">closure</span>-&gt;<span class="i">function</span>-&gt;<span class="i">arity</span>, <span class="i">argCount</span>);
</pre><pre class="insert-after" translate="no">    return false;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>call</em>(), replace 3 lines</div>
<p><font papago-translate="splitted"><font papago-translate="translated">유일한 변화는 기본 함수에 도달하기 위해 클로저를 풀었다는 것입니다.</font><font papago-translate="translated"> 다음 것은 </font></font><code translate="no">call()</code><font papago-translate="splitted"><font papago-translate="translated"> 새로운 CallFrame을 만드는 것입니다.</font><font papago-translate="translated"> 우리는 그 코드를 변경하여 CallFrame에 클로저를 저장하고 클로저의 함수에서 바이트코드 포인터를 가져옵니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  CallFrame* frame = &amp;vm.frames[vm.frameCount++];
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>콜</em> ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 두 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">  <span class="i">frame</span>-&gt;<span class="i">closure</span> = <span class="i">closure</span>;
  <span class="i">frame</span>-&gt;<span class="i">ip</span> = <span class="i">closure</span>-&gt;<span class="i">function</span>-&gt;<span class="i">chunk</span>.<span class="i">code</span>;
</pre><pre class="insert-after" translate="no">  frame-&gt;slots = vm.stackTop - argCount - 1;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>call</em>(), replace 2 lines</div>
<p><font papago-translate="translated">이를 위해서는 CallFrame 선언도 변경해야 합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">typedef struct {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">VM.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 구조 콜<em>프레임</em>에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">  <span class="t">ObjClosure</span>* <span class="i">closure</span>;
</pre><pre class="insert-after" translate="no">  uint8_t* ip;
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, in struct <em>CallFrame</em>, replace 1 line</div>
<p><font papago-translate="translated">그 변화는 몇 가지 다른 연쇄적인 변화를 유발합니다.</font><font papago-translate="translated"> VM에서 CallFrame의 기능에 액세스한 모든 장소는 대신 클로저를 사용해야 합니다.</font><font papago-translate="translated"> 먼저, 현재 함수의 상수 테이블에서 상수를 읽기 위한 매크로입니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    (uint16_t)((frame-&gt;ip[-2] &lt;&lt; 8) | frame-&gt;ip[-1]))

</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 두 줄 바꾸기</font></font></div>
<pre class="insert" translate="no"><span class="a">#define READ_CONSTANT() \</span>
<span class="a">    (frame-&gt;closure-&gt;function-&gt;chunk.constants.values[READ_BYTE()])</span>
</pre><pre class="insert-after" translate="no">
#define READ_STRING() AS_STRING(READ_CONSTANT())
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 2 lines</div>
<p><font papago-translate="splitted"><font papago-translate="translated">언제 </font></font><code translate="no">DEBUG_TRACE_EXECUTION</code><font papago-translate="splitted"><font papago-translate="translated"> 활성화되어 있으며, 닫힘에서 청크에 도달해야 합니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    printf("\n");
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 두 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">    <span class="i">disassembleInstruction</span>(&amp;<span class="i">frame</span>-&gt;<span class="i">closure</span>-&gt;<span class="i">function</span>-&gt;<span class="i">chunk</span>,
        (<span class="t">int</span>)(<span class="i">frame</span>-&gt;<span class="i">ip</span> - <span class="i">frame</span>-&gt;<span class="i">closure</span>-&gt;<span class="i">function</span>-&gt;<span class="i">chunk</span>.<span class="i">code</span>));
</pre><pre class="insert-after" translate="no">#endif
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 2 lines</div>
<p><font papago-translate="translated">런타임 오류를 보고할 때도 마찬가지입니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    CallFrame* frame = &amp;vm.frames[i];
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런타임</em>에<em>Error</em>()</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">    <span class="t">ObjFunction</span>* <span class="i">function</span> = <span class="i">frame</span>-&gt;<span class="i">closure</span>-&gt;<span class="i">function</span>;
</pre><pre class="insert-after" translate="no">    size_t instruction = frame-&gt;ip - function-&gt;chunk.code - 1;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>runtimeError</em>(), replace 1 line</div>
<p><font papago-translate="translated">거의 다 왔어요.</font><font papago-translate="translated"> 마지막 부분은 Lox 스크립트의 최상위 코드를 실행하기 시작하는 첫 번째 CallFrame을 설정하는 코드 덩어리입니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  push(OBJ_VAL(function));
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>해석</em>상 ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">  <span class="t">ObjClosure</span>* <span class="i">closure</span> = <span class="i">newClosure</span>(<span class="i">function</span>);
  <span class="i">pop</span>();
  <span class="i">push</span>(<span class="a">OBJ_VAL</span>(<span class="i">closure</span>));
  <span class="i">call</span>(<span class="i">closure</span>, <span class="n">0</span>);
</pre><pre class="insert-after" translate="no">
  return run();
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>interpret</em>(), replace 1 line</div>
<p><font papago-translate="translated">컴파일러<span name="pop">는</span> 스크립트를 컴파일할 때 여전히 원시<span name="pop"> Ob</span>jFunction을 반환합니다<span name="pop">.</span></font><font papago-translate="translated"> 괜찮지만 VM이 실행하기 전에 여기에 ObjClosure로 포장해야 한다는 뜻입니다.</font></p>
<aside name="pop" style="top: 8024px;">
<p><font papago-translate="translated">코드가 조금 우스꽝스러워 보입니다. 왜냐하면 우리는 여전히 원래의 ObjFunction을 스택에 밀어 넣었기 때문입니다.</font><font papago-translate="translated"> 그런 다음 클로저를 만든 후에 터뜨린 다음 클로저를 밀어 넣습니다.</font><font papago-translate="translated"> 왜 거기에 ObjFunction을 설치하나요?</font><font papago-translate="translated"> 평소처럼 이상한 스택 작업이 발생하는 것을 볼 때<a href="https://youhogeon-meritz.github.io/garbage-collection.html">는 다가오는 쓰레기 수집가</a>에게 더미에 할당된 물체를 계속 알려주는 것입니다.</font></p>
</aside>
<p><font papago-translate="translated">우리는 다시 실무 통역사로 돌아왔습니다.</font><font papago-translate="translated"> <em>사용자</em>는 차이를 구분할 수 없지만, 컴파일러는 이제 VM에게 각 함수 선언에 대한 폐쇄를 생성하라는 코드를 생성합니다.</font><font papago-translate="translated"> VM이 함수 선언을 실행할 때마다 ObjFunction을 새로운 ObjClosure로 감싸줍니다.</font><font papago-translate="translated"> 이제 나머지 VM은 떠다니는 ObjClosure를 처리합니다.</font><font papago-translate="translated"> 그것이 바로 지루한 것들입니다.</font><font papago-translate="translated"> 이제 우리는 이러한 폐쇄 조치를 실제로<em> 취할</em> 준비가 되었습니다.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/closures.html#upvalues" id="upvalues"><small><font papago-translate="translated">25 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">업밸류</font></font></a></h2>
<p><font papago-translate="translated">기존의 로컬 변수 읽기 및 쓰기 지침은 단일 함수의 스택 창으로 제한됩니다.</font><font papago-translate="translated"> 주변 함수의 지역 주민들은 내부 함수의 창 밖에 있습니다.</font><font papago-translate="translated"> 새로운 지침이 필요합니다.</font></p>
<p><font papago-translate="translated">가장 쉬운 접근 방식은 현재 함수의 창<em> 앞에</em> 도달할 수 있는 상대적인 스택 슬롯 오프셋을 취하는 명령일 수 있습니다.</font><font papago-translate="translated"> 폐쇄 변수가 항상 스택에 있다면 그것은 효과가 있을 것입니다.</font><font papago-translate="translated"> 하지만 앞서 보았듯이, 이러한 변수들은 때때로 선언된 함수보다 오래 지속되기도 합니다.</font><font papago-translate="translated"> 즉, 항상 스택에 있지는 않습니다.</font></p>
<p><font papago-translate="translated">그렇다면 다음으로 쉬운 접근 방식은 닫힌 지역 변수를 항상 힙에 저장하는 것입니다.</font><font papago-translate="translated"> 주변 함수에서 로컬 변수 선언이 실행되면 VM은 메모리를 동적으로 할당합니다.</font><font papago-translate="translated"> 그렇게 하면 필요한 만큼 오래 살 수 있습니다.</font></p>
<p><font papago-translate="translated">clox에 단일 패스 컴파일러가 없었다면 이것은 좋은 접근 방식일 것입니다.</font><font papago-translate="translated"> 하지만 우리가 구현할 때 선택한 제한은 상황을 더 어렵게 만듭니다.</font><font papago-translate="translated"> 이 예시를 살펴보세요:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">fun</span> <span class="i">outer</span>() {
  <span class="k">var</span> <span class="i">x</span> = <span class="n">1</span>;    <span class="c">// (1)</span>
  <span class="i">x</span> = <span class="n">2</span>;        <span class="c">// (2)</span>
  <span class="k">fun</span> <span class="i">inner</span>() { <span class="c">// (3)</span>
    <span class="k">print</span> <span class="i">x</span>;
  }
  <span class="i">inner</span>();
}
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">여기서 컴파일러는 선언문을 컴파일합니다 </font></font><code translate="no">x</code><font papago-translate="splitted"><font papago-translate="translated"> 에서 </font></font><code translate="no">(1)</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고 할당을 위한 코드를 다음에서 방출합니다 </font></font><code translate="no">(2)</code><font papago-translate="splitted"><font papago-translate="translated">. 선언에 도달하기 전에 그렇게 합니다 </font></font><code translate="no">inner()</code><font papago-translate="splitted"><font papago-translate="translated"> 에서 </font></font><code translate="no">(3)</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고 그것을 발견하는 것 </font></font><code translate="no">x</code><font papago-translate="splitted"><font papago-translate="translated"> 는 사실상 닫혀 있습니다.</font><font papago-translate="translated"> 우리는 이미 전송된 코드를 치료하기 위해 쉽게 돌아가서 수정할 방법이 없습니다 </font></font><code translate="no">x</code><font papago-translate="splitted"><font papago-translate="translated"> 특별히.</font><font papago-translate="translated"> 대신, 우리는 닫힌 변수가<em> 닫힌 지점까지</em> 일반적인 지역 변수처럼 스택에 정확히 존재할 수 있는 해결책을 원합니다.</font></font></p>
<p><font papago-translate="translated">다행히도 Lua 개발팀 덕분에 해결책이 생겼습니다.</font><font papago-translate="translated"> <strong>우리</strong>는<strong> 그</strong>들이<strong> 업밸류</strong>라고 부르는 수준의 간접 효과를 사용합니다.</font><font papago-translate="translated"> 업값은 엔클로저 함수의 로컬 변수를 의미합니다.</font><font papago-translate="translated"> 모든 폐쇄는 폐쇄가 사용하는 각 주변 지역 변수에 대해 하나씩 일련의 업값을 유지합니다.</font></p>
<p><font papago-translate="translated">업값은 캡처한 변수가 사는 곳을 다시 스택으로 가리킵니다.</font><font papago-translate="translated"> 폐쇄 변수에 접근해야 할 때, 해당 변수에 도달하기 위해 해당 업값을 통과합니다.</font><font papago-translate="translated"> 함수 선언이 처음 실행되고 이를 위한 폐쇄를 생성하면 VM은 업값 배열을 생성하고 이를 연결하여 폐쇄에 필요한 주변 지역 변수를 "포획"합니다.</font></p>
<p><font papago-translate="translated">예를 들어, 이 프로그램을 clox에 던지면,</font></p>
<div class="codehilite"><pre translate="no">{
  <span class="k">var</span> <span class="i">a</span> = <span class="n">3</span>;
  <span class="k">fun</span> <span class="i">f</span>() {
    <span class="k">print</span> <span class="i">a</span>;
  }
}
</pre></div>
<p><font papago-translate="translated">컴파일러와 런타임은 다음과 같은 메모리 내 객체 집합을 구축하기 위해 함께 협력합니다:</font></p><img alt="The object graph of the stack, ObjClosure, ObjFunction, and upvalue array." src="https://youhogeon-meritz.github.io/image/closures/open-upvalue.png">
<p><font papago-translate="translated">압도적으로 보일 수 있지만 두려워하지 마세요.</font><font papago-translate="translated"> 우리는 그것을 해결하기 위해 노력할 것입니다.</font><font papago-translate="translated"> 중요한 부분은 업값이 스택에서 벗어난 후에도 캡처된 로컬 변수를 계속 찾는 데 필요한 간접화 계층 역할을 한다는 것입니다.</font><font papago-translate="translated"> 하지만 그 전에 먼저 캡처된 변수를 수집하는 데 집중해 보겠습니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/closures.html#compiling-upvalues" id="compiling-upvalues"><small><font papago-translate="translated">25 . 2 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">가치를 축적하기</font></font></a></h3>
<p><font papago-translate="translated">평소처럼 컴파일 시 최대한 많은 작업을 수행하여 간단하고 빠르게 실행할 수 있도록 하고 싶습니다.</font><font papago-translate="translated"> 로컬 변수는 Lox에서 사전적으로 범위가 정해져 있기 때문에 컴파일 시 함수가 접근하는 주변 로컬 변수와 해당 로컬 변수가 어디에 선언되는지를 해결할 수 있는 충분한 지식을 가지고 있습니다.</font><font papago-translate="translated"> 즉, 클로저가 얼마나 많은 업밸류를 필요로<em> 하는지,</em> 어떤 변수를 캡처하는지, 그리고 선언 함수의 스택<em></em> 창에 어떤<em> 스택 슬롯</em>에 이러한 변수가 포함되어 있는지 알 수 있습니다.</font></p>
<p><font papago-translate="translated">현재 컴파일러는 식별자를 해결할 때 현재 함수의 블록 범위를 가장 안쪽에서 바깥쪽으로 이동합니다.</font><font papago-translate="translated"> 해당 함수에서 변수를 찾지 못하면 변수가 전역 변수여야 한다고 가정합니다.</font><font papago-translate="translated"> 우리는 함수를 둘러싸는 로컬 범위를 고려하지 않습니다. 함수들은<span class="em"></span> 바로 건너뛸 수 있습니다.</font><font papago-translate="translated"> 첫 번째 변경 사항은 외부 로컬 스코프에 대한 해상도 단계를 삽입하는 것입니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  if (arg != -1) {
    getOp = OP_GET_LOCAL;
    setOp = OP_SET_LOCAL;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>명명</em>된 변수()에서</font></font></div>
<pre class="insert" translate="no">  } <span class="k">else</span> <span class="k">if</span> ((<span class="i">arg</span> = <span class="i">resolveUpvalue</span>(<span class="i">current</span>, &amp;<span class="i">name</span>)) != -<span class="n">1</span>) {
    <span class="i">getOp</span> = <span class="a">OP_GET_UPVALUE</span>;
    <span class="i">setOp</span> = <span class="a">OP_SET_UPVALUE</span>;
</pre><pre class="insert-after" translate="no">  } else {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>namedVariable</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">이 새로운 </font></font><code translate="no">resolveUpvalue()</code><font papago-translate="splitted"><font papago-translate="translated"> 함수는 주변 함수에서 선언된 로컬 변수를 찾습니다.</font><font papago-translate="translated"> 하나를 찾으면 해당 변수에 대한 "업밸류 지수"를 반환합니다.</font><font papago-translate="translated"> (그것이 무엇을 의미하는지는 나중에 설명하겠습니다.)</font><font papago-translate="translated"> 그렇지 않으면 변수가 발견되지 않았음을 나타내기 위해 -1을 반환합니다.</font><font papago-translate="translated"> 발견된 경우, 변수의 업값을 통해 변수를 읽거나 쓰기 위해 이 두 가지 새로운 지침을 사용합니다:</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  OP_SET_GLOBAL,
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">청크.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> enum O<em>pCode</em>에서</font></font></div>
<pre class="insert" translate="no">  <span class="a">OP_GET_UPVALUE</span>,
  <span class="a">OP_SET_UPVALUE</span>,
</pre><pre class="insert-after" translate="no">  OP_EQUAL,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>
<p><font papago-translate="translated">우리는 이러한 종류의 하향식을 구현하고 있으므로, 곧 런타임에서 어떻게 작동하는지 보여드리겠습니다.</font><font papago-translate="translated"> 이제 집중해야 할 부분은 컴파일러가 실제로 식별자를 어떻게 해결하는지입니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>resolve</em>L<em>ocal</em>() 후 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">int</span> <span class="i">resolveUpvalue</span>(<span class="t">Compiler</span>* <span class="i">compiler</span>, <span class="t">Token</span>* <span class="i">name</span>) {
  <span class="k">if</span> (<span class="i">compiler</span>-&gt;<span class="i">enclosing</span> == <span class="a">NULL</span>) <span class="k">return</span> -<span class="n">1</span>;

  <span class="t">int</span> <span class="i">local</span> = <span class="i">resolveLocal</span>(<span class="i">compiler</span>-&gt;<span class="i">enclosing</span>, <span class="i">name</span>);
  <span class="k">if</span> (<span class="i">local</span> != -<span class="n">1</span>) {
    <span class="k">return</span> <span class="i">addUpvalue</span>(<span class="i">compiler</span>, (<span class="t">uint8_t</span>)<span class="i">local</span>, <span class="k">true</span>);
  }

  <span class="k">return</span> -<span class="n">1</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>resolveLocal</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">현재 함수의 범위에서 로컬 변수를 해결하지 못한 후 이를 호출하므로 해당 변수가 현재 컴파일러에 없다는 것을 알 수 있습니다.</font><font papago-translate="translated"> 컴파일러는 엔클로저 함수의 컴파일러 포인터를 저장하며, 이러한 포인터는 최상위 코드의 루트 컴파일러까지 연결된 체인을 형성한다는 점을 기억하세요.</font><font papago-translate="translated"> 따라서, 만약 동봉된 컴파일러가 </font></font><code translate="no">NULL</code><font papago-translate="splitted"><font papago-translate="translated">, 우리는 지역 변수를 찾지 못한 채 가장 바깥쪽 함수에 도달했다는 것을 알고 있습니다.</font><font papago-translate="translated"> 변수<span name="undefined">는 전역 변수</span>여야 하므로 -1을 반환합니다.</font></font></p>
<aside name="undefined" style="top: 11386.5px;">
<p><font papago-translate="translated">그것은 완전히 정의되지 않은 변수가 될 수도 있고, 심지어 글로벌 변수가 될 수도 있습니다.</font><font papago-translate="translated"> 하지만 Lox에서는 런타임까지 오류를 감지하지 못하기 때문에 컴파일러의 관점에서 보면 "희망컨대 글로벌"입니다.</font></p>
</aside>
<p><font papago-translate="translated">그렇지 않으면<em>, 우리</em>는<em> 식별자</em>를<em> 포함</em>하는 컴파일러에서<em> 로컬</em> 변수로 해결하려고 합니다.</font><font papago-translate="translated"> 다시 말해, 우리는 현재 함수 바로 바깥쪽에서 그것을 찾습니다.</font><font papago-translate="translated"> 예를 들어:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">fun</span> <span class="i">outer</span>() {
  <span class="k">var</span> <span class="i">x</span> = <span class="n">1</span>;
  <span class="k">fun</span> <span class="i">inner</span>() {
    <span class="k">print</span> <span class="i">x</span>; <span class="c">// (1)</span>
  }
  <span class="i">inner</span>();
}
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">식별자 표현식을 컴파일할 때 </font></font><code translate="no">(1)</code><font papago-translate="splitted"><font papago-translate="translated">, </font></font><code translate="no">resolveUpvalue()</code><font papago-translate="splitted"><font papago-translate="translated"> 로컬 변수를 찾습니다 </font></font><code translate="no">x</code><font papago-translate="splitted"><font papago-translate="translated"> 선언됨 </font></font><code translate="no">outer()</code><font papago-translate="splitted"><font papago-translate="translated">. 이 예제에서와 같이 발견되면<span class="em"></span><span class="em"></span> 변수를 성공적으로 해결할 수 있습니다.</font><font papago-translate="translated"> 우리는 내적 함수가 그것을 통해 변수에 접근할 수 있도록 업값을 만듭니다.</font><font papago-translate="translated"> 업밸류는 여기서 생성됩니다:</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>resolve</em>L<em>ocal</em>() 후 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">int</span> <span class="i">addUpvalue</span>(<span class="t">Compiler</span>* <span class="i">compiler</span>, <span class="t">uint8_t</span> <span class="i">index</span>,
                      <span class="t">bool</span> <span class="i">isLocal</span>) {
  <span class="t">int</span> <span class="i">upvalueCount</span> = <span class="i">compiler</span>-&gt;<span class="i">function</span>-&gt;<span class="i">upvalueCount</span>;
  <span class="i">compiler</span>-&gt;<span class="i">upvalues</span>[<span class="i">upvalueCount</span>].<span class="i">isLocal</span> = <span class="i">isLocal</span>;
  <span class="i">compiler</span>-&gt;<span class="i">upvalues</span>[<span class="i">upvalueCount</span>].<span class="i">index</span> = <span class="i">index</span>;
  <span class="k">return</span> <span class="i">compiler</span>-&gt;<span class="i">function</span>-&gt;<span class="i">upvalueCount</span>++;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>resolveLocal</em>()</div>
<p><font papago-translate="translated">컴파일러는 각 함수의 본문에서 해결한 폐쇄형 식별자를 추적하기 위해 일련의 업밸류 구조를 유지합니다.</font><font papago-translate="translated"> 컴파일러의 로컬 배열이 런타임에 로컬이 사는 스택 슬롯 인덱스를 어떻게 반영하는지 기억하시나요?</font><font papago-translate="translated"> 이 새로운 업밸류 배열은 동일한 방식으로 작동합니다.</font><font papago-translate="translated"> 컴파일러 배열의 인덱스는 런타임 시 ObjClosure에서 업값이 저장될 인덱스와 일치합니다.</font></p>
<p><font papago-translate="translated">이 함수는 해당 배열에 새로운 업값을 추가합니다.</font><font papago-translate="translated"> 또한 함수가 사용하는 업값의 수를 추적합니다.</font><font papago-translate="translated"> 런타임에 사용하려면 해당 숫자<span name="bridge">가 필요</span>하기 때문에 해당 숫자를 ObjFunction 자체에 직접 저장합니다.</font></p>
<aside name="bridge" style="top: 12194.5px;">
<p><font papago-translate="translated">상수와 함수 아티스와 마찬가지로 업값 카운트도 컴파일러와 런타임 사이의 다리를 이루는 또 다른 작은 데이터 중 하나입니다.</font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">그 </font></font><code translate="no">index</code><font papago-translate="splitted"><font papago-translate="translated"> 필드는 폐쇄형 로컬 변수의 슬롯 인덱스를 추적합니다.</font><font papago-translate="translated"> 그렇게 하면 컴파일러는 엔클로저 함수<em>에서 어떤</em> 변수를 캡처해야 하는지 알 수 있습니다.</font><font papago-translate="translated"> 우리는 그것에 대해 다시 생각해 보겠습니다 </font></font><code translate="no">isLocal</code><font papago-translate="splitted"><font papago-translate="translated"> 필드는 너무 오래 가지 않습니다.</font><font papago-translate="translated"> 마침내. </font></font><code translate="no">addUpvalue()</code><font papago-translate="splitted"><font papago-translate="translated"> 함수의 업값 목록에서 생성된 업값의 인덱스를 반환합니다.</font><font papago-translate="translated"> 그 지수는 다음과 같은 피연산자가 됩니다 </font></font><code translate="no">OP_GET_UPVALUE</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">OP_SET_UPVALUE</code><font papago-translate="splitted"><font papago-translate="translated"> 지침들.</font></font></p>
<p><font papago-translate="translated">그것이 업밸류를 해결하기 위한 기본 아이디어이지만, 함수가 완전히 구워지지 않았습니다.</font><font papago-translate="translated"> 폐쇄는 주변 함수에서 동일한 변수를 여러 번 참조할 수 있습니다.</font><font papago-translate="translated"> 이 경우 각 식별자 표현식에 대해 별도의 업값을 생성하는 데 시간과 메모리를 낭비하고 싶지 않습니다.</font><font papago-translate="translated"> 이 문제를 해결하기 위해, 새로운 업값을 추가하기 전에 먼저 함수가 해당 변수에 대해 이미 닫혀 있는 업값을 가지고 있는지 확인합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  int upvalueCount = compiler-&gt;function-&gt;upvalueCount;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>addUpvalue</em>()에서</font></font></div>
<pre class="insert" translate="no">
  <span class="k">for</span> (<span class="t">int</span> <span class="i">i</span> = <span class="n">0</span>; <span class="i">i</span> &lt; <span class="i">upvalueCount</span>; <span class="i">i</span>++) {
    <span class="t">Upvalue</span>* <span class="i">upvalue</span> = &amp;<span class="i">compiler</span>-&gt;<span class="i">upvalues</span>[<span class="i">i</span>];
    <span class="k">if</span> (<span class="i">upvalue</span>-&gt;<span class="i">index</span> == <span class="i">index</span> &amp;&amp; <span class="i">upvalue</span>-&gt;<span class="i">isLocal</span> == <span class="i">isLocal</span>) {
      <span class="k">return</span> <span class="i">i</span>;
    }
  }

</pre><pre class="insert-after" translate="no">  compiler-&gt;upvalues[upvalueCount].isLocal = isLocal;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>addUpvalue</em>()</div>
<p><font papago-translate="translated">배열에서 슬롯 인덱스가 우리가 추가하려는 것과 일치하는 업값을 찾으면<em>,</em> 그<em> 업값</em> 인덱스를 반환하고 재사용하기만 하면 됩니다.</font><font papago-translate="translated"> 그렇지 않으면 우리는 실패하고 새로운 업밸류를 추가합니다.</font></p>
<p><font papago-translate="translated">이 두 함수는 여러 새로운 상태에 접근하고 수정하므로 이를 정의해 보겠습니다.</font><font papago-translate="translated"> 먼저, 업밸류 카운트를 ObjFunction에 추가합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  int arity;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 구조 Ob<em>jFunction</em>에서</font></font></div>
<pre class="insert" translate="no">  <span class="t">int</span> <span class="i">upvalueCount</span>;
</pre><pre class="insert-after" translate="no">  Chunk chunk;
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, in struct <em>ObjFunction</em></div>
<p><font papago-translate="translated">우리는 양심적인 C 프로그래머이기 때문에 ObjFunction이 처음 할당될 때 이를 0으로 초기화합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  function-&gt;arity = 0;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>newFunction</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="i">function</span>-&gt;<span class="i">upvalueCount</span> = <span class="n">0</span>;
</pre><pre class="insert-after" translate="no">  function-&gt;name = NULL;
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>newFunction</em>()</div>
<p><font papago-translate="translated">컴파일러에서 업밸류 배열을 위한 필드를 추가합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  int localCount;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 구조<em> 컴파일</em>러에서</font></font></div>
<pre class="insert" translate="no">  <span class="t">Upvalue</span> <span class="i">upvalues</span>[<span class="a">UINT8_COUNT</span>];
</pre><pre class="insert-after" translate="no">  int scopeDepth;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in struct <em>Compiler</em></div>
<p><font papago-translate="splitted"><font papago-translate="translated">간단하게 하기 위해 고정된 크기로 제공했습니다.</font><font papago-translate="translated"> 그 </font></font><code translate="no">OP_GET_UPVALUE</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">OP_SET_UPVALUE</code><font papago-translate="splitted"><font papago-translate="translated"> 명령어는 단일 바이트 피연산자를 사용하여 업값 인덱스를 인코딩하므로 함수가 가질 수 있는 업값의 수, 즉 함수<span class="em"></span>가 닫을 수 있는 고유 변수의 수에 제한이 있습니다.</font><font papago-translate="translated"> 이를 고려할 때, 우리는 그렇게 큰 정적 배열을 감당할 수 있습니다.</font><font papago-translate="translated"> 우리는 또한 컴파일러가 그 한계를 넘치지 않도록 해야 합니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    if (upvalue-&gt;index == index &amp;&amp; upvalue-&gt;isLocal == isLocal) {
      return i;
    }
  }

</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>addUpvalue</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="k">if</span> (<span class="i">upvalueCount</span> == <span class="a">UINT8_COUNT</span>) {
    <span class="i">error</span>(<span class="s">"Too many closure variables in function."</span>);
    <span class="k">return</span> <span class="n">0</span>;
  }

</pre><pre class="insert-after" translate="no">  compiler-&gt;upvalues[upvalueCount].isLocal = isLocal;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>addUpvalue</em>()</div>
<p><font papago-translate="translated">마지막으로, 업밸류 구조 유형 자체입니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em></em>구조 후 로컬 추가</font></font></div>
<pre translate="no"><span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">uint8_t</span> <span class="i">index</span>;
  <span class="t">bool</span> <span class="i">isLocal</span>;
} <span class="t">Upvalue</span>;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after struct <em>Local</em></div>
<p><font papago-translate="splitted"><font papago-translate="translated">그 </font></font><code translate="no">index</code><font papago-translate="splitted"><font papago-translate="translated"> 필드는 업값을 캡처하는 로컬 슬롯을 저장합니다.</font><font papago-translate="translated"> 그 </font></font><code translate="no">isLocal</code><font papago-translate="splitted"><font papago-translate="translated"> 필드는 고유한 섹션을 가질 자격이 있으며, 다음 단계로 넘어가겠습니다.</font></font></p>
<h3><a href="https://youhogeon-meritz.github.io/closures.html#flattening-upvalues" id="flattening-upvalues"><small><font papago-translate="translated">25 . 2 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">업값 평탄화</font></font></a></h3>
<p><font papago-translate="translated">제가 이전에 보여드린 예시에서, 클로저는 즉시 엔클로저 함수에서 선언된 변수에 접근하는 것입니다.</font><font papago-translate="translated"> Lox는 또한 다음<em></em>과 같이 모든 범위에서 선언된 로컬 변수에 액세스하는 것을 지원합니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">fun</span> <span class="i">outer</span>() {
  <span class="k">var</span> <span class="i">x</span> = <span class="n">1</span>;
  <span class="k">fun</span> <span class="i">middle</span>() {
    <span class="k">fun</span> <span class="i">inner</span>() {
      <span class="k">print</span> <span class="i">x</span>;
    }
  }
}
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">여기에서 액세스합니다 </font></font><code translate="no">x</code><font papago-translate="splitted"><font papago-translate="translated"> 에서 </font></font><code translate="no">inner()</code><font papago-translate="splitted"><font papago-translate="translated">. 해당 변수는 다음과 같이 정의되지 않습니다 </font></font><code translate="no">middle()</code><font papago-translate="splitted"><font papago-translate="translated">, 하지만 끝까지 </font></font><code translate="no">outer()</code><font papago-translate="splitted"><font papago-translate="translated">. 이와 같은 경우도 처리해야 합니다.</font><font papago-translate="translated"> 변수가 단순히 스택에서 더 아래쪽 어딘가에 있을 것이기 때문에 이것이 훨씬 더 어렵지 않다고 생각<em>할 수 있습니다</em>.</font><font papago-translate="translated"> 하지만 이<span name="devious"> 불길</span>한 예를 생각해 보세요:</font></font></p>
<aside name="devious" style="top: 14402.5px;">
<p><font papago-translate="translated">프로그래밍 언어를 충분히 오랫동안 연구하면 기술적으로 유효하지만 자신보다 덜 비뚤어진 상상력을 가진 사람이 작성한 구현을 넘어뜨릴 수 있는 이와 같은 기괴한 프로그램을 만드는 데 정교하게 연마된 기술을 개발할 수 있습니다.</font></p>
</aside>
<div class="codehilite"><pre translate="no"><span class="k">fun</span> <span class="i">outer</span>() {
  <span class="k">var</span> <span class="i">x</span> = <span class="s">"value"</span>;
  <span class="k">fun</span> <span class="i">middle</span>() {
    <span class="k">fun</span> <span class="i">inner</span>() {
      <span class="k">print</span> <span class="i">x</span>;
    }

    <span class="k">print</span> <span class="s">"create inner closure"</span>;
    <span class="k">return</span> <span class="i">inner</span>;
  }

  <span class="k">print</span> <span class="s">"return from outer"</span>;
  <span class="k">return</span> <span class="i">middle</span>;
}

<span class="k">var</span> <span class="i">mid</span> = <span class="i">outer</span>();
<span class="k">var</span> <span class="i">in</span> = <span class="i">mid</span>();
<span class="i">in</span>();
</pre></div>
<p><font papago-translate="translated">이것을 실행할 때 인쇄해야 합니다:</font></p>
<div class="codehilite"><pre translate="no">return from outer
create inner closure
value
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">알아요, 복잡해요.</font><font papago-translate="translated"> 중요한 부분은 </font></font><code translate="no">outer()</code><font papago-translate="splitted"><font papago-translate="translated"><span class="em"></span>-어디에서 </font></font><code translate="no">x</code><font papago-translate="splitted"><font papago-translate="translated"> 선언됨 — 선언<em></em><span class="em"></span>하기 전에 모든 변수를 스택에서 returns하고 터뜨립니다 </font></font><code translate="no">inner()</code><font papago-translate="splitted"><font papago-translate="translated"> 실행합니다.</font><font papago-translate="translated"> 그래서 우리가 클로저를 만드는 시점에서 </font></font><code translate="no">inner()</code><font papago-translate="splitted"><font papago-translate="translated">, </font></font><code translate="no">x</code><font papago-translate="splitted"><font papago-translate="translated"> 이미 스택에서 벗어났습니다.</font></font></p>
<p><font papago-translate="translated">여기에서 실행 흐름을 추적했습니다:</font></p><img alt="Tracing through the previous example program." src="https://youhogeon-meritz.github.io/image/closures/execution-flow.png">
<p><font papago-translate="splitted"><font papago-translate="translated">어떻게 보입니까 </font></font><code translate="no">x</code><font papago-translate="splitted"><font papago-translate="translated"> ①가 캡처되기 전에 팝업된 후 나중에 ③에 액세스하기 전에 ②가 발생합니까?</font><font papago-translate="translated"> 우리는 정말로 두 가지 문제가 있습니다:</font></font></p>
<ol>
<li>
<p><font papago-translate="translated">우리는 주변 함수에서 선언된 지역 변수들을 즉시 둘러싸는 변수를 넘어서 해결해야 합니다.</font></p>
</li>
<li>
<p><font papago-translate="translated">우리는 이미 스택을 떠난 변수들을 포착할 수 있어야 합니다.</font></p>
</li>
</ol>
<p><font papago-translate="translated">다행히도 우리는 VM에 업값을 추가하는 중이며, 업값은 스택을 벗어난 변수를 추적하기 위해 명시적으로 설계되었습니다.</font><font papago-translate="translated"> 따라서 현명한 자기 참조를 통해 업값을 사용하여 업값이 주변 함수 외부에 선언된 변수를 포착할 수 있도록 할 수 있습니다.</font></p>
<p><font papago-translate="translated">해결책은 클로저가 즉시 둘러싸는 함수에서 로컬 변수나<em> 기존 업값</em>을 포착할 수 있도록 하는 것입니다.</font><font papago-translate="translated"> 깊이 중첩된 함수가 여러 홉 떨어진 곳에 선언된 로컬 변수를 참조하는 경우, 각 함수가 다음 함수를 잡을 때의 업값을 캡처하도록 하여 모든 중간 함수에 이를 스레딩합니다.</font></p><img alt="An upvalue in inner() points to an upvalue in middle(), which points to a local variable in outer()." src="https://youhogeon-meritz.github.io/image/closures/linked-upvalues.png">
<p><font papago-translate="splitted"><font papago-translate="translated">위의 예시에서, </font></font><code translate="no">middle()</code><font papago-translate="splitted"><font papago-translate="translated"> 로컬 변수 캡처 </font></font><code translate="no">x</code><font papago-translate="splitted"><font papago-translate="translated"> 즉시 둘러싸는 함수에서 </font></font><code translate="no">outer()</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고 그것을 고유한 가치로 저장합니다.</font><font papago-translate="translated"> 하지만 이렇게 합니다 </font></font><code translate="no">middle()</code><font papago-translate="splitted"><font papago-translate="translated"> 그 자체는 참조하지 않습니다 </font></font><code translate="no">x</code><font papago-translate="splitted"><font papago-translate="translated">. 그러면, 다음과 같은 선언이 있을 때 </font></font><code translate="no">inner()</code><font papago-translate="splitted"><font papago-translate="translated"> 실행, 그 폐쇄는 ObjClosure에서<em> 다음</em>과 같은<em> 이유</em>로<em> 상승 값</em>을 가져옵니다 </font></font><code translate="no">middle()</code><font papago-translate="splitted"><font papago-translate="translated"> 캡처된 </font></font><code translate="no">x</code><font papago-translate="splitted"><font papago-translate="translated">. 함수는 로컬 또는 업값을 포함하여 바로 주변 함수에서만 캡처되며, 내부 함수 선언<em></em><span class="em"></span><span class="em"></span>이 실행되는 지점에서 여전히 존재할 것이 보장됩니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">이를 구현하기 위해, </font></font><code translate="no">resolveUpvalue()</code><font papago-translate="splitted"><font papago-translate="translated"> 재귀적이 됩니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  if (local != -1) {
    return addUpvalue(compiler, (uint8_t)local, true);
  }

</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>resolve</em>U<em>pvalue</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="t">int</span> <span class="i">upvalue</span> = <span class="i">resolveUpvalue</span>(<span class="i">compiler</span>-&gt;<span class="i">enclosing</span>, <span class="i">name</span>);
  <span class="k">if</span> (<span class="i">upvalue</span> != -<span class="n">1</span>) {
    <span class="k">return</span> <span class="i">addUpvalue</span>(<span class="i">compiler</span>, (<span class="t">uint8_t</span>)<span class="i">upvalue</span>, <span class="k">false</span>);
  }

</pre><pre class="insert-after" translate="no">  return -1;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>resolveUpvalue</em>()</div>
<p><font papago-translate="translated">코드 세 줄만 더 있으면 되지만, 처음에는 이 기능을 제대로 하는 것이 정말 어렵다는 것을 깨달았습니다.</font><font papago-translate="translated"> 이것은 제가 새로운 것을 발명한 것이 아니라 단지 루아에게서 개념을 이식한 것임에도 불구하고 말입니다.</font><font papago-translate="translated"> 대부분의 재귀 함수는 재귀 호출 전에 모든 작업을 수행하거나(<strong>사전 순서 탐색</strong> 또는 "아래로 가는 길"), 재귀 호출 후에 모든 작업을 수행합니다(<strong>사후 순서 탐색</strong> 또는 "다시 올라가는 길").</font><font papago-translate="translated"> 이 함수는 두 가지를 모두 수행합니다.</font><font papago-translate="translated"> 재귀 호출은 바로 중간에 있습니다.</font></p>
<p><font papago-translate="translated">천천히 진행하겠습니다.</font><font papago-translate="translated"> 먼저, 우리는 둘러싸기 함수에서 일치하는 지역 변수를 찾습니다.</font><font papago-translate="translated"> 하나를 찾으면 로컬을 캡처하여 반환합니다.</font><font papago-translate="translated"> <span name="base">그것</span>이<span name="base"> 기본</span> 케이스입니다.</font></p>
<aside name="base" style="top: 16847px;">
<p><font papago-translate="translated">물론 다른 기본 사례는 둘러싸기 기능이 없는 경우입니다.</font><font papago-translate="translated"> 이 경우 변수는 어휘적으로 해결할 수 없으며 전역으로 처리됩니다.</font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">그렇지 않으면, 우리는 즉시 둘러싸는 함수 너머의 지역 변수를 찾습니다.</font><font papago-translate="translated"> 우리는 그것을 재귀적으로 호출함으로써 합니다 </font></font><code translate="no">resolveUpvalue()</code><font papago-translate="splitted"><font papago-translate="translated"> <em>현재</em> 컴파일러가 아닌<em>, 동봉</em>된 컴파일러에서.</font><font papago-translate="translated"> 이 시리즈의 </font></font><code translate="no">resolveUpvalue()</code><font papago-translate="splitted"><font papago-translate="translated"> 호출은 중첩된 컴파일러 체인을 따라 작동하다가 기본 케이스 중 하나에 도달합니다. 캡처할 실제 로컬 변수를 찾거나 컴파일<span class="em"></span>러가 부족합니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">로컬 변수가 발견되면<span name="outer"> 가장</span> 깊이<span name="outer"> 중첩</span>된 호출은 다음과 같습니다 </font></font><code translate="no">resolveUpvalue()</code><font papago-translate="splitted"><font papago-translate="translated"> 캡처하여 업밸류 인덱스를 반환합니다.</font><font papago-translate="translated"> 그것은 내부 함수 선언에 대한 다음 호출로 돌아갑니다.</font><font papago-translate="translated"> 그 호출은 주변 함수에서<em> 업값</em>을 캡처하는 등의 작업을 수행합니다.</font><font papago-translate="translated"> 중첩된 각 호출마다 </font></font><code translate="no">resolveUpvalue()</code><font papago-translate="splitted"><font papago-translate="translated"> 반환되면, 우리는 해결하려는 식별자가 나타나는 가장 안쪽 함수 선언으로 다시 파고듭니다.</font><font papago-translate="translated"> 각 단계마다 중간 함수에 업값을 더하고, 그 결과 업값 인덱스를 다음 호출로 전달합니다.</font></font></p>
<aside name="outer" style="top: 17039px;">
<p><font papago-translate="splitted"><font papago-translate="translated">각 재귀 호출 </font></font><code translate="no">resolveUpvalue()</code><font papago-translate="splitted"><font papago-translate="translated"> 함수 네스팅의 한 단계를 걸어<em> 나갑니다</em>.</font><font papago-translate="translated"> 따라서 내부<em> 재귀 호출은</em><em> 외부</em> 중첩 선언을 의미합니다.</font><font papago-translate="translated"> 가장 안쪽에 있는 재귀적 호출 </font></font><code translate="no">resolveUpvalue()</code><font papago-translate="splitted"><font papago-translate="translated"> 로컬 변수를 찾는 것은 해당 변수가 실제로 선언된 둘러싸기 함수 바로 안쪽<em>의 가장 바깥</em>쪽 함수에 대한 것입니다.</font></font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">해결할 때 원래 예시를 살펴보는 것이 도움이 될 수 있습니다 </font></font><code translate="no">x</code><font papago-translate="splitted"><font papago-translate="translated">:</font></font></p><img alt="Tracing through a recursive call to resolveUpvalue()." src="https://youhogeon-meritz.github.io/image/closures/recursion.png">
<p><font papago-translate="splitted"><font papago-translate="translated">참고로, 새로운 요청은 다음과 같습니다 </font></font><code translate="no">addUpvalue()</code><font papago-translate="splitted"><font papago-translate="translated"> 패스 </font></font><code translate="no">false</code><font papago-translate="splitted"><font papago-translate="translated"> 를 위해 </font></font><code translate="no">isLocal</code><font papago-translate="splitted"><font papago-translate="translated"> 매개변수.</font><font papago-translate="translated"> 이제 그 플래그가 폐쇄가 로컬 변수를 포착하는지 아니면 주변 함수의 업값을 포착하는지를 제어하는 것을 볼 수 있습니다.</font></font></p>
<p><font papago-translate="translated">컴파일러가 함수 선언의 끝에 도달할 때까지 모든 변수 참조는 로컬, 업값 또는 글로벌로 해결되었습니다.</font><font papago-translate="translated"> 각 업값은 주변 함수에서 로컬 변수를 캡처하거나 전이적 폐쇄의 경우 업값을 캡처할 수 있습니다.</font><font papago-translate="translated"> 마침내 바이트코드를 방출할 수 있는 충분한 데이터가 확보되어 런타임에 모든 올바른 변수를 캡처하는 클로저가 생성됩니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  emitBytes(OP_CLOSURE, makeConstant(OBJ_VAL(function)));
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>함수</em> ()에서</font></font></div>
<pre class="insert" translate="no">
  <span class="k">for</span> (<span class="t">int</span> <span class="i">i</span> = <span class="n">0</span>; <span class="i">i</span> &lt; <span class="i">function</span>-&gt;<span class="i">upvalueCount</span>; <span class="i">i</span>++) {
    <span class="i">emitByte</span>(<span class="i">compiler</span>.<span class="i">upvalues</span>[<span class="i">i</span>].<span class="i">isLocal</span> ? <span class="n">1</span> : <span class="n">0</span>);
    <span class="i">emitByte</span>(<span class="i">compiler</span>.<span class="i">upvalues</span>[<span class="i">i</span>].<span class="i">index</span>);
  }
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>function</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">그 </font></font><code translate="no">OP_CLOSURE</code><font papago-translate="splitted"><font papago-translate="translated"> 명령어는 다양한 크기의 인코딩을 가지고 있다는 점에서 독특합니다.</font><font papago-translate="translated"> 클로저가 캡처하는 각 업값에는 두 개의 단일 바이트 피연산자가 있습니다.</font><font papago-translate="translated"> 각 피연산자 쌍은 해당 업밸류가 포착하는 것을 지정합니다.</font><font papago-translate="translated"> 첫 번째 바이트가 1인 경우, 엔클로저 함수의 로컬 변수를 캡처합니다.</font><font papago-translate="translated"> 0이면 함수의 업값 중 하나를 캡처합니다.</font><font papago-translate="translated"> 다음 바이트는 캡처할 로컬 슬롯 또는 업밸류 인덱스입니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">이 이상한 인코딩은 분해 코드에서 맞춤형 지원이 필요하다는 것을 의미합니다 </font></font><code translate="no">OP_CLOSURE</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      printf("\n");
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">debug.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>분해</em> 중 지침()</font></font></div>
<pre class="insert" translate="no">
      <span class="t">ObjFunction</span>* <span class="i">function</span> = <span class="a">AS_FUNCTION</span>(
          <span class="i">chunk</span>-&gt;<span class="i">constants</span>.<span class="i">values</span>[<span class="i">constant</span>]);
      <span class="k">for</span> (<span class="t">int</span> <span class="i">j</span> = <span class="n">0</span>; <span class="i">j</span> &lt; <span class="i">function</span>-&gt;<span class="i">upvalueCount</span>; <span class="i">j</span>++) {
        <span class="t">int</span> <span class="i">isLocal</span> = <span class="i">chunk</span>-&gt;<span class="i">code</span>[<span class="i">offset</span>++];
        <span class="t">int</span> <span class="i">index</span> = <span class="i">chunk</span>-&gt;<span class="i">code</span>[<span class="i">offset</span>++];
        <span class="i">printf</span>(<span class="s">"%04d      |                     %s %d</span><span class="e">\n</span><span class="s">"</span>,
               <span class="i">offset</span> - <span class="n">2</span>, <span class="i">isLocal</span> ? <span class="s">"local"</span> : <span class="s">"upvalue"</span>, <span class="i">index</span>);
      }

</pre><pre class="insert-after" translate="no">      return offset;
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>
<p><font papago-translate="translated">예를 들어, 이 스크립트를 보세요:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">fun</span> <span class="i">outer</span>() {
  <span class="k">var</span> <span class="i">a</span> = <span class="n">1</span>;
  <span class="k">var</span> <span class="i">b</span> = <span class="n">2</span>;
  <span class="k">fun</span> <span class="i">middle</span>() {
    <span class="k">var</span> <span class="i">c</span> = <span class="n">3</span>;
    <span class="k">var</span> <span class="i">d</span> = <span class="n">4</span>;
    <span class="k">fun</span> <span class="i">inner</span>() {
      <span class="k">print</span> <span class="i">a</span> + <span class="i">c</span> + <span class="i">b</span> + <span class="i">d</span>;
    }
  }
}
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">폐쇄를 생성하는 명령어를 분해하면 </font></font><code translate="no">inner()</code><font papago-translate="splitted"><font papago-translate="translated">, 이것이 인쇄됩니다:</font></font></p>
<div class="codehilite"><pre translate="no">0004    9 OP_CLOSURE          2 &lt;fn inner&gt;
0006      |                     upvalue 0
0008      |                     local 1
0010      |                     upvalue 1
0012      |                     local 2
</pre></div>
<p><font papago-translate="translated">분해기 지원을 추가할 수 있는 두 가지 더 간단한 지침이 있습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    case OP_SET_GLOBAL:
      return constantInstruction("OP_SET_GLOBAL", chunk, offset);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">debug.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>분해</em> 중 지침()</font></font></div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="a">OP_GET_UPVALUE</span>:
      <span class="k">return</span> <span class="i">byteInstruction</span>(<span class="s">"OP_GET_UPVALUE"</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
    <span class="k">case</span> <span class="a">OP_SET_UPVALUE</span>:
      <span class="k">return</span> <span class="i">byteInstruction</span>(<span class="s">"OP_SET_UPVALUE"</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
</pre><pre class="insert-after" translate="no">    case OP_EQUAL:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">둘 다 단일 바이트 피연산자를 가지고 있어서 흥미로운 일은 없습니다.</font><font papago-translate="translated"> 디버그 모듈이 다음에 도달할 수 있도록 포함 항목을 추가해야 합니다 </font></font><code translate="no">AS_FUNCTION()</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#include "debug.h"
</pre><div class="source-file"><em>debug.c</em></div>
<pre class="insert" translate="no"><span class="a">#include "object.h"</span>
</pre><pre class="insert-after" translate="no">#include "value.h"
</pre></div>
<div class="source-file-narrow"><em>debug.c</em></div>
<p><font papago-translate="splitted"><font papago-translate="translated">이를 통해 컴파일러가 우리가 원하는 곳에 있습니다.</font><font papago-translate="translated"> 각 함수 선언에 대해 다음을 출력합니다 </font></font><code translate="no">OP_CLOSURE</code><font papago-translate="splitted"><font papago-translate="translated"> 실행 시 캡처해야 하는 각 업값에 대한 일련의 피연산자 바이트 쌍이 뒤따릅니다.</font><font papago-translate="translated"> 이제 VM의 저쪽으로 가서 작업을 실행할 시간입니다.</font></font></p>
<h2><a href="https://youhogeon-meritz.github.io/closures.html#upvalue-objects" id="upvalue-objects"><small><font papago-translate="translated">25 . 3</font></small><font papago-translate="splitted"><font papago-translate="translated">업밸류 객체</font></font></a></h2>
<p><font papago-translate="splitted"><font papago-translate="translated">각각 </font></font><code translate="no">OP_CLOSURE</code><font papago-translate="splitted"><font papago-translate="translated"> 이제 명령어 뒤에는 ObjClosure가 소유해야 할 업값을 지정하는 일련의 바이트가 이어집니다.</font><font papago-translate="translated"> 이러한 피연산자를 처리하기 전에 업값에 대한 런타임 표현이 필요합니다.</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 구조 Ob<em>jString</em> 뒤에 추가</font></font></div>
<pre translate="no"><span class="k">typedef</span> <span class="k">struct</span> <span class="t">ObjUpvalue</span> {
  <span class="t">Obj</span> <span class="i">obj</span>;
  <span class="t">Value</span>* <span class="i">location</span>;
} <span class="t">ObjUpvalue</span>;
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after struct <em>ObjString</em></div>
<p><font papago-translate="translated">업밸류는 스택에 더 이상 존재하지 않는 폐쇄형 변수를 관리해야 한다는 것을 알고 있으며, 이는 어느 정도의 동적 할당을 의미합니다.</font><font papago-translate="translated"> VM에서 이를 수행하는 가장 쉬운 방법은 이미 보유하고 있는 객체 시스템을 기반으로 하는 것입니다.</font><font papago-translate="translated"> 이렇게 하면 다음<a href="https://youhogeon-meritz.github.io/garbage-collection.html"> 장</a>에서 가비지 컬렉터를 구현할 때 GC는 업값에 대한 메모리도 관리할 수 있습니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">따라서 런타임 업값 구조는 일반적인 Obj 헤더 필드를 가진 ObjUpvalue입니다.</font><font papago-translate="translated"> 그 다음은 </font></font><code translate="no">location</code><font papago-translate="splitted"><font papago-translate="translated"> 폐쇄 변수를 가리키는 필드.</font><font papago-translate="translated"> 이것은 가치 자체가 아니라<em> 가치</em>를 가리키는<em> 포인터</em>라는 점에 유의하세요.</font><font papago-translate="translated"> <em>그것</em>은<em> 값</em>이 아니라<em> 변수</em>에 대한 참조입니다.</font><font papago-translate="translated"> 이것은 중요합니다. 왜냐하면 업값이 포착하는 변수에 할당할 때, 복사본이 아닌 실제 변수에 할당된다는 것을 의미하기 때문입니다.</font><font papago-translate="translated"> 예를 들어:</font></font></p>
<div class="codehilite"><pre translate="no"><span class="k">fun</span> <span class="i">outer</span>() {
  <span class="k">var</span> <span class="i">x</span> = <span class="s">"before"</span>;
  <span class="k">fun</span> <span class="i">inner</span>() {
    <span class="i">x</span> = <span class="s">"assigned"</span>;
  }
  <span class="i">inner</span>();
  <span class="k">print</span> <span class="i">x</span>;
}
<span class="i">outer</span>();
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">이 프로그램은 클로저가 다음을 할당하더라도 "할당된" 것으로 인쇄해야 합니다 </font></font><code translate="no">x</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고 주변 기능이 그것에 접근합니다.</font></font></p>
<p><font papago-translate="translated">업값은 객체이기 때문에 생성자와 같은 함수부터 시작하여 일반적인 모든 객체 기계를 갖추고 있습니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">ObjString* copyString(const char* chars, int length);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>copy</em>St<em>ring</em>() 다음에 추가</font></font></div>
<pre class="insert" translate="no"><span class="t">ObjUpvalue</span>* <span class="i">newUpvalue</span>(<span class="t">Value</span>* <span class="i">slot</span>);
</pre><pre class="insert-after" translate="no">void printObject(Value value);
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after <em>copyString</em>()</div>
<p><font papago-translate="translated">폐쇄 변수가 있는 슬롯의 주소를 가져옵니다.</font><font papago-translate="translated"> 다음은 구현입니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>copy</em>St<em>ring</em>() 다음에 추가</font></font></div>
<pre translate="no"><span class="t">ObjUpvalue</span>* <span class="i">newUpvalue</span>(<span class="t">Value</span>* <span class="i">slot</span>) {
  <span class="t">ObjUpvalue</span>* <span class="i">upvalue</span> = <span class="a">ALLOCATE_OBJ</span>(<span class="t">ObjUpvalue</span>, <span class="a">OBJ_UPVALUE</span>);
  <span class="i">upvalue</span>-&gt;<span class="i">location</span> = <span class="i">slot</span>;
  <span class="k">return</span> <span class="i">upvalue</span>;
}
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, add after <em>copyString</em>()</div>
<p><font papago-translate="translated">객체를 초기화하고 포인터를 저장하기만 하면 됩니다.</font><font papago-translate="translated"> 그것은 새로운 객체 유형이 필요합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  OBJ_STRING,
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> enum Ob<em>jType</em>에서</font></font></div>
<pre class="insert" translate="no">  <span class="a">OBJ_UPVALUE</span>
</pre><pre class="insert-after" translate="no">} ObjType;
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, in enum <em>ObjType</em></div>
<p><font papago-translate="translated">그리고 뒷면에는 파괴자와 같은 함수가 있습니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      FREE(ObjString, object);
      break;
    }
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>free</em>O<em>bject</em>()에서</font></font></div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="a">OBJ_UPVALUE</span>:
      <span class="a">FREE</span>(<span class="t">ObjUpvalue</span>, <span class="i">object</span>);
      <span class="k">break</span>;
</pre><pre class="insert-after" translate="no">  }
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>freeObject</em>()</div>
<p><font papago-translate="translated">여러 개의 클로저가 동일한 변수에 대해 닫힐 수 있으므로 ObjUpvalue는 참조하는 변수를 소유하지 않습니다.</font><font papago-translate="translated"> 따라서 자유롭게 할 수 있는 유일한 것은 ObjUpvalue 자체입니다.</font></p>
<p><font papago-translate="translated">마지막으로 인쇄합니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    case OBJ_STRING:
      printf("%s", AS_CSTRING(value));
      break;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>print</em>O<em>bject</em>()에서</font></font></div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="a">OBJ_UPVALUE</span>:
      <span class="i">printf</span>(<span class="s">"upvalue"</span>);
      <span class="k">break</span>;
</pre><pre class="insert-after" translate="no">  }
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>printObject</em>()</div>
<p><font papago-translate="translated">인쇄는 최종 사용자에게 유용하지 않습니다.</font><font papago-translate="translated"> 업값은 VM의 메모리 관리를 활용하기 위한 객체일 뿐입니다.</font><font papago-translate="translated"> 이 값들은 Lox 사용자가 프로그램에서 직접 접근할 수 있는 일류 값이 아닙니다.</font><font papago-translate="translated"> 따라서 이 코드는 실제로 실행되지 않지만 컴파일러가 처리되지 않은 스위치 케이스에 대해 소리를 지르지 않도록 합니다<span class="ellipse">.</span></font></p>
<h3><a href="https://youhogeon-meritz.github.io/closures.html#upvalues-in-closures" id="upvalues-in-closures"><small><font papago-translate="translated">25 . 3 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">폐쇄의 업밸류</font></font></a></h3>
<p><font papago-translate="translated">처음 업값을 소개했을 때, 각 클로저에는 다양한 배열이 있다고 말했습니다.</font><font papago-translate="translated"> 우리는 마침내 그것을 구현하기 위해 다시 노력했습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  ObjFunction* function;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 구조 오브<em>제클로저</em>에서</font></font></div>
<pre class="insert" translate="no">  <span class="t">ObjUpvalue</span>** <span class="i">upvalues</span>;
  <span class="t">int</span> <span class="i">upvalueCount</span>;
</pre><pre class="insert-after" translate="no">} ObjClosure;
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, in struct <em>ObjClosure</em></div>
<p><font papago-translate="translated">폐쇄<span name="count">마다</span> 업값의 수가 다를 수 있으므로 동적 배열이 필요<span name="count">합니다.</span></font><font papago-translate="translated"> 업값 자체도 동적으로 할당되므로, 우리는 업<span class="em"></span>값에 동적으로 할당된 포인터 배열에 대한 포인터인 이중 포인터를 얻게 됩니다.</font><font papago-translate="translated"> 배열에 있는 요소의 수도 저장합니다.</font></p>
<aside name="count" style="top: 21714.5px;">
<p><font papago-translate="translated">ObjClosure에서 참조하는 ObjFunction도 해당 카운트를 유지하기 때문에 업값 카운트를 클로저에 저장하는 것은 중복됩니다.</font><font papago-translate="translated"> 평소처럼 이 이상한 코드는 GC를 달래기 위한 것입니다.</font><font papago-translate="translated"> 수집기는 해당 ObjFunction이 이미 해제된 후 ObjClosure의 업밸류 배열 크기를 알아야 할 수도 있습니다.</font></p>
</aside>
<p><font papago-translate="translated">ObjClosure를 생성할 때 적절한 크기의 업값 배열을 할당하고, 컴파일 시 이를 결정하여 ObjFunction에 저장합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">ObjClosure* newClosure(ObjFunction* function) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>새로운</em> 폐쇄에서()</font></font></div>
<pre class="insert" translate="no">  <span class="t">ObjUpvalue</span>** <span class="i">upvalues</span> = <span class="a">ALLOCATE</span>(<span class="t">ObjUpvalue</span>*,
                                   <span class="i">function</span>-&gt;<span class="i">upvalueCount</span>);
  <span class="k">for</span> (<span class="t">int</span> <span class="i">i</span> = <span class="n">0</span>; <span class="i">i</span> &lt; <span class="i">function</span>-&gt;<span class="i">upvalueCount</span>; <span class="i">i</span>++) {
    <span class="i">upvalues</span>[<span class="i">i</span>] = <span class="a">NULL</span>;
  }

</pre><pre class="insert-after" translate="no">  ObjClosure* closure = ALLOCATE_OBJ(ObjClosure, OBJ_CLOSURE);
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>newClosure</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">클로저 객체 자체를 만들기 전에 업값 배열을 할당하고 모두 초기화합니다 </font></font><code translate="no">NULL</code><font papago-translate="splitted"><font papago-translate="translated">. 이 이상한 기념식은 (다가올) 쓰레기 수집 신들을 기쁘게 하기 위한 신중한 춤입니다.</font><font papago-translate="translated"> 메모리 관리자가 초기화되지 않은 메모리를 보지 않도록 보장합니다.</font></font></p>
<p><font papago-translate="translated">그런 다음 배열을 새 클로저에 저장하고 ObjFunction에서 카운트를 복사합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  closure-&gt;function = function;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>새로운</em> 폐쇄에서()</font></font></div>
<pre class="insert" translate="no">  <span class="i">closure</span>-&gt;<span class="i">upvalues</span> = <span class="i">upvalues</span>;
  <span class="i">closure</span>-&gt;<span class="i">upvalueCount</span> = <span class="i">function</span>-&gt;<span class="i">upvalueCount</span>;
</pre><pre class="insert-after" translate="no">  return closure;
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>newClosure</em>()</div>
<p><font papago-translate="translated">ObjClosure를 해제할 때 업밸류 배열도 해제합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    case OBJ_CLOSURE: {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>free</em>O<em>bject</em>()에서</font></font></div>
<pre class="insert" translate="no">      <span class="t">ObjClosure</span>* <span class="i">closure</span> = (<span class="t">ObjClosure</span>*)<span class="i">object</span>;
      <span class="a">FREE_ARRAY</span>(<span class="t">ObjUpvalue</span>*, <span class="i">closure</span>-&gt;<span class="i">upvalues</span>,
                 <span class="i">closure</span>-&gt;<span class="i">upvalueCount</span>);
</pre><pre class="insert-after" translate="no">      FREE(ObjClosure, object);
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>freeObject</em>()</div>
<p><font papago-translate="translated">ObjClosure는 ObjUpvalue 객체 자체를 소유하지는 않지만, 해당 업값에 대한 포인터가 포함<em>된 배열</em>을 소유하고 있습니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">인터프리터가 닫힘을 생성할 때 업값 배열을 채웁니다.</font><font papago-translate="translated"> 여기서 우리는 모든 피연산자를 지나갑니다 </font></font><code translate="no">OP_CLOSURE</code><font papago-translate="splitted"><font papago-translate="translated"> 각 슬롯이 어떤 업밸류를 포착하는지 확인합니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">        push(OBJ_VAL(closure));
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font></div>
<pre class="insert" translate="no">        <span class="k">for</span> (<span class="t">int</span> <span class="i">i</span> = <span class="n">0</span>; <span class="i">i</span> &lt; <span class="i">closure</span>-&gt;<span class="i">upvalueCount</span>; <span class="i">i</span>++) {
          <span class="t">uint8_t</span> <span class="i">isLocal</span> = <span class="a">READ_BYTE</span>();
          <span class="t">uint8_t</span> <span class="i">index</span> = <span class="a">READ_BYTE</span>();
          <span class="k">if</span> (<span class="i">isLocal</span>) {
            <span class="i">closure</span>-&gt;<span class="i">upvalues</span>[<span class="i">i</span>] =
                <span class="i">captureUpvalue</span>(<span class="i">frame</span>-&gt;<span class="i">slots</span> + <span class="i">index</span>);
          } <span class="k">else</span> {
            <span class="i">closure</span>-&gt;<span class="i">upvalues</span>[<span class="i">i</span>] = <span class="i">frame</span>-&gt;<span class="i">closure</span>-&gt;<span class="i">upvalues</span>[<span class="i">index</span>];
          }
        }
</pre><pre class="insert-after" translate="no">        break;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">이 코드는 폐쇄가 현실화되는 마법의 순간입니다.</font><font papago-translate="translated"> 우리는 폐업이 예상하는 각 업밸류에 대해 반복합니다.</font><font papago-translate="translated"> 각각의 피연산자 바이트 쌍을 읽습니다.</font><font papago-translate="translated"> 업값이 엔클로저 함수의 로컬 변수에 대해 닫히면, 우리는 다음과 같이 합니다 </font></font><code translate="no">captureUpvalue()</code><font papago-translate="splitted"><font papago-translate="translated"> 작업을 수행합니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">그렇지 않으면 주변 함수에서 업값을 포착합니다. An </font></font><code translate="no">OP_CLOSURE</code><font papago-translate="splitted"><font papago-translate="translated"> 명령어는 함수 선언이 끝날 때 방출됩니다.</font><font papago-translate="translated"> 우리가 그 선언을 실행하는 현재,<em> 현재</em>의 기능은 주변의 기능입니다.</font><font papago-translate="translated"> 즉, 현재 기능의 종료는 콜스택 상단의 콜프레임에 저장됩니다.</font><font papago-translate="translated"> 따라서 엔클로저 함수에서 업값을 얻으려면 다음에서 바로 읽을 수 있습니다 </font></font><code translate="no">frame</code><font papago-translate="splitted"><font papago-translate="translated"> 로컬 변수, 즉 해당 CallFrame에 대한 참조를 캐시합니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">지역 변수를 닫는 것이 더 흥미롭습니다.</font><font papago-translate="translated"> 대부분의 작업은 별도의 함수에서 발생하지만, 먼저 인수를 계산하여 전달합니다.</font><font papago-translate="translated"> 주변 함수의 스택 창에서 캡처된 로컬 슬롯에 대한 포인터를 잡아야 합니다.</font><font papago-translate="translated"> 그 창은 다음에서 시작됩니다 </font></font><code translate="no">frame-&gt;slots</code><font papago-translate="splitted"><font papago-translate="translated">, 슬롯 0을 가리킵니다.</font><font papago-translate="translated"> 추가하기 </font></font><code translate="no">index</code><font papago-translate="splitted"><font papago-translate="translated"> 캡처하려는 로컬 슬롯으로 오프셋합니다.</font><font papago-translate="translated"> 우리는 그 포인터를 여기에 전달합니다:</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>호출</em> 후 추가 값()</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">ObjUpvalue</span>* <span class="i">captureUpvalue</span>(<span class="t">Value</span>* <span class="i">local</span>) {
  <span class="t">ObjUpvalue</span>* <span class="i">createdUpvalue</span> = <span class="i">newUpvalue</span>(<span class="i">local</span>);
  <span class="k">return</span> <span class="i">createdUpvalue</span>;
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>callValue</em>()</div>
<p><font papago-translate="translated">조금 우스꽝스러워 보입니다.</font><font papago-translate="translated"> 주어진 스택 슬롯을 캡처하여 반환하는 새로운 ObjUp 값만 생성하면 됩니다.</font><font papago-translate="translated"> 이를 위해 별도의 기능이 필요했나요?</font><font papago-translate="translated"> 아니요<em>, 아직</em>입니다.</font><font papago-translate="translated"> 하지만 여기에 더 많은 코드를 삽입하게 될 것입니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">먼저, 우리가 진행 중인 작업을 마무리하겠습니다.</font><font papago-translate="translated"> 처리를 위해 인터프리터 코드로 돌아가기 </font></font><code translate="no">OP_CLOSURE</code><font papago-translate="splitted"><font papago-translate="translated">, 결국 업밸류 배열을 반복하고 각 배열을 초기화합니다.</font><font papago-translate="translated"> 이 작업이 완료되면 변수를 가리키는 업값으로 가득 찬 배열이 있는 새로운 클로저가 생깁니다.</font></font></p>
<p><font papago-translate="translated">이를 통해 이러한 업밸류에 맞는 지침을 구현할 수 있습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      }
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font></div>
<pre class="insert" translate="no">      <span class="k">case</span> <span class="a">OP_GET_UPVALUE</span>: {
        <span class="t">uint8_t</span> <span class="i">slot</span> = <span class="a">READ_BYTE</span>();
        <span class="i">push</span>(*<span class="i">frame</span>-&gt;<span class="i">closure</span>-&gt;<span class="i">upvalues</span>[<span class="i">slot</span>]-&gt;<span class="i">location</span>);
        <span class="k">break</span>;
      }
</pre><pre class="insert-after" translate="no">      case OP_EQUAL: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p><font papago-translate="translated">피연산자는 현재 함수의 업값 배열에 대한 인덱스입니다.</font><font papago-translate="translated"> 따라서 해당 업값을 찾아 해당 슬롯의 값을 읽기 위해 위치 포인터를 참조 해제하기만 하면 됩니다.</font><font papago-translate="translated"> 변수를 설정하는 것도 비슷합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      }
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font></div>
<pre class="insert" translate="no">      <span class="k">case</span> <span class="a">OP_SET_UPVALUE</span>: {
        <span class="t">uint8_t</span> <span class="i">slot</span> = <span class="a">READ_BYTE</span>();
        *<span class="i">frame</span>-&gt;<span class="i">closure</span>-&gt;<span class="i">upvalues</span>[<span class="i">slot</span>]-&gt;<span class="i">location</span> = <span class="i">peek</span>(<span class="n">0</span>);
        <span class="k">break</span>;
      }
</pre><pre class="insert-after" translate="no">      case OP_EQUAL: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">스택 상단의 값을<span name="assign"> 가져와서</span> 선택한 업값이 가리키는 슬롯에 저장합니다.</font><font papago-translate="translated"> 지역 변수에 대한 지침과 마찬가지로 이러한 지침이 빠른 것이 중요합니다.</font><font papago-translate="translated"> 사용자 프로그램은 변수를 계속 읽고 쓰기 때문에 속도가 느리면 모든 것이 느려집니다.</font><font papago-translate="translated"> 그리고 평소처럼, 우리가 그것들을 빠르게 만드는 방법은 단순하게 유지하는 것입니다.</font><font papago-translate="translated"> 이 두 가지 새로운 지침은 꽤 좋습니다: 제어 흐름이 없고, 복잡한 산술이 없으며, 방향을 가리키는 포인터 몇 개와 a만 있으면 됩니다 </font></font><code translate="no">push()</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p>
<aside name="assign" style="top: 24166.5px;">
<p><font papago-translate="translated">집합 명령어는 스택에서 값<em>을 터뜨리지</em> 않습니다. 왜냐하면 할당은 Lox의 표현식이기 때문입니다.</font><font papago-translate="translated"> 따라서 할당된 값의 결과는 주변<span class="em"></span><span class="em"></span> 표현식을 위해 스택에 남아 있어야 합니다.</font></p>
</aside>
<p><font papago-translate="translated">이것은 중요한 이정표입니다.</font><font papago-translate="translated"> 모든 변수가 스택에 남아 있는 한, 우리는 작업 종료가 있습니다.</font><font papago-translate="translated"> 이렇게 해보세요:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">fun</span> <span class="i">outer</span>() {
  <span class="k">var</span> <span class="i">x</span> = <span class="s">"outside"</span>;
  <span class="k">fun</span> <span class="i">inner</span>() {
    <span class="k">print</span> <span class="i">x</span>;
  }
  <span class="i">inner</span>();
}
<span class="i">outer</span>();
</pre></div>
<p><font papago-translate="translated">이것을 실행하면 "외부"가 올바르게 인쇄됩니다.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/closures.html#closed-upvalues" id="closed-upvalues"><small><font papago-translate="translated">25 . 4</font></small><font papago-translate="splitted"><font papago-translate="translated">닫힌 업값</font></font></a></h2>
<p><font papago-translate="translated">물론 폐쇄의 주요 특징은 변수를 선언하는 함수가 돌아온 후에도 필요한 만큼 변수를 유지한다는 것입니다.</font><font papago-translate="translated"> 다음은 작동<em>해야 할</em> 또 다른 예입니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">fun</span> <span class="i">outer</span>() {
  <span class="k">var</span> <span class="i">x</span> = <span class="s">"outside"</span>;
  <span class="k">fun</span> <span class="i">inner</span>() {
    <span class="k">print</span> <span class="i">x</span>;
  }

  <span class="k">return</span> <span class="i">inner</span>;
}

<span class="k">var</span> <span class="i">closure</span> = <span class="i">outer</span>();
<span class="i">closure</span>();
</pre></div>
<p><font papago-translate="translated">하지만 지금 실행하면<span class="ellipse">... . .</span> 그게 무슨 역할을 하는지 누가 알겠습니까?</font><font papago-translate="translated"> 런타임에 더 이상 폐쇄 변수를 포함하지 않는 스택 슬롯에서 읽게 됩니다.</font><font papago-translate="translated"> 제가 몇 번 언급했듯이, 문제의 핵심은 폐쇄 변수들이 스택 의미를 가지지 않는다는 것입니다.</font><font papago-translate="translated"> 즉, 선언된 함수가 반환되면 스택에서 들어 올려야 합니다.</font><font papago-translate="translated"> 이 장의 마지막 섹션에서는 그렇게 합니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/closures.html#values-and-variables" id="values-and-variables"><small><font papago-translate="translated">25 . 4 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">값과 변수</font></font></a></h3>
<p><font papago-translate="translated">코드 작성에 들어가기 전에 중요한 의미론적 요점을 파고들고 싶습니다.</font><font papago-translate="translated"> 폐쇄가<em> 값</em>이나<em> 변수</em>에 대해 닫혀 있습니까?</font><font papago-translate="translated"> 이것은 순전히<span name="academic"> 학문</span>적인 질문이 아닙니다.</font><font papago-translate="translated"> 저는 단순히 머리카락을 쪼개는 것이 아닙니다.</font><font papago-translate="translated"> 고려:</font></p>
<aside name="academic" style="top: 25362.5px;">
<p><font papago-translate="translated">Lox가 과제를 허락하지 않았다면, 그것은 학문적인 질문<em>이 될 것</em>입니다.</font></p>
</aside>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="i">globalSet</span>;
<span class="k">var</span> <span class="i">globalGet</span>;

<span class="k">fun</span> <span class="i">main</span>() {
  <span class="k">var</span> <span class="i">a</span> = <span class="s">"initial"</span>;

  <span class="k">fun</span> <span class="i">set</span>() { <span class="i">a</span> = <span class="s">"updated"</span>; }
  <span class="k">fun</span> <span class="i">get</span>() { <span class="k">print</span> <span class="i">a</span>; }

  <span class="i">globalSet</span> = <span class="i">set</span>;
  <span class="i">globalGet</span> = <span class="i">get</span>;
}

<span class="i">main</span>();
<span class="i">globalSet</span>();
<span class="i">globalGet</span>();
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">바깥쪽 </font></font><code translate="no">main()</code><font papago-translate="splitted"><font papago-translate="translated"> 함수는 두 개의 클로저를 생성하고<span name="global"> 이</span>를<span name="global"> 전역</span> 변수에 저장하여 실행 기간보다 오래 지속되도록 합니다 </font></font><code translate="no">main()</code><font papago-translate="splitted"><font papago-translate="translated"> 그 자체.</font><font papago-translate="translated"> 두 폐쇄 모두 동일한 변수를 포착합니다.</font><font papago-translate="translated"> 첫 번째 닫힘은 새로운 값을 할당하고 두 번째 닫힘은 변수를 읽습니다.</font></font></p>
<aside name="global" style="top: 25778.5px;">
<p><font papago-translate="translated">제가 몇 가지 글로벌 변수를 사용하고 있다는 사실은 중요하지 않습니다.</font><font papago-translate="translated"> 함수에서 두 값을 반환할 수 있는 방법이 필요했고, Lox에서 어떤 종류의 컬렉션 유형도 없어서 선택지가 제한적이었습니다.</font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">호출 대상 </font></font><code translate="no">globalGet()</code><font papago-translate="splitted"><font papago-translate="translated"> 인쇄?</font><font papago-translate="translated"> 폐쇄가<em> 값</em>을 포착하면 각 폐쇄는 다음과 같은 고유한 복사본을 얻습니다 </font></font><code translate="no">a</code><font papago-translate="splitted"><font papago-translate="translated"> 다음과 같은 가치로 </font></font><code translate="no">a</code><font papago-translate="splitted"><font papago-translate="translated"> 폐쇄 함수 선언이 실행되던 시점에.</font><font papago-translate="translated"> 로의 부름 </font></font><code translate="no">globalSet()</code><font papago-translate="splitted"><font papago-translate="translated"> 수정할 것입니다 </font></font><code translate="no">set()</code><font papago-translate="splitted"><font papago-translate="translated">의 사본 </font></font><code translate="no">a</code><font papago-translate="splitted"><font papago-translate="translated">,그렇지만 </font></font><code translate="no">get()</code><font papago-translate="splitted"><font papago-translate="translated">의 사본은 영향을 받지 않습니다.</font><font papago-translate="translated"> 따라서 다음과 같은 요청 </font></font><code translate="no">globalGet()</code><font papago-translate="splitted"><font papago-translate="translated"> "initial"를 인쇄합니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">변수에 대한 폐쇄가 닫히면 </font></font><code translate="no">get()</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">set()</code><font papago-translate="splitted"><font papago-translate="translated"> 둘 다 동일<em>한 가변</em><span class="em"></span><span class="em"></span><em> 변수</em>를 캡처합니다(참조).</font><font papago-translate="translated"> 언제 </font></font><code translate="no">set()</code><font papago-translate="splitted"><font papago-translate="translated"> 변화들 </font></font><code translate="no">a</code><font papago-translate="splitted"><font papago-translate="translated">, 동일하게 변경됩니다 </font></font><code translate="no">a</code><font papago-translate="splitted"><font papago-translate="translated"> 그거 </font></font><code translate="no">get()</code><font papago-translate="splitted"><font papago-translate="translated"> 에서 읽습니다.</font><font papago-translate="translated"> 단 하나뿐입니다 </font></font><code translate="no">a</code><font papago-translate="splitted"><font papago-translate="translated">. 이는 결국 다음과 같은 요청을 의미합니다 </font></font><code translate="no">globalGet()</code><font papago-translate="splitted"><font papago-translate="translated"> "updated"를 인쇄합니다.</font></font></p>
<p><font papago-translate="translated">그게 뭐예요?</font><font papago-translate="translated"> Lox와 제가 아는 대부분의 다른 언어들에 대한 답은 후자입니다.</font><font papago-translate="translated"> 폐쇄는 변수를 포착합니다.</font><font papago-translate="translated"> <em>그들</em>은<em> 가치가 살아 숨 쉬는 장소</em>를 포착한다고 생각할 수 있습니다.</font><font papago-translate="translated"> 스택에 더 이상 존재하지 않는 폐쇄 변수를 다룰 때 이 점을 염두에 두어야 합니다.</font><font papago-translate="translated"> 변수가 힙으로 이동할 때, 해당 변수를 캡처하는 모든 클로저가 해당 변수<em>의</em> 새로운 위치에 대한 참조를 유지하도록 해야 합니다.</font><font papago-translate="translated"> 그렇게 하면 변수가 변경되면 모든 클로저가 변화를 볼 수 있습니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/closures.html#closing-upvalues" id="closing-upvalues"><small><font papago-translate="translated">25 . 4 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">값 닫기</font></font></a></h3>
<p><font papago-translate="translated">우리는 지역 변수가 항상 스택에서 시작된다는 것을 알고 있습니다.</font><font papago-translate="translated"> 이것은 더 빠르며, 우리의 단일 패스 컴파일러가 변수가 캡처되었음을 발견하기 전에 코드를 방출할 수 있게 합니다.</font><font papago-translate="translated"> 또한 폐쇄 변수가 캡처된 변수가 선언된 함수보다 오래 지속되는 경우 힙으로 이동해야 한다는 것도 알고 있습니다.</font></p>
<p><font papago-translate="translated">Lua를 따라<strong> 열린 업값</strong>을 사용하여 스택에 남아 있는 로컬 변수를 가리키는 업값을 가리킬 것입니다.</font><font papago-translate="translated"> 변수가 힙으로 이동할 때, 우리는 업값<em>을 닫</em>게 되고, 그 결과 자연스럽게<strong> 닫힌 업값</strong>이 됩니다.</font><font papago-translate="translated"> 우리가 답해야 할 두 가지 질문은 다음과 같습니다:</font></p>
<ol>
<li>
<p><font papago-translate="translated">폐쇄 변수는 힙에서 어디로 이동합니까?</font></p>
</li>
<li>
<p><font papago-translate="translated">업밸류는 언제 마감하나요?</font></p>
</li>
</ol>
<p><font papago-translate="translated">첫 번째 질문에 대한 답은 쉽습니다.</font><font papago-translate="translated"> 우리는 이미 변수인 ObjUpvalue<span class="em"></span> 자체에 대한 참조를 나타내는 편리한 객체를 힙에 가지고 있습니다.</font><font papago-translate="translated"> 폐쇄 변수는 ObjUpvalue 구조 바로 안쪽의 새 필드로 이동합니다.</font><font papago-translate="translated"> 그렇게 하면 업값을 닫기 위해 추가 힙 할당을 할 필요가 없습니다.</font></p>
<p><font papago-translate="translated">두 번째 질문도 간단합니다.</font><font papago-translate="translated"> 변수가 스택에 있는 한, 해당 변수를 참조하는 코드가 있을 수 있으며, 해당 코드는 올바르게 작동해야 합니다.</font><font papago-translate="translated"> 따라서 변수를 힙으로 올리는 논리적 시간은 가능한 한 늦습니다.</font><font papago-translate="translated"> 로컬 변수가 범위를 벗어날 때 바로 이동하면, 그 이후의 어떤 코드도 스택에서 액세스하려고 하지 않을 것입니다.</font><font papago-translate="translated"> 변수가 범위를 벗어난<span name="after"> 후</span>, 컴파일러는 어떤 코드가 이를 사용하려고 시도했을 때 오류를 보고했을 것입니다<span name="after">.</span></font></p>
<aside name="after" style="top: 27026.5px;">
<p><font papago-translate="splitted"><font papago-translate="translated">여기서 "이후"라는 뜻은 어휘적 또는 텍스트적 의미에서 — 코드<span class="em"></span>는 다음을 지나갑니다 </font></font><code translate="no">}</code><font papago-translate="splitted"><font papago-translate="translated"> 폐쇄 변수 선언을 포함하는 블록에 대해.</font></font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">컴파일러가 이미 다음을 방출합니다 </font></font><code translate="no">OP_POP</code><font papago-translate="splitted"><font papago-translate="translated"> 로컬 변수가 범위를 벗어날 때의 지침.</font><font papago-translate="translated"> 변수가 닫힘에 의해 포착되면, 대신 그 변수를 스택에서 해당 업값으로 끌어올리라는 다른 지시를 내릴 것입니다.</font><font papago-translate="translated"> 이를 위해 컴파일러는 어떤<span name="param"> 로컬</span>이 닫혀 있는지 알아야 합니다.</font></font></p>
<aside name="param" style="top: 27170.5px;">
<p><font papago-translate="translated">컴파일러는 매개변수와 로컬을 함수의 본문 내부에 바로 선언하지 않습니다.</font><font papago-translate="translated"> 우리는 그것들도 런타임에 처리할 것입니다.</font></p>
</aside>
<p><font papago-translate="translated">컴파일러는 해당 상태를 정확히 추적하기 위해 함수의 각 로컬 변수에 대한 Upvalue 구조 배열을 이미 유지하고 있습니다.</font><font papago-translate="translated"> 그 배열은 "이 폐쇄는 어떤 변수를 사용하나요?"라고 답하기에 좋습니다</font><font papago-translate="translated"> 하지만 "어떤 함수<em>가</em> 이 지역 변수를 포착하나요?"라고 대답하기에는 적합하지 않습니다</font><font papago-translate="translated"> 특히, 어떤 클로저용 컴파일러가 완료되면, 변수가 캡처되지 않은 엔클로저 함수용 컴파일러는 더 이상 업값 상태에 접근할 수 없게 됩니다.</font></p>
<p><font papago-translate="translated">즉, 컴파일러는 상위 값에서 캡처한 로컬로 포인터를 유지하지만 다른 방향으로는 포인터를 유지하지 않습니다.</font><font papago-translate="translated"> 따라서 먼저 기존 로컬 구조 내부에 추가 추적 기능을 추가하여 주어진 로컬이 폐쇄에 의해 캡처되는지 여부를 확인할 수 있어야 합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  int depth;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em></em>구조 로컬에서</font></font></div>
<pre class="insert" translate="no">  <span class="t">bool</span> <span class="i">isCaptured</span>;
</pre><pre class="insert-after" translate="no">} Local;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in struct <em>Local</em></div>
<p><font papago-translate="splitted"><font papago-translate="translated">이 필드는 </font></font><code translate="no">true</code><font papago-translate="splitted"><font papago-translate="translated"> 로컬이 나중에 중첩된 함수 선언에 의해 캡처되는 경우.</font><font papago-translate="translated"> 처음에는 모든 현지인이 포획되지 않습니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  local-&gt;depth = -1;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> ad<em>dLocal</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="i">local</span>-&gt;<span class="i">isCaptured</span> = <span class="k">false</span>;
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>addLocal</em>()</div>
<p><font papago-translate="translated"><span name="zero">마찬가지로</span> 컴파일러가 암묵적으로 선언하는 특별한 "슬롯 제로 로컬"은 캡처되지 않습니다<span name="zero">.</span></font></p>
<aside name="zero" style="top: 27794.5px;">
<p><font papago-translate="translated">책 후반부에는 사용자가 이 변수를 포착하는 것이 가능해질<em> 것입니다</em>.</font><font papago-translate="translated"> 여기서 기대감을 키우고 있습니다.</font></p>
</aside>
<div class="codehilite"><pre class="insert-before" translate="no">  local-&gt;depth = 0;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>initCompiler</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="i">local</span>-&gt;<span class="i">isCaptured</span> = <span class="k">false</span>;
</pre><pre class="insert-after" translate="no">  local-&gt;name.start = "";
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>initCompiler</em>()</div>
<p><font papago-translate="translated">식별자를 해결할 때 로컬 변수에 대한 업값을 생성하면 캡처된 것으로 표시합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  if (local != -1) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>resolve</em>U<em>pvalue</em>()에서</font></font></div>
<pre class="insert" translate="no">    <span class="i">compiler</span>-&gt;<span class="i">enclosing</span>-&gt;<span class="i">locals</span>[<span class="i">local</span>].<span class="i">isCaptured</span> = <span class="k">true</span>;
</pre><pre class="insert-after" translate="no">    return addUpvalue(compiler, (uint8_t)local, true);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>resolveUpvalue</em>()</div>
<p><font papago-translate="translated">이제 컴파일러가 로컬의 스택 슬롯을 해제하기 위해 코드를 방출할 때 블록 범위가 끝나면 어떤 슬롯을 힙에 올려야 하는지 알 수 있습니다.</font><font papago-translate="translated"> 이를 위해 새로운 지침을 사용하겠습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  while (current-&gt;localCount &gt; 0 &amp;&amp;
         current-&gt;locals[current-&gt;localCount - 1].depth &gt;
            current-&gt;scopeDepth) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>endScope</em>()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">    <span class="k">if</span> (<span class="i">current</span>-&gt;<span class="i">locals</span>[<span class="i">current</span>-&gt;<span class="i">localCount</span> - <span class="n">1</span>].<span class="i">isCaptured</span>) {
      <span class="i">emitByte</span>(<span class="a">OP_CLOSE_UPVALUE</span>);
    } <span class="k">else</span> {
      <span class="i">emitByte</span>(<span class="a">OP_POP</span>);
    }
</pre><pre class="insert-after" translate="no">    current-&gt;localCount--;
  }
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>endScope</em>(), replace 1 line</div>
<p><font papago-translate="translated">이 명령어는 피연산자가 필요하지 않습니다.</font><font papago-translate="translated"> 우리는 이 명령어가 실행되는 지점에서 변수가 항상 스택 바로 위에 있다는 것을 알고 있습니다.</font><font papago-translate="translated"> 지침을 선포합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  OP_CLOSURE,
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">청크.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> enum O<em>pCode</em>에서</font></font></div>
<pre class="insert" translate="no">  <span class="a">OP_CLOSE_UPVALUE</span>,
</pre><pre class="insert-after" translate="no">  OP_RETURN,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>
<p><font papago-translate="translated">그리고 그것을 위해 사소한 분해기 지지대를 추가하세요:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    }
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">debug.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>분해</em> 중 지침()</font></font></div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="a">OP_CLOSE_UPVALUE</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">"OP_CLOSE_UPVALUE"</span>, <span class="i">offset</span>);
</pre><pre class="insert-after" translate="no">    case OP_RETURN:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>
<p><font papago-translate="translated">훌륭합니다.</font><font papago-translate="translated"> 이제 생성된 바이트코드는 각 캡처된 로컬 변수가 힙으로 이동해야 하는 런타임을 정확히 알려줍니다.</font><font papago-translate="translated"> 더 좋은 점은 폐쇄 조치로 인해 이 특별<em></em>한 대우가 필요한 지역 주민들에게만 적용된다는 것입니다.</font><font papago-translate="translated"> 이는 사용자가 사용하는 기능에 대해서만 비용을 지불하기를 바라는 일반적인 성능 목표와 일치합니다.</font><font papago-translate="translated"> 폐쇄에 사용되지 않는 변수는 이전과 마찬가지로 스택에서 완전히 생존하고 죽습니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/closures.html#tracking-open-upvalues" id="tracking-open-upvalues"><small><font papago-translate="translated">25 . 4 . 3</font></small><font papago-translate="splitted"><font papago-translate="translated">오픈 값 추적하기</font></font></a></h3>
<p><font papago-translate="splitted"><font papago-translate="translated">런타임 쪽으로 넘어가 보겠습니다.</font><font papago-translate="translated"> 해석하기 전에 </font></font><code translate="no">OP_CLOSE_UPVALUE</code><font papago-translate="splitted"><font papago-translate="translated"> 지침, 해결해야 할 문제가 있습니다.</font><font papago-translate="translated"> 이전에 폐쇄가 변수나 값을 포착하는지에 대해 이야기할 때, 여러 폐쇄가 동일한 변수에 접근하면 메모리에 있는 정확히 동일한 저장 위치를 참조하는 것이 중요하다고 말했습니다.</font><font papago-translate="translated"> 그렇게 하면 한 폐쇄가 변수에 쓰면 다른 폐쇄가 변화를 보게 됩니다.</font></font></p>
<p><font papago-translate="translated">현재 두 개의 클로저가 동일<span name="indirect">한 로컬</span> 변수를 포착하면 VM은 각 클로저에 대해 별도의 Upvalue를 생성합니다.</font><font papago-translate="translated"> 필요한 공유가 누락되었습니다.</font><font papago-translate="translated"> 변수를 스택에서 이동할 때, 변수를 하나의 업값으로만 이동시키면 다른 업값은 고아 값을 갖게 됩니다.</font></p>
<aside name="indirect" style="top: 29166.5px;">
<p><font papago-translate="translated">하나의 클로저가 주변 함수로부터<em> 업값</em>을 포착하면 VM은 업값을 공유<em>합니다</em>.</font><font papago-translate="translated"> 중첩된 경우는 올바르게 작동합니다.</font><font papago-translate="translated"> 하지만<em> 두 형제</em>자매 폐쇄가 동일한 지역 변수를 포착하면 각각 별도의 ObjUp 값을 생성합니다.</font></p>
</aside>
<p><font papago-translate="translated">이를 해결하기 위해 VM이 특정 로컬 변수 슬롯을 캡처하는 업값이 필요할 때마다 먼저 해당 슬롯을 가리키는 기존 업값을 검색합니다.</font><font papago-translate="translated"> 발견되면 재사용합니다.</font><font papago-translate="translated"> 문제는 이전에 생성된 모든 업값이 다양한 클로저의 업값 배열 내부에 흩어져 있다는 것입니다.</font><font papago-translate="translated"> 이러한 폐쇄는 VM의 메모리 어디에나 있을 수 있습니다.</font></p>
<p><font papago-translate="translated">첫 번째 단계는 스택에 남아 있는 변수를 가리키는 모든 열린 값 목록을 VM에 제공하는 것입니다.</font><font papago-translate="translated"> VM에 업값이 필요할 때마다 목록을 검색하는 것은 느릴 수 있지만 실제로는 나쁘지 않습니다.</font><font papago-translate="translated"> 스택에서 실제로 닫히는 변수의 수는 적은 경향이 있습니다.</font><font papago-translate="translated"> 사용자 프로그램에서 폐쇄<span name="create">를 생성</span>하는 함수 선언은 성능에 중요한 실행 경로에 있는 경우가 드뭅니다.</font></p>
<aside name="create" style="top: 29526.5px;">
<p><font papago-translate="translated">핫 루프 내부에서는 폐쇄<em>가</em> 자주<em> 발생</em>합니다.</font><font papago-translate="translated"> <a href="https://en.wikipedia.org/wiki/Map_(higher-order_function)">컬렉션</a>에서 일반적인 고차 함수로 전달된 클로저에 대해 생각해 보세요<a href="https://en.wikipedia.org/wiki/Filter_(higher-order_function)"></a>.</font><font papago-translate="translated"> 빠르면 됩니다.</font><font papago-translate="translated"> 그러나 폐쇄<em>를 생성</em>하는 함수 선언은 한 번만 이루어지며 일반적으로 루프 외부에 있습니다.</font></p>
</aside>
<p><font papago-translate="translated">더 좋은 점은 그들이 가리키는 스택 슬롯 인덱스에 따라 열린 업값 목록을 정렬할 수 있다는 것입니다.</font><font papago-translate="translated"> 일반적인 경우는 슬롯이 아직 포착<em>되지</em> 않았다는 것입니다. 폐쇄 간 변수를 공유하는 것은 드문 일이며, 폐쇄는<span class="em"></span><span class="em"></span> 스택 상단 근처의 로컬을 포착하는 경향이 있습니다.</font><font papago-translate="translated"> 오픈 업밸류 배열을 스택 슬롯 순서대로 저장하면, 우리가 생명을 포착하고 있는 로컬 슬롯을 지나자마자 찾을 수 없다는 것을 알 수 있습니다.</font><font papago-translate="translated"> 그 로컬이 스택의 상단 근처에 있을 때, 우리는 루프를 꽤 일찍 종료할 수 있습니다.</font></p>
<p><font papago-translate="translated">정렬된 목록을 유지하려면 중간에 요소를 효율적으로 삽입해야 합니다.</font><font papago-translate="translated"> 이는 동적 배열 대신 연결된 목록을 사용할 것을 제안합니다.</font><font papago-translate="translated"> 우리가 직접 ObjUpvalue 구조를 정의했기 때문에, 가장 쉬운 구현은 다음 포인터를 ObjUpvalue 구조 자체 안에 넣는 침입형 리스트입니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  Value* location;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 구조 Ob<em>jUpvalue</em>에서</font></font></div>
<pre class="insert" translate="no">  <span class="k">struct</span> <span class="t">ObjUpvalue</span>* <span class="i">next</span>;
</pre><pre class="insert-after" translate="no">} ObjUpvalue;
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, in struct <em>ObjUpvalue</em></div>
<p><font papago-translate="splitted"><font papago-translate="translated">업값을 할당할 때 아직 목록에 첨부되지 않았기 때문에 링크는 다음과 같습니다 </font></font><code translate="no">NULL</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  upvalue-&gt;location = slot;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>newUpvalue</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="i">upvalue</span>-&gt;<span class="i">next</span> = <span class="a">NULL</span>;
</pre><pre class="insert-after" translate="no">  return upvalue;
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>newUpvalue</em>()</div>
<p><font papago-translate="translated">VM이 목록을 소유하고 있으므로 헤드 포인터는 메인 VM 구조 내부로 바로 들어갑니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  Table strings;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">VM.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em></em>구조 VM에서</font></font></div>
<pre class="insert" translate="no">  <span class="t">ObjUpvalue</span>* <span class="i">openUpvalues</span>;
</pre><pre class="insert-after" translate="no">  Obj* objects;
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, in struct <em>VM</em></div>
<p><font papago-translate="translated">목록이 비어 있는 상태로 시작합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  vm.frameCount = 0;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>리셋스택</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="i">vm</span>.<span class="i">openUpvalues</span> = <span class="a">NULL</span>;
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>resetStack</em>()</div>
<p><font papago-translate="translated">VM이 가리키는 첫 번째 업값부터 시작하여 각 오픈 업값은 스택 아래쪽의 로컬 변수를 참조하는 다음 오픈 업값을 가리킵니다.</font><font papago-translate="translated"> 예를 들어, 이 스크립트는,</font></p>
<div class="codehilite"><pre translate="no">{
  <span class="k">var</span> <span class="i">a</span> = <span class="n">1</span>;
  <span class="k">fun</span> <span class="i">f</span>() {
    <span class="k">print</span> <span class="i">a</span>;
  }
  <span class="k">var</span> <span class="i">b</span> = <span class="n">2</span>;
  <span class="k">fun</span> <span class="i">g</span>() {
    <span class="k">print</span> <span class="i">b</span>;
  }
  <span class="k">var</span> <span class="i">c</span> = <span class="n">3</span>;
  <span class="k">fun</span> <span class="i">h</span>() {
    <span class="k">print</span> <span class="i">c</span>;
  }
}
</pre></div>
<p><font papago-translate="translated">다음과 같이 일련의 연결된 업값을 생성해야 합니다:</font></p><img alt="Three upvalues in a linked list." src="https://youhogeon-meritz.github.io/image/closures/linked-list.png">
<p><font papago-translate="translated">로컬 변수를 닫을 때마다 새로운 업값을 만들기 전에 목록에서 기존 변수를 찾습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">static ObjUpvalue* captureUpvalue(Value* local) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>capture</em>U<em>pvalue</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="t">ObjUpvalue</span>* <span class="i">prevUpvalue</span> = <span class="a">NULL</span>;
  <span class="t">ObjUpvalue</span>* <span class="i">upvalue</span> = <span class="i">vm</span>.<span class="i">openUpvalues</span>;
  <span class="k">while</span> (<span class="i">upvalue</span> != <span class="a">NULL</span> &amp;&amp; <span class="i">upvalue</span>-&gt;<span class="i">location</span> &gt; <span class="i">local</span>) {
    <span class="i">prevUpvalue</span> = <span class="i">upvalue</span>;
    <span class="i">upvalue</span> = <span class="i">upvalue</span>-&gt;<span class="i">next</span>;
  }

  <span class="k">if</span> (<span class="i">upvalue</span> != <span class="a">NULL</span> &amp;&amp; <span class="i">upvalue</span>-&gt;<span class="i">location</span> == <span class="i">local</span>) {
    <span class="k">return</span> <span class="i">upvalue</span>;
  }

</pre><pre class="insert-after" translate="no">  ObjUpvalue* createdUpvalue = newUpvalue(local);
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>captureUpvalue</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">우리는 목록<span name="head">의 맨 위</span>에서 시작하는데, 이는 스택의 맨 위에 가장 가까운 업값입니다.</font><font papago-translate="translated"> 우리는 목록을 훑어보며 작은 포인터 비교를 사용하여 우리가 찾고 있는 위쪽 슬롯을 가리키며 모든 업값을 반복합니다.</font><font papago-translate="translated"> 그렇게 하는 동안, 우리는 목록에서 이전의 상승 값을 추적합니다.</font><font papago-translate="translated"> 해당 노드의 </font></font><code translate="no">next</code><font papago-translate="splitted"><font papago-translate="translated"> 포인터 뒤에 노드를 삽입하게 된다면.</font></font></p>
<aside name="head" style="top: 31480.5px;">
<p><font papago-translate="translated">단일 링크 목록입니다.</font><font papago-translate="translated"> 우리가 처음부터 시작해서 거기서부터 앞으로 나아가는 것 외에는 다른 선택의 여지가 없는 것은 아닙니다.</font></p>
</aside>
<p><font papago-translate="translated">루프를 종료할 수 있는 세 가지 이유가 있습니다:</font></p>
<ol>
<li>
<p><font papago-translate="translated"><strong>우리가 들른 지역 슬롯<em>은</em> 우리가 찾고 있는 슬롯<em>입니다</em>.</strong></font><font papago-translate="translated"> 변수를 포착하는 기존 업값을 발견하여 해당 업값을 재사용합니다.</font></p>
</li>
<li>
<p><font papago-translate="splitted"><font papago-translate="translated"><strong>검색할 가치가 떨어졌습니다.</strong></font><font papago-translate="translated"> 언제 </font></font><code translate="no">upvalue</code><font papago-translate="splitted"><font papago-translate="translated"> 이 </font></font><code translate="no">NULL</code><font papago-translate="splitted"><font papago-translate="translated">, 이는 목록의 모든 열린 업값이 우리가 찾고 있는 슬롯 위의 로컬을 가리키거나 (더 가능성이 높은) 업값 목록이 비어 있다는 것을 의미합니다.</font><font papago-translate="translated"> 어느 쪽이든, 우리는 우리 슬롯의 가치 상승을 찾지 못했습니다.</font></font></p>
</li>
<li>
<p><font papago-translate="translated"><strong>우리가 찾고 있는 것<em>보다</em> 낮은 로컬 슬롯을 가진 업값을 발견했습니다.</strong></font><font papago-translate="translated"> 목록이 정렬되었으므로, 이는 우리가 닫는 슬롯을 넘어섰다는 것을 의미하며, 따라서 기존의 상승 가치가 없어야 합니다.</font></p>
</li>
</ol>
<p><font papago-translate="translated">첫 번째 경우에는, 우리는 끝났고 돌아왔습니다.</font><font papago-translate="translated"> 그렇지 않으면 로컬 슬롯에 대한 새로운 업밸류를 생성하여 올바른 위치에 목록에 삽입합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  ObjUpvalue* createdUpvalue = newUpvalue(local);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>capture</em>U<em>pvalue</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="i">createdUpvalue</span>-&gt;<span class="i">next</span> = <span class="i">upvalue</span>;

  <span class="k">if</span> (<span class="i">prevUpvalue</span> == <span class="a">NULL</span>) {
    <span class="i">vm</span>.<span class="i">openUpvalues</span> = <span class="i">createdUpvalue</span>;
  } <span class="k">else</span> {
    <span class="i">prevUpvalue</span>-&gt;<span class="i">next</span> = <span class="i">createdUpvalue</span>;
  }

</pre><pre class="insert-after" translate="no">  return createdUpvalue;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>captureUpvalue</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">이 함수의 현재 형태는 이미 업값을 생성하므로, 업값을 목록에 삽입하기 위해 코드만 추가하면 됩니다.</font><font papago-translate="translated"> 우리는 목록의 끝을 지나치거나, 스택 슬롯이 우리가 찾고 있는 것보다 낮은 첫 번째 업값에 들러 목록 탐색을 종료했습니다.</font><font papago-translate="translated"> 어느 경우든, 그것은 우리가 가리키는 객체<em> 앞에</em> 새로운 업값을 삽입해야 한다는 것을 의미합니다 </font></font><code translate="no">upvalue</code><font papago-translate="splitted"><font papago-translate="translated"> (아마도 </font></font><code translate="no">NULL</code><font papago-translate="splitted"><font papago-translate="translated"> 목록의 끝에 도달하면).</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">데이터 구조 101에서 배웠을 수도 있지만, 연결된 목록에 노드를 삽입하려면 다음을 설정해야 합니다 </font></font><code translate="no">next</code><font papago-translate="splitted"><font papago-translate="translated"> 이전 노드의 포인터로 새 노드를 가리킵니다.</font><font papago-translate="translated"> 우리는 목록을 작성하면서 이전 노드를 편리하게 추적하고 있습니다.</font><font papago-translate="translated"> 우리는 목록의 맨 앞에 새로운 업값을 삽입하는<span name="double"> 특별</span>한 경우도 처리해야 합니다. 이 경우 "다음" 포인터가 VM의 헤드 포인터입니다.</font></font></p>
<aside name="double" style="top: 32448.5px;">
<p><font papago-translate="splitted"><font papago-translate="translated">헤드 포인터 또는 이전 업값의 업데이트를 처리하는 더 짧은 구현이 있습니다 </font></font><code translate="no">next</code><font papago-translate="splitted"><font papago-translate="translated"> 포인터를 사용하여 균일하게 포인터를 만들지만, 그런 종류의 코드는 선 마스터 수준의 포인터 전문 지식에 도달하지 못한 거의 모든 사람을 혼란스럽게 합니다.</font><font papago-translate="translated"> 저는 기본으로 갔습니다 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 진술 접근 방식.</font></font></p>
</aside>
<p><font papago-translate="translated">이 업데이트된 기능을 통해 VM은 이제 주어진 로컬 슬롯에 대해 단일 ObjUp 값만 가지도록 보장합니다.</font><font papago-translate="translated"> 두 개의 폐쇄가 동일한 변수를 포착하면 동일한 업값을 얻게 됩니다.</font><font papago-translate="translated"> 이제 이러한 업값을 스택에서 이동할 준비가 되었습니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/closures.html#closing-upvalues-at-runtime" id="closing-upvalues-at-runtime"><small><font papago-translate="translated">25 . 4 . 4</font></small><font papago-translate="splitted"><font papago-translate="translated">런타임 시 값 닫기</font></font></a></h3>
<p><font papago-translate="splitted"><font papago-translate="translated">컴파일러는 유용하게 다음을 방출합니다 </font></font><code translate="no">OP_CLOSE_UPVALUE</code><font papago-translate="splitted"><font papago-translate="translated"> VM에 로컬 변수를 힙에 올려놓아야 하는 시점을 정확히 알려주는 지침.</font><font papago-translate="translated"> 그 지시를 실행하는 것은 통역사의 책임입니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      }
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font></div>
<pre class="insert" translate="no">      <span class="k">case</span> <span class="a">OP_CLOSE_UPVALUE</span>:
        <span class="i">closeUpvalues</span>(<span class="i">vm</span>.<span class="i">stackTop</span> - <span class="n">1</span>);
        <span class="i">pop</span>();
        <span class="k">break</span>;
</pre><pre class="insert-after" translate="no">      case OP_RETURN: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">지시에 도달하면, 우리가 올리고 있는 변수는 스택 바로 위에 있습니다.</font><font papago-translate="translated"> 우리는 그 스택 슬롯의 주소를 전달하는 도우미 함수를 호출합니다.</font><font papago-translate="translated"> 그 함수는 업값을 닫고 로컬을 스택에서 힙으로 이동시키는 역할을 합니다.</font><font papago-translate="translated"> 그 후, VM은 스택 슬롯을 자유롭게 폐기할 수 있으며, 이는 호출을 통해 이루어집니다 </font></font><code translate="no">pop()</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p>
<p><font papago-translate="translated">재미있는 일은 여기서 일어납니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>capture</em>U<em>pvalue</em>() 이후에 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">closeUpvalues</span>(<span class="t">Value</span>* <span class="i">last</span>) {
  <span class="k">while</span> (<span class="i">vm</span>.<span class="i">openUpvalues</span> != <span class="a">NULL</span> &amp;&amp;
         <span class="i">vm</span>.<span class="i">openUpvalues</span>-&gt;<span class="i">location</span> &gt;= <span class="i">last</span>) {
    <span class="t">ObjUpvalue</span>* <span class="i">upvalue</span> = <span class="i">vm</span>.<span class="i">openUpvalues</span>;
    <span class="i">upvalue</span>-&gt;<span class="i">closed</span> = *<span class="i">upvalue</span>-&gt;<span class="i">location</span>;
    <span class="i">upvalue</span>-&gt;<span class="i">location</span> = &amp;<span class="i">upvalue</span>-&gt;<span class="i">closed</span>;
    <span class="i">vm</span>.<span class="i">openUpvalues</span> = <span class="i">upvalue</span>-&gt;<span class="i">next</span>;
  }
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>captureUpvalue</em>()</div>
<p><font papago-translate="translated">이 함수는 스택 슬롯으로 포인터를 가져옵니다.</font><font papago-translate="translated"> 스택에서 해당 슬롯 또는 그 위의 슬롯을 가리킬 수 있는 모든 열린 업값을 닫습니다.</font><font papago-translate="translated"> 지금은 스택의 상단 슬롯에만 포인터를 전달하므로 "또는 그 위" 부분은 작동하지 않지만 곧 작동할 것입니다.</font></p>
<p><font papago-translate="translated">이를 위해 VM의 열린 업값 목록을 위에서 아래로 다시 한 번 이동합니다.</font><font papago-translate="translated"> 업값의 위치가 우리가 닫는 슬롯 범위를 가리키면, 우리는 업값을 닫습니다.</font><font papago-translate="translated"> 그렇지 않으면 범위를 벗어난 업값에 도달하면 나머지 값도 마찬가지라는 것을 알 수 있으므로 반복을 중지합니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">업밸류가 마감되는 방식은 꽤<span name="cool"> 멋진 일</span>입니다.</font><font papago-translate="translated"> 먼저 변수의 값을 다음과 같이 복사합니다 </font></font><code translate="no">closed</code><font papago-translate="splitted"><font papago-translate="translated"> ObjUpvalue 필드.</font><font papago-translate="translated"> 폐쇄 변수가 힙에 존재하는 곳입니다.</font><font papago-translate="translated"> 그 </font></font><code translate="no">OP_GET_UPVALUE</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">OP_SET_UPVALUE</code><font papago-translate="splitted"><font papago-translate="translated"> 지침은 변수를 이동한 후에 해당 변수를 찾아야 합니다.</font><font papago-translate="translated"> 해당 지침에 대해 인터프리터 코드에 조건부 논리를 추가하여 업값이 열려 있는지 닫혔는지 확인할 수 있습니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">하지만 이미 어느 정도의 간접적인 지시가 이루어지고 있습니다—이러한 지시는 다음<span class="em"></span>을 참조하지 않습니다 </font></font><code translate="no">location</code><font papago-translate="splitted"><font papago-translate="translated"> 변수 값으로 이동하는 포인터.</font><font papago-translate="translated"> 변수가 스택에서 다음으로 이동할 때 </font></font><code translate="no">closed</code><font papago-translate="splitted"><font papago-translate="translated"> 필드, 간단히 업데이트합니다 </font></font><code translate="no">location</code><font papago-translate="splitted"><font papago-translate="translated"> ObjUpvalue<em>의 주소</em>로</font></font> <code translate="no">closed</code><font papago-translate="splitted"><font papago-translate="translated"> 들판.</font></font></p>
<aside name="cool" style="top: 33588.5px;">
<p><font papago-translate="translated">여기서 제 자신을 칭찬하는 것이 아닙니다.</font><font papago-translate="translated"> 이것이 바로 루아 개발 팀의 혁신입니다.</font></p>
</aside><img alt="Moving a value from the stack to the upvalue's 'closed' field and then pointing the 'value' field to it." src="https://youhogeon-meritz.github.io/image/closures/closing.png">
<p><font papago-translate="splitted"><font papago-translate="translated">우리는 방법을 바꿀 필요가 없습니다 </font></font><code translate="no">OP_GET_UPVALUE</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">OP_SET_UPVALUE</code><font papago-translate="splitted"><font papago-translate="translated"> 전혀 해석되지 않습니다.</font><font papago-translate="translated"> 그것은 그들을 단순하게 유지하고, 다시 빠르게 유지합니다.</font><font papago-translate="translated"> 하지만 ObjUpvalue에 새 필드를 추가해야 합니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  Value* location;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 구조 Ob<em>jUpvalue</em>에서</font></font></div>
<pre class="insert" translate="no">  <span class="t">Value</span> <span class="i">closed</span>;
</pre><pre class="insert-after" translate="no">  struct ObjUpvalue* next;
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, in struct <em>ObjUpvalue</em></div>
<p><font papago-translate="translated">그리고 초기화되지 않은 메모리가 떠다니지 않도록 ObjUp 값을 만들 때 이 값을 0으로 설정해야 합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  ObjUpvalue* upvalue = ALLOCATE_OBJ(ObjUpvalue, OBJ_UPVALUE);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>newUpvalue</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="i">upvalue</span>-&gt;<span class="i">closed</span> = <span class="a">NIL_VAL</span>;
</pre><pre class="insert-after" translate="no">  upvalue-&gt;location = slot;
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>newUpvalue</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">컴파일러가 블록의 끝에 도달할 때마다 해당 블록의 모든 로컬 변수를 버리고 다음을 방출합니다 </font></font><code translate="no">OP_CLOSE_UPVALUE</code> <font papago-translate="splitted"><font papago-translate="translated"> 닫힌 각 지역 변수에 대해.</font><font papago-translate="translated"> 컴파일러는 함수<em></em><span name="close"></span> 본문을 정의하는 가장 바깥쪽 블록 범위의 끝에서 어떠한 명령도 방출하지 않습니다.</font><font papago-translate="translated"> 해당 범위에는 함수의 매개변수와 함수 내부에 즉시 선언된 모든 로컬이 포함되어 있습니다.</font><font papago-translate="translated"> 그것들도 닫아야 합니다.</font></font></p>
<aside name="close" style="top: 34457.5px;">
<p><font papago-translate="splitted"><font papago-translate="translated">컴파일러에서 가장 바깥쪽 함수 범위를 닫고 방출하는<em> 것을 막을</em> 수 있는 것은 없습니다 </font></font><code translate="no">OP_POP</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">OP_CLOSE_UPVALUE</code><font papago-translate="splitted"><font papago-translate="translated"> 지침들.</font><font papago-translate="translated"> 그렇게 하는 것은 불필요합니다. 왜냐하면 런타임이 호출 프레임을 실행할 때 함수가 사용하는 모든 스택 슬롯을 암묵적으로 버리기 때문입니다.</font></font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">이것이 이유입니다 </font></font><code translate="no">closeUpvalues()</code><font papago-translate="splitted"><font papago-translate="translated"> 스택 슬롯에 대한 포인터를 수락합니다.</font><font papago-translate="translated"> 함수가 돌아오면 동일한 도우미를 호출하여 함수가 소유한 첫 번째 스택 슬롯을 통과합니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">        Value result = pop();
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font></div>
<pre class="insert" translate="no">        <span class="i">closeUpvalues</span>(<span class="i">frame</span>-&gt;<span class="i">slots</span>);
</pre><pre class="insert-after" translate="no">        vm.frameCount--;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p><font papago-translate="translated">함수의 스택 창에서 첫 번째 슬롯을 통과하면 반환 함수가 소유한 나머지 모든 열린 업값을 닫습니다.</font><font papago-translate="translated"> 그리고 이제 완전히 작동하는 폐쇄 구현이 되었습니다.</font><font papago-translate="translated"> 폐쇄 변수는 이를 포착하는 함수에 의해 필요한 만큼 오래 지속됩니다.</font></p>
<p><font papago-translate="translated">정말 많은 일이었어요!</font><font papago-translate="translated"> Jlox에서는 환경 표현에서 자연스럽게 폐쇄가 발생했습니다.</font><font papago-translate="translated"> clox에서는 새로운 바이트코드 명령어, 컴파일러의 더 많은 데이터 구조, 새로운 런타임<span class="em"></span> 객체 등 많은 코드를 추가해야 했습니다.</font><font papago-translate="translated"> VM은 폐쇄 상태의 변수를 다른 변수와 다르게 취급합니다.</font></p>
<p><font papago-translate="translated">그럴 만한 이유가 있습니다.</font><font papago-translate="translated"> 구현 복잡성 측면에서 Jlox는 "무료로" 클로저를 제공했습니다.</font><font papago-translate="translated"> 하지만<em> 성능</em> 면에서 Jlox의 폐쇄는 전혀 의미가 없습니다.</font><font papago-translate="translated"> 힙에<em> 모든</em> 환경을 할당함으로써, Jlox는 폐쇄로 포착되지 않는 대부분의 지역 변수들까지도<em> 모든</em> 지역 변수에 대해 상당한 성능 대가를 치르게 됩니다.</font></p>
<p><font papago-translate="translated">clox를 사용하면 더 복잡한 시스템을 만들 수 있지만, 이를 통해 로컬 변수에 대해 관찰하는 두 가지 사용 패턴에 맞게 구현을 조정할 수 있습니다.</font><font papago-translate="translated"> 스택 의미론을 가진 대부분의 변수에 대해서는 간단하고 빠른 스택에 전적으로 할당합니다.</font><font papago-translate="translated"> 그런 다음 몇 가지 지역 변수가 작동하지 않는 경우 필요에 따라 두 번째로 느린 경로를 선택할 수 있습니다.</font></p>
<p><font papago-translate="translated">다행히도 사용자들은 그 복잡성을 인식하지 못합니다.</font><font papago-translate="translated"> 그들의 관점에서 볼 때, Lox의 지역 변수는 간단하고 균일합니다.</font><font papago-translate="translated"> <em>언어 자체는</em> Jlox의 구현처럼 간단합니다.</font><font papago-translate="translated"> 하지만 후드 아래에서 clox는 사용자가 하는 일을 지켜보고 특정 용도에 맞게 최적화합니다.</font><font papago-translate="translated"> 언어 구현이 정교해짐에 따라, 당신은 이것을 더 많이 하게 될 것입니다.</font><font papago-translate="translated"> "최적화"의 큰 부분은 특정 용도를 감지하고 해당 패턴에 맞는 맞춤형 더 빠른 코드 경로를 제공하는 특수 케이스 코드를 추가하는 것입니다.</font></p>
<p><font papago-translate="translated">우리는 현재 클록스에서 완전히 작동하는 어휘 범위를 가지고 있으며, 이는 중요한 이정표입니다.</font><font papago-translate="translated"> 그리고 이제 복잡한 수명을 가진 함수와 변수가 생겼으니, 많은 객체들이 클록스 더미에 떠다니고, 이<em></em>들을 연결하는 포인터 웹이 있습니다.</font><font papago-translate="translated"> <a href="https://youhogeon-meritz.github.io/garbage-collection.html">다음 단계</a>는 더 이상 필요하지 않을 때 일부 객체를 해제할 수 있도록 메모리를 관리하는 방법을 찾는 것입니다.</font></p>
<div class="challenges">
<h2><a href="https://youhogeon-meritz.github.io/closures.html#challenges" id="challenges"><font papago-translate="translated">과제들</font></a></h2>
<ol>
<li>
<p><font papago-translate="translated">모든 ObjFunction을 ObjClosure로 감싸면 성능 비용이 드는 수준의 간접 효과가 발생합니다.</font><font papago-translate="translated"> 그 비용은 변수에 대해 닫히지 않는 함수에는 필요하지 않지만, 런타임이 모든 호출을 균일하게 처리할 수 있게 해줍니다.</font></p>
<p><font papago-translate="translated">clox를 변경하여 업값이 필요한 ObjClosures 함수만 랩핑하도록 합니다.</font><font papago-translate="translated"> 코드 복잡도와 성능이 항상 랩핑 기능과 비교했을 때 어떻습니까?</font><font papago-translate="translated"> 클로저를 사용하는 프로그램과 사용하지 않는 프로그램을 벤치마킹하는 데 주의하세요.</font><font papago-translate="translated"> 각 벤치마크의 중요도를 어떻게 평가해야합니까?</font><font papago-translate="translated"> 속도가 느려지고 빨라지면 구현 전략을 선택하기 위해 어떤 절충안을 선택해야 하는지 어떻게 결정하나요?</font></p>
</li>
<li>
<p><font papago-translate="translated">아래 디자인 노트를 읽어보세요.</font><font papago-translate="translated"> 기다릴게요.</font><font papago-translate="translated"> 이제 Lox는 어떻게 행동<em>해야</em> 한다고 생각하십니까?</font><font papago-translate="translated"> 구현을 변경하여 각 루프 반복에 대한 새 변수를 만듭니다.</font></p>
</li>
<li>
<p><font papago-translate="translated"><a href="http://wiki.c2.com/?ClosuresAndObjectsAreEquivalent">유명한 코안</a>은 우리에게 "물건은 가난한 사람의 폐쇄"라고 가르칩니다 (그리고 그 반대도 마찬가지입니다).</font><font papago-translate="translated"> 우리 VM은 아직 객체를 지원하지 않지만, 이제 클로저가 생겼으니 객체를 근사할 수 있습니다.</font><font papago-translate="translated"> 클로저를 사용하여 2차원 벡터 "객체"를 모델링하는 Lox 프로그램을 작성합니다.</font><font papago-translate="translated"> 그래야 합니다:</font></p>
<ul>
<li>
<p><font papago-translate="translated">주어진<em> x</em>와<em> y</em> 좌표로 새로운 벡터를 만들기 위해 "생성자" 함수를 정의합니다.</font></p>
</li>
<li>
<p><font papago-translate="translated">해당 생성자로부터 반환된 값<em>의 x</em>와<em> y</em> 좌표에 접근할 수 있는 "방법"을 제공합니다.</font></p>
</li>
<li>
<p><font papago-translate="translated">두 벡터를 더하고 세 번째 벡터를 생성하는 덧셈 "방법"을 정의합니다.</font></p>
</li>
</ul>
</li>
</ol>
</div>
<div class="design-note">
<h2><a href="https://youhogeon-meritz.github.io/closures.html#design-note" id="design-note"><font papago-translate="translated">디자인 노트:</font><font papago-translate="translated"> 루프 변수에 대한 클로징</font></a></h2>
<p><font papago-translate="translated">폐쇄는 변수를 포착합니다.</font><font papago-translate="translated"> 두 개의 폐쇄가 동일한 변수를 포착하면 동일한 기본 저장 위치에 대한 참조를 공유합니다.</font><font papago-translate="translated"> 이 사실은 변수에 새로운 값이 할당될 때 보입니다.</font><font papago-translate="translated"> 물론 두 개의 폐쇄가<em> 서로 다른</em> 변수를 포착하면 공유가 이루어지지 않습니다.</font></p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="i">globalOne</span>;
<span class="k">var</span> <span class="i">globalTwo</span>;

<span class="k">fun</span> <span class="i">main</span>() {
  {
    <span class="k">var</span> <span class="i">a</span> = <span class="s">"one"</span>;
    <span class="k">fun</span> <span class="i">one</span>() {
      <span class="k">print</span> <span class="i">a</span>;
    }
    <span class="i">globalOne</span> = <span class="i">one</span>;
  }

  {
    <span class="k">var</span> <span class="i">a</span> = <span class="s">"two"</span>;
    <span class="k">fun</span> <span class="i">two</span>() {
      <span class="k">print</span> <span class="i">a</span>;
    }
    <span class="i">globalTwo</span> = <span class="i">two</span>;
  }
}

<span class="i">main</span>();
<span class="i">globalOne</span>();
<span class="i">globalTwo</span>();
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">이것은 "하나"를 출력한 다음 "둘"을 출력합니다.</font><font papago-translate="translated"> 이 예제에서 두 가지가 매우 명확합니다 </font></font><code translate="no">a</code><font papago-translate="splitted"><font papago-translate="translated"> 변수는 다릅니다.</font><font papago-translate="translated"> 하지만 항상 그렇게 분명하지는 않습니다.</font><font papago-translate="translated"> 고려:</font></font></p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="i">globalOne</span>;
<span class="k">var</span> <span class="i">globalTwo</span>;

<span class="k">fun</span> <span class="i">main</span>() {
  <span class="k">for</span> (<span class="k">var</span> <span class="i">a</span> = <span class="n">1</span>; <span class="i">a</span> &lt;= <span class="n">2</span>; <span class="i">a</span> = <span class="i">a</span> + <span class="n">1</span>) {
    <span class="k">fun</span> <span class="i">closure</span>() {
      <span class="k">print</span> <span class="i">a</span>;
    }
    <span class="k">if</span> (<span class="i">globalOne</span> == <span class="k">nil</span>) {
      <span class="i">globalOne</span> = <span class="i">closure</span>;
    } <span class="k">else</span> {
      <span class="i">globalTwo</span> = <span class="i">closure</span>;
    }
  }
}

<span class="i">main</span>();
<span class="i">globalOne</span>();
<span class="i">globalTwo</span>();
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">Lox에는 컬렉션 유형이 없기 때문에 코드가 복잡합니다.</font><font papago-translate="translated"> 중요한 부분은 </font></font><code translate="no">main()</code><font papago-translate="splitted"><font papago-translate="translated"> 함수는 다음과 같은 두 가지 반복을 수행합니다 </font></font><code translate="no">for</code><font papago-translate="splitted"><font papago-translate="translated"> 루프. 루프를 통과할 때마다 루프 변수를 포착하는 클로저가 생성됩니다.</font><font papago-translate="translated"> 첫 번째 클로저를 저장합니다 </font></font><code translate="no">globalOne</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고 두 번째 </font></font><code translate="no">globalTwo</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">분명히 두 가지 다른 폐쇄가 있습니다.</font><font papago-translate="translated"> 두 개의 다른 변수에 대해 닫히나요?</font><font papago-translate="translated"> 하나뿐인가요 </font></font><code translate="no">a</code><font papago-translate="splitted"><font papago-translate="translated"> 루프의 전체 기간 동안, 아니면 각 반복이 고유하게 변할까요 </font></font><code translate="no">a</code><font papago-translate="splitted"><font papago-translate="translated"> 변수?</font></font></p>
<p><font papago-translate="translated">여기 있는 스크립트는 이상하고 인위적이지만, 클록스만큼 작지 않은 언어에서는 실제 코드로 나타납니다.</font><font papago-translate="translated"> 다음은 JavaScript 예제입니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="i">closures</span> = [];
<span class="k">for</span> (<span class="k">var</span> <span class="i">i</span> = <span class="n">1</span>; <span class="i">i</span> &lt;= <span class="n">2</span>; <span class="i">i</span>++) {
  <span class="i">closures</span>.<span class="i">push</span>(<span class="k">function</span> () { <span class="i">console</span>.<span class="i">log</span>(<span class="i">i</span>); });
}

<span class="i">closures</span>[<span class="n">0</span>]();
<span class="i">closures</span>[<span class="n">1</span>]();
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">이 인쇄는 "1" 다음에 "2"를 인쇄하나요, 아니면<span name="three"> "3</span>"을 두 번 인쇄하나요?</font><font papago-translate="translated"> "3"이 두 번 인쇄된다는 소식을 들으면 놀랄 수도 있습니다.</font><font papago-translate="translated"> 이 JavaScript 프로그램에는 단 하나의 </font></font><code translate="no">i</code><font papago-translate="splitted"><font papago-translate="translated"> 최종 종료를 포함한 루프의 모든 반복을 포함하는 수명을 가진 변수.</font></font></p>
<aside name="three" style="top: 37903.5px;">
<p><font papago-translate="splitted"><font papago-translate="translated"><em>세 사람이</em> 어떻게 그림에 들어가는지 궁금하신가요?</font><font papago-translate="translated"> 두 번째 반복 후에, </font></font><code translate="no">i++</code><font papago-translate="splitted"><font papago-translate="translated"> 실행됩니다, 증가합니다 </font></font><code translate="no">i</code><font papago-translate="splitted"><font papago-translate="translated"> 셋까지.</font><font papago-translate="translated"> 그것이 원인입니다 </font></font><code translate="no">i &lt;= 2</code><font papago-translate="splitted"><font papago-translate="translated"> 거짓으로 평가하고 루프를 종료합니다. 만약 </font></font><code translate="no">i</code><font papago-translate="splitted"><font papago-translate="translated"> 세 번에 도달하지 못하면 루프는 영원히 실행될 것입니다.</font></font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">JavaScript에 익숙하다면 다음과 같은 변수를 사용하여 선언한 것을 알고 계실 것입니다 </font></font><code translate="no">var</code><font papago-translate="splitted"><font papago-translate="translated"> 은 암묵적으로 주변 함수 또는 최상위 범위로<em> 이동합니다</em>.</font><font papago-translate="translated"> 마치 당신이 이걸 정말로 쓴 것 같아요:</font></font></p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="i">closures</span> = [];
<span class="k">var</span> <span class="i">i</span>;
<span class="k">for</span> (<span class="i">i</span> = <span class="n">1</span>; <span class="i">i</span> &lt;= <span class="n">2</span>; <span class="i">i</span>++) {
  <span class="i">closures</span>.<span class="i">push</span>(<span class="k">function</span> () { <span class="i">console</span>.<span class="i">log</span>(<span class="i">i</span>); });
}

<span class="i">closures</span>[<span class="n">0</span>]();
<span class="i">closures</span>[<span class="n">1</span>]();
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">그 시점에서, 단 하나만 존재한다는 것이 더 명확합니다 </font></font><code translate="no">i</code><font papago-translate="splitted"><font papago-translate="translated">. 이제 최신 프로그램을 사용하도록 프로그램을 변경할지 고려해 보세요 </font></font><code translate="no">let</code><font papago-translate="splitted"><font papago-translate="translated"> 키워드:</font></font></p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="i">closures</span> = [];
<span class="k">for</span> (<span class="k">let</span> <span class="i">i</span> = <span class="n">1</span>; <span class="i">i</span> &lt;= <span class="n">2</span>; <span class="i">i</span>++) {
  <span class="i">closures</span>.<span class="i">push</span>(<span class="k">function</span> () { <span class="i">console</span>.<span class="i">log</span>(<span class="i">i</span>); });
}

<span class="i">closures</span>[<span class="n">0</span>]();
<span class="i">closures</span>[<span class="n">1</span>]();
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">이 새로운 프로그램도 똑같이 작동하나요?</font><font papago-translate="translated"> 아니.</font><font papago-translate="translated"> 이 경우에는 "1"을 출력한 다음 "2"를 출력합니다.</font><font papago-translate="translated"> 각 폐쇄마다 고유한 기능이 있습니다 </font></font><code translate="no">i</code><font papago-translate="splitted"><font papago-translate="translated">. 생각해보면 좀 이상하네요.</font><font papago-translate="translated"> 증분 조항은 </font></font><code translate="no">i++</code><font papago-translate="splitted"><font papago-translate="translated">. 그것은 새로운 변수를 생성하는 것이 아니라 기존 변수에 할당하고 돌연변이시키는 것처럼 보입니다.</font></font></p>
<p><font papago-translate="translated">다른 언어들도 시도해 보겠습니다.</font><font papago-translate="translated"> 파이썬은 다음과 같습니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="i">closures</span> = []
<span class="k">for</span> <span class="i">i</span> <span class="k">in</span> <span class="k">range</span>(<span class="n">1</span>, <span class="n">3</span>):
  <span class="i">closures</span>.<span class="i">append</span>(<span class="k">lambda</span>: <span class="k">print</span>(<span class="i">i</span>))

<span class="i">closures</span>[<span class="n">0</span>]()
<span class="i">closures</span>[<span class="n">1</span>]()
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">파이썬에는 블록 범위가 실제로 없습니다.</font><font papago-translate="translated"> 변수는 암묵적으로 선언되며 자동으로 주변 함수로 범위가 지정됩니다.</font><font papago-translate="translated"> 지금 생각해보니 JS에서 게양하는 것과 비슷합니다.</font><font papago-translate="translated"> 따라서 두 폐쇄 모두 동일한 변수를 포착합니다.</font><font papago-translate="translated"> 하지만 C와 달리, 우리는 다음을 증가시켜 루프를 종료하지 않습니다 </font></font><code translate="no">i</code> <font papago-translate="splitted"><font papago-translate="translated">마지막 값<em>을 넘겨</em>서 "2"를 두 번 출력합니다<em>.</em></font></font></p>
<p><font papago-translate="translated">루비는 어때요?</font><font papago-translate="translated"> 루비는 수치적으로 반복하는 두 가지 일반적인 방법이 있습니다.</font><font papago-translate="translated"> 고전적인 명령형 스타일은 다음과 같습니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="i">closures</span> = []
<span class="k">for</span> <span class="i">i</span> <span class="k">in</span> <span class="n">1</span>..<span class="n">2</span> <span class="k">do</span>
  <span class="i">closures</span> &lt;&lt; <span class="k">lambda</span> { <span class="i">puts</span> <span class="i">i</span> }
<span class="k">end</span>

<span class="i">closures</span>[<span class="n">0</span>].<span class="i">call</span>
<span class="i">closures</span>[<span class="n">1</span>].<span class="i">call</span>
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">이것은 파이썬처럼 "2"를 두 번 인쇄합니다.</font><font papago-translate="translated"> 하지만 더 관용적인 루비 스타일은 더 높은 차수를 사용합니다 </font></font><code translate="no">each()</code><font papago-translate="splitted"><font papago-translate="translated"> 범위 객체에 대한 메서드:</font></font></p>
<div class="codehilite"><pre translate="no"><span class="i">closures</span> = []
(<span class="n">1</span>..<span class="n">2</span>).<span class="i">each</span> <span class="k">do</span> |<span class="i">i</span>|
  <span class="i">closures</span> &lt;&lt; <span class="k">lambda</span> { <span class="i">puts</span> <span class="i">i</span> }
<span class="k">end</span>

<span class="i">closures</span>[<span class="n">0</span>].<span class="i">call</span>
<span class="i">closures</span>[<span class="n">1</span>].<span class="i">call</span>
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">루비에 대해 잘 모르신다면 </font></font><code translate="no">do |i| ... end</code><font papago-translate="splitted"><font papago-translate="translated"> 부분은 기본적으로 생성되고 전달되는 클로저입니다 </font></font><code translate="no">each()</code><font papago-translate="splitted"><font papago-translate="translated"> 방법.</font><font papago-translate="translated"> 그 </font></font><code translate="no">|i|</code><font papago-translate="splitted"><font papago-translate="translated"> 는 폐쇄에 대한 매개변수 서명입니다.</font><font papago-translate="translated"> 그 </font></font><code translate="no">each()</code><font papago-translate="splitted"><font papago-translate="translated"> 메서드는 해당 폐쇄를 두 번 호출하여 다음을 위해 1을 전달합니다 </font></font><code translate="no">i</code><font papago-translate="splitted"><font papago-translate="translated"> 첫 번째와 두 번째.</font></font></p>
<p><font papago-translate="translated">이 경우, "루프 변수"는 실제로 함수 매개변수입니다.</font><font papago-translate="translated"> 그리고 루프의 각 반복은 함수의 개별 호출이므로, 이는 각 호출에 대해 확실히 개별 변수입니다.</font><font papago-translate="translated"> 그래서 이것은 "1"을 출력한 다음 "2"를 출력합니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">언어가 다음과 같이 더 높은 수준의 반복자 기반 루프 구조를 가지고 있는 경우 </font></font><code translate="no">foreach</code><font papago-translate="splitted"><font papago-translate="translated"> C#에서 Java의 "enhanced for", </font></font><code translate="no">for-of</code><font papago-translate="splitted"><font papago-translate="translated"> JavaScript에서, </font></font><code translate="no">for-in</code><font papago-translate="splitted"><font papago-translate="translated"> 다트 등에서는 독자가 각 반복마다 새로운 변수를 생성하는 것이 자연스럽다고 생각합니다.</font><font papago-translate="translated"> 루프 헤더가 변수 선언처럼 보이기 때문에 코드는 새로운 변수처럼<em> 보입니다</em>.</font><font papago-translate="translated"> 그리고 다음 단계로 나아가기 위해 그 변수를 변형시키는 것처럼 보이는 증분 표현은 없습니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">StackOverflow와 다른 장소들을 둘러보면, 사용자들이 기대하는 것이 바로 이것이라는 증거를 발견할 수 있습니다. 왜냐하면 사용자들이 그것을 이해<em>하지</em> 못할 때 매우 놀라기 때문입니다.</font><font papago-translate="translated"> 특히, C#는 원래 각 반복에 대해 새로운 루프 변수를 생성<em>하지 않았습니다</em> </font></font><code translate="no">foreach</code><font papago-translate="splitted"><font papago-translate="translated"> 루프. 사용자 혼란의 원인이 너무 빈번해서 언어에 획기적인 변화를 가져오는 매우 드문 조치를 취했습니다.</font><font papago-translate="translated"> C# 5에서는 각 반복이 새로운 변수를 생성합니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">올드 C 스타일 </font></font><code translate="no">for</code><font papago-translate="splitted"><font papago-translate="translated"> 루프는 더 어렵습니다.</font><font papago-translate="translated"> 증가 조항은 정말 돌연변이처럼 보입니다.</font><font papago-translate="translated"> 이는 각 단계마다 업데이트되는 단일 변수가 있다는 것을 의미합니다.</font><font papago-translate="translated"> 하지만 각 반복마다 루프 변수를 공유하는 것<em>은</em> 거의<em> 유용</em>하지 않습니다.</font><font papago-translate="translated"> 이것을 감지할 수 있는 유일한 경우는 폐쇄가 포착할 때입니다.</font><font papago-translate="translated"> 그리고 루프를 종료하게 만든 값을 나타내는 변수를 참조하는 클로저를 갖는 것은 거의 도움이 되지 않습니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">실용적으로 유용한 답은 아마도 JavaScript가 하는 일을 하는 것입니다 </font></font><code translate="no">let</code><font papago-translate="splitted"><font papago-translate="translated"> 에서 </font></font><code translate="no">for</code><font papago-translate="splitted"><font papago-translate="translated"> 루프.</font><font papago-translate="translated"> 돌연변이처럼 보이지만 실제로는 매번 새로운 변수를 만듭니다. 왜냐하면 그것이 사용자들이 원하는 것이기 때문입니다.</font><font papago-translate="translated"> 하지만 생각해보면 좀 이상합니다.</font></font></p>
</div>
<footer>
<a class="next" href="https://youhogeon-meritz.github.io/garbage-collection.html"><font papago-translate="translated"> 다음 장: "쓰레기 컬렉션" → </font></a><font papago-translate="splitted"><font papago-translate="translated"> 로버트 니스트롬이 수작업으로 제작한 -<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE"> © 2015 ~ 2021</a></font></font>
</footer>
</article>
</div>


</body></html>