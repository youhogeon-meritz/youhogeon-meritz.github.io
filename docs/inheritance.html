<!DOCTYPE html>

<html>
<head>
<meta content="text/html;charset=utf-8" http-equiv="Content-type"/>
<title>Inheritance · Crafting Interpreters</title>
<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<link href="style.css" rel="stylesheet" type="text/css"/>
<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600" rel="stylesheet" type="text/css"/>
<link href="image/favicon.png" rel="icon" type="image/png">
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>
<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>
</link></head>
<body id="top">
<!-- <div class="scrim"></div> -->
<nav class="wide">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"/></a>
<div class="contents">
<h3><a href="#top">Inheritance<small>13</small></a></h3>
<ul>
<li><a href="#superclasses-and-subclasses"><small>13.1</small> Superclasses and Subclasses</a></li>
<li><a href="#inheriting-methods"><small>13.2</small> Inheriting Methods</a></li>
<li><a href="#calling-superclass-methods"><small>13.3</small> Calling Superclass Methods</a></li>
<li><a href="#conclusion"><small>13.4</small> Conclusion</a></li>
<li class="divider"></li>
<li class="end-part"><a href="#challenges">Challenges</a></li>
</ul>
<div class="prev-next">
<a class="left" href="classes.html" title="Classes">← Previous</a>
<a href="a-tree-walk-interpreter.html" title="A Tree-Walk Interpreter">↑ Up</a>
<a class="right" href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">Next →</a>
</div> </div>
</nav>
<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"/></a>
<a class="prev" href="classes.html" title="Classes">←</a>
<a class="next" href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">→</a>
</nav>
<div class="page">
<div class="nav-wrapper">
<nav class="floating">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"/></a>
<div class="expandable">
<h3><a href="#top">Inheritance<small>13</small></a></h3>
<ul>
<li><a href="#superclasses-and-subclasses"><small>13.1</small> Superclasses and Subclasses</a></li>
<li><a href="#inheriting-methods"><small>13.2</small> Inheriting Methods</a></li>
<li><a href="#calling-superclass-methods"><small>13.3</small> Calling Superclass Methods</a></li>
<li><a href="#conclusion"><small>13.4</small> Conclusion</a></li>
<li class="divider"></li>
<li class="end-part"><a href="#challenges">Challenges</a></li>
</ul>
<div class="prev-next">
<a class="left" href="classes.html" title="Classes">← Previous</a>
<a href="a-tree-walk-interpreter.html" title="A Tree-Walk Interpreter">↑ Up</a>
<a class="right" href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">Next →</a>
</div> </div>
<a id="expand-nav">≡</a>
</nav>
</div>
<article class="chapter">
<div class="number">13</div>
<h1>Inheritance</h1>
<blockquote>
<p>Once we were blobs in the sea, and then fishes, and then lizards and rats and
then monkeys, and hundreds of things in between. This hand was once a fin,
this hand once had claws! In my human mouth I have the pointy teeth of a wolf
and the chisel teeth of a rabbit and the grinding teeth of a cow! Our blood is
as salty as the sea we used to live in! When we’re frightened, the hair on our
skin stands up, just like it did when we had fur. We are history! Everything
we’ve ever been on the way to becoming us, we still are.</p>
<p><cite>Terry Pratchett, <em>A Hat Full of Sky</em></cite></p>
</blockquote>
<p>Can you believe it? We’ve reached the last chapter of <a href="a-tree-walk-interpreter.html">Part II</a>. We’re almost
done with our first Lox interpreter. The <a href="classes.html">previous chapter</a> was a big ball of
intertwined object-orientation features. I couldn’t separate those from each
other, but I did manage to untangle one piece. In this chapter, we’ll finish
off Lox’s class support by adding inheritance.</p>
<p>Inheritance appears in object-oriented languages all the way back to the <span name="inherited">first</span> one, <a href="https://en.wikipedia.org/wiki/Simula">Simula</a>. Early on, Kristen Nygaard and
Ole-Johan Dahl noticed commonalities across classes in the simulation programs
they wrote. Inheritance gave them a way to reuse the code for those similar
parts.</p>
<aside name="inherited">
<p>You could say all those other languages <em>inherited</em> it from Simula. Hey-ooo!
I’ll, uh, see myself out.</p>
</aside>
<h2><a href="#superclasses-and-subclasses" id="superclasses-and-subclasses"><small>13 . 1</small>Superclasses and Subclasses</a></h2>
<p>Given that the concept is “inheritance”, you would hope they would pick a
consistent metaphor and call them “parent” and “child” classes, but that would
be too easy. Way back when, C. A. R. Hoare coined the term “<span name="subclass">subclass</span>” to refer to a record type that refines another
type. Simula borrowed that term to refer to a <em>class</em> that inherits from
another. I don’t think it was until Smalltalk came along that someone flipped
the Latin prefix to get “superclass” to refer to the other side of the
relationship. From C++, you also hear “base” and “derived” classes. I’ll mostly
stick with “superclass” and “subclass”.</p>
<aside name="subclass">
<p>“Super-” and “sub-” mean “above” and “below” in Latin, respectively. Picture an
inheritance tree like a family tree with the root at the top<span class="em">—</span>subclasses are
below their superclasses on the diagram. More generally, “sub-” refers to things
that refine or are contained by some more general concept. In zoology, a
subclass is a finer categorization of a larger class of living things.</p>
<p>In set theory, a subset is contained by a larger superset which has all of the
elements of the subset and possibly more. Set theory and programming languages
meet each other in type theory. There, you have “supertypes” and “subtypes”.</p>
<p>In statically typed object-oriented languages, a subclass is also often a
subtype of its superclass. Say we have a Doughnut superclass and a BostonCream
subclass. Every BostonCream is also an instance of Doughnut, but there may be
doughnut objects that are not BostonCreams (like Crullers).</p>
<p>Think of a type as the set of all values of that type. The set of all Doughnut
instances contains the set of all BostonCream instances since every BostonCream
is also a Doughnut. So BostonCream is a subclass, and a subtype, and its
instances are a subset. It all lines up.</p><img alt="Boston cream &lt;: doughnut." src="image/inheritance/doughnuts.png">
</img></aside>
<p>Our first step towards supporting inheritance in Lox is a way to specify a
superclass when declaring a class. There’s a lot of variety in syntax for this.
C++ and C# place a <code translate="no">:</code> after the subclass’s name, followed by the superclass
name. Java uses <code translate="no">extends</code> instead of the colon. Python puts the superclass(es)
in parentheses after the class name. Simula puts the superclass’s name <em>before</em>
the <code translate="no">class</code> keyword.</p>
<p>This late in the game, I’d rather not add a new reserved word or token to the
lexer. We don’t have <code translate="no">extends</code> or even <code translate="no">:</code>, so we’ll follow Ruby and use a
less-than sign (<code translate="no">&lt;</code>).</p>
<div class="codehilite"><pre translate="no"><span class="k">class</span> <span class="t">Doughnut</span> {
  <span class="c">// General doughnut stuff...</span>
}

<span class="k">class</span> <span class="t">BostonCream</span> &lt; <span class="t">Doughnut</span> {
  <span class="c">// Boston Cream-specific stuff...</span>
}
</pre></div>
<p>To work this into the grammar, we add a new optional clause in our existing
<code translate="no">classDecl</code> rule.</p>
<div class="codehilite"><pre translate="no"><span class="i">classDecl</span>      → <span class="s">"class"</span> <span class="t">IDENTIFIER</span> ( <span class="s">"&lt;"</span> <span class="t">IDENTIFIER</span> )?
                 <span class="s">"{"</span> <span class="i">function</span>* <span class="s">"}"</span> ;
</pre></div>
<p>After the class name, you can have a <code translate="no">&lt;</code> followed by the superclass’s name. The
superclass clause is optional because you don’t <em>have</em> to have a superclass.
Unlike some other object-oriented languages like Java, Lox has no root “Object”
class that everything inherits from, so when you omit the superclass clause, the
class has <em>no</em> superclass, not even an implicit one.</p>
<p>We want to capture this new syntax in the class declaration’s AST node.</p>
<div class="codehilite"><pre class="insert-before" translate="no">      "Block      : List&lt;Stmt&gt; statements",
</pre><div class="source-file"><em>tool/GenerateAst.java</em><br/>
in <em>main</em>()<br/>
replace 1 line</div>
<pre class="insert" translate="no">      <span class="s">"Class      : Token name, Expr.Variable superclass,"</span> +
                  <span class="s">" List&lt;Stmt.Function&gt; methods"</span>,
</pre><pre class="insert-after" translate="no">      "Expression : Expr expression",
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>main</em>(), replace 1 line</div>
<p>You might be surprised that we store the superclass name as an Expr.Variable,
not a Token. The grammar restricts the superclass clause to a single identifier,
but at runtime, that identifier is evaluated as a variable access. Wrapping the
name in an Expr.Variable early on in the parser gives us an object that the
resolver can hang the resolution information off of.</p>
<p>The new parser code follows the grammar directly.</p>
<div class="codehilite"><pre class="insert-before" translate="no">    Token name = consume(IDENTIFIER, "Expect class name.");
</pre><div class="source-file"><em>lox/Parser.java</em><br/>
in <em>classDeclaration</em>()</div>
<pre class="insert" translate="no">

    <span class="t">Expr</span>.<span class="t">Variable</span> <span class="i">superclass</span> = <span class="k">null</span>;
    <span class="k">if</span> (<span class="i">match</span>(<span class="i">LESS</span>)) {
      <span class="i">consume</span>(<span class="i">IDENTIFIER</span>, <span class="s">"Expect superclass name."</span>);
      <span class="i">superclass</span> = <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Variable</span>(<span class="i">previous</span>());
    }

</pre><pre class="insert-after" translate="no">    consume(LEFT_BRACE, "Expect '{' before class body.");
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>classDeclaration</em>()</div>
<p>Once we’ve (possibly) parsed a superclass declaration, we store it in the AST.</p>
<div class="codehilite"><pre class="insert-before" translate="no">    consume(RIGHT_BRACE, "Expect '}' after class body.");

</pre><div class="source-file"><em>lox/Parser.java</em><br/>
in <em>classDeclaration</em>()<br/>
replace 1 line</div>
<pre class="insert" translate="no">    <span class="k">return</span> <span class="k">new</span> <span class="t">Stmt</span>.<span class="t">Class</span>(<span class="i">name</span>, <span class="i">superclass</span>, <span class="i">methods</span>);
</pre><pre class="insert-after" translate="no">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>classDeclaration</em>(), replace 1 line</div>
<p>If we didn’t parse a superclass clause, the superclass expression will be
<code translate="no">null</code>. We’ll have to make sure the later passes check for that. The first of
those is the resolver.</p>
<div class="codehilite"><pre class="insert-before" translate="no">    define(stmt.name);
</pre><div class="source-file"><em>lox/Resolver.java</em><br/>
in <em>visitClassStmt</em>()</div>
<pre class="insert" translate="no">

    <span class="k">if</span> (<span class="i">stmt</span>.<span class="i">superclass</span> != <span class="k">null</span>) {
      <span class="i">resolve</span>(<span class="i">stmt</span>.<span class="i">superclass</span>);
    }
</pre><pre class="insert-after" translate="no">

    beginScope();
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in <em>visitClassStmt</em>()</div>
<p>The class declaration AST node has a new subexpression, so we traverse into and
resolve that. Since classes are usually declared at the top level, the
superclass name will most likely be a global variable, so this doesn’t usually
do anything useful. However, Lox allows class declarations even inside blocks,
so it’s possible the superclass name refers to a local variable. In that case,
we need to make sure it’s resolved.</p>
<p>Because even well-intentioned programmers sometimes write weird code, there’s a
silly edge case we need to worry about while we’re in here. Take a look at this:</p>
<div class="codehilite"><pre translate="no"><span class="k">class</span> <span class="t">Oops</span> &lt; <span class="t">Oops</span> {}
</pre></div>
<p>There’s no way this will do anything useful, and if we let the runtime try to
run this, it will break the expectation the interpreter has about there not
being cycles in the inheritance chain. The safest thing is to detect this case
statically and report it as an error.</p>
<div class="codehilite"><pre class="insert-before" translate="no">    define(stmt.name);

</pre><div class="source-file"><em>lox/Resolver.java</em><br/>
in <em>visitClassStmt</em>()</div>
<pre class="insert" translate="no">    <span class="k">if</span> (<span class="i">stmt</span>.<span class="i">superclass</span> != <span class="k">null</span> &amp;&amp;
        <span class="i">stmt</span>.<span class="i">name</span>.<span class="i">lexeme</span>.<span class="i">equals</span>(<span class="i">stmt</span>.<span class="i">superclass</span>.<span class="i">name</span>.<span class="i">lexeme</span>)) {
      <span class="t">Lox</span>.<span class="i">error</span>(<span class="i">stmt</span>.<span class="i">superclass</span>.<span class="i">name</span>,
          <span class="s">"A class can't inherit from itself."</span>);
    }

</pre><pre class="insert-after" translate="no">    if (stmt.superclass != null) {
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in <em>visitClassStmt</em>()</div>
<p>Assuming the code resolves without error, the AST travels to the interpreter.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  public Void visitClassStmt(Stmt.Class stmt) {
</pre><div class="source-file"><em>lox/Interpreter.java</em><br/>
in <em>visitClassStmt</em>()</div>
<pre class="insert" translate="no">    <span class="t">Object</span> <span class="i">superclass</span> = <span class="k">null</span>;
    <span class="k">if</span> (<span class="i">stmt</span>.<span class="i">superclass</span> != <span class="k">null</span>) {
      <span class="i">superclass</span> = <span class="i">evaluate</span>(<span class="i">stmt</span>.<span class="i">superclass</span>);
      <span class="k">if</span> (!(<span class="i">superclass</span> <span class="k">instanceof</span> <span class="t">LoxClass</span>)) {
        <span class="k">throw</span> <span class="k">new</span> <span class="t">RuntimeError</span>(<span class="i">stmt</span>.<span class="i">superclass</span>.<span class="i">name</span>,
            <span class="s">"Superclass must be a class."</span>);
      }
    }

</pre><pre class="insert-after" translate="no">    environment.define(stmt.name.lexeme, null);
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in <em>visitClassStmt</em>()</div>
<p>If the class has a superclass expression, we evaluate it. Since that could
potentially evaluate to some other kind of object, we have to check at runtime
that the thing we want to be the superclass is actually a class. Bad things
would happen if we allowed code like:</p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="t">NotAClass</span> = <span class="s">"I am totally not a class"</span>;

<span class="k">class</span> <span class="t">Subclass</span> &lt; <span class="t">NotAClass</span> {} <span class="c">// ?!</span>
</pre></div>
<p>Assuming that check passes, we continue on. Executing a class declaration turns
the syntactic representation of a class<span class="em">—</span>its AST node<span class="em">—</span>into its runtime
representation, a LoxClass object. We need to plumb the superclass through to
that too. We pass the superclass to the constructor.</p>
<div class="codehilite"><pre class="insert-before" translate="no">      methods.put(method.name.lexeme, function);
    }

</pre><div class="source-file"><em>lox/Interpreter.java</em><br/>
in <em>visitClassStmt</em>()<br/>
replace 1 line</div>
<pre class="insert" translate="no">    <span class="t">LoxClass</span> <span class="i">klass</span> = <span class="k">new</span> <span class="t">LoxClass</span>(<span class="i">stmt</span>.<span class="i">name</span>.<span class="i">lexeme</span>,
        (<span class="t">LoxClass</span>)<span class="i">superclass</span>, <span class="i">methods</span>);

</pre><pre class="insert-after" translate="no">    environment.assign(stmt.name, klass);
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in <em>visitClassStmt</em>(), replace 1 line</div>
<p>The constructor stores it in a field.</p>
<div class="codehilite"><div class="source-file"><em>lox/LoxClass.java</em><br/>
constructor <em>LoxClass</em>()<br/>
replace 1 line</div>
<pre class="insert" translate="no">  <span class="t">LoxClass</span>(<span class="t">String</span> <span class="i">name</span>, <span class="t">LoxClass</span> <span class="i">superclass</span>,
           <span class="t">Map</span>&lt;<span class="t">String</span>, <span class="t">LoxFunction</span>&gt; <span class="i">methods</span>) {
    <span class="k">this</span>.<span class="i">superclass</span> = <span class="i">superclass</span>;
</pre><pre class="insert-after" translate="no">    this.name = name;
</pre></div>
<div class="source-file-narrow"><em>lox/LoxClass.java</em>, constructor <em>LoxClass</em>(), replace 1 line</div>
<p>Which we declare here:</p>
<div class="codehilite"><pre class="insert-before" translate="no">  final String name;
</pre><div class="source-file"><em>lox/LoxClass.java</em><br/>
in class <em>LoxClass</em></div>
<pre class="insert" translate="no">  <span class="k">final</span> <span class="t">LoxClass</span> <span class="i">superclass</span>;
</pre><pre class="insert-after" translate="no">  private final Map&lt;String, LoxFunction&gt; methods;
</pre></div>
<div class="source-file-narrow"><em>lox/LoxClass.java</em>, in class <em>LoxClass</em></div>
<p>With that, we can define classes that are subclasses of other classes. Now, what
does having a superclass actually <em>do?</em></p>
<h2><a href="#inheriting-methods" id="inheriting-methods"><small>13 . 2</small>Inheriting Methods</a></h2>
<p>Inheriting from another class means that everything that’s <span name="liskov">true</span> of the superclass should be true, more or less, of the
subclass. In statically typed languages, that carries a lot of implications. The
sub<em>class</em> must also be a sub<em>type</em>, and the memory layout is controlled so that
you can pass an instance of a subclass to a function expecting a superclass and
it can still access the inherited fields correctly.</p>
<aside name="liskov">
<p>A fancier name for this hand-wavey guideline is the <a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle"><em>Liskov substitution
principle</em></a>. Barbara Liskov introduced it in a keynote during the
formative period of object-oriented programming.</p>
</aside>
<p>Lox is a dynamically typed language, so our requirements are much simpler.
Basically, it means that if you can call some method on an instance of the
superclass, you should be able to call that method when given an instance of the
subclass. In other words, methods are inherited from the superclass.</p>
<p>This lines up with one of the goals of inheritance<span class="em">—</span>to give users a way to
reuse code across classes. Implementing this in our interpreter is
astonishingly easy.</p>
<div class="codehilite"><pre class="insert-before" translate="no">      return methods.get(name);
    }

</pre><div class="source-file"><em>lox/LoxClass.java</em><br/>
in <em>findMethod</em>()</div>
<pre class="insert" translate="no">    <span class="k">if</span> (<span class="i">superclass</span> != <span class="k">null</span>) {
      <span class="k">return</span> <span class="i">superclass</span>.<span class="i">findMethod</span>(<span class="i">name</span>);
    }

</pre><pre class="insert-after" translate="no">    return null;
</pre></div>
<div class="source-file-narrow"><em>lox/LoxClass.java</em>, in <em>findMethod</em>()</div>
<p>That’s literally all there is to it. When we are looking up a method on an
instance, if we don’t find it on the instance’s class, we recurse up through the
superclass chain and look there. Give it a try:</p>
<div class="codehilite"><pre translate="no"><span class="k">class</span> <span class="t">Doughnut</span> {
  <span class="i">cook</span>() {
    <span class="k">print</span> <span class="s">"Fry until golden brown."</span>;
  }
}

<span class="k">class</span> <span class="t">BostonCream</span> &lt; <span class="t">Doughnut</span> {}

<span class="t">BostonCream</span>().<span class="i">cook</span>();
</pre></div>
<p>There we go, half of our inheritance features are complete with only three lines
of Java code.</p>
<h2><a href="#calling-superclass-methods" id="calling-superclass-methods"><small>13 . 3</small>Calling Superclass Methods</a></h2>
<p>In <code translate="no">findMethod()</code> we look for a method on the current class <em>before</em> walking up
the superclass chain. If a method with the same name exists in both the subclass
and the superclass, the subclass one takes precedence or <strong>overrides</strong> the
superclass method. Sort of like how variables in inner scopes shadow outer ones.</p>
<p>That’s great if the subclass wants to <em>replace</em> some superclass behavior
completely. But, in practice, subclasses often want to <em>refine</em> the superclass’s
behavior. They want to do a little work specific to the subclass, but also
execute the original superclass behavior too.</p>
<p>However, since the subclass has overridden the method, there’s no way to refer
to the original one. If the subclass method tries to call it by name, it will
just recursively hit its own override. We need a way to say “Call this method,
but look for it directly on my superclass and ignore my override”. Java uses
<code translate="no">super</code> for this, and we’ll use that same syntax in Lox. Here is an example:</p>
<div class="codehilite"><pre translate="no"><span class="k">class</span> <span class="t">Doughnut</span> {
  <span class="i">cook</span>() {
    <span class="k">print</span> <span class="s">"Fry until golden brown."</span>;
  }
}

<span class="k">class</span> <span class="t">BostonCream</span> &lt; <span class="t">Doughnut</span> {
  <span class="i">cook</span>() {
    <span class="k">super</span>.<span class="i">cook</span>();
    <span class="k">print</span> <span class="s">"Pipe full of custard and coat with chocolate."</span>;
  }
}

<span class="t">BostonCream</span>().<span class="i">cook</span>();
</pre></div>
<p>If you run this, it should print:</p>
<div class="codehilite"><pre translate="no">Fry until golden brown.
Pipe full of custard and coat with chocolate.
</pre></div>
<p>We have a new expression form. The <code translate="no">super</code> keyword, followed by a dot and an
identifier, looks for a method with that name. Unlike calls on <code translate="no">this</code>, the search
starts at the superclass.</p>
<h3><a href="#syntax" id="syntax"><small>13 . 3 . 1</small>Syntax</a></h3>
<p>With <code translate="no">this</code>, the keyword works sort of like a magic variable, and the expression
is that one lone token. But with <code translate="no">super</code>, the subsequent <code translate="no">.</code> and property name
are inseparable parts of the <code translate="no">super</code> expression. You can’t have a bare <code translate="no">super</code>
token all by itself.</p>
<div class="codehilite"><pre translate="no"><span class="k">print</span> <span class="k">super</span>; <span class="c">// Syntax error.</span>
</pre></div>
<p>So the new clause we add to the <code translate="no">primary</code> rule in our grammar includes the
property access as well.</p>
<div class="codehilite"><pre translate="no"><span class="i">primary</span>        → <span class="s">"true"</span> | <span class="s">"false"</span> | <span class="s">"nil"</span> | <span class="s">"this"</span>
               | <span class="t">NUMBER</span> | <span class="t">STRING</span> | <span class="t">IDENTIFIER</span> | <span class="s">"("</span> <span class="i">expression</span> <span class="s">")"</span>
               | <span class="s">"super"</span> <span class="s">"."</span> <span class="t">IDENTIFIER</span> ;
</pre></div>
<p>Typically, a <code translate="no">super</code> expression is used for a method call, but, as with regular
methods, the argument list is <em>not</em> part of the expression. Instead, a super
<em>call</em> is a super <em>access</em> followed by a function call. Like other method calls,
you can get a handle to a superclass method and invoke it separately.</p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="i">method</span> = <span class="k">super</span>.<span class="i">cook</span>;
<span class="i">method</span>();
</pre></div>
<p>So the <code translate="no">super</code> expression itself contains only the token for the <code translate="no">super</code> keyword
and the name of the method being looked up. The corresponding <span name="super-ast">syntax tree node</span> is thus:</p>
<div class="codehilite"><pre class="insert-before" translate="no">      "Set      : Expr object, Token name, Expr value",
</pre><div class="source-file"><em>tool/GenerateAst.java</em><br/>
in <em>main</em>()</div>
<pre class="insert" translate="no">      <span class="s">"Super    : Token keyword, Token method"</span>,
</pre><pre class="insert-after" translate="no">      "This     : Token keyword",
</pre></div>
<div class="source-file-narrow"><em>tool/GenerateAst.java</em>, in <em>main</em>()</div>
<aside name="super-ast">
<p>The generated code for the new node is in <a href="appendix-ii.html#super-expression">Appendix II</a>.</p>
</aside>
<p>Following the grammar, the new parsing code goes inside our existing <code translate="no">primary()</code>
method.</p>
<div class="codehilite"><pre class="insert-before" translate="no">      return new Expr.Literal(previous().literal);
    }
</pre><div class="source-file"><em>lox/Parser.java</em><br/>
in <em>primary</em>()</div>
<pre class="insert" translate="no">

    <span class="k">if</span> (<span class="i">match</span>(<span class="i">SUPER</span>)) {
      <span class="t">Token</span> <span class="i">keyword</span> = <span class="i">previous</span>();
      <span class="i">consume</span>(<span class="i">DOT</span>, <span class="s">"Expect '.' after 'super'."</span>);
      <span class="t">Token</span> <span class="i">method</span> = <span class="i">consume</span>(<span class="i">IDENTIFIER</span>,
          <span class="s">"Expect superclass method name."</span>);
      <span class="k">return</span> <span class="k">new</span> <span class="t">Expr</span>.<span class="t">Super</span>(<span class="i">keyword</span>, <span class="i">method</span>);
    }
</pre><pre class="insert-after" translate="no">

    if (match(THIS)) return new Expr.This(previous());
</pre></div>
<div class="source-file-narrow"><em>lox/Parser.java</em>, in <em>primary</em>()</div>
<p>A leading <code translate="no">super</code> keyword tells us we’ve hit a <code translate="no">super</code> expression. After that we
consume the expected <code translate="no">.</code> and method name.</p>
<h3><a href="#semantics" id="semantics"><small>13 . 3 . 2</small>Semantics</a></h3>
<p>Earlier, I said a <code translate="no">super</code> expression starts the method lookup from “the
superclass”, but <em>which</em> superclass? The naïve answer is the superclass of
<code translate="no">this</code>, the object the surrounding method was called on. That coincidentally
produces the right behavior in a lot of cases, but that’s not actually correct.
Gaze upon:</p>
<div class="codehilite"><pre translate="no"><span class="k">class</span> <span class="t">A</span> {
  <span class="i">method</span>() {
    <span class="k">print</span> <span class="s">"A method"</span>;
  }
}

<span class="k">class</span> <span class="t">B</span> &lt; <span class="t">A</span> {
  <span class="i">method</span>() {
    <span class="k">print</span> <span class="s">"B method"</span>;
  }

  <span class="i">test</span>() {
    <span class="k">super</span>.<span class="i">method</span>();
  }
}

<span class="k">class</span> <span class="t">C</span> &lt; <span class="t">B</span> {}

<span class="t">C</span>().<span class="i">test</span>();
</pre></div>
<p>Translate this program to Java, C#, or C++ and it will print “A method”, which
is what we want Lox to do too. When this program runs, inside the body of
<code translate="no">test()</code>, <code translate="no">this</code> is an instance of C. The superclass of C is B, but that is
<em>not</em> where the lookup should start. If it did, we would hit B’s <code translate="no">method()</code>.</p>
<p>Instead, lookup should start on the superclass of <em>the class containing the
<code translate="no">super</code> expression</em>. In this case, since <code translate="no">test()</code> is defined inside B, the
<code translate="no">super</code> expression inside it should start the lookup on <em>B</em>’s superclass<span class="em">—</span>A.</p>
<p><span name="flow"></span></p><img alt="The call chain flowing through the classes." src="image/inheritance/classes.png">
<aside name="flow">
<p>The execution flow looks something like this:</p>
<ol>
<li>
<p>We call <code translate="no">test()</code> on an instance of C.</p>
</li>
<li>
<p>That enters the <code translate="no">test()</code> method inherited from B. That calls
<code translate="no">super.method()</code>.</p>
</li>
<li>
<p>The superclass of B is A, so that chains to <code translate="no">method()</code> on A, and the program
prints “A method”.</p>
</li>
</ol>
</aside>
<p>Thus, in order to evaluate a <code translate="no">super</code> expression, we need access to the
superclass of the class definition surrounding the call. Alack and alas, at the
point in the interpreter where we are executing a <code translate="no">super</code> expression, we don’t
have that easily available.</p>
<p>We <em>could</em> add a field to LoxFunction to store a reference to the LoxClass that
owns that method. The interpreter would keep a reference to the
currently executing LoxFunction so that we could look it up later when we hit a
<code translate="no">super</code> expression. From there, we’d get the LoxClass of the method, then its
superclass.</p>
<p>That’s a lot of plumbing. In the <a href="classes.html">last chapter</a>, we had a similar problem when
we needed to add support for <code translate="no">this</code>. In that case, we used our existing
environment and closure mechanism to store a reference to the current object.
Could we do something similar for storing the superclass<span name="rhetorical">?</span> Well, I probably wouldn’t be talking about it if the
answer was no, so<span class="ellipse"> . . . </span>yes.</p>
<aside name="rhetorical">
<p>Does anyone even like rhetorical questions?</p>
</aside>
<p>One important difference is that we bound <code translate="no">this</code> when the method was <em>accessed</em>.
The same method can be called on different instances and each needs its own
<code translate="no">this</code>. With <code translate="no">super</code> expressions, the superclass is a fixed property of the
<em>class declaration itself</em>. Every time you evaluate some <code translate="no">super</code> expression, the
superclass is always the same.</p>
<p>That means we can create the environment for the superclass once, when the class
definition is executed. Immediately before we define the methods, we make a new
environment to bind the class’s superclass to the name <code translate="no">super</code>.</p><img alt="The superclass environment." src="image/inheritance/superclass.png">
<p>When we create the LoxFunction runtime representation for each method, that is
the environment they will capture in their closure. Later, when a method is
invoked and <code translate="no">this</code> is bound, the superclass environment becomes the parent for
the method’s environment, like so:</p><img alt="The environment chain including the superclass environment." src="image/inheritance/environments.png"/>
<p>That’s a lot of machinery, but we’ll get through it a step at a time. Before we
can get to creating the environment at runtime, we need to handle the
corresponding scope chain in the resolver.</p>
<div class="codehilite"><pre class="insert-before" translate="no">      resolve(stmt.superclass);
    }
</pre><div class="source-file"><em>lox/Resolver.java</em><br/>
in <em>visitClassStmt</em>()</div>
<pre class="insert" translate="no">

    <span class="k">if</span> (<span class="i">stmt</span>.<span class="i">superclass</span> != <span class="k">null</span>) {
      <span class="i">beginScope</span>();
      <span class="i">scopes</span>.<span class="i">peek</span>().<span class="i">put</span>(<span class="s">"super"</span>, <span class="k">true</span>);
    }
</pre><pre class="insert-after" translate="no">

    beginScope();
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in <em>visitClassStmt</em>()</div>
<p>If the class declaration has a superclass, then we create a new scope
surrounding all of its methods. In that scope, we define the name “super”. Once
we’re done resolving the class’s methods, we discard that scope.</p>
<div class="codehilite"><pre class="insert-before" translate="no">    endScope();

</pre><div class="source-file"><em>lox/Resolver.java</em><br/>
in <em>visitClassStmt</em>()</div>
<pre class="insert" translate="no">    <span class="k">if</span> (<span class="i">stmt</span>.<span class="i">superclass</span> != <span class="k">null</span>) <span class="i">endScope</span>();

</pre><pre class="insert-after" translate="no">    currentClass = enclosingClass;
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in <em>visitClassStmt</em>()</div>
<p>It’s a minor optimization, but we only create the superclass environment if the
class actually <em>has</em> a superclass. There’s no point creating it when there isn’t
a superclass since there’d be no superclass to store in it anyway.</p>
<p>With “super” defined in a scope chain, we are able to resolve the <code translate="no">super</code>
expression itself.</p>
<div class="codehilite"><div class="source-file"><em>lox/Resolver.java</em><br/>
add after <em>visitSetExpr</em>()</div>
<pre translate="no">  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Void</span> <span class="i">visitSuperExpr</span>(<span class="t">Expr</span>.<span class="t">Super</span> <span class="i">expr</span>) {
    <span class="i">resolveLocal</span>(<span class="i">expr</span>, <span class="i">expr</span>.<span class="i">keyword</span>);
    <span class="k">return</span> <span class="k">null</span>;
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, add after <em>visitSetExpr</em>()</div>
<p>We resolve the <code translate="no">super</code> token exactly as if it were a variable. The resolution
stores the number of hops along the environment chain that the interpreter needs
to walk to find the environment where the superclass is stored.</p>
<p>This code is mirrored in the interpreter. When we evaluate a subclass
definition, we create a new environment.</p>
<div class="codehilite"><pre class="insert-before" translate="no">        throw new RuntimeError(stmt.superclass.name,
            "Superclass must be a class.");
      }
    }

    environment.define(stmt.name.lexeme, null);
</pre><div class="source-file"><em>lox/Interpreter.java</em><br/>
in <em>visitClassStmt</em>()</div>
<pre class="insert" translate="no">

    <span class="k">if</span> (<span class="i">stmt</span>.<span class="i">superclass</span> != <span class="k">null</span>) {
      <span class="i">environment</span> = <span class="k">new</span> <span class="t">Environment</span>(<span class="i">environment</span>);
      <span class="i">environment</span>.<span class="i">define</span>(<span class="s">"super"</span>, <span class="i">superclass</span>);
    }
</pre><pre class="insert-after" translate="no">

    Map&lt;String, LoxFunction&gt; methods = new HashMap&lt;&gt;();
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in <em>visitClassStmt</em>()</div>
<p>Inside that environment, we store a reference to the superclass<span class="em">—</span>the actual
LoxClass object for the superclass which we have now that we are in the runtime.
Then we create the LoxFunctions for each method. Those will capture the current
environment<span class="em">—</span>the one where we just bound “super”<span class="em">—</span>as their closure, holding
on to the superclass like we need. Once that’s done, we pop the environment.</p>
<div class="codehilite"><pre class="insert-before" translate="no">    LoxClass klass = new LoxClass(stmt.name.lexeme,
        (LoxClass)superclass, methods);
</pre><div class="source-file"><em>lox/Interpreter.java</em><br/>
in <em>visitClassStmt</em>()</div>
<pre class="insert" translate="no">

    <span class="k">if</span> (<span class="i">superclass</span> != <span class="k">null</span>) {
      <span class="i">environment</span> = <span class="i">environment</span>.<span class="i">enclosing</span>;
    }
</pre><pre class="insert-after" translate="no">

    environment.assign(stmt.name, klass);
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in <em>visitClassStmt</em>()</div>
<p>We’re ready to interpret <code translate="no">super</code> expressions themselves. There are a few moving
parts, so we’ll build this method up in pieces.</p>
<div class="codehilite"><div class="source-file"><em>lox/Interpreter.java</em><br/>
add after <em>visitSetExpr</em>()</div>
<pre translate="no">  <span class="a">@Override</span>
  <span class="k">public</span> <span class="t">Object</span> <span class="i">visitSuperExpr</span>(<span class="t">Expr</span>.<span class="t">Super</span> <span class="i">expr</span>) {
    <span class="t">int</span> <span class="i">distance</span> = <span class="i">locals</span>.<span class="i">get</span>(<span class="i">expr</span>);
    <span class="t">LoxClass</span> <span class="i">superclass</span> = (<span class="t">LoxClass</span>)<span class="i">environment</span>.<span class="i">getAt</span>(
        <span class="i">distance</span>, <span class="s">"super"</span>);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, add after <em>visitSetExpr</em>()</div>
<p>First, the work we’ve been leading up to. We look up the surrounding class’s
superclass by looking up “super” in the proper environment.</p>
<p>When we access a method, we also need to bind <code translate="no">this</code> to the object the method is
accessed from. In an expression like <code translate="no">doughnut.cook</code>, the object is whatever we
get from evaluating <code translate="no">doughnut</code>. In a <code translate="no">super</code> expression like <code translate="no">super.cook</code>, the
current object is implicitly the <em>same</em> current object that we’re using. In
other words, <code translate="no">this</code>. Even though we are looking up the <em>method</em> on the
superclass, the <em>instance</em> is still <code translate="no">this</code>.</p>
<p>Unfortunately, inside the <code translate="no">super</code> expression, we don’t have a convenient node
for the resolver to hang the number of hops to <code translate="no">this</code> on. Fortunately, we do
control the layout of the environment chains. The environment where “this” is
bound is always right inside the environment where we store “super”.</p>
<div class="codehilite"><pre class="insert-before" translate="no">    LoxClass superclass = (LoxClass)environment.getAt(
        distance, "super");
</pre><div class="source-file"><em>lox/Interpreter.java</em><br/>
in <em>visitSuperExpr</em>()</div>
<pre class="insert" translate="no">

    <span class="t">LoxInstance</span> <span class="i">object</span> = (<span class="t">LoxInstance</span>)<span class="i">environment</span>.<span class="i">getAt</span>(
        <span class="i">distance</span> - <span class="n">1</span>, <span class="s">"this"</span>);
</pre><pre class="insert-after" translate="no">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in <em>visitSuperExpr</em>()</div>
<p>Offsetting the distance by one looks up “this” in that inner environment. I
admit this isn’t the most <span name="elegant">elegant</span> code, but it
works.</p>
<aside name="elegant">
<p>Writing a book that includes every single line of code for a program means I
can’t hide the hacks by leaving them as an “exercise for the reader”.</p>
</aside>
<p>Now we’re ready to look up and bind the method, starting at the superclass.</p>
<div class="codehilite"><pre class="insert-before" translate="no">    LoxInstance object = (LoxInstance)environment.getAt(
        distance - 1, "this");
</pre><div class="source-file"><em>lox/Interpreter.java</em><br/>
in <em>visitSuperExpr</em>()</div>
<pre class="insert" translate="no">

    <span class="t">LoxFunction</span> <span class="i">method</span> = <span class="i">superclass</span>.<span class="i">findMethod</span>(<span class="i">expr</span>.<span class="i">method</span>.<span class="i">lexeme</span>);
    <span class="k">return</span> <span class="i">method</span>.<span class="i">bind</span>(<span class="i">object</span>);
</pre><pre class="insert-after" translate="no">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in <em>visitSuperExpr</em>()</div>
<p>This is almost exactly like the code for looking up a method of a get
expression, except that we call <code translate="no">findMethod()</code> on the superclass instead of on
the class of the current object.</p>
<p>That’s basically it. Except, of course, that we might <em>fail</em> to find the method.
So we check for that too.</p>
<div class="codehilite"><pre class="insert-before" translate="no">

    LoxFunction method = superclass.findMethod(expr.method.lexeme);
</pre><div class="source-file"><em>lox/Interpreter.java</em><br/>
in <em>visitSuperExpr</em>()</div>
<pre class="insert" translate="no">

    <span class="k">if</span> (<span class="i">method</span> == <span class="k">null</span>) {
      <span class="k">throw</span> <span class="k">new</span> <span class="t">RuntimeError</span>(<span class="i">expr</span>.<span class="i">method</span>,
          <span class="s">"Undefined property '"</span> + <span class="i">expr</span>.<span class="i">method</span>.<span class="i">lexeme</span> + <span class="s">"'."</span>);
    }

</pre><pre class="insert-after" translate="no">    return method.bind(object);
  }
</pre></div>
<div class="source-file-narrow"><em>lox/Interpreter.java</em>, in <em>visitSuperExpr</em>()</div>
<p>There you have it! Take that BostonCream example earlier and give it a try.
Assuming you and I did everything right, it should fry it first, then stuff it
with cream.</p>
<h3><a href="#invalid-uses-of-super" id="invalid-uses-of-super"><small>13 . 3 . 3</small>Invalid uses of super</a></h3>
<p>As with previous language features, our implementation does the right thing when
the user writes correct code, but we haven’t bulletproofed the intepreter
against bad code. In particular, consider:</p>
<div class="codehilite"><pre translate="no"><span class="k">class</span> <span class="t">Eclair</span> {
  <span class="i">cook</span>() {
    <span class="k">super</span>.<span class="i">cook</span>();
    <span class="k">print</span> <span class="s">"Pipe full of crème pâtissière."</span>;
  }
}
</pre></div>
<p>This class has a <code translate="no">super</code> expression, but no superclass. At runtime, the code for
evaluating <code translate="no">super</code> expressions assumes that “super” was successfully resolved
and will be found in the environment. That’s going to fail here because there is
no surrounding environment for the superclass since there is no superclass. The
JVM will throw an exception and bring our interpreter to its knees.</p>
<p>Heck, there are even simpler broken uses of super:</p>
<div class="codehilite"><pre translate="no"><span class="k">super</span>.<span class="i">notEvenInAClass</span>();
</pre></div>
<p>We could handle errors like these at runtime by checking to see if the lookup
of “super” succeeded. But we can tell statically<span class="em">—</span>just by looking at the
source code<span class="em">—</span>that Eclair has no superclass and thus no <code translate="no">super</code> expression will
work inside it. Likewise, in the second example, we know that the <code translate="no">super</code>
expression is not even inside a method body.</p>
<p>Even though Lox is dynamically typed, that doesn’t mean we want to defer
<em>everything</em> to runtime. If the user made a mistake, we’d like to help them find
it sooner rather than later. So we’ll report these errors statically, in the
resolver.</p>
<p>First, we add a new case to the enum we use to keep track of what kind of class
is surrounding the current code being visited.</p>
<div class="codehilite"><pre class="insert-before" translate="no">    NONE,
</pre><pre class="insert-before" translate="no">    <span class="i">CLASS</span><span class="insert-comma">,</span>
</pre><div class="source-file"><em>lox/Resolver.java</em><br/>
in enum <em>ClassType</em><br/>
add <em>“,”</em> to previous line</div>
<pre class="insert" translate="no">    <span class="i">SUBCLASS</span>
</pre><pre class="insert-after" translate="no">  }
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in enum <em>ClassType</em>, add <em>“,”</em> to previous line</div>
<p>We’ll use that to distinguish when we’re inside a class that has a superclass
versus one that doesn’t. When we resolve a class declaration, we set that if the
class is a subclass.</p>
<div class="codehilite"><pre class="insert-before" translate="no">    if (stmt.superclass != null) {
</pre><div class="source-file"><em>lox/Resolver.java</em><br/>
in <em>visitClassStmt</em>()</div>
<pre class="insert" translate="no">      <span class="i">currentClass</span> = <span class="t">ClassType</span>.<span class="i">SUBCLASS</span>;
</pre><pre class="insert-after" translate="no">      resolve(stmt.superclass);
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in <em>visitClassStmt</em>()</div>
<p>Then, when we resolve a <code translate="no">super</code> expression, we check to see that we are
currently inside a scope where that’s allowed.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  public Void visitSuperExpr(Expr.Super expr) {
</pre><div class="source-file"><em>lox/Resolver.java</em><br/>
in <em>visitSuperExpr</em>()</div>
<pre class="insert" translate="no">    <span class="k">if</span> (<span class="i">currentClass</span> == <span class="t">ClassType</span>.<span class="i">NONE</span>) {
      <span class="t">Lox</span>.<span class="i">error</span>(<span class="i">expr</span>.<span class="i">keyword</span>,
          <span class="s">"Can't use 'super' outside of a class."</span>);
    } <span class="k">else</span> <span class="k">if</span> (<span class="i">currentClass</span> != <span class="t">ClassType</span>.<span class="i">SUBCLASS</span>) {
      <span class="t">Lox</span>.<span class="i">error</span>(<span class="i">expr</span>.<span class="i">keyword</span>,
          <span class="s">"Can't use 'super' in a class with no superclass."</span>);
    }

</pre><pre class="insert-after" translate="no">    resolveLocal(expr, expr.keyword);
</pre></div>
<div class="source-file-narrow"><em>lox/Resolver.java</em>, in <em>visitSuperExpr</em>()</div>
<p>If not<span class="em">—</span>oopsie!<span class="em">—</span>the user made a mistake.</p>
<h2><a href="#conclusion" id="conclusion"><small>13 . 4</small>Conclusion</a></h2>
<p>We made it! That final bit of error handling is the last chunk of code needed to
complete our Java implementation of Lox. This is a real <span name="superhero">accomplishment</span> and one you should be proud of. In the
past dozen chapters and a thousand or so lines of code, we have learned and
implemented<span class="ellipse"> . . . </span></p>
<ul>
<li><a href="scanning.html">tokens and lexing</a>,</li>
<li><a href="representing-code.html">abstract syntax trees</a>,</li>
<li><a href="parsing-expressions.html">recursive descent parsing</a>,</li>
<li>prefix and infix expressions,</li>
<li>runtime representation of objects,</li>
<li><a href="evaluating-expressions.html">interpreting code using the Visitor pattern</a>,</li>
<li><a href="statements-and-state.html">lexical scope</a>,</li>
<li>environment chains for storing variables,</li>
<li><a href="control-flow.html">control flow</a>,</li>
<li><a href="functions.html">functions with parameters</a>,</li>
<li>closures,</li>
<li><a href="resolving-and-binding.html">static variable resolution and error detection</a>,</li>
<li><a href="classes.html">classes</a>,</li>
<li>constructors,</li>
<li>fields,</li>
<li>methods, and finally,</li>
<li>inheritance.</li>
</ul>
<aside name="superhero"><img alt="You, being your bad self." src="image/inheritance/superhero.png"/>
</aside>
<p>We did all of that from scratch, with no external dependencies or magic tools.
Just you and I, our respective text editors, a couple of collection classes in
the Java standard library, and the JVM runtime.</p>
<p>This marks the end of Part II, but not the end of the book. Take a break. Maybe
write a few fun Lox programs and run them in your interpreter. (You may want to
add a few more native methods for things like reading user input.) When you’re
refreshed and ready, we’ll embark on our <a href="a-bytecode-virtual-machine.html">next adventure</a>.</p>
<div class="challenges">
<h2><a href="#challenges" id="challenges">Challenges</a></h2>
<ol>
<li>
<p>Lox supports only <em>single inheritance</em><span class="em">—</span>a class may have a single
superclass and that’s the only way to reuse methods across classes. Other
languages have explored a variety of ways to more freely reuse and share
capabilities across classes: mixins, traits, multiple inheritance, virtual
inheritance, extension methods, etc.</p>
<p>If you were to add some feature along these lines to Lox, which would you
pick and why? If you’re feeling courageous (and you should be at this
point), go ahead and add it.</p>
</li>
<li>
<p>In Lox, as in most other object-oriented languages, when looking up a
method, we start at the bottom of the class hierarchy and work our way up<span class="em">—</span>a subclass’s method is preferred over a superclass’s. In order to get to the
superclass method from within an overriding method, you use <code translate="no">super</code>.</p>
<p>The language <a href="https://beta.cs.au.dk/">BETA</a> takes the <a href="http://journal.stuffwithstuff.com/2012/12/19/the-impoliteness-of-overriding-methods/">opposite approach</a>. When you call a
method, it starts at the <em>top</em> of the class hierarchy and works <em>down</em>. A
superclass method wins over a subclass method. In order to get to the
subclass method, the superclass method can call <code translate="no">inner</code>, which is sort of
like the inverse of <code translate="no">super</code>. It chains to the next method down the
hierarchy.</p>
<p>The superclass method controls when and where the subclass is allowed to
refine its behavior. If the superclass method doesn’t call <code translate="no">inner</code> at all,
then the subclass has no way of overriding or modifying the superclass’s
behavior.</p>
<p>Take out Lox’s current overriding and <code translate="no">super</code> behavior and replace it with
BETA’s semantics. In short:</p>
<ul>
<li>
<p>When calling a method on a class, prefer the method <em>highest</em> on the
class’s inheritance chain.</p>
</li>
<li>
<p>Inside the body of a method, a call to <code translate="no">inner</code> looks for a method with
the same name in the nearest subclass along the inheritance chain
between the class containing the <code translate="no">inner</code> and the class of <code translate="no">this</code>. If
there is no matching method, the <code translate="no">inner</code> call does nothing.</p>
</li>
</ul>
<p>For example:</p>
<div class="codehilite"><pre translate="no"><span class="k">class</span> <span class="t">Doughnut</span> {
  <span class="i">cook</span>() {
    <span class="k">print</span> <span class="s">"Fry until golden brown."</span>;
    <span class="i">inner</span>();
    <span class="k">print</span> <span class="s">"Place in a nice box."</span>;
  }
}

<span class="k">class</span> <span class="t">BostonCream</span> &lt; <span class="t">Doughnut</span> {
  <span class="i">cook</span>() {
    <span class="k">print</span> <span class="s">"Pipe full of custard and coat with chocolate."</span>;
  }
}

<span class="t">BostonCream</span>().<span class="i">cook</span>();
</pre></div>
<p>This should print:</p>
<div class="codehilite"><pre translate="no">Fry until golden brown.
Pipe full of custard and coat with chocolate.
Place in a nice box.
</pre></div>
</li>
<li>
<p>In the chapter where I introduced Lox, <a href="the-lox-language.html#challenges">I challenged you</a> to
come up with a couple of features you think the language is missing. Now
that you know how to build an interpreter, implement one of those features.</p>
</li>
</ol>
</div>
<footer>
<a class="next" href="a-bytecode-virtual-machine.html">
  Next Part: “A Bytecode Virtual Machine” →
</a>
Handcrafted by Robert Nystrom — <a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">© 2015 – 2021</a>
</footer>
</img></img></article>
</div>
</body>
</html>
