<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>Jumping Back and Forth · Crafting Interpreters</title>
<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta content="width=device-width, initial-scale=1" name="viewport">
<link href="https://youhogeon-meritz.github.io/style.css" rel="stylesheet" type="text/css">
<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600" rel="stylesheet" type="text/css">
<link href="https://youhogeon-meritz.github.io/image/favicon.png" rel="icon" type="image/png">


<!-- Google analytics -->

</head>
<body id="top">
<!-- <div class="scrim"></div> -->
<nav class="wide">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<div class="contents">
<h3><a href="https://youhogeon-meritz.github.io/jumping-back-and-forth.html#top"><font papago-translate="splitted"><font papago-translate="translated">앞뒤로 뛰기</font></font><small>23</small></a></h3>
<ul>
<li><a href="https://youhogeon-meritz.github.io/jumping-back-and-forth.html#if-statements"><small>23.1</small><font papago-translate="splitted"><font papago-translate="translated"> 만약 진술</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/jumping-back-and-forth.html#logical-operators"><small>23.2</small><font papago-translate="splitted"><font papago-translate="translated"> 논리 연산자</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/jumping-back-and-forth.html#while-statements"><small>23.3</small><font papago-translate="splitted"><font papago-translate="translated"> 진술하는 동안</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/jumping-back-and-forth.html#for-statements"><small>23.4</small><font papago-translate="splitted"><font papago-translate="translated"> 진술을 위해</font></font></a></li>
<li class="divider"></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/jumping-back-and-forth.html#challenges"><font papago-translate="translated">과제들</font></a></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/jumping-back-and-forth.html#design-note"><small><font papago-translate="translated">메모</font></small><font papago-translate="splitted"><font papago-translate="translated">고토 해로움을 고려하기</font></font></a></li>
</ul>
<div class="prev-next">
<a class="left" href="https://youhogeon-meritz.github.io/local-variables.html" title="지역 변수" papago-attr-id="1"><font papago-translate="translated">← 이전</font></a>
<a href="https://youhogeon-meritz.github.io/a-bytecode-virtual-machine.html" title="바이트코드 가상 머신" papago-attr-id="2"><font papago-translate="translated">↑ 위로</font></a>
<a class="right" href="https://youhogeon-meritz.github.io/calls-and-functions.html" title="호출 및 기능" papago-attr-id="3"><font papago-translate="translated">다음 →</font></a>
</div> </div>
</nav>
<nav class="narrow">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<a class="prev" href="https://youhogeon-meritz.github.io/local-variables.html" title="Local Variables">←</a>
<a class="next" href="https://youhogeon-meritz.github.io/calls-and-functions.html" title="Calls and Functions">→</a>
</nav>
<div class="page">
<div class="nav-wrapper">
<nav class="floating pinned">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<div class="expandable">
<h3><a href="https://youhogeon-meritz.github.io/jumping-back-and-forth.html#top"><font papago-translate="splitted"><font papago-translate="translated">앞뒤로 뛰기</font></font><small>23</small></a></h3>
<ul>
<li><a href="https://youhogeon-meritz.github.io/jumping-back-and-forth.html#if-statements"><small>23.1</small><font papago-translate="splitted"><font papago-translate="translated"> 만약 진술</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/jumping-back-and-forth.html#logical-operators"><small>23.2</small><font papago-translate="splitted"><font papago-translate="translated"> 논리 연산자</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/jumping-back-and-forth.html#while-statements"><small>23.3</small><font papago-translate="splitted"><font papago-translate="translated"> 진술하는 동안</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/jumping-back-and-forth.html#for-statements"><small>23.4</small><font papago-translate="splitted"><font papago-translate="translated"> 진술을 위해</font></font></a></li>
<li class="divider"></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/jumping-back-and-forth.html#challenges">Challenges</a></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/jumping-back-and-forth.html#design-note"><small>note</small><font papago-translate="splitted"><font papago-translate="translated">고토 해로움을 고려하기</font></font></a></li>
</ul>
<div class="prev-next">
<a class="left" href="https://youhogeon-meritz.github.io/local-variables.html" title="Local Variables">←&nbsp;Previous</a>
<a href="https://youhogeon-meritz.github.io/a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">↑&nbsp;Up</a>
<a class="right" href="https://youhogeon-meritz.github.io/calls-and-functions.html" title="Calls and Functions">Next&nbsp;→</a>
</div> </div>
<a id="expand-nav">≡</a>
</nav>
</div>
<article class="chapter">
<div class="number">23</div>
<h1><font papago-translate="translated">앞뒤로 뛰기</font></h1>
<blockquote>
<p><font papago-translate="translated">우리의 마음이 상상하는 질서는 무언가를 이루기 위해 만들어진 그물이나 사다리와 같습니다.</font><font papago-translate="translated"> 하지만 나중에 사다리를 버려야 합니다. 왜냐하면 사다리가 유용하더라도 의미가 없다는 것을 알게 되기 때문입니다.</font></p>
<p><cite>Umberto Eco, <em>The Name of the Rose</em></cite></p>
</blockquote>
<p><font papago-translate="splitted"><font papago-translate="translated">여기까지 오는 데 시간이 좀 걸렸지만, 드디어 가상 머신에 제어 흐름을 추가할 준비가 되었습니다.</font><font papago-translate="translated"> Jlox를 위해 구축한 트리 워크 인터프리터에서는 Java 측면에서 Lox의 제어 흐름을 구현했습니다.</font><font papago-translate="translated"> Lox 실행하기 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 문장, 우리는 Java를 사용했습니다 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 선택한 분기를 실행하기 위한 문.</font><font papago-translate="translated"> 효과는 있지만 완전히 만족스럽지는 않습니다.</font><font papago-translate="translated"> J<em>VM 자체</em> 또는 네이티브 CPU는 어떤 마법으로 구현됩니까 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 진술?</font><font papago-translate="translated"> 이제 자체 바이트코드 VM을 해킹할 수 있게 되었으니 이에 대한 답변을 드릴 수 있습니다.</font></font></p>
<p><font papago-translate="translated">"제어 흐름"에 대해 이야기할 때, 우리가 말하는 것은 무엇인가요?</font><font papago-translate="translated"> "흐름"이라는 것은 프로그램의 텍스트를 통해 실행이 이동하는 방식을 의미합니다.</font><font papago-translate="translated"> 마치 컴퓨터 안에 작은 로봇이 우리의 코드를 돌아다니며 여기저기서 작은 조각들을 실행하는 것처럼 말입니다.</font><font papago-translate="translated"> 플로우는 로봇이 가는 길이며, 로봇<em>을 제어</em>하여 실행할 코드 조각을 구동합니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">Jlox에서 로봇의 관심 위치,<em> 즉 현재</em> 코드 비트는 다양한 Java 변수에 저장된 AST 노드와<span class="em"></span><span class="em"></span> 실행 중인 Java 코드에 따라 암시적으로 결정되었습니다.</font><font papago-translate="translated"> clox에서는 훨씬 더 명확합니다.</font><font papago-translate="translated"> VM의 </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated"> 필드는 현재 바이트코드 명령어의 주소를 저장합니다.</font><font papago-translate="translated"> 그 필드의 값은 프로그램에서 정확히 "우리가 있는 곳"입니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">실행은 다음을 증가시켜 정상적으로 진행됩니다 </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated">. 하지만 우리는 그 변수를 원하는 대로 변형할 수 있습니다.</font><font papago-translate="translated"> 제어 흐름을 구현하기 위해 필요한 것은 다음을 변경하는 것뿐입니다 </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated"> 더 흥미로운 방식으로.</font><font papago-translate="translated"> 가장 간단한 제어 흐름 구조는 다음과 같습니다 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 없음이 있는 진술 </font></font><code translate="no">else</code><font papago-translate="splitted"><font papago-translate="translated"> 조항:</font></font></p>
<div class="codehilite"><pre translate="no"><span class="k">if</span> (<span class="i">condition</span>) <span class="k">print</span>(<span class="s">"condition was truthy"</span>);
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">VM은 조건 표현식의 바이트코드를 평가합니다.</font><font papago-translate="translated"> 결과가 사실이라면 계속 진행되어 다음을 실행합니다 </font></font><code translate="no">print</code><font papago-translate="splitted"><font papago-translate="translated"> 본문에서의 진술.</font><font papago-translate="translated"> 흥미로운 경우는 조건이 거짓일 때입니다.</font><font papago-translate="translated"> 그런 일이 발생하면 실행이 분기를 건너뛰고 다음 문장으로 진행됩니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">코드 조각을 건너뛰려면 다음을 설정하기만 하면 됩니다 </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated"> 해당 코드 뒤에 있는 바이트코드 명령어의 주소로 필드를 입력합니다.</font><font papago-translate="translated"> 어떤 코드를<em> 무조건</em> 건너뛰려면 스택 위의 값을 살펴보는 명령어가 필요합니다.</font><font papago-translate="translated"> 만약 그것이 거짓이라면, 주어진 오프셋을 더합니다 </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated"> 다양한 지침을 뛰어넘기 위해.</font><font papago-translate="translated"> 그렇지 않으면 아무 일도 하지 않고 평소처럼 다음 명령어로 실행을 진행합니다.</font></font></p>
<p><font papago-translate="translated">바이트코드로 컴파일하면 코드의 명시적 중첩 블록 구조가 증발하여 일련의 명령어만 남게 됩니다.</font><font papago-translate="translated"> Lox는<a href="https://en.wikipedia.org/wiki/Structured_programming"> 구조화된 프로그래밍</a> 언어이지만, clox 바이트코드는 그렇지 않습니다.</font><font papago-translate="translated"> 바이트코드 명령어 세트는 어떻게 보느냐에 따라 블록의 중앙에 들어갈 수도 있고, 한 범위에서<span class="em"></span><span class="em"></span> 다른 범위로 들어갈 수도 있습니다.</font></p>
<p><font papago-translate="translated">VM은 결과가 스택을 알 수 없고 일관성이 없는 상태로 남겨두더라도 기꺼이 실행할 것입니다.</font><font papago-translate="translated"> 따라서 바이트코드가 비구조화되어 있더라도 컴파일러가 Lox 자체와 동일한 구조를 유지하고 중첩하는 깨끗한 코드만 생성하도록 주의하겠습니다.</font></p>
<p><font papago-translate="translated">이것이 바로 실제 CPU가 작동하는 방식입니다.</font><font papago-translate="translated"> 구조화된 제어 흐름을 요구하는 상위 언어를 사용하여 프로그래밍할 수 있지만, 컴파일러는 이를 원시 점프로 낮춥니다.</font><font papago-translate="translated"> 맨 아래에서는 고토가 유일한 진정한 제어 흐름임이 밝혀졌습니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">어쨌든, 저는 모든 것을 철학적으로 이해하려고 한 것은 아닙니다.</font><font papago-translate="translated"> 중요한 점은 조건부 점프 명령어 하나만 있으면 Lox의 명령어를 구현하기에 충분하다는 것입니다 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 진술서가 없는 한 </font></font><code translate="no">else</code><font papago-translate="splitted"><font papago-translate="translated"> 조항.</font><font papago-translate="translated"> 그럼 이제 시작해 보겠습니다.</font></font></p>
<h2><a href="https://youhogeon-meritz.github.io/jumping-back-and-forth.html#if-statements" id="if-statements"><small><font papago-translate="translated">23 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">만약 진술</font></font></a></h2>
<p><font papago-translate="splitted"><font papago-translate="translated">이 많은 장에서 드릴을 알고 계실 겁니다.</font><font papago-translate="translated"> 새로운 기능은 프론트엔드에서 시작하여 파이프라인을 통해 작동합니다 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 문장은 문장이기 때문에 파서에 연결합니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  if (match(TOKEN_PRINT)) {
    printStatement();
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>성명</em>서 ()에서</font></font></div>
<pre class="insert" translate="no">  } <span class="k">else</span> <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_IF</span>)) {
    <span class="i">ifStatement</span>();
</pre><pre class="insert-after" translate="no">  } else if (match(TOKEN_LEFT_BRACE)) {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>statement</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">우리가 볼 때 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 키워드, 우리는 이 함수에 컴파일을 부여합니다:</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>식</em> 뒤에 추가St<em>atement</em>()</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">ifStatement</span>() {
  <span class="i">consume</span>(<span class="a">TOKEN_LEFT_PAREN</span>, <span class="s">"Expect '(' after 'if'."</span>);
  <span class="i">expression</span>();
  <span class="i">consume</span>(<span class="a">TOKEN_RIGHT_PAREN</span>, <span class="s">"Expect ')' after condition."</span>);<span name="paren"> </span>

  <span class="t">int</span> <span class="i">thenJump</span> = <span class="i">emitJump</span>(<span class="a">OP_JUMP_IF_FALSE</span>);
  <span class="i">statement</span>();

  <span class="i">patchJump</span>(<span class="i">thenJump</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>expressionStatement</em>()</div>
<aside name="paren" style="top: 2187px;">
<p><font papago-translate="splitted"><font papago-translate="translated">다음과 같은 사실을 눈치챈 적이 있습니까 </font></font><code translate="no">(</code><font papago-translate="splitted"><font papago-translate="translated"> 그 후에 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 키워드는 실제로 유용한 기능을 하지 않나요?</font><font papago-translate="translated"> 그 언어는 모호하지 않고도 쉽게 구문 분석할 수 있을 것입니다:</font></font></p>
<div class="codehilite"><pre translate="no"><span class="k">if</span> <span class="i">condition</span>) <span class="k">print</span>(<span class="s">"looks weird"</span>);
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">마무리 </font></font><code translate="no">)</code><font papago-translate="splitted"><font papago-translate="translated"> 상태 표현을 신체에서 분리하기 때문에 유용합니다.</font><font papago-translate="translated"> 일부 언어는 다음을 사용합니다 </font></font><code translate="no">then</code><font papago-translate="splitted"><font papago-translate="translated"> 대신 키워드.</font><font papago-translate="translated"> 하지만 오프닝 </font></font><code translate="no">(</code><font papago-translate="splitted"><font papago-translate="translated"> 아무것도 하지 않습니다.</font><font papago-translate="translated"> 일치하지 않는 괄호가 우리 인간에게 나쁘게 보이기 때문에 그냥 거기에 있습니다.</font></font></p>
</aside>
<p><font papago-translate="translated">먼저 괄호로 묶은 조건식을 컴파일합니다.</font><font papago-translate="translated"> 런타임 시에는 조건 값이 스택 위에 남게 됩니다.</font><font papago-translate="translated"> 이를 사용하여 분기를 실행할지 건너뛸지 결정할 것입니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">그러면 우리는 새로운 것을 방출합니다 </font></font><code translate="no">OP_JUMP_IF_FALSE</code><font papago-translate="splitted"><font papago-translate="translated"> 설명.</font><font papago-translate="translated"> 상쇄할 피연산자가 있습니다 </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated">- 건너뛸 코드의 바이트 수입니다<span class="em">.</span></font><font papago-translate="translated"> 조건이 거짓인 경우 다음을 조정합니다 </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated"> 그 금액만큼.</font><font papago-translate="translated"> 이런 식으로:</font></font></p>
<aside name="legend" style="top: 2542px;">
<p><font papago-translate="translated">여기서 모서리가 찢어진 상자는 제어 흐름 구조의 일부 하위 절을 컴파일하여 생성된 바이트코드의 덩어리를 나타냅니다.</font><font papago-translate="translated"> 그래서 "조건 표현식" 상자는 우리가 그 표현식을 컴파일할 때 나오는 모든 지시사항입니다.</font></p>
</aside>
<p><span name="legend"></span></p><img alt="Flowchart of the compiled bytecode of an if statement." src="https://youhogeon-meritz.github.io/image/jumping-back-and-forth/if-without-else.png">
<p><font papago-translate="splitted"><font papago-translate="translated">하지만 문제가 있습니다.</font><font papago-translate="translated"> 우리가 글을 쓸 때 </font></font><code translate="no">OP_JUMP_IF_FALSE</code><font papago-translate="splitted"><font papago-translate="translated"> 명령어의 피연산자, 얼마나 멀리 점프해야 하는지 어떻게 알 수 있습니까?</font><font papago-translate="translated"> 당시 분기를 아직 컴파일하지 않았기 때문에 바이트코드가 얼마나 포함되어 있는지 알 수 없습니다.</font></font></p>
<p><font papago-translate="translated">이를 해결하기 위해<strong> 백패칭</strong>이라는 고전적인 트릭을 사용합니다.</font><font papago-translate="translated"> 우리는 먼저 자리 표시자 오프셋 피연산자를 사용하여 점프 명령을 실행합니다.</font><font papago-translate="translated"> 우리는 그 반쯤 완성된 지시가 어디에 있는지 추적합니다.</font><font papago-translate="translated"> 다음으로, 당시 본문을 컴파일합니다.</font><font papago-translate="translated"> 일단 그것이 끝나면, 우리는 얼마나 멀리 뛰어오를지 알 수 있습니다.</font><font papago-translate="translated"> 그래서 우리는 다시 돌아가서 그 자리 표시자 오프셋을 실제 오프셋으로 대체합니다. 이제 계산할 수 있게 되었습니다.</font><font papago-translate="translated"> 마치 컴파일된 코드의 기존 패브릭에 패치를 바느질하는 것과 같습니다.</font></p><img alt="A patch containing a number being sewn onto a sheet of bytecode." src="https://youhogeon-meritz.github.io/image/jumping-back-and-forth/patch.png">
<p><font papago-translate="translated">이 트릭을 두 가지 도우미 함수로 인코딩합니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>emitBytes</em>() 후에 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">int</span> <span class="i">emitJump</span>(<span class="t">uint8_t</span> <span class="i">instruction</span>) {
  <span class="i">emitByte</span>(<span class="i">instruction</span>);
  <span class="i">emitByte</span>(<span class="n">0xff</span>);
  <span class="i">emitByte</span>(<span class="n">0xff</span>);
  <span class="k">return</span> <span class="i">currentChunk</span>()-&gt;<span class="i">count</span> - <span class="n">2</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>emitBytes</em>()</div>
<p><font papago-translate="translated">첫 번째는 바이트코드 명령어를 방출하고 점프 오프셋을 위한 자리 표시자 피연산자를 작성합니다.</font><font papago-translate="translated"> 나중에 이 도우미를 사용하는 두 가지 다른 지침이 있기 때문에 opcode를 인수로 전달합니다.</font><font papago-translate="translated"> 점프 오프셋 피연산자에는 두 바이트를 사용합니다.</font><font papago-translate="translated"> <span name="offset">16</span>비트<span name="offset"> 오프셋</span>을 사용하면 최대 65,535바이트의 코드를 뛰어넘을 수 있으며, 이는 우리의 필요에 충분할 것입니다.</font></p>
<aside name="offset" style="top: 3615px;">
<p><font papago-translate="translated">일부 명령어 세트에는 더 먼 거리를 점프해야 할 때 더 큰 피연산자가 필요한 별도의 "긴" 점프 명령어가 있습니다.</font></p>
</aside>
<p><font papago-translate="translated">함수는 청크에서 방출된 명령어의 오프셋을 반환합니다.</font><font papago-translate="translated"> 그때 분기를 컴파일한 후, 우리는 그 오프셋을 가져와서 다음과 같이 전달합니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>emitConstant</em>() 다음에 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">patchJump</span>(<span class="t">int</span> <span class="i">offset</span>) {
  <span class="c">// -2 to adjust for the bytecode for the jump offset itself.</span>
  <span class="t">int</span> <span class="i">jump</span> = <span class="i">currentChunk</span>()-&gt;<span class="i">count</span> - <span class="i">offset</span> - <span class="n">2</span>;

  <span class="k">if</span> (<span class="i">jump</span> &gt; <span class="a">UINT16_MAX</span>) {
    <span class="i">error</span>(<span class="s">"Too much code to jump over."</span>);
  }

  <span class="i">currentChunk</span>()-&gt;<span class="i">code</span>[<span class="i">offset</span>] = (<span class="i">jump</span> &gt;&gt; <span class="n">8</span>) &amp; <span class="n">0xff</span>;
  <span class="i">currentChunk</span>()-&gt;<span class="i">code</span>[<span class="i">offset</span> + <span class="n">1</span>] = <span class="i">jump</span> &amp; <span class="n">0xff</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>emitConstant</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">이것은 바이트코드로 돌아가서 주어진 위치의 피연산자를 계산된 점프 오프셋으로 대체합니다.</font><font papago-translate="translated"> 우리는 전화합니다 </font></font><code translate="no">patchJump()</code><font papago-translate="splitted"><font papago-translate="translated"> 다음 명령을 실행하기 직전에 점프를 착륙시키기 위해 현재 바이트코드 수를 사용하여 점프 거리를 결정합니다.</font><font papago-translate="translated"> 의 경우 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 문장은 우리가 그 분기를 컴파일한 직후와 다음 문장을 컴파일하기 직전을 의미합니다.</font></font></p>
<p><font papago-translate="translated">컴파일 시 필요한 것은 그것뿐입니다.</font><font papago-translate="translated"> 새로운 지침을 정의해 보겠습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  OP_PRINT,
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">청크.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> enum O<em>pCode</em>에서</font></font></div>
<pre class="insert" translate="no">  <span class="a">OP_JUMP_IF_FALSE</span>,
</pre><pre class="insert-after" translate="no">  OP_RETURN,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>
<p><font papago-translate="translated">VM에서는 이렇게 작동합니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">        break;
      }
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font></div>
<pre class="insert" translate="no">      <span class="k">case</span> <span class="a">OP_JUMP_IF_FALSE</span>: {
        <span class="t">uint16_t</span> <span class="i">offset</span> = <span class="a">READ_SHORT</span>();
        <span class="k">if</span> (<span class="i">isFalsey</span>(<span class="i">peek</span>(<span class="n">0</span>))) <span class="i">vm</span>.<span class="i">ip</span> += <span class="i">offset</span>;
        <span class="k">break</span>;
      }
</pre><pre class="insert-after" translate="no">      case OP_RETURN: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p><font papago-translate="translated">이것은 16비트 피연산자를 사용하는 첫 번째 명령어입니다.</font><font papago-translate="translated"> 청크에서 이를 읽기 위해 새로운 매크로를 사용합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#define READ_CONSTANT() (vm.chunk-&gt;constants.values[READ_BYTE()])
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font></div>
<pre class="insert" translate="no"><span class="a">#define READ_SHORT() \</span>
<span class="a">    (vm.ip += 2, (uint16_t)((vm.ip[-2] &lt;&lt; 8) | vm.ip[-1]))</span>
</pre><pre class="insert-after" translate="no">#define READ_STRING() AS_STRING(READ_CONSTANT())
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p><font papago-translate="translated">그것은 청크에서 다음 두 바이트를 제거하고, 그들로부터 16비트의 부호 없는 정수를 만듭니다.</font><font papago-translate="translated"> 평소처럼, 우리는 그것을 다 마치면 매크로를 정리합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#undef READ_BYTE
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font></div>
<pre class="insert" translate="no"><span class="a">#undef READ_SHORT</span>
</pre><pre class="insert-after" translate="no">#undef READ_CONSTANT
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">오프셋을 읽은 후 스택 상단의 조건 값을 확인합니다.</font><font papago-translate="translated"> 만약 그것이 거짓<span name="if">이라면</span>, 우리는 이 점프 오프셋을 다음에 적용합니다 </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated">. 그렇지 않으면, 우리는 떠납니다 </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated"> 단독으로 실행하면 점프 명령 후 다음 명령으로 자동으로 진행됩니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">상태가 거짓인 경우에는 다른 작업을 할 필요가 없습니다.</font><font papago-translate="translated"> 우리는 상쇄했습니다 </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated">, 그래서 외부 명령어 디스패치 루프가 다시 회전하면, 그 새로운 명령어에서 실행이 시작되며, 그때 브랜치의 모든 코드를 지나게 됩니다.</font></font></p>
<aside name="if" style="top: 4843px;">
<p><font papago-translate="splitted"><font papago-translate="translated">C를 사용하지 않겠다고 말했습니다 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> Lox의 제어 흐름을 구현하기 위한 문이지만, 여기서는 명령 포인터를 상쇄할지 여부를 결정하기 위해 하나를 사용합니다.</font><font papago-translate="translated"> 하지만<em> 우리</em>는<em> 실제로 C를 제어 흐름</em>에 사용하지 않습니다.</font><font papago-translate="translated"> 원한다면 순수하게 산술적으로 동일한 작업을 수행할 수 있습니다.</font><font papago-translate="translated"> 함수가 있다고 가정해 보겠습니다 </font></font><code translate="no">falsey()</code><font papago-translate="splitted"><font papago-translate="translated"> 그것은 Lox 값을 취하고 거짓이면 1을 반환하거나 그렇지 않으면 0을 반환합니다.</font><font papago-translate="translated"> 그런 다음 점프 명령을 다음과 같이 구현할 수 있습니다:</font></font></p>
<div class="codehilite"><pre translate="no"><span class="k">case</span> <span class="a">OP_JUMP_IF_FALSE</span>: {
  <span class="t">uint16_t</span> <span class="i">offset</span> = <span class="a">READ_SHORT</span>();
  <span class="i">vm</span>.<span class="i">ip</span> += <span class="i">falsey</span>() * <span class="i">offset</span>;
  <span class="k">break</span>;
}
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">그 </font></font><code translate="no">falsey()</code><font papago-translate="splitted"><font papago-translate="translated"> 함수는 다양한 값 유형을 처리하기 위해 일부 제어 흐름을 사용할 수 있지만, 이는 해당 함수의 구현 세부 사항이며 VM이 자체 제어 흐름을 수행하는 방식에는 영향을 미치지 않습니다.</font></font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">점프 명령어는 스택에서 조건 값을 터뜨리지 않는다는 점에 유의하세요.</font><font papago-translate="translated"> 그래서 여기서 완전히 끝난 것은 아닙니다. 왜냐하면 이것이 스택에 추가적인 가치를 남기게 되기 때문입니다.</font><font papago-translate="translated"> 곧 정리해 드리겠습니다.</font><font papago-translate="translated"> 현재로서는 그것을 무시하고, 우리는 일을 하고 있습니다 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 지금 Lox에 있는 문장입니다. VM에서 런타임에 이를 지원하기 위해 필요한 작은 명령어는 단 하나뿐입니다.</font></font></p>
<h3><a href="https://youhogeon-meritz.github.io/jumping-back-and-forth.html#else-clauses" id="else-clauses"><small><font papago-translate="translated">23 . 1 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">기타 조항</font></font></a></h3>
<p><font papago-translate="splitted"><font papago-translate="translated">안 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 지원이 없는 진술 </font></font><code translate="no">else</code><font papago-translate="splitted"><font papago-translate="translated"> 절은 고메즈가 없는 모티시아 아담스와 같습니다.</font><font papago-translate="translated"> 그래서, 우리가 그때 분기를 컴파일한 후에 </font></font><code translate="no">else</code><font papago-translate="splitted"><font papago-translate="translated"> 키워드.</font><font papago-translate="translated"> 하나를 찾으면 다른 분기를 컴파일합니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  patchJump(thenJump);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>if</em>St<em>atement</em>()에서</font></font></div>
<pre class="insert" translate="no">
  <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_ELSE</span>)) <span class="i">statement</span>();
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>ifStatement</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">조건이 거짓일 때, 우리는 그 지점을 뛰어넘을 것입니다.</font><font papago-translate="translated"> 다른 지점이 있다면 </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated"> 코드가 시작될 때 바로 착륙할 것입니다.</font><font papago-translate="translated"> 하지만 그것만으로는 충분하지 않습니다.</font><font papago-translate="translated"> 다음은 다음과 같은 흐름입니다:</font></font></p><img alt="Flowchart of the compiled bytecode with the then branch incorrectly falling through to the else branch." src="https://youhogeon-meritz.github.io/image/jumping-back-and-forth/bad-else.png">
<p><font papago-translate="translated">조건이 사실이라면, 우리는 원하는 대로 지점을 실행합니다.</font><font papago-translate="translated"> 하지만 그 후에는 실행이 다른 지점으로 바로 이어집니다.</font><font papago-translate="translated"> 어머나!</font><font papago-translate="translated"> 조건이 참일 때, 우리가 그 지점을 실행한 후에 다른 지점을 뛰어넘어야 합니다.</font><font papago-translate="translated"> 그렇게 하면, 어느 경우든, 우리는 다음과 같은 단일 분기만 실행합니다:</font></p><img alt="Flowchart of the compiled bytecode for an if with an else clause." src="https://youhogeon-meritz.github.io/image/jumping-back-and-forth/if-else.png">
<p><font papago-translate="translated">이를 구현하려면 당시 지점 끝에서 한 번 더 점프해야 합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  statement();

</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>if</em>St<em>atement</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="t">int</span> <span class="i">elseJump</span> = <span class="i">emitJump</span>(<span class="a">OP_JUMP</span>);

</pre><pre class="insert-after" translate="no">  patchJump(thenJump);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>ifStatement</em>()</div>
<p><font papago-translate="translated">다른 본체가 끝난 후에 그 오프셋을 패치합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  if (match(TOKEN_ELSE)) statement();
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>if</em>St<em>atement</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="i">patchJump</span>(<span class="i">elseJump</span>);
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>ifStatement</em>()</div>
<p><font papago-translate="translated">그 후 분기를 실행한 후, 이것은 다른 분기 뒤의 다음 문장으로 넘어갑니다.</font><font papago-translate="translated"> 다른 점프와 달리, 이 점프는 무조건적입니다.</font><font papago-translate="translated"> 우리는 항상 그것을 받아들이기 때문에, 그것을 표현하는 또 다른 지침이 필요합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  OP_PRINT,
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">청크.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> enum O<em>pCode</em>에서</font></font></div>
<pre class="insert" translate="no">  <span class="a">OP_JUMP</span>,
</pre><pre class="insert-after" translate="no">  OP_JUMP_IF_FALSE,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>
<p><font papago-translate="translated">우리는 이렇게 해석합니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">        break;
      }
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font></div>
<pre class="insert" translate="no">      <span class="k">case</span> <span class="a">OP_JUMP</span>: {
        <span class="t">uint16_t</span> <span class="i">offset</span> = <span class="a">READ_SHORT</span>();
        <span class="i">vm</span>.<span class="i">ip</span> += <span class="i">offset</span>;
        <span class="k">break</span>;
      }
</pre><pre class="insert-after" translate="no">      case OP_JUMP_IF_FALSE: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p><font papago-translate="translated">여기서 그리 놀라운 것은 없습니다. 유일한 차이점은 조건을 확인하지 않고<span class="em"></span> 항상 오프셋을 적용한다는 점입니다.</font></p>
<p><font papago-translate="translated">그때와 지금 다른 지점들이 운영되고 있어서 거의 가까워졌습니다.</font><font papago-translate="translated"> 마지막 비트는 스택에 남긴 조건 값을 정리하는 것입니다.</font><font papago-translate="translated"> 각 문은 스택 효과가 0이어야 한다는 점을 기억하세요. 문 실행이 완료된 후에는 스택의 높이가<span class="em"></span> 이전만큼 높아야 합니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">우리는 그것을 가질 수 있습니다 </font></font><code translate="no">OP_JUMP_IF_FALSE</code><font papago-translate="splitted"><font papago-translate="translated"> 명령어는 조건 자체를 팝업하지만, 곧 조건이 팝업되는 것을 원하지 않는 논리 연산자에 대해서도 동일한 명령어를 사용할 것입니다.</font><font papago-translate="translated"> 대신 컴파일러가 몇 가지 명시적인 내용을 공개하도록 하겠습니다 </font></font><code translate="no">OP_POP</code><font papago-translate="splitted"><font papago-translate="translated"> 컴파일할 때의 지침 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 진술.</font><font papago-translate="translated"> 생성된 코드를 통한 모든 실행 경로가 조건을 충족하도록 주의해야 합니다.</font></font></p>
<p><font papago-translate="translated">조건이 사실일 때, 우리는 그것을 그 지점 내부의 코드 바로 앞에 놓습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  int thenJump = emitJump(OP_JUMP_IF_FALSE);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>if</em>St<em>atement</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="i">emitByte</span>(<span class="a">OP_POP</span>);
</pre><pre class="insert-after" translate="no">  statement();
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>ifStatement</em>()</div>
<p><font papago-translate="translated">그렇지 않으면 다른 분기의 시작 부분에 터뜨립니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  patchJump(thenJump);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>if</em>St<em>atement</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="i">emitByte</span>(<span class="a">OP_POP</span>);
</pre><pre class="insert-after" translate="no">
  if (match(TOKEN_ELSE)) statement();
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>ifStatement</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">여기 이 작은 지침은 또한 모든 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 사용자가 글을 쓰지 않았더라도 문장에는 암묵적으로 다른 분기가 있습니다 </font></font><code translate="no">else</code><font papago-translate="splitted"><font papago-translate="translated"> 조항.</font><font papago-translate="translated"> 그들이 그것을 중단한 경우, 지점은 조건 값을 버리기만 하면 됩니다.</font></font></p>
<p><font papago-translate="translated">전체 올바른 흐름은 다음과 같습니다:</font></p><img alt="Flowchart of the compiled bytecode including necessary pop instructions." src="https://youhogeon-meritz.github.io/image/jumping-back-and-forth/full-if-else.png">
<p><font papago-translate="translated">추적해 보면 항상 단일 분기를 실행하고 조건이 먼저 팝업되는 것을 확인할 수 있습니다.</font><font papago-translate="translated"> 남은 것은 약간의 분해기 지지대뿐입니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      return simpleInstruction("OP_PRINT", offset);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">debug.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>분해</em> 중 지침()</font></font></div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="a">OP_JUMP</span>:
      <span class="k">return</span> <span class="i">jumpInstruction</span>(<span class="s">"OP_JUMP"</span>, <span class="n">1</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
    <span class="k">case</span> <span class="a">OP_JUMP_IF_FALSE</span>:
      <span class="k">return</span> <span class="i">jumpInstruction</span>(<span class="s">"OP_JUMP_IF_FALSE"</span>, <span class="n">1</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
</pre><pre class="insert-after" translate="no">    case OP_RETURN:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>
<p><font papago-translate="translated">이 두 명령어는 16비트 피연산자가 있는 새로운 형식을 가지고 있으므로, 이를 분해하기 위해 새로운 유틸리티 함수를 추가합니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">debug.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>바이트</em> 명령어 뒤에 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">int</span> <span class="i">jumpInstruction</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">name</span>, <span class="t">int</span> <span class="i">sign</span>,
                           <span class="t">Chunk</span>* <span class="i">chunk</span>, <span class="t">int</span> <span class="i">offset</span>) {
  <span class="t">uint16_t</span> <span class="i">jump</span> = (<span class="t">uint16_t</span>)(<span class="i">chunk</span>-&gt;<span class="i">code</span>[<span class="i">offset</span> + <span class="n">1</span>] &lt;&lt; <span class="n">8</span>);
  <span class="i">jump</span> |= <span class="i">chunk</span>-&gt;<span class="i">code</span>[<span class="i">offset</span> + <span class="n">2</span>];
  <span class="i">printf</span>(<span class="s">"%-16s %4d -&gt; %d</span><span class="e">\n</span><span class="s">"</span>, <span class="i">name</span>, <span class="i">offset</span>,
         <span class="i">offset</span> + <span class="n">3</span> + <span class="i">sign</span> * <span class="i">jump</span>);
  <span class="k">return</span> <span class="i">offset</span> + <span class="n">3</span>;
}
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, add after <em>byteInstruction</em>()</div>
<p><font papago-translate="translated">자, 완벽한 제어 흐름 구조가 하나 있습니다.</font><font papago-translate="translated"> 이 영화가 80년대 영화라면 몽타주 음악이 시작되고 나머지 제어 흐름 구문이 알아서 처리될 것입니다.</font><font papago-translate="translated"> 아,<span name="80s"> 80</span>년대는 이미 끝났으니 우리가 직접 갈아내야 할 것 같습니다.</font></p>
<aside name="80s" style="top: 8595px;">
<p><font papago-translate="translated">그럼에도 불구하고 디페쉬 모드에 대한 나의 영원한 사랑.</font></p>
</aside>
<h2><a href="https://youhogeon-meritz.github.io/jumping-back-and-forth.html#logical-operators" id="logical-operators"><small><font papago-translate="translated">23 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">논리 연산자</font></font></a></h2>
<p><font papago-translate="splitted"><font papago-translate="translated">아마도 이것을 Jlox에서 기억하실 겁니다. 하지만 논리 연산자들은 </font></font><code translate="no">and</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">or</code><font papago-translate="splitted"><font papago-translate="translated"> 또 다른 쌍의 이진 연산자는 다음과 같은 것이 아닙니다 </font></font><code translate="no">+</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">-</code><font papago-translate="splitted"><font papago-translate="translated">. 왼쪽 피연산자의 값에 따라 오른쪽 피연산자를 단락시키고 평가하지 않을 수 있기 때문에 제어 흐름 표현식처럼 작동합니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">그것들은 기본적으로 약간의 변형입니다 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 다음과 같은 진술 </font></font><code translate="no">else</code><font papago-translate="splitted"><font papago-translate="translated"> 조항.</font><font papago-translate="translated"> 그것들을 설명하는 가장 쉬운 방법은 컴파일러 코드와 그것이 결과 바이트코드에서 생성하는 제어 흐름을 보여주는 것입니다.</font><font papago-translate="translated"> 처음부터 </font></font><code translate="no">and</code><font papago-translate="splitted"><font papago-translate="translated">, 우리는 그것을 여기 표현 구문 분석 테이블에 연결합니다:</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  [TOKEN_NUMBER]        = {number,   NULL,   PREC_NONE},
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">  [<span class="a">TOKEN_AND</span>]           = {<span class="a">NULL</span>,     <span class="i">and_</span>,   <span class="a">PREC_AND</span>},
</pre><pre class="insert-after" translate="no">  [TOKEN_CLASS]         = {NULL,     NULL,   PREC_NONE},
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, replace 1 line</div>
<p><font papago-translate="translated">그것은 새로운 파서 함수로 이어집니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>변수 정의</em> 후에 추가하기()</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">and_</span>(<span class="t">bool</span> <span class="i">canAssign</span>) {
  <span class="t">int</span> <span class="i">endJump</span> = <span class="i">emitJump</span>(<span class="a">OP_JUMP_IF_FALSE</span>);

  <span class="i">emitByte</span>(<span class="a">OP_POP</span>);
  <span class="i">parsePrecedence</span>(<span class="a">PREC_AND</span>);

  <span class="i">patchJump</span>(<span class="i">endJump</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>defineVariable</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">이 시점에서 왼쪽 표현식은 이미 컴파일되었습니다.</font><font papago-translate="translated"> 즉, 런타임 시 그 값이 스택 위에 있다는 뜻입니다.</font><font papago-translate="translated"> 그 값이 거짓이라면, 우리는 전체를 알고 있습니다 </font></font><code translate="no">and</code><font papago-translate="splitted"><font papago-translate="translated"> 거짓이어야 하므로 오른쪽 피연산자를 건너뛰고 전체 식의 결과로 왼쪽 값을 남깁니다.</font><font papago-translate="translated"> 그렇지 않으면 왼쪽 값을 버리고 전체의 결과가 되는 오른쪽 피연산자를 평가합니다 </font></font><code translate="no">and</code><font papago-translate="splitted"><font papago-translate="translated"> 표현.</font></font></p>
<p><font papago-translate="translated">저기 있는 네 줄의 코드가 바로 그것을 만들어냅니다.</font><font papago-translate="translated"> 흐름은 다음과 같습니다:</font></p><img alt="Flowchart of the compiled bytecode of an 'and' expression." src="https://youhogeon-meritz.github.io/image/jumping-back-and-forth/and.png">
<p><font papago-translate="splitted"><font papago-translate="translated">이제 이유를 알 수 있습니다 </font></font><code translate="no">OP_JUMP_IF_FALSE</code> <font papago-translate="splitted"><font papago-translate="translated">스택 위에 값<span name="instr">을 남깁니다.</span></font><font papago-translate="translated"> 왼쪽이 </font></font><code translate="no">and</code><font papago-translate="splitted"><font papago-translate="translated"> 거짓입니다. 그 값은 전체 표현의 결과가 되기 위해 계속 유지됩니다.</font></font></p>
<aside name="instr" style="top: 9748.5px;">
<p><font papago-translate="translated">우리의 opcode 범위에는 충분한 공간이 남아 있어서 암묵적으로 터지는 조건부 점프와 그렇지 않은 점프에 대한 별도의 지침을 가질 수 있을 것 같습니다.</font><font papago-translate="translated"> 하지만 책을 위해 최소한의 것만 유지하려고 노력하고 있습니다.</font><font papago-translate="translated"> 바이트코드 VM에서는 더 전문화된 명령어를 추가하고 성능에 어떤 영향을 미치는지 살펴볼 가치가 있습니다.</font></p>
</aside>
<h3><a href="https://youhogeon-meritz.github.io/jumping-back-and-forth.html#logical-or-operator" id="logical-or-operator"><small><font papago-translate="translated">23 . 2 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">논리 연산자</font></font></a></h3>
<p><font papago-translate="splitted"><font papago-translate="translated">그 </font></font><code translate="no">or</code><font papago-translate="splitted"><font papago-translate="translated"> 연산자는 조금 더 복잡합니다.</font><font papago-translate="translated"> 먼저 구문 분석 테이블에 추가합니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  [TOKEN_NIL]           = {literal,  NULL,   PREC_NONE},
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">  [<span class="a">TOKEN_OR</span>]            = {<span class="a">NULL</span>,     <span class="i">or_</span>,    <span class="a">PREC_OR</span>},
</pre><pre class="insert-after" translate="no">  [TOKEN_PRINT]         = {NULL,     NULL,   PREC_NONE},
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, replace 1 line</div>
<p><font papago-translate="splitted"><font papago-translate="translated">파서가 인픽스를 사용할 때 </font></font><code translate="no">or</code><font papago-translate="splitted"><font papago-translate="translated"> 토큰을 이렇게 부릅니다:</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>숫자</em> () 뒤에 추가하기</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">or_</span>(<span class="t">bool</span> <span class="i">canAssign</span>) {
  <span class="t">int</span> <span class="i">elseJump</span> = <span class="i">emitJump</span>(<span class="a">OP_JUMP_IF_FALSE</span>);
  <span class="t">int</span> <span class="i">endJump</span> = <span class="i">emitJump</span>(<span class="a">OP_JUMP</span>);

  <span class="i">patchJump</span>(<span class="i">elseJump</span>);
  <span class="i">emitByte</span>(<span class="a">OP_POP</span>);

  <span class="i">parsePrecedence</span>(<span class="a">PREC_OR</span>);
  <span class="i">patchJump</span>(<span class="i">endJump</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>number</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">안에서 </font></font><code translate="no">or</code><font papago-translate="splitted"><font papago-translate="translated"> 표현식, 만약 왼쪽이<em> 진실</em>이라면, 우리는 오른쪽 피연산자를 건너뛰게 됩니다.</font><font papago-translate="translated"> 따라서 값이 참일 때 점프해야 합니다.</font><font papago-translate="translated"> 별도의 명령어를 추가할 수도 있지만, 컴파일러가 원하는 명령어 시퀀스에 언어의 의미를 자유롭게 매핑할 수 있는 방법을 보여주기 위해 이미 가지고 있는 점프 명령어 측면에서 구현했습니다.</font></font></p>
<p><font papago-translate="translated">왼쪽이 거짓일 때, 다음 문장을 약간 뛰어넘습니다.</font><font papago-translate="translated"> 그 문장은 올바른 피연산자를 위한 코드를 무조건적으로 뛰어넘는 것입니다.</font><font papago-translate="translated"> 이 작은 춤은 가치가 진실할 때 효과적으로 점프를 합니다.</font><font papago-translate="translated"> 흐름은 다음과 같습니다:</font></p><img alt="Flowchart of the compiled bytecode of a logical or expression." src="https://youhogeon-meritz.github.io/image/jumping-back-and-forth/or.png">
<p><font papago-translate="splitted"><font papago-translate="translated">솔직히 말해서, 이것은 최선의 방법이 아닙니다.</font><font papago-translate="translated"> 더 많은 지시 사항과 더 많은 오버헤드가 있습니다.</font><font papago-translate="translated"> 그럴 만한 이유가 없습니다 </font></font><code translate="no">or</code><font papago-translate="splitted"><font papago-translate="translated"> 다음보다 느려야 합니다 </font></font><code translate="no">and</code><font papago-translate="splitted"><font papago-translate="translated">. 하지만 새로운 지침을 추가하지 않고도 두 연산자를 모두 구현할 수 있다는 점은 꽤 재미있습니다.</font><font papago-translate="translated"> 면죄부를 드려 죄송합니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">좋아요, 그것들이 Lox의 세<em> 가지 분기</em> 구조입니다.</font><font papago-translate="translated"> 즉, 이것들은 코드 위에서만<em> 앞으로</em> 나아가는 제어 흐름 기능입니다.</font><font papago-translate="translated"> 다른 언어들은 종종 다음과 같은 다방향 분기문을 가지고 있습니다 </font></font><code translate="no">switch</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고 아마도 조건부 표현은 다음과 같습니다 </font></font><code translate="no">?:</code><font papago-translate="splitted"><font papago-translate="translated">, 하지만 Lox는 그것을 단순하게 유지합니다.</font></font></p>
<h2><a href="https://youhogeon-meritz.github.io/jumping-back-and-forth.html#while-statements" id="while-statements"><small><font papago-translate="translated">23 . 3</font></small><font papago-translate="splitted"><font papago-translate="translated">진술하는 동안</font></font></a></h2>
<p><font papago-translate="splitted"><font papago-translate="translated">이는 코드를 여러 번 실행할 수 있도록<em> 뒤로</em> 점프하는<em> 반복</em>문으로 이어집니다.</font><font papago-translate="translated"> Lox는 두 개의 루프 구조만 가지고 있습니다, </font></font><code translate="no">while</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">for</code><font papago-translate="splitted"><font papago-translate="translated">.a </font></font><code translate="no">while</code><font papago-translate="splitted"><font papago-translate="translated"> 루프는 (much) 더 간단하므로 파티를 시작합니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    ifStatement();
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>성명</em>서 ()에서</font></font></div>
<pre class="insert" translate="no">  } <span class="k">else</span> <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_WHILE</span>)) {
    <span class="i">whileStatement</span>();
</pre><pre class="insert-after" translate="no">  } else if (match(TOKEN_LEFT_BRACE)) {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>statement</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">우리가 도달할 때 </font></font><code translate="no">while</code><font papago-translate="splitted"><font papago-translate="translated"> 토큰을 호출합니다:</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>print</em>St<em>atement</em>() 후에 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">whileStatement</span>() {
  <span class="i">consume</span>(<span class="a">TOKEN_LEFT_PAREN</span>, <span class="s">"Expect '(' after 'while'."</span>);
  <span class="i">expression</span>();
  <span class="i">consume</span>(<span class="a">TOKEN_RIGHT_PAREN</span>, <span class="s">"Expect ')' after condition."</span>);

  <span class="t">int</span> <span class="i">exitJump</span> = <span class="i">emitJump</span>(<span class="a">OP_JUMP_IF_FALSE</span>);
  <span class="i">emitByte</span>(<span class="a">OP_POP</span>);
  <span class="i">statement</span>();

  <span class="i">patchJump</span>(<span class="i">exitJump</span>);
  <span class="i">emitByte</span>(<span class="a">OP_POP</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>printStatement</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">이 거울들 대부분 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 문—필수<span class="em"></span> 괄호로 둘러싸인 조건 표현식을 컴파일합니다.</font><font papago-translate="translated"> 그 다음에는 조건이 거짓일 경우 다음 본문 문장을 건너뛰는 점프 명령이 이어집니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">본문을 컴파일한 후 점프를 패치하고 어느 경로에서든 스택에서 조건 값<span name="pop">을 터뜨</span>릴 수 있도록 주의합니다.</font><font papago-translate="translated"> ~와의 유일한 차이점 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 문장은 루프입니다.</font><font papago-translate="translated"> 다음과 같이 보입니다:</font></font></p>
<aside name="pop" style="top: 11714.5px;">
<p><font papago-translate="translated">논리 연산자에 대해 동일한 점프 명령을 사용하기로 한 결정을 다시 한 번 추측하기 시작했습니다.</font></p>
</aside>
<div class="codehilite"><pre class="insert-before" translate="no">  statement();
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>while</em>St<em>atement</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="i">emitLoop</span>(<span class="i">loopStart</span>);
</pre><pre class="insert-after" translate="no">
  patchJump(exitJump);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>whileStatement</em>()</div>
<p><font papago-translate="translated">몸이 끝난 후, 우리는 이 함수를 호출하여 "루프" 명령을 내립니다.</font><font papago-translate="translated"> 그 지침은 얼마나 더 멀리 뛰어내려야 하는지 알아야 합니다.</font><font papago-translate="translated"> 앞으로 점프할 때는 점프 지시를 내린 후에야 얼마나 멀리 점프할지 알 수 있었기 때문에 두 단계로 나누어 지시를 내려야 했습니다.</font><font papago-translate="translated"> 지금은 그런 문제가 없습니다.</font><font papago-translate="translated"> 우리는 이미 코드에서 우리가 다시 시작하고 싶은 지점을 정리했습니다—조건<span class="em"></span>식 직전입니다.</font></p>
<p><font papago-translate="translated">우리가 해야 할 일은 그 위치를 컴파일하면서 캡처하는 것뿐입니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">static void whileStatement() {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>while</em>St<em>atement</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="t">int</span> <span class="i">loopStart</span> = <span class="i">currentChunk</span>()-&gt;<span class="i">count</span>;
</pre><pre class="insert-after" translate="no">  consume(TOKEN_LEFT_PAREN, "Expect '(' after 'while'.");
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>whileStatement</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">본문을 실행한 후 </font></font><code translate="no">while</code><font papago-translate="splitted"><font papago-translate="translated"> 루프, 우리는 조건 이전으로 완전히 돌아갑니다.</font><font papago-translate="translated"> 그렇게 하면 각 반복마다 조건 표현식을 재평가합니다.</font><font papago-translate="translated"> 청크의 현재 명령어 수를 저장합니다 </font></font><code translate="no">loopStart</code><font papago-translate="splitted"><font papago-translate="translated"> 우리가 컴파일하려는 조건식 직전에 바이트코드에 오프셋을 기록합니다.</font><font papago-translate="translated"> 그런 다음 이 도우미 함수에 이를 전달합니다:</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>emitBytes</em>() 후에 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">emitLoop</span>(<span class="t">int</span> <span class="i">loopStart</span>) {
  <span class="i">emitByte</span>(<span class="a">OP_LOOP</span>);

  <span class="t">int</span> <span class="i">offset</span> = <span class="i">currentChunk</span>()-&gt;<span class="i">count</span> - <span class="i">loopStart</span> + <span class="n">2</span>;
  <span class="k">if</span> (<span class="i">offset</span> &gt; <span class="a">UINT16_MAX</span>) <span class="i">error</span>(<span class="s">"Loop body too large."</span>);

  <span class="i">emitByte</span>((<span class="i">offset</span> &gt;&gt; <span class="n">8</span>) &amp; <span class="n">0xff</span>);
  <span class="i">emitByte</span>(<span class="i">offset</span> &amp; <span class="n">0xff</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>emitBytes</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">약간 그런 것 같아요 </font></font><code translate="no">emitJump()</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">patchJump()</code><font papago-translate="splitted"><font papago-translate="translated"> 합쳐진.</font><font papago-translate="translated"> 주어진 오프셋만큼<em> 무조건 뒤로</em> 점프하는 새로운 루프 명령을 방출합니다.</font><font papago-translate="translated"> 점프 지침과 마찬가지로 그 후에는 16비트 피연산자가 있습니다.</font><font papago-translate="translated"> 현재 진행 중인 지침에서 오프셋을 계산합니다 </font></font><code translate="no">loopStart</code><font papago-translate="splitted"><font papago-translate="translated"> 우리가 다시 돌아가고 싶은 지점.</font><font papago-translate="translated"> 그 </font></font><code translate="no">+ 2</code><font papago-translate="splitted"><font papago-translate="translated"> 의 크기를 고려합니다 </font></font><code translate="no">OP_LOOP</code><font papago-translate="splitted"><font papago-translate="translated"> 우리가 뛰어넘어야 할 명령어 자체의 피연산자.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">VM의 관점에서 보면 다음과 같은 의미의 차이는 없습니다 </font></font><code translate="no">OP_LOOP</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">OP_JUMP</code><font papago-translate="splitted"><font papago-translate="translated">. 둘 다 그냥 오프셋을 추가합니다 </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated">. 두 명령어 모두에 대해 단일 명령어를 사용하고 부호 오프셋 피연산자를 부여할 수 있었습니다.</font><font papago-translate="translated"> 하지만 부호가 있는 16비트 정수를 수동으로 2바이트로 묶는 데 필요한 성가신 비트 트위들링을 피하는 것이 조금 더 쉽다고 생각했고, 오피코드 공간도 확보했으니 사용해보는 건 어떨까요?</font></font></p>
<p><font papago-translate="translated">새로운 지침이 여기 있습니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  OP_JUMP_IF_FALSE,
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">청크.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> enum O<em>pCode</em>에서</font></font></div>
<pre class="insert" translate="no">  <span class="a">OP_LOOP</span>,
</pre><pre class="insert-after" translate="no">  OP_RETURN,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>
<p><font papago-translate="translated">그리고 VM에서는 이렇게 구현합니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      }
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font></div>
<pre class="insert" translate="no">      <span class="k">case</span> <span class="a">OP_LOOP</span>: {
        <span class="t">uint16_t</span> <span class="i">offset</span> = <span class="a">READ_SHORT</span>();
        <span class="i">vm</span>.<span class="i">ip</span> -= <span class="i">offset</span>;
        <span class="k">break</span>;
      }
</pre><pre class="insert-after" translate="no">      case OP_RETURN: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">유일한 차이점은 </font></font><code translate="no">OP_JUMP</code><font papago-translate="splitted"><font papago-translate="translated"> 는 덧셈 대신 뺄셈입니다.</font><font papago-translate="translated"> 분해도 비슷합니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      return jumpInstruction("OP_JUMP_IF_FALSE", 1, chunk, offset);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">debug.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>분해</em> 중 지침()</font></font></div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="a">OP_LOOP</span>:
      <span class="k">return</span> <span class="i">jumpInstruction</span>(<span class="s">"OP_LOOP"</span>, -<span class="n">1</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
</pre><pre class="insert-after" translate="no">    case OP_RETURN:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">그게 우리의 </font></font><code translate="no">while</code><font papago-translate="splitted"><font papago-translate="translated"> 진술.</font><font papago-translate="translated"> 조건이 충족되지 않을 때 루프를 탈출하는 조건부 전진 점프와<span class="em"></span> 본체를 실행한 후 무조건 후진 점프 두 가지가 포함되어 있습니다.</font><font papago-translate="translated"> 흐름은 다음과 같습니다:</font></font></p><img alt="Flowchart of the compiled bytecode of a while statement." src="https://youhogeon-meritz.github.io/image/jumping-back-and-forth/while.png">
<h2><a href="https://youhogeon-meritz.github.io/jumping-back-and-forth.html#for-statements" id="for-statements"><small><font papago-translate="translated">23 . 4</font></small><font papago-translate="splitted"><font papago-translate="translated">진술을 위해</font></font></a></h2>
<p><font papago-translate="splitted"><font papago-translate="translated">Lox의 또 다른 반복되는 문장은 다음과 같습니다 </font></font><code translate="no">for</code><font papago-translate="splitted"><font papago-translate="translated"> 루프, C에서 상속됨.</font><font papago-translate="translated"> 그것은 a에 비해 훨씬 더 많은 일이 일어나고 있습니다 </font></font><code translate="no">while</code><font papago-translate="splitted"><font papago-translate="translated"> 루프. 세 가지 조항이 있으며, 모두 선택 사항입니다:</font></font></p>
<p><span name="detail"></span></p>
<ul>
<li>
<p><font papago-translate="translated">초기화는 변수 선언이나 표현식일 수 있습니다.</font><font papago-translate="translated"> 문이 시작될 때 한 번 실행됩니다.</font></p>
</li>
<li>
<p><font papago-translate="splitted"><font papago-translate="translated">조건 조항은 표현입니다.</font><font papago-translate="translated"> 마치 </font></font><code translate="no">while</code><font papago-translate="splitted"><font papago-translate="translated"> 루프가 잘못된 것으로 평가되면 루프를 종료합니다.</font></font></p>
</li>
<li>
<p><font papago-translate="translated">증분 표현식은 각 루프 반복이 끝날 때마다 한 번씩 실행됩니다.</font></p>
</li>
</ul>
<aside name="detail" style="top: 13908px;">
<p><font papago-translate="translated">새로 고침을 원한다면, 2부의 해당 장에서 의미론을<a href="https://youhogeon-meritz.github.io/control-flow.html#for-loops"> 더 자세히</a> 살펴봅니다.</font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">Jlox에서 파서는 다음과 같이 설명했습니다 </font></font><code translate="no">for</code><font papago-translate="splitted"><font papago-translate="translated"> 합성된 AST로의 루프 </font></font><code translate="no">while</code><font papago-translate="splitted"><font papago-translate="translated"> 몸의 앞부분과 끝부분에 추가적인 것들이 있습니다.</font><font papago-translate="translated"> 우리는 비슷한 일을 할 것이지만, AST 같은 것은 하지 않을 것입니다.</font><font papago-translate="translated"> 대신, 우리 바이트코드 컴파일러는 이미 가지고 있는 점프 및 루프 명령어를 사용할 것입니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">우리는 구현 과정을 한 번에 한 조각씩 진행할 것입니다 </font></font><code translate="no">for</code><font papago-translate="splitted"><font papago-translate="translated"> 키워드.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    printStatement();
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>성명</em>서 ()에서</font></font></div>
<pre class="insert" translate="no">  } <span class="k">else</span> <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_FOR</span>)) {
    <span class="i">forStatement</span>();
</pre><pre class="insert-after" translate="no">  } else if (match(TOKEN_IF)) {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>statement</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">그것은 도우미 기능이라고 부릅니다.</font><font papago-translate="translated"> 우리가 지원만 한다면 </font></font><code translate="no">for</code><font papago-translate="splitted"><font papago-translate="translated"> 다음과 같은 빈 절이 있는 루프 </font></font><code translate="no">for (;;)</code><font papago-translate="splitted"><font papago-translate="translated">, 그러면 이렇게 구현할 수 있습니다:</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>식</em> 뒤에 추가St<em>atement</em>()</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">forStatement</span>() {
  <span class="i">consume</span>(<span class="a">TOKEN_LEFT_PAREN</span>, <span class="s">"Expect '(' after 'for'."</span>);
  <span class="i">consume</span>(<span class="a">TOKEN_SEMICOLON</span>, <span class="s">"Expect ';'."</span>);

  <span class="t">int</span> <span class="i">loopStart</span> = <span class="i">currentChunk</span>()-&gt;<span class="i">count</span>;
  <span class="i">consume</span>(<span class="a">TOKEN_SEMICOLON</span>, <span class="s">"Expect ';'."</span>);
  <span class="i">consume</span>(<span class="a">TOKEN_RIGHT_PAREN</span>, <span class="s">"Expect ')' after for clauses."</span>);

  <span class="i">statement</span>();
  <span class="i">emitLoop</span>(<span class="i">loopStart</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>expressionStatement</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">상단에는 필수 구두점이 많이 있습니다.</font><font papago-translate="translated"> 그런 다음 본문을 컴파일합니다.</font><font papago-translate="translated"> 우리가 했던 것처럼 </font></font><code translate="no">while</code><font papago-translate="splitted"><font papago-translate="translated"> 루프, 우리는 본체 상단의 바이트코드 오프셋을 기록하고 루프를 방출하여 그 후에 그 지점으로 다시 이동합니다.</font><font papago-translate="translated"> <span name="infinite">우리</span>는 이제<span name="infinite"> 무한</span> 루프의 작동 구현을 가지고 있습니다.</font></font></p>
<aside name="infinite" style="top: 14738px;">
<p><font papago-translate="splitted"><font papago-translate="translated">아, 없이 </font></font><code translate="no">return</code><font papago-translate="splitted"><font papago-translate="translated"> 런타임 오류 없이 종료할 수 있는 방법은 없습니다.</font></font></p>
</aside>
<h3><a href="https://youhogeon-meritz.github.io/jumping-back-and-forth.html#initializer-clause" id="initializer-clause"><small><font papago-translate="translated">23 . 4 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">이니셜라이저 조항</font></font></a></h3>
<p><font papago-translate="translated">이제 첫 번째 절인 이니셜라이저를 추가하겠습니다.</font><font papago-translate="translated"> 본체 앞에서 한 번만 실행되므로 컴파일이 간단합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  consume(TOKEN_LEFT_PAREN, "Expect '(' after 'for'.");
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>forStatement</em>()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">  <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_SEMICOLON</span>)) {
    <span class="c">// No initializer.</span>
  } <span class="k">else</span> <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_VAR</span>)) {
    <span class="i">varDeclaration</span>();
  } <span class="k">else</span> {
    <span class="i">expressionStatement</span>();
  }
</pre><pre class="insert-after" translate="no">
  int loopStart = currentChunk()-&gt;count;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>forStatement</em>(), replace 1 line</div>
<p><font papago-translate="splitted"><font papago-translate="translated">구문은 변수 선언이나 표현식을 허용하기 때문에 조금 복잡합니다.</font><font papago-translate="translated"> 우리는 다음의 존재를 사용합니다 </font></font><code translate="no">var</code><font papago-translate="splitted"><font papago-translate="translated"> 우리가 가지고 있는 것을 알려주는 키워드.</font><font papago-translate="translated"> 표현의 경우, 우리는 다음과 같이 부릅니다 </font></font><code translate="no">expressionStatement()</code><font papago-translate="splitted"><font papago-translate="translated"> 대신 </font></font><code translate="no">expression()</code><font papago-translate="splitted"><font papago-translate="translated">. 그것은 우리가 여기에서도 필요로 하는 세미콜론을 찾고 있으며, 또한 다음을 방출합니다 </font></font><code translate="no">OP_POP</code><font papago-translate="splitted"><font papago-translate="translated"> 값을 버리기 위한 지침.</font><font papago-translate="translated"> 초기화기가 스택에 아무것도 남기지 않기를 바랍니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">만약 </font></font><code translate="no">for</code><font papago-translate="splitted"><font papago-translate="translated"> 문은 변수를 선언하며, 그 변수는 루프 본체에 적용되어야 합니다.</font><font papago-translate="translated"> 우리는 전체 진술을 범위 내에서 마무리함으로써 그것을 보장합니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">static void forStatement() {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>forStatement</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="i">beginScope</span>();
</pre><pre class="insert-after" translate="no">  consume(TOKEN_LEFT_PAREN, "Expect '(' after 'for'.");
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>forStatement</em>()</div>
<p><font papago-translate="translated">그런 다음 마지막에 닫습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  emitLoop(loopStart);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>forStatement</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="i">endScope</span>();
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>forStatement</em>()</div>
<h3><a href="https://youhogeon-meritz.github.io/jumping-back-and-forth.html#condition-clause" id="condition-clause"><small><font papago-translate="translated">23 . 4 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">조건 조항</font></font></a></h3>
<p><font papago-translate="translated">다음으로, 루프를 종료하는 데 사용할 수 있는 조건 표현식입니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  int loopStart = currentChunk()-&gt;count;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>forStatement</em>()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">  <span class="t">int</span> <span class="i">exitJump</span> = -<span class="n">1</span>;
  <span class="k">if</span> (!<span class="i">match</span>(<span class="a">TOKEN_SEMICOLON</span>)) {
    <span class="i">expression</span>();
    <span class="i">consume</span>(<span class="a">TOKEN_SEMICOLON</span>, <span class="s">"Expect ';' after loop condition."</span>);

    <span class="c">// Jump out of the loop if the condition is false.</span>
    <span class="i">exitJump</span> = <span class="i">emitJump</span>(<span class="a">OP_JUMP_IF_FALSE</span>);
    <span class="i">emitByte</span>(<span class="a">OP_POP</span>); <span class="c">// Condition.</span>
  }

</pre><pre class="insert-after" translate="no">  consume(TOKEN_RIGHT_PAREN, "Expect ')' after for clauses.");
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>forStatement</em>(), replace 1 line</div>
<p><font papago-translate="translated">이 조항은 선택 사항이므로 실제로 존재하는지 확인해야 합니다.</font><font papago-translate="translated"> 이 절이 생략되면 다음 토큰은 세미콜론이어야 하므로 이를 확인할 수 있습니다.</font><font papago-translate="translated"> 세미콜론이 없으면 조건식이 있어야 합니다.</font></p>
<p><font papago-translate="translated">이 경우, 우리는 그것을 컴파일합니다.</font><font papago-translate="translated"> 그런 다음, 조건이 거짓일 경우 루프를 벗어나는 조건 점프를 방출합니다.</font><font papago-translate="translated"> 점프가 스택에 값을 남기므로, 우리는 본문을 실행하기 전에 그것을 터뜨립니다.</font><font papago-translate="translated"> 그렇게 하면 조건이 참일 때 값을 버리게 됩니다.</font></p>
<p><font papago-translate="translated">루프 본체가 끝나면 점프를 패치해야 합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  emitLoop(loopStart);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>forStatement</em>()에서</font></font></div>
<pre class="insert" translate="no">
  <span class="k">if</span> (<span class="i">exitJump</span> != -<span class="n">1</span>) {
    <span class="i">patchJump</span>(<span class="i">exitJump</span>);
    <span class="i">emitByte</span>(<span class="a">OP_POP</span>); <span class="c">// Condition.</span>
  }

</pre><pre class="insert-after" translate="no">  endScope();
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>forStatement</em>()</div>
<p><font papago-translate="translated">조건 조항이 있을 때만 이 작업을 수행합니다.</font><font papago-translate="translated"> 그렇지 않으면 패치할 점프도 없고 스택에서 팝업할 조건 값도 없습니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/jumping-back-and-forth.html#increment-clause" id="increment-clause"><small><font papago-translate="translated">23 . 4 . 3</font></small><font papago-translate="splitted"><font papago-translate="translated">증분 조항</font></font></a></h3>
<p><font papago-translate="splitted"><font papago-translate="translated">마지막으로 가장 좋은 점은 증분 조항입니다.</font><font papago-translate="translated"> 꽤 복잡합니다.</font><font papago-translate="translated"> 그것은 본문 앞에 나타나지만<em>, 본문 뒤</em>에 실행됩니다.</font><font papago-translate="translated"> AST로 파싱하고 별도의 패스로 코드를 생성하면 다음과 같이 이동하여 컴파일할 수 있습니다 </font></font><code translate="no">for</code><font papago-translate="splitted"><font papago-translate="translated"> 증분 절 앞에 AST의 본문 필드를 명시합니다.</font></font></p>
<p><font papago-translate="translated">안타깝게도 컴파일러가 코드를 한 번만 통과하기 때문에 나중에 증분 절을 컴파일할 수 없습니다.</font><font papago-translate="translated"> 대신, 우리는 증가분<em>을 뛰어넘</em>고, 본문을 실행한 다음, 다시 증가분으로 이동하고, 실행한 다음<em></em>, 다음 반복으로 이동할 것입니다.</font></p>
<p><font papago-translate="translated">조금 이상하긴 한데, 메모리에서 AST를 수동으로 관리하는 것보다 C가 더 낫죠?</font><font papago-translate="translated"> 코드는 다음과 같습니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  }

</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>forStatement</em>()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">  <span class="k">if</span> (!<span class="i">match</span>(<span class="a">TOKEN_RIGHT_PAREN</span>)) {
    <span class="t">int</span> <span class="i">bodyJump</span> = <span class="i">emitJump</span>(<span class="a">OP_JUMP</span>);
    <span class="t">int</span> <span class="i">incrementStart</span> = <span class="i">currentChunk</span>()-&gt;<span class="i">count</span>;
    <span class="i">expression</span>();
    <span class="i">emitByte</span>(<span class="a">OP_POP</span>);
    <span class="i">consume</span>(<span class="a">TOKEN_RIGHT_PAREN</span>, <span class="s">"Expect ')' after for clauses."</span>);

    <span class="i">emitLoop</span>(<span class="i">loopStart</span>);
    <span class="i">loopStart</span> = <span class="i">incrementStart</span>;
    <span class="i">patchJump</span>(<span class="i">bodyJump</span>);
  }
</pre><pre class="insert-after" translate="no">
  statement();
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>forStatement</em>(), replace 1 line</div>
<p><font papago-translate="translated">다시 말하지만, 선택 사항입니다.</font><font papago-translate="translated"> 이것이 마지막 절이므로 생략하면 다음 토큰은 마무리 괄호가 됩니다.</font><font papago-translate="translated"> 증분이 있을 때 지금 컴파일해야 하지만 아직 실행되지 않아야 합니다.</font><font papago-translate="translated"> 그래서 먼저, 우리는 증가절의 코드를 루프 본체로 넘기는 무조건적인 점프를 방출합니다.</font></p>
<p><font papago-translate="translated">다음으로, 증분 표현식 자체를 컴파일합니다.</font><font papago-translate="translated"> 이것은 보통 과제입니다.</font><font papago-translate="translated"> 그것이 무엇이든 간에, 우리는 그것의 부작용에 대해서만 실행하기 때문에, 그 가치를 버리기 위해 팝을 방출합니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">마지막 부분은 조금 까다롭습니다.</font><font papago-translate="translated"> 먼저, 루프 명령을 보냅니다.</font><font papago-translate="translated"> 이것이 우리를 다시 정상으로 이끄는 주요 루프입니다 </font></font><code translate="no">for</code><font papago-translate="splitted"><font papago-translate="translated"> 루프 — 조건 표현식이<span class="em"></span> 있는 경우 바로 앞에 있습니다.</font><font papago-translate="translated"> 그 루프는 각 루프 반복이 끝날 때마다 증가가 실행되기 때문에 증가 직후에 발생합니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">그러면 우리는 변합니다 </font></font><code translate="no">loopStart</code><font papago-translate="splitted"><font papago-translate="translated"> 증분 표현이 시작되는 오프셋을 가리킵니다.</font><font papago-translate="translated"> 나중에 본문 뒤에 루프 명령을 보낼 때, 증가가 없을 때처럼 루프 상단이<em> 아닌 증가</em> 표현식으로 점프하게 됩니다.</font><font papago-translate="translated"> 이것이 우리가 몸을 따라 달리기 위해 증가분을 엮는 방법입니다.</font></font></p>
<p><font papago-translate="translated">복잡하지만 모든 것이 잘 풀립니다.</font><font papago-translate="translated"> 모든 절이 포함된 완전 루프는 다음과 같은 흐름으로 컴파일됩니다:</font></p><img alt="Flowchart of the compiled bytecode of a for statement." src="https://youhogeon-meritz.github.io/image/jumping-back-and-forth/for.png">
<p><font papago-translate="splitted"><font papago-translate="translated">구현할 때와 마찬가지로 </font></font><code translate="no">for</code><font papago-translate="splitted"><font papago-translate="translated"> jlox의 루프는 런타임을 터치할 필요가 없었습니다.</font><font papago-translate="translated"> 이 모든 것은 VM이 이미 지원하는 원시 제어 흐름 연산으로 컴파일됩니다.</font><font papago-translate="translated"> 이 장에서 우리는 큰<span name="leap"> 도약</span>을 이루었습니다—클록스는 이제 튜링<span class="em"></span>이 완성되었습니다.</font><font papago-translate="translated"> 우리는 또한 세 개의 문장과 두 개의 표현 형식이라는 새로운 구문을 꽤 많이 다루었습니다.</font><font papago-translate="translated"> 그럼에도 불구하고, 새로운 간단한 지침 세 가지만 필요했습니다.</font><font papago-translate="translated"> 이는 VM 아키텍처에 비해 꽤 좋은 노력 대비 보상 비율입니다.</font></font></p>
<aside name="leap" style="top: 18380px;">
<p><font papago-translate="translated">말장난을 참을 수 없었습니다.</font><font papago-translate="translated"> 후회하지 않습니다.</font></p>
</aside>
<div class="challenges">
<h2><a href="https://youhogeon-meritz.github.io/jumping-back-and-forth.html#challenges" id="challenges"><font papago-translate="translated">과제들</font></a></h2>
<ol>
<li>
<p><font papago-translate="splitted"><font papago-translate="translated">에 더하여 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 대부분의 C-패밀리 언어는 다중 방향을 가지고 있습니다 </font></font><code translate="no">switch</code><font papago-translate="splitted"><font papago-translate="translated"> 진술.</font><font papago-translate="translated"> 클록스에 하나를 추가합니다.</font><font papago-translate="translated"> 문법은 다음과 같습니다:</font></font></p>
<div class="codehilite"><pre translate="no"><span class="i">switchStmt</span>     → <span class="s">"switch"</span> <span class="s">"("</span> <span class="i">expression</span> <span class="s">")"</span>
                 <span class="s">"{"</span> <span class="i">switchCase</span>* <span class="i">defaultCase</span>? <span class="s">"}"</span> ;
<span class="i">switchCase</span>     → <span class="s">"case"</span> <span class="i">expression</span> <span class="s">":"</span> <span class="i">statement</span>* ;
<span class="i">defaultCase</span>    → <span class="s">"default"</span> <span class="s">":"</span> <span class="i">statement</span>* ;
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">실행하기 </font></font><code translate="no">switch</code><font papago-translate="splitted"><font papago-translate="translated"> 문, 먼저 괄호로 묶은 스위치 값 표현식을 평가합니다.</font><font papago-translate="translated"> 그런 다음 케이스를 걸어보세요.</font><font papago-translate="translated"> 각 경우마다 그 가치 표현을 평가합니다.</font><font papago-translate="translated"> 케이스 값이 스위치 값과 같으면, 케이스 아래의 문장을 실행한 다음 종료합니다 </font></font><code translate="no">switch</code><font papago-translate="splitted"><font papago-translate="translated"> 진술.</font><font papago-translate="translated"> 그렇지 않으면 다음 경우를 시도해 보세요.</font><font papago-translate="translated"> 사례가 일치하지 않고 다음과 같은 경우 </font></font><code translate="no">default</code><font papago-translate="splitted"><font papago-translate="translated"> 절, 그 진술을 실행합니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">상황을 더 간단하게 만들기 위해, 우리는 실수를 생략하고 있습니다 </font></font><code translate="no">break</code><font papago-translate="splitted"><font papago-translate="translated"> 진술들.</font><font papago-translate="translated"> 각 경우는 진술이 완료된 후 자동으로 스위치 문의 끝으로 이동합니다.</font></font></p>
</li>
<li>
<p><font papago-translate="splitted"><font papago-translate="translated">Jlox에서는 지원을 추가해야 하는 과제가 있었습니다 </font></font><code translate="no">break</code><font papago-translate="splitted"><font papago-translate="translated"> 진술들.</font><font papago-translate="translated"> 이번에는 그렇게 합시다 </font></font><code translate="no">continue</code><font papago-translate="splitted"><font papago-translate="translated">:</font></font></p>
<div class="codehilite"><pre translate="no"><span class="i">continueStmt</span>   → <span class="s">"continue"</span> <span class="s">";"</span> ;
</pre></div>
<p><font papago-translate="splitted">A </font><code translate="no">continue</code><font papago-translate="splitted"><font papago-translate="translated"> 문은 가장 가까운 둘러싸기 루프의 맨 위로 바로 이동하여 루프 본체의 나머지 부분을 건너뛰게 됩니다.</font><font papago-translate="translated"> 내부 </font></font><code translate="no">for</code><font papago-translate="splitted"><font papago-translate="translated"> 루프, a </font></font><code translate="no">continue</code><font papago-translate="splitted"><font papago-translate="translated"> 증가절이 있는 경우 증가절로 이동합니다.</font><font papago-translate="translated"> 컴파일 타임 오류입니다 </font></font><code translate="no">continue</code><font papago-translate="splitted"><font papago-translate="translated"> 루프에 포함되지 않은 문장.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">범위에 대해 꼭 생각해 보세요.</font><font papago-translate="translated"> 루프 본체 내부 또는 루프 내부에 중첩된 블록에 선언된 로컬 변수에 어떤 일이 발생해야합니까 </font></font><code translate="no">continue</code><font papago-translate="splitted"><font papago-translate="translated"> 실행되었습니까?</font></font></p>
</li>
<li>
<p><font papago-translate="translated">제어 흐름 구조는 Algol 68 이후로 대부분 변하지 않았습니다.</font><font papago-translate="translated"> 그 이후로 언어의 발전은 코드를 보다 선언적이고 높은 수준으로 만드는 데 중점을 두었기 때문에, 명령형 제어 흐름은 큰 주목을 받지 못했습니다.</font></p>
<p><font papago-translate="translated">재미로 Lox를 위한 유용한 새로운 제어 흐름 기능을 만들어 보세요.</font><font papago-translate="translated"> 기존 형태를 개선하거나 완전히 새로운 형태일 수 있습니다.</font><font papago-translate="translated"> 실제로 이 낮은 표현력 수준에서는 사용자가 익숙하지 않은 표기법과 동작을 배우도록 강요하는 비용을 능가할 만큼 유용한 것을 생각해내기 어렵지만, 디자인 기술을 연습할 수 있는 좋은 기회입니다.</font></p>
</li>
</ol>
</div>
<div class="design-note">
<h2><a href="https://youhogeon-meritz.github.io/jumping-back-and-forth.html#design-note" id="design-note"><font papago-translate="translated">디자인 노트:</font><font papago-translate="translated"> 고토 해로움을 고려하기</font></a></h2>
<p><font papago-translate="translated">록스에서 우리의 모든 아름다운 구조화된 제어 흐름이 실제로 원시 비구조화된 점프로 컴파일된다는 것을 발견하는 것은 마치 스쿠비두에서 괴물이 얼굴에서 마스크를 떼어내는 순간과 같습니다.</font><font papago-translate="translated"> 계속 진행 중이었어요!</font><font papago-translate="translated"> 이 경우를 제외하고, 괴물은 가면<em> 아래</em>에 있습니다.</font><font papago-translate="translated"> 우리는 모두 고토가 악하다는 것을 알고 있습니다.</font><font papago-translate="translated"> 하지만<span class="ellipse"></span> . . . 왜?</font></p>
<p><font papago-translate="translated">고토를 사용하여 터무니없이 유지 관리 불가능한 코드를 작성할 수 있다는 것은 사실입니다.</font><font papago-translate="translated"> 하지만 오늘날 대부분의 프로그래머들이 직접 본 적은 없는 것 같습니다.</font><font papago-translate="translated"> 그 스타일이 흔해진 지 오래되었습니다.</font><font papago-translate="translated"> 요즘 캠프파이어 주변의 무서운 이야기에서 우리가 부르는 것은 부기맨입니다.</font></p>
<p><font papago-translate="translated">우리가 그 괴물과 직접 대면하는 일이 거의<em></em> 없는 이유는 에드저 다이크스트라가 1968년 3월에 발행된 유명한 편지 "유해하다고 여겨지는 진술로 가기"로 괴물을 죽였기 때문입니다.</font><font papago-translate="translated"> 구조화된 프로그래밍에 대한 논쟁은 한동안 양측 지지자들 사이에서 치열했지만, 디크스트라가 이를 효과적으로 끝낸 것이 가장 큰 공로라고 생각합니다.</font><font papago-translate="translated"> 오늘날 대부분의 새로운 언어에는 비정형 점프 문이 없습니다.</font></p>
<p><font papago-translate="translated">거의 한 손으로 언어 기능을 파괴한 한 페이지 반짜리 편지는 꽤 인상적인 내용임에 틀림없습니다.</font><font papago-translate="translated"> 읽지 않으셨다면 꼭 읽어보시길 권장합니다.</font><font papago-translate="translated"> 그것은 우리 부족의 조상 노래 중 하나인 컴퓨터 과학의 중요한 전설입니다.</font><font papago-translate="translated"> 또한, 이것은 학문적 CS<span name="style"> 글쓰기</span>를 읽기 위한 짧고 멋진 연습이며, 이는 개발하는 데 유용한 기술입니다.</font></p>
<aside name="style" style="top: 20026px;">
<p><font papago-translate="translated">즉, 다이크스트라의 참을 수 없는 가짜 절제된 자기 과장적 글쓰기 스타일을 극복할 수 있다면:</font></p>
<blockquote>
<p><font papago-translate="translated">최근에 저는 Go to 진술의 사용이 왜 그렇게 비참한 영향을 미치는지 알게 되었습니다<span class="ellipse">. . . 그</span> 당시 저는 이 발견에 큰 중요성을 두지 않았습니다. 최근 이 주제에 대한 논의에서 저는 이를 촉구받았기 때문에 이제 출판에 대한 고려 사항을 제출합니다.</font></p>
</blockquote>
<p><font papago-translate="translated">아, 또 하나의 많은 발견 중 하나입니다.</font><font papago-translate="translated"> 소리치는 대중들이 저에게 간청하기 전까지는 그것을 쓰는 것조차 귀찮아할 수 없었습니다.</font></p>
</aside>
<p><font papago-translate="translated">저는 몇 번의 비평, 답변, 그리고 해설과 함께 여러 번 읽었습니다.</font><font papago-translate="translated"> 기껏해야 만감이 교차했습니다.</font><font papago-translate="translated"> 매우 높은 수준에서 저는 그와 함께합니다.</font><font papago-translate="translated"> 그의 일반적인 주장은 다음과 같습니다:</font></p>
<ol>
<li>
<p><font papago-translate="translated">프로그래머로서 우리는 프로그램—정적 텍스트—하지만 우리가 신경 쓰는 것은 실제 실행 중인 프로그램—의 동적<span class="em"></span><span class="em"></span><span class="em"></span> 동작입니다.</font></p>
</li>
<li>
<p><font papago-translate="translated">우리는 동적인 것보다 정적인 것에 대해 더 잘 추론합니다.</font><font papago-translate="translated"> (그는 이 주장을 뒷받침할 증거를 제공하지 않지만, 저는 이를 받아들입니다.)</font></p>
</li>
<li>
<p><font papago-translate="translated">따라서 프로그램의 동적 실행이 텍스트 구조를 반영할 수 있을수록 좋습니다.</font></p>
</li>
</ol>
<p><font papago-translate="translated">좋은 시작입니다.</font><font papago-translate="translated"> 우리가 작성하는 코드와 기계 내부에서 실행되는 코드 사이의 분리에 주목하는 것은 흥미로운 통찰입니다.</font><font papago-translate="translated"> 그런 다음 그는 프로그램 텍스트와 실행 간의 "대응"을 정의하려고 합니다.</font><font papago-translate="translated"> 말 그대로 그의 경력 전체를 프로그래밍의 더 엄격함을 옹호하며 보낸 사람에게 그의 정의는 꽤나 손재주가 있습니다.</font><font papago-translate="translated"> 그는 말합니다:</font></p>
<blockquote>
<p><font papago-translate="translated">이제 프로세스의 진행 상황을 어떻게 특성화할 수 있는지 생각해 보겠습니다.</font><font papago-translate="translated"> (이 질문에 대해 매우 구체적인 방식으로 생각할 수 있습니다: 행동의 시간적 연속으로 간주되는 프로세스가 임의의 행동 후에 중단된다고 가정하면, 동일한 지점까지 프로세스를 다시 수행하려면 어떤 데이터를 수정해야 하나요?)</font></p>
</blockquote>
<p><font papago-translate="translated">이렇게 상상해 보세요.</font><font papago-translate="translated"> 두 대의 컴퓨터가 동일한 입력으로 동일한 프로그램을 실행하고 있기 때문에 완전히 결정<span class="em"></span>론적입니다.</font><font papago-translate="translated"> 실행 중인 임의의 지점에서 하나를 일시 중지합니다.</font><font papago-translate="translated"> 첫 번째 컴퓨터만큼 정확히 멈추려면 어떤 데이터를 다른 컴퓨터로 보내야합니까?</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">프로그램이 과제와 같은 간단한 문장만 허용한다면, 그것은 쉽습니다.</font><font papago-translate="translated"> 마지막으로 실행한 문장 뒤의 요점만 알면 됩니다.</font><font papago-translate="translated"> 기본적으로 중단점은 </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated"> VM 또는 오류 메시지의 줄 번호.</font><font papago-translate="translated"> 분기 제어 흐름 추가하기 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">switch</code><font papago-translate="splitted"><font papago-translate="translated"> 여기에 더 이상 추가되지 않습니다.</font><font papago-translate="translated"> 마커가 나뭇가지 안쪽을 가리키더라도 우리는 여전히 우리가 어디에 있는지 알 수 있습니다.</font></font></p>
<p><font papago-translate="translated">함수 호출을 추가하면 더 많은 것이 필요합니다.</font><font papago-translate="translated"> 함수의 중간에 첫 번째 컴퓨터를 일시 중지할 수도 있었지만, 그 함수는 여러 곳에서 호출될 수 있습니다.</font><font papago-translate="translated"> 전체<em> 프로그램</em> 실행 중 정확히 같은 지점에서 두 번째 기계를 일시 중지하려면 해당 기능에 대한<em> 올바른</em> 호출 시 일시 중지해야 합니다.</font></p>
<p><font papago-translate="translated">따라서 현재 상태뿐만 아니라 아직 반환되지 않은 함수 호출의 경우 호출 사이트의 위치를 알아야 합니다.</font><font papago-translate="translated"> 다시 말해, 콜 스택이라는 용어는 다이크스트라가 이 글을 썼을 때 존재하지 않았던 것 같습니다.</font><font papago-translate="translated"> 그루비.</font></p>
<p><font papago-translate="translated">그는 루프가 상황을 더 어렵게 만든다고 지적합니다.</font><font papago-translate="translated"> 루프 본체의 중간에 잠시 멈추면 몇 번의 반복이 실행되었는지 알 수 없습니다.</font><font papago-translate="translated"> 그래서 그는 반복 횟수도 유지해야 한다고 말합니다.</font><font papago-translate="translated"> 그리고 루프가 둥지를 틀 수 있기 때문에 이러한 루프 스택이 필요합니다(외부 호출에서도 루프에 있을 수 있기 때문에 호출 스택 포인터와 인터리빙된 것으로 추정됩니다).</font></p>
<p><font papago-translate="translated">여기서부터 이상해집니다.</font><font papago-translate="translated"> 그래서 우리는 지금 정말로 무언가를 구축하고 있는데, 그가 이 모든 것을 깨는 방법을 설명해 줄 것이라고 기대할 수 있습니다.</font><font papago-translate="translated"> 대신 그는 그냥 말합니다:</font></p>
<blockquote>
<p><font papago-translate="translated">Go to 문을 무제한으로 사용하면 프로세스 진행 상황을 설명할 수 있는 의미 있는 좌표 집합을 찾기가 매우 어려워지는 즉각적인 결과를 초래할 수 있습니다.</font></p>
</blockquote>
<p><font papago-translate="translated">그는 이것이 어렵다는 것을 증명하거나 이유를 말하지 않습니다.</font><font papago-translate="translated"> 그는 그냥 말합니다.</font><font papago-translate="translated"> 그는 한 가지 접근 방식이 불만족스럽다고 말합니다:</font></p>
<blockquote>
<p><font papago-translate="translated">물론 문으로 이동하면 프로그램이 시작된 이후 수행된 작업의 수를 세는 카운터(즉, 일종의 정규화된 시계)를 통해 진행 상황을 고유하게 설명할 수 있습니다.</font><font papago-translate="translated"> 어려운 점은 그러한 좌표가 독특하지만 전혀 도움이 되지 않는다는 것입니다.</font></p>
</blockquote>
<p><font papago-translate="splitted"><font papago-translate="translated">하지만 루프 카운터는 사실상 그렇게 작동하며, 그는<span class="ellipse"></span> 그것들에 대해 괜찮았습니다.</font><font papago-translate="translated"> 모든 루프가 단순한 "0에서 10까지의 모든 정수에 대해" 증가하는 카운트인 것은 아닙니다.</font><font papago-translate="translated"> 많은 </font></font><code translate="no">while</code><font papago-translate="splitted"><font papago-translate="translated"> 복소수 조건을 가진 루프.</font></font></p>
<p><font papago-translate="translated">집 근처의 예를 들어, clox의 중심에 있는 핵심 바이트코드 실행 루프를 생각해 보세요.</font><font papago-translate="translated"> 다이크스트라는 그 루프가 실행 가능하다고 주장합니다. 왜냐하면 우리는 단순히 루프가 몇 번이나 실행되었는지 세어 그 진행 상황을 추론할 수 있기 때문입니다.</font><font papago-translate="translated"> 하지만 이 루프는 일부 사용자의 컴파일된 Lox 프로그램에서 실행되는 각 명령어마다 한 번씩 실행됩니다.</font><font papago-translate="translated"> 6,201개의 바이트코드 명령어를 실행했다는 사실을 알면 VM 유지보수 담당자들이 인터프리터의 상태에 대해 정말로 알<em> 수 있을까</em>요?</font></p>
<p><font papago-translate="translated">사실, 이 특정 예시는 더 깊은 진실을 가리킵니다.</font><font papago-translate="translated"> Böhm과 Jacopini는 고토를 사용하는 모든 제어 흐름이 시퀀싱, 루프,<em></em> 분기만으로 하나로 변환될 수<a href="https://en.wikipedia.org/wiki/Structured_program_theorem"> 있음을 증명했습니다</a>.</font><font papago-translate="translated"> 우리의 바이트코드 인터프리터 루프는 그 증명의 실제 예입니다: 고토 자체를 사용하지 않고도 clox 바이트코드 명령어 세트의 비구조적 제어 흐름을 구현합니다.</font></p>
<p><font papago-translate="translated">이는 다이크스트라의 주장에 대한 반론을 제시하는 것 같습니다: 고토를 사용하여 프로그램의 대응을 정의한 다음 그렇지 않은 프로그램으로 변환하여 해당 프로그램의 대응을 사용<em>할 수 있는데</em>, 그에 따르면 프로그램은 분기와<span class="em"></span><span class="em"></span> 루프만 사용하기 때문에 허용된다고 합니다.</font></p>
<p><font papago-translate="translated">하지만 솔직히 말해서, 제 주장도 약합니다.</font><font papago-translate="translated"> 우리 둘 다 기본적으로 수학을 가장하고 가짜 논리를 사용하여 경험적이고 인간 중심적인 주장을 하고 있다고 생각합니다.</font><font papago-translate="translated"> 고토를 사용하는 일부 코드가 정말 나쁘다는 것은 Dijkstra의 말이 맞습니다.</font><font papago-translate="translated"> 그 중 많은 부분이 구조화된 제어 흐름을 사용하여 더 명확한 코드로 변환될 수 있으며, 그렇게 해야 합니다.</font></p>
<p><font papago-translate="translated">언어에서 고토를 완전히 제거하면 고토를 사용하여 나쁜 코드를 작성하는 것을 확실히 방지할 수 있습니다.</font><font papago-translate="translated"> 사용자들에게 구조화된 제어 흐름을 사용하도록 강요하고, 이러한 구조를 사용하여 고토와 유사한 코드를 작성하는 것을 어렵게 만드는 것은 우리의 모든 생산성에 순익이 될 수 있습니다.</font></p>
<p><font papago-translate="translated">하지만 가끔은 우리가 아기를 목욕물에 버렸을지도 궁금합니다.</font><font papago-translate="translated"> 고토가 없는 경우, 우리는 종종 더 복잡한 구조화된 패턴에 의존합니다.</font><font papago-translate="translated"> "루프 내부의 스위치"는 고전적인 것입니다.</font><font papago-translate="translated"> 다른 하나는 가드 변수를 사용하여 일련의 중첩 루프를 종료하는 것입니다:</font></p><span name="break">
</span>
<div class="codehilite"><pre translate="no"><span class="c">// See if the matrix contains a zero.</span>
<span class="t">bool</span> <span class="i">found</span> = <span class="k">false</span>;
<span class="k">for</span> (<span class="t">int</span> <span class="i">x</span> = <span class="n">0</span>; <span class="i">x</span> &lt; <span class="i">xSize</span>; <span class="i">x</span>++) {
  <span class="k">for</span> (<span class="t">int</span> <span class="i">y</span> = <span class="n">0</span>; <span class="i">y</span> &lt; <span class="i">ySize</span>; <span class="i">y</span>++) {
    <span class="k">for</span> (<span class="t">int</span> <span class="i">z</span> = <span class="n">0</span>; <span class="i">z</span> &lt; <span class="i">zSize</span>; <span class="i">z</span>++) {
      <span class="k">if</span> (<span class="i">matrix</span>[<span class="i">x</span>][<span class="i">y</span>][<span class="i">z</span>] == <span class="n">0</span>) {
        <span class="i">printf</span>(<span class="s">"found"</span>);
        <span class="i">found</span> = <span class="k">true</span>;
        <span class="k">break</span>;
      }
    }
    <span class="k">if</span> (<span class="i">found</span>) <span class="k">break</span>;
  }
  <span class="k">if</span> (<span class="i">found</span>) <span class="k">break</span>;
}
</pre></div>
<p><font papago-translate="translated">그게 정말 더 나은가요:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">for</span> (<span class="t">int</span> <span class="i">x</span> = <span class="n">0</span>; <span class="i">x</span> &lt; <span class="i">xSize</span>; <span class="i">x</span>++) {
  <span class="k">for</span> (<span class="t">int</span> <span class="i">y</span> = <span class="n">0</span>; <span class="i">y</span> &lt; <span class="i">ySize</span>; <span class="i">y</span>++) {
    <span class="k">for</span> (<span class="t">int</span> <span class="i">z</span> = <span class="n">0</span>; <span class="i">z</span> &lt; <span class="i">zSize</span>; <span class="i">z</span>++) {
      <span class="k">if</span> (<span class="i">matrix</span>[<span class="i">x</span>][<span class="i">y</span>][<span class="i">z</span>] == <span class="n">0</span>) {
        <span class="i">printf</span>(<span class="s">"found"</span>);
        <span class="k">goto</span> <span class="i">done</span>;
      }
    }
  }
}
<span class="i">done</span>:
</pre></div>
<aside name="break" style="top: 22580px;">
<p><font papago-translate="splitted"><font papago-translate="translated">없이도 이 작업을 수행할 수 있습니다 </font></font><code translate="no">break</code><font papago-translate="splitted"><font papago-translate="translated"> 문장 - 자체가 제한적인 구성 요소 -<span class="em"></span><span class="em"></span> 을 삽입하여 설명합니다 </font></font><code translate="no">!found &amp;&amp;</code><font papago-translate="splitted"><font papago-translate="translated"> 각 루프의 조건 절의 시작 부분에서.</font></font></p>
</aside>
<p><font papago-translate="translated">제가 정말 싫어하는 것은 오늘날 우리가 두려움을 바탕으로 언어 설계와 엔지니어링 결정을 내리고 있다는 점입니다.</font><font papago-translate="translated"> 오늘날 고토의 문제점과 이점에 대해 미묘한 이해를 가진 사람은 거의 없습니다.</font><font papago-translate="translated"> 대신, 우리는 그것이 "해롭다고 간주된다"고 생각할 뿐입니다.</font><font papago-translate="translated"> 개인적으로 저는 도그마가 양질의 창작 작업을 위한 좋은 출발점이라고 생각해 본 적이 없습니다.</font></p>
</div>
<footer>
<a class="next" href="https://youhogeon-meritz.github.io/calls-and-functions.html"><font papago-translate="translated"> 다음 장: "콜과 기능" → </font></a><font papago-translate="splitted"><font papago-translate="translated"> 로버트 니스트롬이 수작업으로 제작한 -<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE"> © 2015 ~ 2021</a></font></font>
</footer>
</article>
</div>


</body></html>