<!DOCTYPE html>

<html>
<head>
<meta content="text/html;charset=utf-8" http-equiv="Content-type"/>
<title>Superclasses · Crafting Interpreters</title>
<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<link href="style.css" rel="stylesheet" type="text/css"/>
<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600" rel="stylesheet" type="text/css"/>
<link href="image/favicon.png" rel="icon" type="image/png">
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>
<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>
</link></head>
<body id="top">
<!-- <div class="scrim"></div> -->
<nav class="wide">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"/></a>
<div class="contents">
<h3><a href="#top">Superclasses<small>29</small></a></h3>
<ul>
<li><a href="#inheriting-methods"><small>29.1</small> Inheriting Methods</a></li>
<li><a href="#storing-superclasses"><small>29.2</small> Storing Superclasses</a></li>
<li><a href="#super-calls"><small>29.3</small> Super Calls</a></li>
<li><a href="#a-complete-virtual-machine"><small>29.4</small> A Complete Virtual Machine</a></li>
<li class="divider"></li>
<li class="end-part"><a href="#challenges">Challenges</a></li>
</ul>
<div class="prev-next">
<a class="left" href="methods-and-initializers.html" title="Methods and Initializers">← Previous</a>
<a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">↑ Up</a>
<a class="right" href="optimization.html" title="Optimization">Next →</a>
</div> </div>
</nav>
<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"/></a>
<a class="prev" href="methods-and-initializers.html" title="Methods and Initializers">←</a>
<a class="next" href="optimization.html" title="Optimization">→</a>
</nav>
<div class="page">
<div class="nav-wrapper">
<nav class="floating">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"/></a>
<div class="expandable">
<h3><a href="#top">Superclasses<small>29</small></a></h3>
<ul>
<li><a href="#inheriting-methods"><small>29.1</small> Inheriting Methods</a></li>
<li><a href="#storing-superclasses"><small>29.2</small> Storing Superclasses</a></li>
<li><a href="#super-calls"><small>29.3</small> Super Calls</a></li>
<li><a href="#a-complete-virtual-machine"><small>29.4</small> A Complete Virtual Machine</a></li>
<li class="divider"></li>
<li class="end-part"><a href="#challenges">Challenges</a></li>
</ul>
<div class="prev-next">
<a class="left" href="methods-and-initializers.html" title="Methods and Initializers">← Previous</a>
<a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">↑ Up</a>
<a class="right" href="optimization.html" title="Optimization">Next →</a>
</div> </div>
<a id="expand-nav">≡</a>
</nav>
</div>
<article class="chapter">
<div class="number">29</div>
<h1>Superclasses</h1>
<blockquote>
<p>You can choose your friends but you sho’ can’t choose your family, an’ they’re
still kin to you no matter whether you acknowledge ’em or not, and it
makes you look right silly when you don’t.</p>
<p><cite>Harper Lee, <em>To Kill a Mockingbird</em></cite></p>
</blockquote>
<p>This is the very last chapter where we add new functionality to our VM. We’ve
packed almost the entire Lox language in there already. All that remains is
inheriting methods and calling superclass methods. We have <a href="optimization.html">another
chapter</a> after this one, but it introduces no new behavior. It
<span name="faster">only</span> makes existing stuff faster. Make it to the end
of this one, and you’ll have a complete Lox implementation.</p>
<aside name="faster">
<p>That “only” should not imply that making stuff faster isn’t important! After
all, the whole purpose of our entire second virtual machine is better
performance over jlox. You could argue that <em>all</em> of the past fifteen chapters
are “optimization”.</p>
</aside>
<p>Some of the material in this chapter will remind you of jlox. The way we resolve
super calls is pretty much the same, though viewed through clox’s more complex
mechanism for storing state on the stack. But we have an entirely different,
much faster, way of handling inherited method calls this time around.</p>
<h2><a href="#inheriting-methods" id="inheriting-methods"><small>29 . 1</small>Inheriting Methods</a></h2>
<p>We’ll kick things off with method inheritance since it’s the simpler piece. To
refresh your memory, Lox inheritance syntax looks like this:</p>
<div class="codehilite"><pre translate="no"><span class="k">class</span> <span class="t">Doughnut</span> {
  <span class="i">cook</span>() {
    <span class="k">print</span> <span class="s">"Dunk in the fryer."</span>;
  }
}

<span class="k">class</span> <span class="t">Cruller</span> &lt; <span class="t">Doughnut</span> {
  <span class="i">finish</span>() {
    <span class="k">print</span> <span class="s">"Glaze with icing."</span>;
  }
}
</pre></div>
<p>Here, the Cruller class inherits from Doughnut and thus, instances of Cruller
inherit the <code translate="no">cook()</code> method. I don’t know why I’m belaboring this. You know how
inheritance works. Let’s start compiling the new syntax.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  currentClass = &amp;classCompiler;

</pre><div class="source-file"><em>compiler.c</em><br/>
in <em>classDeclaration</em>()</div>
<pre class="insert" translate="no">  <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_LESS</span>)) {
    <span class="i">consume</span>(<span class="a">TOKEN_IDENTIFIER</span>, <span class="s">"Expect superclass name."</span>);
    <span class="i">variable</span>(<span class="k">false</span>);
    <span class="i">namedVariable</span>(<span class="i">className</span>, <span class="k">false</span>);
    <span class="i">emitByte</span>(<span class="a">OP_INHERIT</span>);
  }

</pre><pre class="insert-after" translate="no">  namedVariable(className, false);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>classDeclaration</em>()</div>
<p>After we compile the class name, if the next token is a <code translate="no">&lt;</code>, then we found a
superclass clause. We consume the superclass’s identifier token, then call
<code translate="no">variable()</code>. That function takes the previously consumed token, treats it as a
variable reference, and emits code to load the variable’s value. In other words,
it looks up the superclass by name and pushes it onto the stack.</p>
<p>After that, we call <code translate="no">namedVariable()</code> to load the subclass doing the inheriting
onto the stack, followed by an <code translate="no">OP_INHERIT</code> instruction. That instruction
wires up the superclass to the new subclass. In the last chapter, we defined an
<code translate="no">OP_METHOD</code> instruction to mutate an existing class object by adding a method to
its method table. This is similar<span class="em">—</span>the <code translate="no">OP_INHERIT</code> instruction takes an
existing class and applies the effect of inheritance to it.</p>
<p>In the previous example, when the compiler works through this bit of syntax:</p>
<div class="codehilite"><pre translate="no"><span class="k">class</span> <span class="t">Cruller</span> &lt; <span class="t">Doughnut</span> {
</pre></div>
<p>The result is this bytecode:</p><img alt="The series of bytecode instructions for a Cruller class inheriting from Doughnut." src="image/superclasses/inherit-stack.png">
<p>Before we implement the new <code translate="no">OP_INHERIT</code> instruction, we have an edge case to
detect.</p>
<div class="codehilite"><pre class="insert-before" translate="no">    variable(false);
</pre><div class="source-file"><em>compiler.c</em><br/>
in <em>classDeclaration</em>()</div>
<pre class="insert" translate="no">

    <span class="k">if</span> (<span class="i">identifiersEqual</span>(&amp;<span class="i">className</span>, &amp;<span class="i">parser</span>.<span class="i">previous</span>)) {
      <span class="i">error</span>(<span class="s">"A class can't inherit from itself."</span>);
    }

</pre><pre class="insert-after" translate="no">    namedVariable(className, false);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>classDeclaration</em>()</div>
<p><span name="cycle">A</span> class cannot be its own superclass. Unless you have
access to a deranged nuclear physicist and a very heavily modified DeLorean, you
cannot inherit from yourself.</p>
<aside name="cycle">
<p>Interestingly, with the way we implement method inheritance, I don’t think
allowing cycles would actually cause any problems in clox. It wouldn’t do
anything <em>useful</em>, but I don’t think it would cause a crash or infinite loop.</p>
</aside>
<h3><a href="#executing-inheritance" id="executing-inheritance"><small>29 . 1 . 1</small>Executing inheritance</a></h3>
<p>Now onto the new instruction.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  OP_CLASS,
</pre><div class="source-file"><em>chunk.h</em><br/>
in enum <em>OpCode</em></div>
<pre class="insert" translate="no">  <span class="a">OP_INHERIT</span>,
</pre><pre class="insert-after" translate="no">  OP_METHOD
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>
<p>There are no operands to worry about. The two values we need<span class="em">—</span>superclass and
subclass<span class="em">—</span>are both found on the stack. That means disassembling is easy.</p>
<div class="codehilite"><pre class="insert-before" translate="no">      return constantInstruction("OP_CLASS", chunk, offset);
</pre><div class="source-file"><em>debug.c</em><br/>
in <em>disassembleInstruction</em>()</div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="a">OP_INHERIT</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">"OP_INHERIT"</span>, <span class="i">offset</span>);
</pre><pre class="insert-after" translate="no">    case OP_METHOD:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>
<p>The interpreter is where the action happens.</p>
<div class="codehilite"><pre class="insert-before" translate="no">        break;
</pre><div class="source-file"><em>vm.c</em><br/>
in <em>run</em>()</div>
<pre class="insert" translate="no">      <span class="k">case</span> <span class="a">OP_INHERIT</span>: {
        <span class="t">Value</span> <span class="i">superclass</span> = <span class="i">peek</span>(<span class="n">1</span>);
        <span class="t">ObjClass</span>* <span class="i">subclass</span> = <span class="a">AS_CLASS</span>(<span class="i">peek</span>(<span class="n">0</span>));
        <span class="i">tableAddAll</span>(&amp;<span class="a">AS_CLASS</span>(<span class="i">superclass</span>)-&gt;<span class="i">methods</span>,
                    &amp;<span class="i">subclass</span>-&gt;<span class="i">methods</span>);
        <span class="i">pop</span>(); <span class="c">// Subclass.</span>
        <span class="k">break</span>;
      }
</pre><pre class="insert-after" translate="no">      case OP_METHOD:
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p>From the top of the stack down, we have the subclass then the superclass. We
grab both of those and then do the inherit-y bit. This is where clox takes a
different path than jlox. In our first interpreter, each subclass stored a
reference to its superclass. On method access, if we didn’t find the method in
the subclass’s method table, we recursed through the inheritance chain looking
at each ancestor’s method table until we found it.</p>
<p>For example, calling <code translate="no">cook()</code> on an instance of Cruller sends jlox on this
journey:</p><img alt="Resolving a call to cook() in an instance of Cruller means walking the superclass chain." src="image/superclasses/jlox-resolve.png">
<p>That’s a lot of work to perform during method <em>invocation</em> time. It’s slow, and
worse, the farther an inherited method is up the ancestor chain, the slower it
gets. Not a great performance story.</p>
<p>The new approach is much faster. When the subclass is declared, we copy all of
the inherited class’s methods down into the subclass’s own method table. Later,
when <em>calling</em> a method, any method inherited from a superclass will be found
right in the subclass’s own method table. There is no extra runtime work needed
for inheritance at all. By the time the class is declared, the work is done.
This means inherited method calls are exactly as fast as normal method calls<span class="em">—</span>a <span name="two">single</span> hash table lookup.</p><img alt="Resolving a call to cook() in an instance of Cruller which has the method in its own method table." src="image/superclasses/clox-resolve.png">
<aside name="two">
<p>Well, two hash table lookups, I guess. Because first we have to make sure a
field on the instance doesn’t shadow the method.</p>
</aside>
<p>I’ve sometimes heard this technique called “copy-down inheritance”. It’s simple
and fast, but, like most optimizations, you get to use it only under certain
constraints. It works in Lox because Lox classes are <em>closed</em>. Once a class
declaration is finished executing, the set of methods for that class can never
change.</p>
<p>In languages like Ruby, Python, and JavaScript, it’s possible to <span name="monkey">crack</span> open an existing class and jam some new methods into
it or even remove them. That would break our optimization because if those
modifications happened to a superclass <em>after</em> the subclass declaration
executed, the subclass would not pick up those changes. That breaks a user’s
expectation that inheritance always reflects the current state of the
superclass.</p>
<aside name="monkey">
<p>As you can imagine, changing the set of methods a class defines imperatively at
runtime can make it hard to reason about a program. It is a very powerful tool,
but also a dangerous tool.</p>
<p>Those who find this tool maybe a little <em>too</em> dangerous gave it the unbecoming
name “monkey patching”, or the even less decorous “duck punching”.</p><img alt="A monkey with an eyepatch, naturally." src="image/superclasses/monkey.png"/>
</aside>
<p>Fortunately for us (but not for users who like the feature, I guess), Lox
doesn’t let you patch monkeys or punch ducks, so we can safely apply this
optimization.</p>
<p>What about method overrides? Won’t copying the superclass’s methods into the
subclass’s method table clash with the subclass’s own methods? Fortunately, no.
We emit the <code translate="no">OP_INHERIT</code> after the <code translate="no">OP_CLASS</code> instruction that creates the
subclass but before any method declarations and <code translate="no">OP_METHOD</code> instructions have
been compiled. At the point that we copy the superclass’s methods down, the
subclass’s method table is empty. Any methods the subclass overrides will
overwrite those inherited entries in the table.</p>
<h3><a href="#invalid-superclasses" id="invalid-superclasses"><small>29 . 1 . 2</small>Invalid superclasses</a></h3>
<p>Our implementation is simple and fast, which is just the way I like my VM code.
But it’s not robust. Nothing prevents a user from inheriting from an object that
isn’t a class at all:</p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="t">NotClass</span> = <span class="s">"So not a class"</span>;
<span class="k">class</span> <span class="t">OhNo</span> &lt; <span class="t">NotClass</span> {}
</pre></div>
<p>Obviously, no self-respecting programmer would write that, but we have to guard
against potential Lox users who have no self respect. A simple runtime check
fixes that.</p>
<div class="codehilite"><pre class="insert-before" translate="no">        Value superclass = peek(1);
</pre><div class="source-file"><em>vm.c</em><br/>
in <em>run</em>()</div>
<pre class="insert" translate="no">        <span class="k">if</span> (!<span class="a">IS_CLASS</span>(<span class="i">superclass</span>)) {
          <span class="i">runtimeError</span>(<span class="s">"Superclass must be a class."</span>);
          <span class="k">return</span> <span class="a">INTERPRET_RUNTIME_ERROR</span>;
        }

</pre><pre class="insert-after" translate="no">        ObjClass* subclass = AS_CLASS(peek(0));
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p>If the value we loaded from the identifier in the superclass clause isn’t an
ObjClass, we report a runtime error to let the user know what we think of them
and their code.</p>
<h2><a href="#storing-superclasses" id="storing-superclasses"><small>29 . 2</small>Storing Superclasses</a></h2>
<p>Did you notice that when we added method inheritance, we didn’t actually add any
reference from a subclass to its superclass? After we copy the inherited methods
over, we forget the superclass entirely. We don’t need to keep a handle on the
superclass, so we don’t.</p>
<p>That won’t be sufficient to support super calls. Since a subclass <span name="may">may</span> override the superclass method, we need to be able to get
our hands on superclass method tables. Before we get to that mechanism, I want 
to refresh your memory on how super calls are statically resolved.</p>
<aside name="may">
<p>“May” might not be a strong enough word. Presumably the method <em>has</em> been
overridden. Otherwise, why are you bothering to use <code translate="no">super</code> instead of just
calling it directly?</p>
</aside>
<p>Back in the halcyon days of jlox, I showed you <a href="inheritance.html#semantics">this tricky example</a> to
explain the way super calls are dispatched:</p>
<div class="codehilite"><pre translate="no"><span class="k">class</span> <span class="t">A</span> {
  <span class="i">method</span>() {
    <span class="k">print</span> <span class="s">"A method"</span>;
  }
}

<span class="k">class</span> <span class="t">B</span> &lt; <span class="t">A</span> {
  <span class="i">method</span>() {
    <span class="k">print</span> <span class="s">"B method"</span>;
  }

  <span class="i">test</span>() {
    <span class="k">super</span>.<span class="i">method</span>();
  }
}

<span class="k">class</span> <span class="t">C</span> &lt; <span class="t">B</span> {}

<span class="t">C</span>().<span class="i">test</span>();
</pre></div>
<p>Inside the body of the <code translate="no">test()</code> method, <code translate="no">this</code> is an instance of C. If super
calls were resolved relative to the superclass of the <em>receiver</em>, then we would
look in C’s superclass, B. But super calls are resolved relative to the
superclass of the <em>surrounding class where the super call occurs</em>. In this case,
we are in B’s <code translate="no">test()</code> method, so the superclass is A, and the program should
print “A method”.</p>
<p>This means that super calls are not resolved dynamically based on the runtime
instance. The superclass used to look up the method is a static<span class="em">—</span>practically
lexical<span class="em">—</span>property of where the call occurs. When we added inheritance to jlox,
we took advantage of that static aspect by storing the superclass in the same
Environment structure we used for all lexical scopes. Almost as if the
interpreter saw the above program like this:</p>
<div class="codehilite"><pre translate="no"><span class="k">class</span> <span class="t">A</span> {
  <span class="i">method</span>() {
    <span class="k">print</span> <span class="s">"A method"</span>;
  }
}

<span class="k">var</span> <span class="t">Bs_super</span> = <span class="t">A</span>;
<span class="k">class</span> <span class="t">B</span> &lt; <span class="t">A</span> {
  <span class="i">method</span>() {
    <span class="k">print</span> <span class="s">"B method"</span>;
  }

  <span class="i">test</span>() {
    <span class="i">runtimeSuperCall</span>(<span class="t">Bs_super</span>, <span class="s">"method"</span>);
  }
}

<span class="k">var</span> <span class="t">Cs_super</span> = <span class="t">B</span>;
<span class="k">class</span> <span class="t">C</span> &lt; <span class="t">B</span> {}

<span class="t">C</span>().<span class="i">test</span>();
</pre></div>
<p>Each subclass has a hidden variable storing a reference to its superclass.
Whenever we need to perform a super call, we access the superclass from that
variable and tell the runtime to start looking for methods there.</p>
<p>We’ll take the same path with clox. The difference is that instead of jlox’s
heap-allocated Environment class, we have the bytecode VM’s value stack and
upvalue system. The machinery is a little different, but the overall effect is
the same.</p>
<h3><a href="#a-superclass-local-variable" id="a-superclass-local-variable"><small>29 . 2 . 1</small>A superclass local variable</a></h3>
<p>Our compiler already emits code to load the superclass onto the stack. Instead
of leaving that slot as a temporary, we create a new scope and make it a local
variable.</p>
<div class="codehilite"><pre class="insert-before" translate="no">    }

</pre><div class="source-file"><em>compiler.c</em><br/>
in <em>classDeclaration</em>()</div>
<pre class="insert" translate="no">    <span class="i">beginScope</span>();
    <span class="i">addLocal</span>(<span class="i">syntheticToken</span>(<span class="s">"super"</span>));
    <span class="i">defineVariable</span>(<span class="n">0</span>);

</pre><pre class="insert-after" translate="no">    namedVariable(className, false);
    emitByte(OP_INHERIT);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>classDeclaration</em>()</div>
<p>Creating a new lexical scope ensures that if we declare two classes in the same
scope, each has a different local slot to store its superclass. Since we always
name this variable “super”, if we didn’t make a scope for each subclass, the
variables would collide.</p>
<p>We name the variable “super” for the same reason we use “this” as the name of
the hidden local variable that <code translate="no">this</code> expressions resolve to: “super” is a
reserved word, which guarantees the compiler’s hidden variable won’t collide
with a user-defined one.</p>
<p>The difference is that when compiling <code translate="no">this</code> expressions, we conveniently have a
token sitting around whose lexeme is “this”. We aren’t so lucky here. Instead,
we add a little helper function to create a synthetic token for the given <span name="constant">constant</span> string.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br/>
add after <em>variable</em>()</div>
<pre translate="no"><span class="k">static</span> <span class="t">Token</span> <span class="i">syntheticToken</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">text</span>) {
  <span class="t">Token</span> <span class="i">token</span>;
  <span class="i">token</span>.<span class="i">start</span> = <span class="i">text</span>;
  <span class="i">token</span>.<span class="i">length</span> = (<span class="t">int</span>)<span class="i">strlen</span>(<span class="i">text</span>);
  <span class="k">return</span> <span class="i">token</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>variable</em>()</div>
<aside class="bottom" name="constant">
<p>I say “constant string” because tokens don’t do any memory management of their
lexeme. If we tried to use a heap-allocated string for this, we’d end up leaking
memory because it never gets freed. But the memory for C string literals lives
in the executable’s constant data section and never needs to be freed, so we’re
fine.</p>
</aside>
<p>Since we opened a local scope for the superclass variable, we need to close it.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  emitByte(OP_POP);
</pre><div class="source-file"><em>compiler.c</em><br/>
in <em>classDeclaration</em>()</div>
<pre class="insert" translate="no">

  <span class="k">if</span> (<span class="i">classCompiler</span>.<span class="i">hasSuperclass</span>) {
    <span class="i">endScope</span>();
  }
</pre><pre class="insert-after" translate="no">

  currentClass = currentClass-&gt;enclosing;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>classDeclaration</em>()</div>
<p>We pop the scope and discard the “super” variable after compiling the class body
and its methods. That way, the variable is accessible in all of the methods of
the subclass. It’s a somewhat pointless optimization, but we create the scope
only if there <em>is</em> a superclass clause. Thus we need to close the scope only if
there is one.</p>
<p>To track that, we could declare a little local variable in <code translate="no">classDeclaration()</code>.
But soon, other functions in the compiler will need to know whether the
surrounding class is a subclass or not. So we may as well give our future selves
a hand and store this fact as a field in the ClassCompiler now.</p>
<div class="codehilite"><pre class="insert-before" translate="no">typedef struct ClassCompiler {
  struct ClassCompiler* enclosing;
</pre><div class="source-file"><em>compiler.c</em><br/>
in struct <em>ClassCompiler</em></div>
<pre class="insert" translate="no">  <span class="t">bool</span> <span class="i">hasSuperclass</span>;
</pre><pre class="insert-after" translate="no">} ClassCompiler;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in struct <em>ClassCompiler</em></div>
<p>When we first initialize a ClassCompiler, we assume it is not a subclass.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  ClassCompiler classCompiler;
</pre><div class="source-file"><em>compiler.c</em><br/>
in <em>classDeclaration</em>()</div>
<pre class="insert" translate="no">  <span class="i">classCompiler</span>.<span class="i">hasSuperclass</span> = <span class="k">false</span>;
</pre><pre class="insert-after" translate="no">  classCompiler.enclosing = currentClass;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>classDeclaration</em>()</div>
<p>Then, if we see a superclass clause, we know we are compiling a subclass.</p>
<div class="codehilite"><pre class="insert-before" translate="no">    emitByte(OP_INHERIT);
</pre><div class="source-file"><em>compiler.c</em><br/>
in <em>classDeclaration</em>()</div>
<pre class="insert" translate="no">    <span class="i">classCompiler</span>.<span class="i">hasSuperclass</span> = <span class="k">true</span>;
</pre><pre class="insert-after" translate="no">  }
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>classDeclaration</em>()</div>
<p>This machinery gives us a mechanism at runtime to access the superclass object
of the surrounding subclass from within any of the subclass’s methods<span class="em">—</span>simply
emit code to load the variable named “super”. That variable is a local outside
of the method body, but our existing upvalue support enables the VM to capture
that local inside the body of the method or even in functions nested inside that
method.</p>
<h2><a href="#super-calls" id="super-calls"><small>29 . 3</small>Super Calls</a></h2>
<p>With that runtime support in place, we are ready to implement super calls. As
usual, we go front to back, starting with the new syntax. A super call <span name="last">begins</span>, naturally enough, with the <code translate="no">super</code> keyword.</p>
<aside name="last">
<p>This is it, friend. The very last entry you’ll add to the parsing table.</p>
</aside>
<div class="codehilite"><pre class="insert-before" translate="no">  [TOKEN_RETURN]        = {NULL,     NULL,   PREC_NONE},
</pre><div class="source-file"><em>compiler.c</em><br/>
replace 1 line</div>
<pre class="insert" translate="no">  [<span class="a">TOKEN_SUPER</span>]         = {<span class="i">super_</span>,   <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
</pre><pre class="insert-after" translate="no">  [TOKEN_THIS]          = {this_,    NULL,   PREC_NONE},
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, replace 1 line</div>
<p>When the expression parser lands on a <code translate="no">super</code> token, control jumps to a new
parsing function which starts off like so:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br/>
add after <em>syntheticToken</em>()</div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">super_</span>(<span class="t">bool</span> <span class="i">canAssign</span>) {
  <span class="i">consume</span>(<span class="a">TOKEN_DOT</span>, <span class="s">"Expect '.' after 'super'."</span>);
  <span class="i">consume</span>(<span class="a">TOKEN_IDENTIFIER</span>, <span class="s">"Expect superclass method name."</span>);
  <span class="t">uint8_t</span> <span class="i">name</span> = <span class="i">identifierConstant</span>(&amp;<span class="i">parser</span>.<span class="i">previous</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>syntheticToken</em>()</div>
<p>This is pretty different from how we compiled <code translate="no">this</code> expressions. Unlike <code translate="no">this</code>,
a <code translate="no">super</code> <span name="token">token</span> is not a standalone expression.
Instead, the dot and method name following it are inseparable parts of the
syntax. However, the parenthesized argument list is separate. As with normal
method access, Lox supports getting a reference to a superclass method as a
closure without invoking it:</p>
<aside name="token">
<p>Hypothetical question: If a bare <code translate="no">super</code> token <em>was</em> an expression, what kind of
object would it evaluate to?</p>
</aside>
<div class="codehilite"><pre translate="no"><span class="k">class</span> <span class="t">A</span> {
  <span class="i">method</span>() {
    <span class="k">print</span> <span class="s">"A"</span>;
  }
}

<span class="k">class</span> <span class="t">B</span> &lt; <span class="t">A</span> {
  <span class="i">method</span>() {
    <span class="k">var</span> <span class="i">closure</span> = <span class="k">super</span>.<span class="i">method</span>;
    <span class="i">closure</span>(); <span class="c">// Prints "A".</span>
  }
}
</pre></div>
<p>In other words, Lox doesn’t really have super <em>call</em> expressions, it has super
<em>access</em> expressions, which you can choose to immediately invoke if you want. So
when the compiler hits a <code translate="no">super</code> token, we consume the subsequent <code translate="no">.</code> token and
then look for a method name. Methods are looked up dynamically, so we use
<code translate="no">identifierConstant()</code> to take the lexeme of the method name token and store it
in the constant table just like we do for property access expressions.</p>
<p>Here is what the compiler does after consuming those tokens:</p>
<div class="codehilite"><pre class="insert-before" translate="no">  uint8_t name = identifierConstant(&amp;parser.previous);
</pre><div class="source-file"><em>compiler.c</em><br/>
in <em>super_</em>()</div>
<pre class="insert" translate="no">

  <span class="i">namedVariable</span>(<span class="i">syntheticToken</span>(<span class="s">"this"</span>), <span class="k">false</span>);
  <span class="i">namedVariable</span>(<span class="i">syntheticToken</span>(<span class="s">"super"</span>), <span class="k">false</span>);
  <span class="i">emitBytes</span>(<span class="a">OP_GET_SUPER</span>, <span class="i">name</span>);
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>super_</em>()</div>
<p>In order to access a <em>superclass method</em> on <em>the current instance</em>, the runtime
needs both the receiver <em>and</em> the superclass of the surrounding method’s class.
The first <code translate="no">namedVariable()</code> call generates code to look up the current receiver
stored in the hidden variable “this” and push it onto the stack. The second
<code translate="no">namedVariable()</code> call emits code to look up the superclass from its “super”
variable and push that on top.</p>
<p>Finally, we emit a new <code translate="no">OP_GET_SUPER</code> instruction with an operand for the
constant table index of the method name. That’s a lot to hold in your head. To
make it tangible, consider this example program:</p>
<div class="codehilite"><pre translate="no"><span class="k">class</span> <span class="t">Doughnut</span> {
  <span class="i">cook</span>() {
    <span class="k">print</span> <span class="s">"Dunk in the fryer."</span>;
    <span class="k">this</span>.<span class="i">finish</span>(<span class="s">"sprinkles"</span>);
  }

  <span class="i">finish</span>(<span class="i">ingredient</span>) {
    <span class="k">print</span> <span class="s">"Finish with "</span> + <span class="i">ingredient</span>;
  }
}

<span class="k">class</span> <span class="t">Cruller</span> &lt; <span class="t">Doughnut</span> {
  <span class="i">finish</span>(<span class="i">ingredient</span>) {
    <span class="c">// No sprinkles, always icing.</span>
    <span class="k">super</span>.<span class="i">finish</span>(<span class="s">"icing"</span>);
  }
}
</pre></div>
<p>The bytecode emitted for the <code translate="no">super.finish("icing")</code> expression looks and works
like this:</p><img alt="The series of bytecode instructions for calling super.finish()." src="image/superclasses/super-instructions.png"/>
<p>The first three instructions give the runtime access to the three pieces of
information it needs to perform the super access:</p>
<ol>
<li>
<p>The first instruction loads <strong>the instance</strong> onto the stack.</p>
</li>
<li>
<p>The second instruction loads <strong>the superclass where the method is
resolved</strong>.</p>
</li>
<li>
<p>Then the new <code translate="no">OP_GET_SUPER</code> instuction encodes <strong>the name of the method to
access</strong> as an operand.</p>
</li>
</ol>
<p>The remaining instructions are the normal bytecode for evaluating an argument
list and calling a function.</p>
<p>We’re almost ready to implement the new <code translate="no">OP_GET_SUPER</code> instruction in the
interpreter. But before we do, the compiler has some errors it is responsible
for reporting.</p>
<div class="codehilite"><pre class="insert-before" translate="no">static void super_(bool canAssign) {
</pre><div class="source-file"><em>compiler.c</em><br/>
in <em>super_</em>()</div>
<pre class="insert" translate="no">  <span class="k">if</span> (<span class="i">currentClass</span> == <span class="a">NULL</span>) {
    <span class="i">error</span>(<span class="s">"Can't use 'super' outside of a class."</span>);
  } <span class="k">else</span> <span class="k">if</span> (!<span class="i">currentClass</span>-&gt;<span class="i">hasSuperclass</span>) {
    <span class="i">error</span>(<span class="s">"Can't use 'super' in a class with no superclass."</span>);
  }

</pre><pre class="insert-after" translate="no">  consume(TOKEN_DOT, "Expect '.' after 'super'.");
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>super_</em>()</div>
<p>A super call is meaningful only inside the body of a method (or in a function
nested inside a method), and only inside the method of a class that has a
superclass. We detect both of these cases using the value of <code translate="no">currentClass</code>. If
that’s <code translate="no">NULL</code> or points to a class with no superclass, we report those errors.</p>
<h3><a href="#executing-super-accesses" id="executing-super-accesses"><small>29 . 3 . 1</small>Executing super accesses</a></h3>
<p>Assuming the user didn’t put a <code translate="no">super</code> expression where it’s not allowed, their
code passes from the compiler over to the runtime. We’ve got ourselves a new
instruction.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  OP_SET_PROPERTY,
</pre><div class="source-file"><em>chunk.h</em><br/>
in enum <em>OpCode</em></div>
<pre class="insert" translate="no">  <span class="a">OP_GET_SUPER</span>,
</pre><pre class="insert-after" translate="no">  OP_EQUAL,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>
<p>We disassemble it like other opcodes that take a constant table index operand.</p>
<div class="codehilite"><pre class="insert-before" translate="no">      return constantInstruction("OP_SET_PROPERTY", chunk, offset);
</pre><div class="source-file"><em>debug.c</em><br/>
in <em>disassembleInstruction</em>()</div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="a">OP_GET_SUPER</span>:
      <span class="k">return</span> <span class="i">constantInstruction</span>(<span class="s">"OP_GET_SUPER"</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
</pre><pre class="insert-after" translate="no">    case OP_EQUAL:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>
<p>You might anticipate something harder, but interpreting the new instruction is
similar to executing a normal property access.</p>
<div class="codehilite"><pre class="insert-before" translate="no">      }
</pre><div class="source-file"><em>vm.c</em><br/>
in <em>run</em>()</div>
<pre class="insert" translate="no">      <span class="k">case</span> <span class="a">OP_GET_SUPER</span>: {
        <span class="t">ObjString</span>* <span class="i">name</span> = <span class="a">READ_STRING</span>();
        <span class="t">ObjClass</span>* <span class="i">superclass</span> = <span class="a">AS_CLASS</span>(<span class="i">pop</span>());

        <span class="k">if</span> (!<span class="i">bindMethod</span>(<span class="i">superclass</span>, <span class="i">name</span>)) {
          <span class="k">return</span> <span class="a">INTERPRET_RUNTIME_ERROR</span>;
        }
        <span class="k">break</span>;
      }
</pre><pre class="insert-after" translate="no">      case OP_EQUAL: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p>As with properties, we read the method name from the
constant table. Then we pass that to <code translate="no">bindMethod()</code> which looks up the method in
the given class’s method table and creates an ObjBoundMethod to bundle the
resulting closure to the current instance.</p>
<p>The key <span name="field">difference</span> is <em>which</em> class we pass to
<code translate="no">bindMethod()</code>. With a normal property access, we use the ObjInstances’s own
class, which gives us the dynamic dispatch we want. For a super call, we don’t
use the instance’s class. Instead, we use the statically resolved superclass of
the containing class, which the compiler has conveniently ensured is sitting on
top of the stack waiting for us.</p>
<p>We pop that superclass and pass it to <code translate="no">bindMethod()</code>, which correctly skips over
any overriding methods in any of the subclasses between that superclass and the
instance’s own class. It also correctly includes any methods inherited by the
superclass from any of <em>its</em> superclasses.</p>
<p>The rest of the behavior is the same. Popping the superclass leaves the instance
at the top of the stack. When <code translate="no">bindMethod()</code> succeeds, it pops the instance and
pushes the new bound method. Otherwise, it reports a runtime error and returns
<code translate="no">false</code>. In that case, we abort the interpreter.</p>
<aside name="field">
<p>Another difference compared to <code translate="no">OP_GET_PROPERTY</code> is that we don’t try to look
for a shadowing field first. Fields are not inherited, so <code translate="no">super</code> expressions
always resolve to methods.</p>
<p>If Lox were a prototype-based language that used <em>delegation</em> instead of
<em>inheritance</em>, then instead of one <em>class</em> inheriting from another <em>class</em>,
instances would inherit from (“delegate to”) other instances. In that case,
fields <em>could</em> be inherited, and we would need to check for them here.</p>
</aside>
<h3><a href="#faster-super-calls" id="faster-super-calls"><small>29 . 3 . 2</small>Faster super calls</a></h3>
<p>We have superclass method accesses working now. And since the returned object is
an ObjBoundMethod that you can then invoke, we’ve got super <em>calls</em> working too.
Just like last chapter, we’ve reached a point where our VM has the complete,
correct semantics.</p>
<p>But, also like last chapter, it’s pretty slow. Again, we’re heap allocating an
ObjBoundMethod for each super call even though most of the time the very next
instruction is an <code translate="no">OP_CALL</code> that immediately unpacks that bound method, invokes
it, and then discards it. In fact, this is even more likely to be true for
super calls than for regular method calls. At least with method calls there is
a chance that the user is actually invoking a function stored in a field. With
super calls, you’re <em>always</em> looking up a method. The only question is whether
you invoke it immediately or not.</p>
<p>The compiler can certainly answer that question for itself if it sees a left
parenthesis after the superclass method name, so we’ll go ahead and perform the
same optimization we did for method calls. Take out the two lines of code that
load the superclass and emit <code translate="no">OP_GET_SUPER</code>, and replace them with this:</p>
<div class="codehilite"><pre class="insert-before" translate="no">  namedVariable(syntheticToken("this"), false);
</pre><div class="source-file"><em>compiler.c</em><br/>
in <em>super_</em>()<br/>
replace 2 lines</div>
<pre class="insert" translate="no">  <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_LEFT_PAREN</span>)) {
    <span class="t">uint8_t</span> <span class="i">argCount</span> = <span class="i">argumentList</span>();
    <span class="i">namedVariable</span>(<span class="i">syntheticToken</span>(<span class="s">"super"</span>), <span class="k">false</span>);
    <span class="i">emitBytes</span>(<span class="a">OP_SUPER_INVOKE</span>, <span class="i">name</span>);
    <span class="i">emitByte</span>(<span class="i">argCount</span>);
  } <span class="k">else</span> {
    <span class="i">namedVariable</span>(<span class="i">syntheticToken</span>(<span class="s">"super"</span>), <span class="k">false</span>);
    <span class="i">emitBytes</span>(<span class="a">OP_GET_SUPER</span>, <span class="i">name</span>);
  }
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>super_</em>(), replace 2 lines</div>
<p>Now before we emit anything, we look for a parenthesized argument list. If we
find one, we compile that. Then we load the superclass. After that, we emit a
new <code translate="no">OP_SUPER_INVOKE</code> instruction. This <span name="superinstruction">superinstruction</span> combines the behavior of
<code translate="no">OP_GET_SUPER</code> and <code translate="no">OP_CALL</code>, so it takes two operands: the constant table index
of the method name to look up and the number of arguments to pass to it.</p>
<aside name="superinstruction">
<p>This is a particularly <em>super</em> superinstruction, if you get what I’m saying.
I<span class="ellipse"> . . . </span>I’m sorry for this terrible joke.</p>
</aside>
<p>Otherwise, if we don’t find a <code translate="no">(</code>, we continue to compile the expression as a
super access like we did before and emit an <code translate="no">OP_GET_SUPER</code>.</p>
<p>Drifting down the compilation pipeline, our first stop is a new instruction.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  OP_INVOKE,
</pre><div class="source-file"><em>chunk.h</em><br/>
in enum <em>OpCode</em></div>
<pre class="insert" translate="no">  <span class="a">OP_SUPER_INVOKE</span>,
</pre><pre class="insert-after" translate="no">  OP_CLOSURE,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>
<p>And just past that, its disassembler support.</p>
<div class="codehilite"><pre class="insert-before" translate="no">      return invokeInstruction("OP_INVOKE", chunk, offset);
</pre><div class="source-file"><em>debug.c</em><br/>
in <em>disassembleInstruction</em>()</div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="a">OP_SUPER_INVOKE</span>:
      <span class="k">return</span> <span class="i">invokeInstruction</span>(<span class="s">"OP_SUPER_INVOKE"</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
</pre><pre class="insert-after" translate="no">    case OP_CLOSURE: {
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>
<p>A super invocation instruction has the same set of operands as <code translate="no">OP_INVOKE</code>, so
we reuse the same helper to disassemble it. Finally, the pipeline dumps us into
the interpreter.</p>
<div class="codehilite"><pre class="insert-before" translate="no">        break;
      }
</pre><div class="source-file"><em>vm.c</em><br/>
in <em>run</em>()</div>
<pre class="insert" translate="no">      <span class="k">case</span> <span class="a">OP_SUPER_INVOKE</span>: {
        <span class="t">ObjString</span>* <span class="i">method</span> = <span class="a">READ_STRING</span>();
        <span class="t">int</span> <span class="i">argCount</span> = <span class="a">READ_BYTE</span>();
        <span class="t">ObjClass</span>* <span class="i">superclass</span> = <span class="a">AS_CLASS</span>(<span class="i">pop</span>());
        <span class="k">if</span> (!<span class="i">invokeFromClass</span>(<span class="i">superclass</span>, <span class="i">method</span>, <span class="i">argCount</span>)) {
          <span class="k">return</span> <span class="a">INTERPRET_RUNTIME_ERROR</span>;
        }
        <span class="i">frame</span> = &amp;<span class="i">vm</span>.<span class="i">frames</span>[<span class="i">vm</span>.<span class="i">frameCount</span> - <span class="n">1</span>];
        <span class="k">break</span>;
      }
</pre><pre class="insert-after" translate="no">      case OP_CLOSURE: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p>This handful of code is basically our implementation of <code translate="no">OP_INVOKE</code> mixed
together with a dash of <code translate="no">OP_GET_SUPER</code>. There are some differences in how the
stack is organized, though. With an unoptimized super call, the superclass is
popped and replaced by the ObjBoundMethod for the resolved function <em>before</em> the
arguments to the call are executed. This ensures that by the time the <code translate="no">OP_CALL</code>
is executed, the bound method is <em>under</em> the argument list, where the runtime
expects it to be for a closure call.</p>
<p>With our optimized instructions, things are shuffled a bit:</p><img alt="The series of bytecode instructions for calling super.finish() using OP_SUPER_INVOKE." class="wide" src="image/superclasses/super-invoke.png"/>
<p>Now resolving the superclass method is part of the <em>invocation</em>, so the
arguments need to already be on the stack at the point that we look up the
method. This means the superclass object is on top of the arguments.</p>
<p>Aside from that, the behavior is roughly the same as an <code translate="no">OP_GET_SUPER</code> followed
by an <code translate="no">OP_CALL</code>. First, we pull out the method name and argument count operands.
Then we pop the superclass off the top of the stack so that we can look up the
method in its method table. This conveniently leaves the stack set up just right
for a method call.</p>
<p>We pass the superclass, method name, and argument count to our existing
<code translate="no">invokeFromClass()</code> function. That function looks up the given method on the
given class and attempts to create a call to it with the given arity. If a
method could not be found, it returns <code translate="no">false</code>, and we bail out of the
interpreter. Otherwise, <code translate="no">invokeFromClass()</code> pushes a new CallFrame onto the call
stack for the method’s closure. That invalidates the interpreter’s cached
CallFrame pointer, so we refresh <code translate="no">frame</code>.</p>
<h2><a href="#a-complete-virtual-machine" id="a-complete-virtual-machine"><small>29 . 4</small>A Complete Virtual Machine</a></h2>
<p>Take a look back at what we’ve created. By my count, we wrote around 2,500 lines
of fairly clean, straightforward C. That little program contains a complete
implementation of the<span class="em">—</span>quite high-level!<span class="em">—</span>Lox language, with a whole
precedence table full of expression types and a suite of control flow
statements. We implemented variables, functions, closures, classes, fields,
methods, and inheritance.</p>
<p>Even more impressive, our implementation is portable to any platform with a C
compiler, and is fast enough for real-world production use. We have a
single-pass bytecode compiler, a tight virtual machine interpreter for our
internal instruction set, compact object representations, a stack for storing
variables without heap allocation, and a precise garbage collector.</p>
<p>If you go out and start poking around in the implementations of Lua, Python, or
Ruby, you will be surprised by how much of it now looks familiar to you. You
have seriously leveled up your knowledge of how programming languages work,
which in turn gives you a deeper understanding of programming itself. It’s like
you used to be a race car driver, and now you can pop the hood and repair the
engine too.</p>
<p>You can stop here if you like. The two implementations of Lox you have are
complete and full featured. You built the car and can drive it wherever you want
now. But if you are looking to have more fun tuning and tweaking for even
greater performance out on the track, there is one more chapter. We don’t add
any new capabilities, but we roll in a couple of classic optimizations to
squeeze even more perf out. If that sounds fun, <a href="optimization.html">keep reading</a><span class="ellipse"> . . . </span></p>
<div class="challenges">
<h2><a href="#challenges" id="challenges">Challenges</a></h2>
<ol>
<li>
<p>A tenet of object-oriented programming is that a class should ensure new
objects are in a valid state. In Lox, that means defining an initializer
that populates the instance’s fields. Inheritance complicates invariants
because the instance must be in a valid state according to all of the
classes in the object’s inheritance chain.</p>
<p>The easy part is remembering to call <code translate="no">super.init()</code> in each subclass’s
<code translate="no">init()</code> method. The harder part is fields. There is nothing preventing two
classes in the inheritance chain from accidentally claiming the same field
name. When this happens, they will step on each other’s fields and possibly
leave you with an instance in a broken state.</p>
<p>If Lox was your language, how would you address this, if at all? If you
would change the language, implement your change.</p>
</li>
<li>
<p>Our copy-down inheritance optimization is valid only because Lox does not
permit you to modify a class’s methods after its declaration. This means we
don’t have to worry about the copied methods in the subclass getting out of
sync with later changes to the superclass.</p>
<p>Other languages, like Ruby, <em>do</em> allow classes to be modified after the
fact. How do implementations of languages like that support class
modification while keeping method resolution efficient?</p>
</li>
<li>
<p>In the <a href="inheritance.html">jlox chapter on inheritance</a>, we had a challenge to
implement the BETA language’s approach to method overriding. Solve the
challenge again, but this time in clox. Here’s the description of the
previous challenge:</p>
<p>In Lox, as in most other object-oriented languages, when looking up a
method, we start at the bottom of the class hierarchy and work our way up<span class="em">—</span>a subclass’s method is preferred over a superclass’s. In order to get to the
superclass method from within an overriding method, you use <code translate="no">super</code>.</p>
<p>The language <a href="https://beta.cs.au.dk/">BETA</a> takes the <a href="http://journal.stuffwithstuff.com/2012/12/19/the-impoliteness-of-overriding-methods/">opposite approach</a>. When you call a
method, it starts at the <em>top</em> of the class hierarchy and works <em>down</em>. A
superclass method wins over a subclass method. In order to get to the
subclass method, the superclass method can call <code translate="no">inner</code>, which is sort of
like the inverse of <code translate="no">super</code>. It chains to the next method down the
hierarchy.</p>
<p>The superclass method controls when and where the subclass is allowed to
refine its behavior. If the superclass method doesn’t call <code translate="no">inner</code> at all,
then the subclass has no way of overriding or modifying the superclass’s
behavior.</p>
<p>Take out Lox’s current overriding and <code translate="no">super</code> behavior, and replace it with
BETA’s semantics. In short:</p>
<ul>
<li>
<p>When calling a method on a class, the method <em>highest</em> on the
class’s inheritance chain takes precedence.</p>
</li>
<li>
<p>Inside the body of a method, a call to <code translate="no">inner</code> looks for a method with
the same name in the nearest subclass along the inheritance chain
between the class containing the <code translate="no">inner</code> and the class of <code translate="no">this</code>. If
there is no matching method, the <code translate="no">inner</code> call does nothing.</p>
</li>
</ul>
<p>For example:</p>
<div class="codehilite"><pre translate="no"><span class="k">class</span> <span class="t">Doughnut</span> {
  <span class="i">cook</span>() {
    <span class="k">print</span> <span class="s">"Fry until golden brown."</span>;
    <span class="i">inner</span>();
    <span class="k">print</span> <span class="s">"Place in a nice box."</span>;
  }
}

<span class="k">class</span> <span class="t">BostonCream</span> &lt; <span class="t">Doughnut</span> {
  <span class="i">cook</span>() {
    <span class="k">print</span> <span class="s">"Pipe full of custard and coat with chocolate."</span>;
  }
}

<span class="t">BostonCream</span>().<span class="i">cook</span>();
</pre></div>
<p>This should print:</p>
<div class="codehilite"><pre translate="no">Fry until golden brown.
Pipe full of custard and coat with chocolate.
Place in a nice box.
</pre></div>
<p>Since clox is about not just implementing Lox, but doing so with good
performance, this time around try to solve the challenge with an eye towards
efficiency.</p>
</li>
</ol>
</div>
<footer>
<a class="next" href="optimization.html">
  Next Chapter: “Optimization” →
</a>
Handcrafted by Robert Nystrom — <a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">© 2015 – 2021</a>
</footer>
</img></img></img></article>
</div>
</body>
</html>
