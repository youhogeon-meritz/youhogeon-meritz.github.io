<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link rel="stylesheet" type="text/css" href="cid:css-53092cbe-27cf-4abc-94c9-fa7d84f90df0@mhtml.blink" />

<title>A Virtual Machine · Crafting Interpreters</title>
<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta content="width=device-width, initial-scale=1" name="viewport">
<link href="https://youhogeon-meritz.github.io/style.css" rel="stylesheet" type="text/css">
<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600" rel="stylesheet" type="text/css">
<link href="https://youhogeon-meritz.github.io/image/favicon.png" rel="icon" type="image/png">


<!-- Google analytics -->

</head>
<body id="top">
<!-- <div class="scrim"></div> -->
<nav class="wide">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<div class="contents">
<h3><a href="https://youhogeon-meritz.github.io/a-virtual-machine.html#top"><font papago-translate="splitted"><font papago-translate="translated">가상 머신</font></font><small>15</small></a></h3>
<ul>
<li><a href="https://youhogeon-meritz.github.io/a-virtual-machine.html#an-instruction-execution-machine"><small>15.1</small><font papago-translate="splitted"><font papago-translate="translated"> 명령어 실행 기계</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/a-virtual-machine.html#a-value-stack-manipulator"><small>15.2</small><font papago-translate="splitted"><font papago-translate="translated"> 가치 스택 조작기</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/a-virtual-machine.html#an-arithmetic-calculator"><small>15.3</small><font papago-translate="splitted"><font papago-translate="translated"> 산술 계산기</font></font></a></li>
<li class="divider"></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/a-virtual-machine.html#challenges"><font papago-translate="translated">과제들</font></a></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/a-virtual-machine.html#design-note"><small><font papago-translate="translated">메모</font></small><font papago-translate="splitted"><font papago-translate="translated">레지스터 기반 바이트코드</font></font></a></li>
</ul>
<div class="prev-next">
<a class="left" href="https://youhogeon-meritz.github.io/chunks-of-bytecode.html" title="바이트코드 덩어리" papago-attr-id="1"><font papago-translate="translated">← 이전</font></a>
<a href="https://youhogeon-meritz.github.io/a-bytecode-virtual-machine.html" title="바이트코드 가상 머신" papago-attr-id="2"><font papago-translate="translated">↑ 위로</font></a>
<a class="right" href="https://youhogeon-meritz.github.io/scanning-on-demand.html" title="온디맨드 스캔" papago-attr-id="3"><font papago-translate="translated">다음 →</font></a>
</div> </div>
</nav>
<nav class="narrow">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<a class="prev" href="https://youhogeon-meritz.github.io/chunks-of-bytecode.html" title="Chunks of Bytecode">←</a>
<a class="next" href="https://youhogeon-meritz.github.io/scanning-on-demand.html" title="Scanning on Demand">→</a>
</nav>
<div class="page">
<div class="nav-wrapper">
<nav class="floating">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<div class="expandable">
<h3><a href="https://youhogeon-meritz.github.io/a-virtual-machine.html#top"><font papago-translate="splitted"><font papago-translate="translated">가상 머신</font></font><small>15</small></a></h3>
<ul>
<li><a href="https://youhogeon-meritz.github.io/a-virtual-machine.html#an-instruction-execution-machine"><small>15.1</small><font papago-translate="splitted"><font papago-translate="translated"> 명령어 실행 기계</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/a-virtual-machine.html#a-value-stack-manipulator"><small>15.2</small><font papago-translate="splitted"><font papago-translate="translated"> 가치 스택 조작기</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/a-virtual-machine.html#an-arithmetic-calculator"><small>15.3</small><font papago-translate="splitted"><font papago-translate="translated"> 산술 계산기</font></font></a></li>
<li class="divider"></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/a-virtual-machine.html#challenges">Challenges</a></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/a-virtual-machine.html#design-note"><small>note</small><font papago-translate="splitted"><font papago-translate="translated">레지스터 기반 바이트코드</font></font></a></li>
</ul>
<div class="prev-next">
<a class="left" href="https://youhogeon-meritz.github.io/chunks-of-bytecode.html" title="Chunks of Bytecode">←&nbsp;Previous</a>
<a href="https://youhogeon-meritz.github.io/a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">↑&nbsp;Up</a>
<a class="right" href="https://youhogeon-meritz.github.io/scanning-on-demand.html" title="Scanning on Demand">Next&nbsp;→</a>
</div> </div>
<a id="expand-nav">≡</a>
</nav>
</div>
<article class="chapter">
<div class="number">15</div>
<h1><font papago-translate="translated">가상 머신</font></h1>
<blockquote>
<p><font papago-translate="translated">마술사들은 비밀이 크고 중요해서가 아니라, 그 비밀이 너무 작고 사소해서 보호합니다.</font><font papago-translate="translated"> 무대에서 만들어내는 놀라운 효과는 종종 너무 터무니없는 비밀의 결과로, 마술사가 그렇게 했다는 사실을 인정하는 것을 부끄러워할 정도입니다.</font></p>
<p><cite>Christopher Priest, <em>The Prestige</em></cite></p>
</blockquote>
<p><font papago-translate="translated" class="">우리는 프로그램을 바이트코드 지침의 연속으로 표현하는 방법에 대해 많은 시간을 보냈지만, 마치 박제된 죽은 동물만을 사용하여 생물학을 배우는 것처럼 느껴집니다.</font><font papago-translate="translated"> 이론적으로는 어떤 지시가 있는지 알고 있지만 실제로 실행되는 것을 본 적이 없기 때문에 그 지시가 무엇<em>을 하는지</em> 제대로 이해하기 어렵습니다.</font><font papago-translate="translated"> 바이트코드가 어떻게 작동하는지에 대한 이해가 부족할 때 바이트코드를 출력하는 컴파일러를 작성하는 것은 어려울 것입니다.</font></p>
<p><font papago-translate="translated">그래서 새로운 인터프리터의 프런트엔드를 구축하기 전에,<span class="em"></span> 먼저 백엔드, 즉 명령어를 실행하는 가상 머신부터 시작하겠습니다.</font><font papago-translate="translated"> 바이트코드에 생명을 불어넣습니다.</font><font papago-translate="translated"> 명령어들이 이리저리 움직이는 것을 보면 컴파일러가 사용자의 소스 코드를 일련의 명령어로 어떻게 번역할 수 있는지 더 명확하게 알 수 있습니다.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/a-virtual-machine.html#an-instruction-execution-machine" id="an-instruction-execution-machine"><small><font papago-translate="translated">15 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">명령어 실행 기계</font></font></a></h2>
<p><font papago-translate="translated">가상 머신은 우리 통역사의 내부 아키텍처 중 하나입니다.</font><font papago-translate="translated"> 코드 덩어리를 건네주면<span class="em"></span><span class="em"></span>, 말 그대로 덩어리가 실행됩니다.</font><font papago-translate="translated"> VM의 코드와 데이터 구조는 새로운 모듈에 있습니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">VM.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 새 파일 만들기</font></font></div>
<pre translate="no"><span class="a">#ifndef clox_vm_h</span>
<span class="a">#define clox_vm_h</span>

<span class="a">#include "chunk.h"</span>

<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">Chunk</span>* <span class="i">chunk</span>;
} <span class="a">VM</span>;

<span class="t">void</span> <span class="i">initVM</span>();
<span class="t">void</span> <span class="i">freeVM</span>();

<span class="a">#endif</span>
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, create new file</div>
<p><font papago-translate="translated">평소처럼, 우리는 간단하게 시작합니다.</font><font papago-translate="translated"> VM은 점차 추적해야 할 전체 상태 더미를 얻게 될 것이므로 이제 이 모든 것을 담을 수 있는 구조를 정의합니다.</font><font papago-translate="translated"> 현재 우리가 저장하는 것은 실행되는 청크뿐입니다.</font></p>
<p><font papago-translate="translated">우리가 만드는 대부분의 데이터 구조와 마찬가지로, VM을 생성하고 분해하는 기능도 정의합니다.</font><font papago-translate="translated"> 구현은 다음과 같습니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 새 파일 만들기</font></font></div>
<pre translate="no"><span class="a">#include "common.h"</span>
<span class="a">#include "vm.h"</span>

<span class="a">VM</span> <span class="i">vm</span>;<span name="one"> </span>

<span class="t">void</span> <span class="i">initVM</span>() {
}

<span class="t">void</span> <span class="i">freeVM</span>() {
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, create new file</div>
<p><font papago-translate="translated">좋아요, 그 기능들을 "구현"이라고 부르는 것은 무리입니다.</font><font papago-translate="translated"> 아직 초기화하거나 자유롭게 할 흥미로운 상태가 없어서 함수가 비어 있습니다.</font><font papago-translate="translated"> 저를 믿으세요, 우리는 거기까지 갈 거예요.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">여기서 조금 더 흥미로운 점은 다음과 같은 선언입니다 </font></font><code translate="no">vm</code><font papago-translate="splitted"><font papago-translate="translated">. 이 모듈은 결국 여러 가지 기능을 갖추게 될 것이며, VM의 포인터를 모두에게 전달하는 것은 번거로울 것입니다.</font><font papago-translate="translated"> 대신, 우리는 단일 글로벌 VM 객체를 선언합니다.</font><font papago-translate="translated"> 어차피 하나만 필요하고, 이렇게 하면 책의 코드가 페이지에 조금 더 가볍게 유지됩니다.</font></font></p>
<aside name="one" style="top: 1475px;">
<p><font papago-translate="translated">정적 VM 인스턴스를 선택하는 것은 책에 대한 양보이지만, 실제 언어 구현을 위한 반드시 건전한 엔지니어링 선택은 아닙니다.</font><font papago-translate="translated"> 다른 호스트 애플리케이션에 내장되도록 설계된 VM을 구축하는 경우, 명시적으로 VM 포인터를 가져와서<em></em> 전달하면 호스트에 더 많은 유연성을 제공합니다.</font></p>
<p><font papago-translate="translated">그렇게 하면 호스트 앱이 VM의 메모리가 할당되는 시기와 위치를 제어하고, 여러 VM을 병렬로 실행하는 등의 작업을 수행할 수 있습니다.</font></p>
<p><font papago-translate="translated">제가 여기서 하고 있는 일은 전역 변수입니다.<a href="http://gameprogrammingpatterns.com/singleton.html"> 전역 변수에 대해 들었던 나쁜 이야기들은</a> 대부분 프로그래밍할 때 여전히 사실입니다.</font><font papago-translate="translated"> 하지만 책을 위해 물건을 작게 보관할 때<span class="ellipse"> . . .</span></font></p>
</aside>
<p><font papago-translate="translated">재미있는 코드를 VM에 펌핑하기 전에 인터프리터의 주요 진입점에 연결해 보겠습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">int main(int argc, const char* argv[]) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">주요.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>메인</em> ()에서</font></font></div>
<pre class="insert" translate="no">  <span class="i">initVM</span>();

</pre><pre class="insert-after" translate="no">  Chunk chunk;
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>main</em>()</div>
<p><font papago-translate="translated">인터프리터가 처음 시작되면 VM을 회전시킵니다.</font><font papago-translate="translated"> 그런 다음 우리가 막 나가려고 할 때, 우리는 그것을 마무리합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  disassembleChunk(&amp;chunk, "test chunk");
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">주요.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>메인</em> ()에서</font></font></div>
<pre class="insert" translate="no">  <span class="i">freeVM</span>();
</pre><pre class="insert-after" translate="no">  freeChunk(&amp;chunk);
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>main</em>()</div>
<p><font papago-translate="translated">마지막 의식적 의무:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#include "debug.h"
</pre><div class="source-file"><em><font papago-translate="translated">주요.c</font></em></div>
<pre class="insert" translate="no"><span class="a">#include "vm.h"</span>
</pre><pre class="insert-after" translate="no">
int main(int argc, const char* argv[]) {
</pre></div>
<div class="source-file-narrow"><em>main.c</em></div>
<p><font papago-translate="translated">이제 clox를 실행하면<a href="https://youhogeon-meritz.github.io/chunks-of-bytecode.html#disassembling-chunks"> 마지막 장</a>에서 직접 작성한 청크를 생성하기 전에 VM이 시작됩니다.</font><font papago-translate="translated"> VM이 준비되어 기다리고 있으니, 무언가를 하도록 가르쳐 보겠습니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/a-virtual-machine.html#executing-instructions" id="executing-instructions"><small><font papago-translate="translated">15 . 1 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">지침 실행</font></font></a></h3>
<p><font papago-translate="translated">VM이 바이트코드의 일부를 해석하도록 명령하면 실행됩니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  disassembleChunk(&amp;chunk, "test chunk");
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">주요.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>메인</em> ()에서</font></font></div>
<pre class="insert" translate="no">  <span class="i">interpret</span>(&amp;<span class="i">chunk</span>);
</pre><pre class="insert-after" translate="no">  freeVM();
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>main</em>()</div>
<p><font papago-translate="translated">이 기능은 VM의 주요 진입점입니다.</font><font papago-translate="translated"> 이렇게 선언되었습니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">void freeVM();
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">VM.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>freeVM</em>() 이후에 추가</font></font></div>
<pre class="insert" translate="no"><span class="t">InterpretResult</span> <span class="i">interpret</span>(<span class="t">Chunk</span>* <span class="i">chunk</span>);
</pre><pre class="insert-after" translate="no">
#endif
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, add after <em>freeVM</em>()</div>
<p><font papago-translate="translated">VM은 청크를 실행한 다음 이 항목의 값으로 응답합니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">} VM;

</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">VM.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 구조 후<em> VM</em> 추가</font></font></div>
<pre class="insert" translate="no"><span class="k">typedef</span> <span class="k">enum</span> {
  <span class="a">INTERPRET_OK</span>,
  <span class="a">INTERPRET_COMPILE_ERROR</span>,
  <span class="a">INTERPRET_RUNTIME_ERROR</span>
} <span class="t">InterpretResult</span>;

</pre><pre class="insert-after" translate="no">void initVM();
void freeVM();
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, add after struct <em>VM</em></div>
<p><font papago-translate="translated">아직 결과를 사용하지는 않지만, 정적 오류를 보고하는 컴파일러와 런타임 오류를 감지하는 VM이 있으면 인터프리터는 이를 사용하여 프로세스의 종료 코드를 설정하는 방법을 알 수 있습니다.</font></p>
<p><font papago-translate="translated">우리는 실제 구현을 향해 나아가고 있습니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>freeVM</em>() 이후에 추가</font></font></div>
<pre translate="no"><span class="t">InterpretResult</span> <span class="i">interpret</span>(<span class="t">Chunk</span>* <span class="i">chunk</span>) {
  <span class="i">vm</span>.<span class="i">chunk</span> = <span class="i">chunk</span>;
  <span class="i">vm</span>.<span class="i">ip</span> = <span class="i">vm</span>.<span class="i">chunk</span>-&gt;<span class="i">code</span>;
  <span class="k">return</span> <span class="i">run</span>();
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>freeVM</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">먼저, 실행 중인 청크를 VM에 저장합니다.</font><font papago-translate="translated"> 그러면 우리는 전화합니다 </font></font><code translate="no">run()</code><font papago-translate="splitted"><font papago-translate="translated">, 바이트코드 명령어를 실제로 실행하는 내부 도우미 기능입니다.</font><font papago-translate="translated"> 그 두 부분 사이에는 흥미로운 선이 있습니다.</font><font papago-translate="translated"> 이것은 무엇인가… </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated"> 사업?</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">VM이 바이트코드를 통과하면서 현재<span class="em"></span> 실행 중인 명령어의 위치를 추적합니다.</font><font papago-translate="translated"> 우리는 내부<span name="local">에 지역</span> 변수를 사용하지 않습니다 </font></font><code translate="no">run()</code><font papago-translate="splitted"><font papago-translate="translated"> 이를 위해 결국 다른 기능들이 접근해야 하기 때문입니다.</font><font papago-translate="translated"> 대신 VM에 필드로 저장합니다.</font></font></p>
<aside name="local" style="top: 3452px;">
<p><font papago-translate="splitted"><font papago-translate="translated">바이트코드 인터프리터에서 모든 온스의 속도를 짜내려고 한다면, 우리는 저장할 것입니다 </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated"> 지역 변수에서.</font><font papago-translate="translated"> 실행 중에 너무 자주 수정되어 C 컴파일러가 레지스터에 보관하기를 원합니다.</font></font></p>
</aside>
<div class="codehilite"><pre class="insert-before" translate="no">typedef struct {
  Chunk* chunk;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">VM.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em></em>구조 VM에서</font></font></div>
<pre class="insert" translate="no">  <span class="t">uint8_t</span>* <span class="i">ip</span>;
</pre><pre class="insert-after" translate="no">} VM;
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, in struct <em>VM</em></div>
<p><font papago-translate="translated">그것의 유형은 바이트 포인터입니다.</font><font papago-translate="translated"> 우리는 정수 인덱스와 같은 것 대신 바이트코드 배열의 중간을 가리키는 실제 C 포인터를 사용합니다. 왜냐하면 인덱스를 기준으로 배열의 요소를 찾는 것보다 포인터를 기준에서 벗어나는 것이 더 빠르기 때문입니다.</font></p>
<p><font papago-translate="translated">"IP"라는 이름은 전통적이며, CS의 많은 전통적인 이름들과는 달리<strong><a href="https://en.wikipedia.org/wiki/Program_counter"> 실제로</a></strong> 의미가 있습니다. 이는<strong><a href="https://en.wikipedia.org/wiki/Program_counter"> 명령</a></strong><span class="em"></span><span class="em"></span><strong><a href="https://en.wikipedia.org/wiki/Program_counter">어 포인터</a></strong>입니다.</font><font papago-translate="translated"> 전<span name="ip"> 세계</span>의 거의 모든 명령어 세트에는 실제와 가상 모두 이와 같은 레지스터나 변수가 있습니다.</font></p>
<aside name="ip" style="top: 3772px;">
<p><font papago-translate="translated">x86, x64, 그리고 CLR은 이를 "IP"라고 부릅니다. 68k, PowerPC, ARM, p-코드, 그리고 JVM은<strong> 프로그램 카운터</strong>를 "PC"라고 부릅니다.</font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">초기화 </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated"> 청크의 코드 첫 번째 바이트를 가리키며.</font><font papago-translate="translated"> 아직 그 지시를 실행하지 않았기 때문에 </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated"> <em>실행될</em> 지침을 가리킵니다.</font><font papago-translate="translated"> 이는 VM이 실행되는 동안에도 적용됩니다. IP는 항상 현재 처리 중인 명령이 아닌 다음 명령을 가리킵니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">진정한 재미는 다음과 같습니다 </font></font><code translate="no">run</code><font papago-translate="splitted"><font papago-translate="translated">().</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>freeVM</em>() 이후에 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">InterpretResult</span> <span class="i">run</span>() {
<span class="a">#define READ_BYTE() (*vm.ip++)</span>

  <span class="k">for</span> (;;) {
    <span class="t">uint8_t</span> <span class="i">instruction</span>;
    <span class="k">switch</span> (<span class="i">instruction</span> = <span class="a">READ_BYTE</span>()) {
      <span class="k">case</span> <span class="a">OP_RETURN</span>: {
        <span class="k">return</span> <span class="a">INTERPRET_OK</span>;
      }
    }
  }

<span class="a">#undef READ_BYTE</span>
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>freeVM</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">이것은 지금까지 모든 클록스에서 가장<span name="important"> 중요</span>한 단일 기능입니다.</font><font papago-translate="translated"> 통역사가 사용자의 프로그램을 실행할 때, 약 90%의 시간을 내부에서 보냅니다 </font></font><code translate="no">run()</code><font papago-translate="splitted"><font papago-translate="translated">. 그것은 VM의 심장 박동입니다.</font></font></p>
<aside name="important" style="top: 4292px;">
<p><font papago-translate="translated">또는 적어도 유용할 만한 충분한 콘텐츠가 있을 때는 몇 장 안에 있을<em> 것입니다</em>.</font><font papago-translate="translated"> 지금은 소프트웨어 마법의 경이로움이 아닙니다.</font></p>
</aside>
<p><font papago-translate="translated">극적인 도입부에도 불구하고 개념적으로는 꽤 간단합니다.</font><font papago-translate="translated"> 우리는 왔다 갔다 하는 외부 루프를 가지고 있습니다.</font><font papago-translate="translated"> 그 루프를 통과할 때마다, 우리는 하나의 바이트코드 명령어를 읽고 실행합니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">명령어를 처리하기 위해 먼저 어떤 종류의 명령어를 다루고 있는지 파악합니다.</font><font papago-translate="translated"> 그 </font></font><code translate="no">READ_BYTE</code><font papago-translate="splitted"><font papago-translate="translated"> 매크로는 현재 다음과 같은 바이트를 읽습니다 </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고 나서 지시 포인터<span name="next">를 앞으로 이동</span>합니다.</font><font papago-translate="translated"> 모든 명령어의 첫 번째 바이트는 opcode입니다.</font><font papago-translate="translated"> 숫자 연산 코드가 주어지면 해당 명령어의 의미를 구현하는 올바른 C 코드에 도달해야 합니다.</font><font papago-translate="translated"> 이 과정을<strong> 디코딩</strong> 또는<strong> 디스패치</strong>라고 합니다.</font></font></p>
<aside name="next" style="top: 4532px;">
<p><font papago-translate="splitted"><font papago-translate="translated">참고로 </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated"> 명령어를 실제로 실행하기 전에, 우리가 오피코드를 읽자마자 진행됩니다.</font><font papago-translate="translated"> 그래서 다시, </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated"> 사용<em></em>할 다음 바이트 코드를 가리킵니다.</font></font></p>
</aside>
<p><font papago-translate="translated">우리는 각 명령어가 실행될 때마다 그 과정을 수행하므로, 이것이 전체 가상 머신에서 가장 성능이 중요한 부분입니다.</font><font papago-translate="translated"> 프로그래밍 언어의 전설은 바이트코드를 효율적으로 전송할<span name="dispatch"> 수</span> 있는<span name="dispatch"> 영리</span>한 기술로 가득 차 있으며, 이는 컴퓨터의 초기 시절로 거슬러 올라갑니다.</font></p>
<aside name="dispatch" style="top: 4676px;">
<p><font papago-translate="translated">이러한 기술 중 일부를 배우고 싶다면 "직접 스레드 코드", "점프 테이블", "계산된 고토"를 찾아보세요.</font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">안타깝게도 가장 빠른 솔루션은 C로의 비표준 확장 또는 손으로 작성한 어셈블리 코드가 필요합니다.</font><font papago-translate="translated"> clox의 경우, 간단하게 하겠습니다.</font><font papago-translate="translated"> 우리의 분해기와 마찬가지로, 우리는 하나의 거대한 장치를 가지고 있습니다 </font></font><code translate="no">switch</code><font papago-translate="splitted"><font papago-translate="translated"> 각 오피코드에 대한 대소문자가 포함된 문장.</font><font papago-translate="translated"> 각 케이스의 본문은 해당 옵코드의 동작을 구현합니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">지금까지 우리는 단 하나의 지시만 처리합니다, </font></font><code translate="no">OP_RETURN</code><font papago-translate="splitted"><font papago-translate="translated">, 그리고 그것이 하는 유일한 일은 루프를 완전히 벗어나는 것입니다.</font><font papago-translate="translated"> 결국, 해당 명령어는 현재 Lox 함수에서 반환되는 데 사용될 것이지만, 아직 함수가 없기 때문에 실행을 종료하기 위해 일시적으로 용도를 변경할 것입니다.</font></font></p>
<p><font papago-translate="translated">다른 한 가지 지침을 지원해 보겠습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    switch (instruction = READ_BYTE()) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font></div>
<pre class="insert" translate="no">      <span class="k">case</span> <span class="a">OP_CONSTANT</span>: {
        <span class="t">Value</span> <span class="i">constant</span> = <span class="a">READ_CONSTANT</span>();
        <span class="i">printValue</span>(<span class="i">constant</span>);
        <span class="i">printf</span>(<span class="s">"</span><span class="e">\n</span><span class="s">"</span>);
        <span class="k">break</span>;
      }
</pre><pre class="insert-after" translate="no">      case OP_RETURN: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">우리는 아직 상수로 유용한 작업을 수행할 충분한 기계가 없습니다.</font><font papago-translate="translated"> 지금은 해커들이 VM 내부에서 무슨 일이 일어나고 있는지 볼 수 있도록 그냥 출력해 보겠습니다.</font><font papago-translate="translated"> 그 부름은 </font></font><code translate="no">printf()</code><font papago-translate="splitted"><font papago-translate="translated"> 포함이 필요합니다.</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 파일 위에 추가</font></font></div>
<pre class="insert" translate="no"><span class="a">#include &lt;stdio.h&gt;</span>

</pre><pre class="insert-after" translate="no">#include "common.h"
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add to top of file</div>
<p><font papago-translate="translated">우리는 또한 정의할 새로운 매크로가 있습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#define READ_BYTE() (*vm.ip++)
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font></div>
<pre class="insert" translate="no"><span class="a">#define READ_CONSTANT() (vm.chunk-&gt;constants.values[READ_BYTE()])</span>
</pre><pre class="insert-after" translate="no">
  for (;;) {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p><code translate="no">READ_CONSTANT()</code><font papago-translate="splitted"><font papago-translate="translated"> 바이트코드에서 다음 바이트를 읽고, 결과 숫자를 인덱스로 처리한 다음, 청크의 상수 테이블에서 해당 값을 찾습니다.</font><font papago-translate="translated"> 이후 장에서는 상수를 참조하는 피연산자와 함께 몇 가지 지침을 추가할 예정이므로 이제 이 헬퍼 매크로를 설정합니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">이전과 마찬가지로 </font></font><code translate="no">READ_BYTE</code><font papago-translate="splitted"><font papago-translate="translated"> 매크로, </font></font><code translate="no">READ_CONSTANT</code><font papago-translate="splitted"><font papago-translate="translated"> 내부에서만 사용됩니다 </font></font><code translate="no">run()</code><font papago-translate="splitted"><font papago-translate="translated">. 범위를 더 명확하게 하기 위해 매크로 정의 자체는 해당 함수에 국한됩니다.</font><font papago-translate="translated"> 우리는 처음에는 그것들<span name="macro">을 정의</span>하고, 결국에는 우리가 신경 쓰기 때문에<span class="em"></span><span class="em"></span> 정의를 해제합니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#undef READ_BYTE
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font></div>
<pre class="insert" translate="no"><span class="a">#undef READ_CONSTANT</span>
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<aside name="macro" style="top: 5720px;">
<p><font papago-translate="translated">이러한 매크로를 명시적으로 정의 해제하는 것은 불필요하게 까다로워 보일 수 있지만, C는 허술한 사용자를 처벌하는 경향이 있고 C 전처리기는 두 배로 처벌합니다.</font></p>
</aside>
<h3><a href="https://youhogeon-meritz.github.io/a-virtual-machine.html#execution-tracing" id="execution-tracing"><small><font papago-translate="translated">15 . 1 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">실행 추적</font></font></a></h3>
<p><font papago-translate="splitted"><font papago-translate="translated">지금 clox를 실행하면 지난 장에서 손으로 작성한 청크를 실행하고 뱉어냅니다 </font></font><code translate="no">1.2</code><font papago-translate="splitted"><font papago-translate="translated"> 단말기로.</font><font papago-translate="translated"> 우리는 그것이 효과가 있다는 것을 알 수 있지만, 그것은 단지 우리의 구현 때문입니다 </font></font><code translate="no">OP_CONSTANT</code><font papago-translate="splitted"><font papago-translate="translated"> 값을 기록하기 위한 임시 코드가 있습니다.</font><font papago-translate="translated"> 그 명령어가 원래 해야 할 일을 하고 그것을 소비하려는 다른 작업에 맞춰 일정하게 배관을 하면, VM은 블랙박스가 될 것입니다.</font><font papago-translate="translated"> 이는 VM 구현자로서의 우리의 삶을 더 어렵게 만듭니다.</font></font></p>
<p><font papago-translate="translated">지금이야말로 청크 자체에서 그랬던 것처럼 VM에 진단 로깅을 추가하기에 좋은 시기입니다.</font><font papago-translate="translated"> 사실, 우리는 같은 코드를 재사용할 것입니다.</font><font papago-translate="translated"> 우리는 이 로깅이 항상 활성화되는 것을 원하지 않습니다. 이는 Lox 사용자가 아닌 VM 해커들만을 위한 것이기 때문에, 먼저<span class="em"></span><span class="em"></span> 이를 숨기기 위해 플래그를 만듭니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#include &lt;stdint.h&gt;
</pre><div class="source-file"><em><font papago-translate="translated">일반적인.h</font></em></div>
<pre class="insert" translate="no">
<span class="a">#define DEBUG_TRACE_EXECUTION</span>
</pre><pre class="insert-after" translate="no">
#endif
</pre></div>
<div class="source-file-narrow"><em>common.h</em></div>
<p><font papago-translate="translated">이 플래그가 정의되면 VM은 각 명령어를 실행하기 직전에 분해하고 인쇄합니다.</font><font papago-translate="translated"> 이전 분해기가 전체 덩어리를 정적으로 한 번 걸었을 때, 이는 명령어를 즉시 동적으로 분해합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  for (;;) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font></div>
<pre class="insert" translate="no"><span class="a">#ifdef DEBUG_TRACE_EXECUTION</span>
    <span class="i">disassembleInstruction</span>(<span class="i">vm</span>.<span class="i">chunk</span>,
                           (<span class="t">int</span>)(<span class="i">vm</span>.<span class="i">ip</span> - <span class="i">vm</span>.<span class="i">chunk</span>-&gt;<span class="i">code</span>));
<span class="a">#endif</span>

</pre><pre class="insert-after" translate="no">    uint8_t instruction;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">부터 </font></font><code translate="no">disassembleInstruction()</code><font papago-translate="splitted"><font papago-translate="translated"> 정수 바이트<em> 오프셋</em>을 가져와서 현재 명령 참조를 직접 포인터로 저장하고, 먼저 작은 포인터 계산을 통해 변환합니다 </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated"> 바이트코드의 시작부터 상대적인 오프셋으로 돌아갑니다.</font><font papago-translate="translated"> 그런 다음 해당 바이트에서 시작하는 명령어를 분해합니다.</font></font></p>
<p><font papago-translate="translated">언제나 그렇듯이 함수를 부르기 전에 함수의 선언을 가져와야 합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#include "common.h"
</pre><div class="source-file"><em>vm.c</em></div>
<pre class="insert" translate="no"><span class="a">#include "debug.h"</span>
</pre><pre class="insert-after" translate="no">#include "vm.h"
</pre></div>
<div class="source-file-narrow"><em>vm.c</em></div>
<p><font papago-translate="splitted"><font papago-translate="translated">이 코드가 아직까지는 그다지 인상적이지 않다는 것을 알고 있습니다. 말 그대로 스위치 문장<span class="em"></span>으로 포장되어 있습니다 </font></font><code translate="no">for</code><font papago-translate="splitted"><font papago-translate="translated"> 하지만 믿기 어렵겠지만, 이것은 우리 VM의 두 가지 주요 구성 요소 중 하나입니다.</font><font papago-translate="translated"> 이것으로 우리는 명령어를 긴급히 실행할 수 있습니다.</font><font papago-translate="translated"> 그것의 단순함은 미덕입니다. 일을 덜 할수록 더 빨리<span class="em"></span> 할 수 있습니다.</font><font papago-translate="translated"> 이를 AST를 걷기 위한 방문자 패턴과 함께 Jlox의 모든 복잡성과 오버헤드와 대조해 보세요.</font></font></p>
<h2><a href="https://youhogeon-meritz.github.io/a-virtual-machine.html#a-value-stack-manipulator" id="a-value-stack-manipulator"><small><font papago-translate="translated">15 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">가치 스택 조작기</font></font></a></h2>
<p><font papago-translate="translated">Lox는 명령적인 부작용 외에도 가치를 생성하고 수정하며 소비하는 표현을 가지고 있습니다.</font><font papago-translate="translated"> 따라서 컴파일된 바이트코드는 필요한 서로 다른 명령어 간에 값을 교환할 수 있는 방법이 필요합니다.</font><font papago-translate="translated"> 예를 들어:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">print</span> <span class="n">3</span> - <span class="n">2</span>;
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">우리는 분명히 상수 3과 2에 대한 지침이 필요합니다 </font></font><code translate="no">print</code><font papago-translate="splitted"><font papago-translate="translated"> 문장과 뺄셈.</font><font papago-translate="translated"> 하지만 뺄셈 명령어는 3이<span name="word"> 미뉴엔드</span>이고 2가 미뉴엔드라는 것을 어떻게 알 수 있을까요?</font><font papago-translate="translated"> 인쇄 지침이 그 결과를 인쇄하는 방법을 어떻게 알 수 있습니까?</font></font></p>
<aside name="word" style="top: 7324px;">
<p><font papago-translate="translated">네, 사전에서 "서브트라엔드"와 "미누엔드"를 찾아봐야 했어요.</font><font papago-translate="translated"> 하지만 그것들은 즐거운 말이 아닌가요?</font><font papago-translate="translated"> "미누엔드"는 일종의 엘리자베스 시대 춤처럼 들리고, "지하"는 일종의 지하 구석기 시대 기념물일 수 있습니다.</font></p>
</aside>
<p><font papago-translate="translated">더 자세히 설명하자면, 바로 여기 있는 이것을 보세요:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">fun</span> <span class="i">echo</span>(<span class="i">n</span>) {
  <span class="k">print</span> <span class="i">n</span>;
  <span class="k">return</span> <span class="i">n</span>;
}

<span class="k">print</span> <span class="i">echo</span>(<span class="i">echo</span>(<span class="n">1</span>) + <span class="i">echo</span>(<span class="n">2</span>)) + <span class="i">echo</span>(<span class="i">echo</span>(<span class="n">4</span>) + <span class="i">echo</span>(<span class="n">5</span>));
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">다음과 같은 전화를 통해 각 하위 표현식을 마무리했습니다 </font></font><code translate="no">echo()</code><font papago-translate="splitted"><font papago-translate="translated"> 그것은 주장을 출력하고 반환합니다.</font><font papago-translate="translated"> 그 부작용은 우리가 정확한 작업 순서를 볼 수 있다는 것을 의미합니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">VM에 대해 잠시도 걱정하지 마세요.</font><font papago-translate="translated"> Lox 자체의 의미만 생각해 보세요.</font><font papago-translate="translated"> 연산 자체를 수행하기 전에 산술 연산자의 피연산자를 평가해야 합니다.</font><font papago-translate="translated"> (추가하기가 꽤 어렵습니다 </font></font><code translate="no">a + b</code><font papago-translate="splitted"><font papago-translate="translated"> 만약 당신이 그것을 모른다면 </font></font><code translate="no">a</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">b</code><font papago-translate="splitted"><font papago-translate="translated"> ) 또한, jlox로 표현을 구현할 때 왼쪽 피연산자를 오른쪽보다 먼저 평가해야<span name="undefined"> 한다고 결정했습니다</span>.</font></font></p>
<aside name="undefined" style="top: 7756px;">
<p><font papago-translate="translated">평가 순서를 지정하지 않고 각 구현이 결정하도록 내버려둘 수도 있었습니다.</font><font papago-translate="translated"> 이는 피연산자가 눈에 보이는 부작용이 있는 경우에도 컴파일러가 효율성을 위해 산술 표현식을 재정렬할 수 있도록 최적화할 수 있는 문을 열어줍니다.</font><font papago-translate="translated"> C와 체계는 평가 순서를 지정하지 않습니다.</font><font papago-translate="translated"> Java는 Lox와 마찬가지로 왼쪽에서 오른쪽으로 평가를 지정합니다.</font></p>
<p><font papago-translate="translated">이런 것들을 고정하는 것이 일반적으로 사용자들에게 더 좋다고 생각합니다.</font><font papago-translate="translated"> 표현식이 사용자 직관 순서대로 평가되지 않을 때 -<span class="em"></span> 구현마다 다른 순서로 평가될 수 있습니다!</font><font papago-translate="translated"><span class="em">-</span>무슨 일이 일어나고<span class="em"> 있는지</span> 알아내는 것은 불타는 지옥 같은 고통이 될 수 있습니다<span class="em">.</span></font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">다음은 구문 트리입니다 </font></font><code translate="no">print</code><font papago-translate="splitted"><font papago-translate="translated"> 진술:</font></font></p>
<p><img alt="The AST for the example
statement, with numbers marking the order that the nodes are evaluated." src="https://youhogeon-meritz.github.io/image/a-virtual-machine/ast.png"></p>
<p><font papago-translate="translated">왼쪽에서 오른쪽으로 평가하고 표현식이 중첩되는 방식을 고려할 때, 올바른 Lox 구현은 다음과 같은 순서로 이 숫자를 출력<em>해야 합니다</em>:</font></p>
<div class="codehilite"><pre translate="no">1  // from echo(1)
2  // from echo(2)
3  // from echo(1 + 2)
4  // from echo(4)
5  // from echo(5)
9  // from echo(4 + 5)
12 // from print 3 + 9
</pre></div>
<p><font papago-translate="translated">우리의 오래된 Jlox 인터프리터는 AST를 재귀적으로 탐색함으로써 이를 달성합니다.</font><font papago-translate="translated"> 그것은 후순 탐색을 수행합니다.</font><font papago-translate="translated"> 먼저 왼쪽 피연산자 분기를 따라 재귀하고, 오른쪽 피연산자 분기를 따라 재귀하며, 마지막으로 노드 자체를 평가합니다.</font></p>
<p><font papago-translate="translated">왼쪽 피연산자를 평가한 후, jlox는 오른쪽 피연산자 트리를 통해 이동하는 동안 그 결과를 일시적으로 어딘가에 저장해야 합니다.</font><font papago-translate="translated"> 이를 위해 Java의 로컬 변수를 사용합니다.</font><font papago-translate="translated"> 우리의 재귀 트리 워크 인터프리터는 평가될 각 노드에 대해 고유한 Java 호출 프레임을 생성하므로, 필요한 만큼의 로컬 변수를 가질 수 있습니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">클록스에서, 우리의 </font></font><code translate="no">run()</code><font papago-translate="splitted"><font papago-translate="translated"> 함수는 재귀적이지 않습니다. 중첩된 표현식 트리는 선형<span class="em"></span> 일련의 명령어로 평탄화됩니다.</font><font papago-translate="translated"> 우리는 C개의 지역 변수를 사용할 여유가 없는데, 이러한 임시 값들을 어떻게 그리고 어디에 저장해야 할까요?</font><font papago-translate="translated"> 이미<span name="guess"> 짐작</span>할 수 있겠지만, 저는 이것을 깊이 파고들고 싶습니다. 왜냐하면 이것이 우리가 당연하게 여기는 프로그래밍의 한 측면이기 때문입니다. 하지만 컴퓨터가 왜 이런<em></em> 방식으로 설계되는지 거의 알지 못하기 때문입니다.</font></font></p>
<aside name="guess" style="top: 8656px;">
<p><font papago-translate="translated">힌트: 이 섹션의 이름에 나와 있으며, Java와 C가 함수에 대한 재귀 호출을 관리하는 방법입니다.</font></p>
</aside>
<p><font papago-translate="translated">이상한 운동을 해보겠습니다.</font><font papago-translate="translated"> 위 프로그램의 실행 과정을 한 번에 한 걸음씩 진행하겠습니다:</font></p>
<p><img alt="The series of instructions with
bars showing which numbers need to be preserved across which instructions." src="https://youhogeon-meritz.github.io/image/a-virtual-machine/bars.png"></p>
<p><font papago-translate="translated">왼쪽에는 코드의 단계가 있습니다.</font><font papago-translate="translated"> 오른쪽에는 우리가 추적하고 있는 값들이 있습니다.</font><font papago-translate="translated"> 각 막대는 숫자를 나타냅니다.</font><font papago-translate="translated"> 값이 처음 생성될 때, 즉 상수나<span class="em"></span> 덧셈의 결과가 나올 때 시작됩니다.</font><font papago-translate="translated"> 막대의 길이는 이전에 생성된 값을 유지해야 할 때 추적되며, 그 값이 연산에 의해 최종적으로 소비될 때 끝납니다.</font></p>
<p><font papago-translate="translated">단계를 거치면서 가치관이 나타나고 나중에 먹히는 것을 볼 수 있습니다.</font><font papago-translate="translated"> 가장 오래 지속되는 값은 덧셈의 왼쪽에서 생성된 값입니다.</font><font papago-translate="translated"> 그것들은 우리가 오른쪽 피연산자 표현식을 통해 작업하는 동안 계속 유지됩니다.</font></p>
<p><font papago-translate="translated">위 다이어그램에서 각 고유 번호에 고유한 시각적 열을 부여했습니다.</font><font papago-translate="translated"> 조금 더 간결하게 설명해 보겠습니다.</font><font papago-translate="translated"> 숫자가 소비되면, 우리는 그 열을 나중에 다른 값으로 재사용할 수 있도록 허용합니다.</font><font papago-translate="translated"> 즉, 우리는 위에 있는 모든 공백을 채우고 오른쪽에서 숫자를 밀어 넣습니다:</font></p>
<p><img alt="Like the previous
diagram, but with number bars pushed to the left, forming a stack." src="https://youhogeon-meritz.github.io/image/a-virtual-machine/bars-stacked.png"></p>
<p><font papago-translate="translated">여기서 흥미로운 일들이 벌어지고 있습니다.</font><font papago-translate="translated"> 모든 것을 전환해도 각 숫자는 평생 동안 하나의 열에 머무릅니다.</font><font papago-translate="translated"> 또한, 남은 틈이 없습니다.</font><font papago-translate="translated"> 다시 말해, 숫자가 다른 숫자보다 먼저 나타날 때마다 적어도 그 두 번째 숫자만큼 오래 지속될 것입니다.</font><font papago-translate="translated"> 가장 먼저 나타나는 숫자는 마지막으로 소비되는 숫자입니다.</font><font papago-translate="translated"> 흠<span class="ellipse">...</span> . . . 마지막, 첫 번째 아웃<span class="ellipse"> .</span> . 왜<span name="pancakes">, 그건 스택</span>이에요!</font></p>
<aside name="pancakes" style="top: 10036px;">
<p><font papago-translate="translated">이것도 스택입니다:</font></p><img alt="A stack... of pancakes." src="https://youhogeon-meritz.github.io/image/a-virtual-machine/pancakes.png">
</aside>
<p><font papago-translate="translated">두 번째 다이어그램에서는 숫자를 도입할 때마다 오른쪽에서 스택으로 밀어 넣습니다.</font><font papago-translate="translated"> 숫자가 소비되면 항상 맨 오른쪽에서 왼쪽으로 튀어나오게 됩니다.</font></p>
<p><font papago-translate="translated">우리가 추적해야 할 임시 값들은 자연스럽게 스택과 같은 동작을 가지기 때문에, 우리의 VM은 이를 관리하기 위해 스택을 사용할 것입니다.</font><font papago-translate="translated"> 명령어가 값을 "생성"하면, 그것을 스택으로 밀어 넣습니다.</font><font papago-translate="translated"> 하나 이상의 값을 소비해야 할 때, 스택에서 그것들을 꺼내어 얻습니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/a-virtual-machine.html#the-vms-stack" id="the-vms-stack"><small><font papago-translate="translated">15 . 2 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">VM의 스택</font></font></a></h3>
<p><font papago-translate="translated">이건 계시처럼 보이지 않을 수도 있지만, 저는 스택 기반 VM<em>을 좋아합니다</em>. 처음 마술 트릭을 보면 정말 마법 같은 느낌이 듭니다.</font><font papago-translate="translated"> 하지만 그 후에 그것이 어떻게 작동하는지 알게 됩니다. 보통 기계적인 속임수나 잘못된 방향성 때문에, 경이로움이 사라<span class="em"></span><span class="em"></span>집니다.</font><font papago-translate="translated"> 컴퓨터 과학에는 몇 가지 아이디어가 있는데, 제가 그것들을 분해하고 모든 것을 배운 후에도 초기 반짝임<span name="wonder"></span>은 남아 있었습니다.</font><font papago-translate="translated"> 스택 기반 VM도 그 중 하나입니다.</font></p>
<aside name="wonder" style="top: 10468px;">
<p><font papago-translate="translated"><a href="https://en.wikipedia.org/wiki/Memory_management#HEAP">힙</a><a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">스—</a><a href="https://en.wikipedia.org/wiki/Memory_management#HEAP">메모리 관리가</a> 아닌<a href="https://en.wikipedia.org/wiki/Heap_(data_structure)"> 데이터 구조</a>—<span class="em"></span><span class="em"></span>는 또 다른 문제입니다.</font><font papago-translate="translated"> 그리고<a href="https://youhogeon-meritz.github.io/compiling-expressions.html"> 본</a> 프랫의 하향식 연산자 우선순위 구문 분석 방식에 대해서<a href="https://youhogeon-meritz.github.io/compiling-expressions.html">는 나중에</a> 알게 될<a href="https://youhogeon-meritz.github.io/compiling-expressions.html"> 것</a>입니다.</font></p>
</aside>
<p><font papago-translate="translated">이 장에서 볼 수 있듯이 스택 기반 VM에서 명령어를 실행하는 것은 매우<span name="cheat"> 간단</span>합니다.</font><font papago-translate="translated"> 이후 장에서는 소스 언어를 스택 기반 명령어 집합에 컴파일하는 것이 식은 죽 먹기라는 사실도 알게 될 것입니다.</font><font papago-translate="translated"> 그럼에도 불구하고 이 아키텍처는 프로덕션 언어 구현에서 사용할 수 있을 만큼 빠릅니다.</font><font papago-translate="translated"> 프로그래밍 언어 게임에서 부정행위를 하는 것처럼 느껴질 정도입니다.</font></p>
<aside name="cheat" style="top: 10540px;">
<p><font papago-translate="translated">약간의 광택을 제거하려면: 스택 기반 통역사는 은총이 아닙니다.</font><font papago-translate="translated"> 종종<em> 충분</em>하지만, 현대의 JVM, CLR, JavaScript 구현은 모두 정교한<a href="https://en.wikipedia.org/wiki/Just-in-time_compilation"> 적시 컴파일</a> 파이프라인을 사용하여<em> 훨씬</em> 빠른 네이티브 코드를 즉석에서 생성합니다.</font></p>
</aside>
<p><font papago-translate="translated">좋아요, 코딩 타임입니다!</font><font papago-translate="translated"> 스택은 다음과 같습니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">typedef struct {
  Chunk* chunk;
  uint8_t* ip;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">VM.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em></em>구조 VM에서</font></font></div>
<pre class="insert" translate="no">  <span class="t">Value</span> <span class="i">stack</span>[<span class="a">STACK_MAX</span>];
  <span class="t">Value</span>* <span class="i">stackTop</span>;
</pre><pre class="insert-after" translate="no">} VM;
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, in struct <em>VM</em></div>
<p><font papago-translate="translated">우리는 원시 C 배열 위에 스택 의미론을 직접 구현합니다.</font><font papago-translate="translated"> 스택의 하단(첫 번째 값이 푸시되고 마지막으로 팝업되는 값)은 배열에서 요소 0에 있으며, 나중에 푸시된 값이 그<span class="em"></span><span class="em"></span> 뒤를 따릅니다.</font><font papago-translate="translated"> 제가 가장 좋아하는 스태커블 아침 식사 아이템인 "crepe" 글자를 순서대로 스택에 밀어 넣으면, 결과적으로 C 배열은<span class="em"></span><span class="em"></span> 다음과 같이 나타납니다:</font></p>
<p><img alt="An array containing the
letters in 'crepe' in order starting at element 0." src="https://youhogeon-meritz.github.io/image/a-virtual-machine/array.png"></p>
<p><font papago-translate="splitted"><font papago-translate="translated">스택이 값이 밀리고 튀어나오면서 커지고 줄어들기 때문에, 우리는 스택의 상단이 배열에서 어디에 있는지 추적해야 합니다.</font><font papago-translate="translated"> 마찬가지로 </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated">, 필요할 때마다 인덱스에서 오프셋을 계산하는 것보다 포인터를 비참조하는 것이 더 빠르기 때문에 정수 인덱스 대신 직접 포인터를 사용합니다.</font></font></p>
<p><font papago-translate="translated">포인터는 스택의 상단 값을 포함하는 요소<em> 바로 뒤</em>에 배열 요소를 가리킵니다.</font><font papago-translate="translated"> 조금 이상해 보이지만 거의 모든 구현이 이렇게 합니다.</font><font papago-translate="translated"> 배열의 원소 0을 가리키면 스택이 비어 있음을 나타낼 수 있다는 뜻입니다.</font></p>
<p><img alt="An empty array with
stackTop pointing at the first element." src="https://youhogeon-meritz.github.io/image/a-virtual-machine/stack-empty.png"></p>
<p><font papago-translate="translated">만약 우리가 맨 위의 요소를 가리킨다면, 빈 스택의 경우에는 -1 요소를 가리킬 필요가 있을 것입니다.</font><font papago-translate="translated"> 그것은 C에서<span name="defined"> 정의되지 않았습니다</span>.</font><font papago-translate="translated"> 값을 스택에 밀어 넣을 때<span class="ellipse"> . . .</span></font></p>
<aside name="defined" style="top: 11500.5px;">
<p><font papago-translate="translated">스택이<em> 가득</em> 차면 어떨까요, 클레버 리더?</font><font papago-translate="translated"> C 표준은 당신보다 한 단계 앞서 있습니다.</font><font papago-translate="translated"> <em></em>배열 포인터가 배열의 끝을 지나도록 위치하는 것은 허용되고 명확하게 지정됩니다.</font></p>
</aside>
<p><img alt="An array with 'c' at element
zero." src="https://youhogeon-meritz.github.io/image/a-virtual-machine/stack-c.png"></p>
<p><font papago-translate="splitted"><span class="ellipse"><font papago-translate="translated"> . . .&nbsp;</font></span></font><code translate="no">stackTop</code><font papago-translate="splitted"><font papago-translate="translated"> 항상 마지막 항목 바로 뒤를 가리킵니다.</font></font></p>
<p><img alt="An array with 'c', 'r',
'e', 'p', and 'e' in the first five elements." src="https://youhogeon-meritz.github.io/image/a-virtual-machine/stack-crepe.png"></p>
<p><font papago-translate="splitted"><font papago-translate="translated">이렇게 기억합니다: </font></font><code translate="no">stackTop</code><font papago-translate="splitted"><font papago-translate="translated"> 다음에 푸시할 값이 어디로 갈지를 가리킵니다.</font><font papago-translate="translated"> 스택에 저장할 수 있는 최대 값 수(현재로서는 적어도)는 다음과 같습니다:</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#include "chunk.h"
</pre><div class="source-file"><em><font papago-translate="translated">VM.h</font></em></div>
<pre class="insert" translate="no">
<span class="a">#define STACK_MAX 256</span>
</pre><pre class="insert-after" translate="no">
typedef struct {
</pre></div>
<div class="source-file-narrow"><em>vm.h</em></div>
<p><font papago-translate="translated">VM<span class="em"></span>에 고정된 스택 크기를 제공한다는 것은 일부 명령어 시퀀스가 너무 많은 값을 밀어내고 스택 공간이 부족할 수 있음을 의미합니다. 이는 고전적인 "스택 오버플로"입니다.</font><font papago-translate="translated"> 필요에 따라 스택을 동적으로 성장시킬 수 있지만, 지금은 단순하게 유지하겠습니다.</font><font papago-translate="translated"> VM은 Value를 사용하므로 선언을 포함해야 합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#include "chunk.h"
</pre><div class="source-file"><em><font papago-translate="translated">VM.h</font></em></div>
<pre class="insert" translate="no"><span class="a">#include "value.h"</span>
</pre><pre class="insert-after" translate="no">
#define STACK_MAX 256
</pre></div>
<div class="source-file-narrow"><em>vm.h</em></div>
<p><font papago-translate="translated">이제 VM에 흥미로운 상태가 생겼으니 초기화할 수 있습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">void initVM() {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>initVM</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="i">resetStack</span>();
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>initVM</em>()</div>
<p><font papago-translate="translated">이 도우미 기능을 사용합니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 변수<em> vm</em> 뒤에 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">resetStack</span>() {
  <span class="i">vm</span>.<span class="i">stackTop</span> = <span class="i">vm</span>.<span class="i">stack</span>;
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after variable <em>vm</em></div>
<p><font papago-translate="splitted"><font papago-translate="translated">스택 배열은 VM 구조에서 직접 인라인으로 선언되므로 할당할 필요가 없습니다.</font><font papago-translate="translated"> 배열에서 사용되지 않은 셀을 지울 필요도 없습니다. 값이<span class="em"></span> 저장될 때까지 액세스할 수 없습니다.</font><font papago-translate="translated"> 우리가 필요한 유일한 초기화는 설정하는 것입니다 </font></font><code translate="no">stackTop</code><font papago-translate="splitted"><font papago-translate="translated"> 배열의 시작 부분을 가리키며 스택이 비어 있음을 나타냅니다.</font></font></p>
<p><font papago-translate="translated">스택 프로토콜은 두 가지 작업을 지원합니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">InterpretResult interpret(Chunk* chunk);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">VM.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>해석</em> 후 () 추가</font></font></div>
<pre class="insert" translate="no"><span class="t">void</span> <span class="i">push</span>(<span class="t">Value</span> <span class="i">value</span>);
<span class="t">Value</span> <span class="i">pop</span>();
</pre><pre class="insert-after" translate="no">
#endif
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, add after <em>interpret</em>()</div>
<p><font papago-translate="translated">새로운 값을 스택 상단에 밀어넣을 수 있으며, 가장 최근에 밀어낸 값을 다시 밀어낼 수 있습니다.</font><font papago-translate="translated"> 첫 번째 함수는 다음과 같습니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>freeVM</em>() 이후에 추가</font></font></div>
<pre translate="no"><span class="t">void</span> <span class="i">push</span>(<span class="t">Value</span> <span class="i">value</span>) {
  *<span class="i">vm</span>.<span class="i">stackTop</span> = <span class="i">value</span>;
  <span class="i">vm</span>.<span class="i">stackTop</span>++;
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>freeVM</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">C 포인터 구문과 연산에 녹슬었다면, 이것은 좋은 준비 운동입니다.</font><font papago-translate="translated"> 첫 번째 라인 스토어 </font></font><code translate="no">value</code><font papago-translate="splitted"><font papago-translate="translated"> 스택 상단의 배열 요소에서.</font><font papago-translate="translated"> 기억하세요. </font></font><code translate="no">stackTop</code><font papago-translate="splitted"><font papago-translate="translated"> 마지막으로 사용된 요소<em>를 지나</em> 다음으로 사용 가능한 요소에 있는 점들.</font><font papago-translate="translated"> 이렇게 하면 해당 슬롯에 값이 저장됩니다.</font><font papago-translate="translated"> 그런 다음 포인터 자체를 증가시켜 이전 슬롯이 점유되었으므로 배열에서 다음으로 사용되지 않는 슬롯을 가리킵니다.</font></font></p>
<p><font papago-translate="translated">팝핑은 거울 이미지입니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>푸시</em> () 후 추가</font></font></div>
<pre translate="no"><span class="t">Value</span> <span class="i">pop</span>() {
  <span class="i">vm</span>.<span class="i">stackTop</span>--;
  <span class="k">return</span> *<span class="i">vm</span>.<span class="i">stackTop</span>;
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>push</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">먼저 스택 포인터<em>를 다시</em> 움직여 배열에서 가장 최근에 사용된 슬롯으로 이동합니다.</font><font papago-translate="translated"> 그런 다음 해당 인덱스의 값을 찾아 반환합니다.</font><font papago-translate="translated"> 배열에서 명시적으로 "제거"할 필요는 없습니다—<span class="em"></span>이동합니다 </font></font><code translate="no">stackTop</code><font papago-translate="splitted"><font papago-translate="translated"> 다운은 해당 슬롯을 더 이상 사용하지 않는 것으로 표시하기에 충분합니다.</font></font></p>
<h3><a href="https://youhogeon-meritz.github.io/a-virtual-machine.html#stack-tracing" id="stack-tracing"><small><font papago-translate="translated">15 . 2 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">스택 추적</font></font></a></h3>
<p><font papago-translate="translated">우리는 작동하는 스택이 있지만, 작동<em>하는지 확인</em>하기가 어렵습니다.</font><font papago-translate="translated"> 더 복잡한 명령어를 구현하고 더 큰 코드 조각을 컴파일하고 실행하기 시작하면 해당 배열에 많은 값이 채워지게 됩니다.</font><font papago-translate="translated"> 스택에 대한 가시성이 있다면 VM 해커로서의 삶이 더 쉬워질 것입니다.</font></p>
<p><font papago-translate="translated">이를 위해 실행을 추적할 때마다 각 명령어를 해석하기 전에 스택의 현재 내용도 표시합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#ifdef DEBUG_TRACE_EXECUTION
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font></div>
<pre class="insert" translate="no">    <span class="i">printf</span>(<span class="s">"          "</span>);
    <span class="k">for</span> (<span class="t">Value</span>* <span class="i">slot</span> = <span class="i">vm</span>.<span class="i">stack</span>; <span class="i">slot</span> &lt; <span class="i">vm</span>.<span class="i">stackTop</span>; <span class="i">slot</span>++) {
      <span class="i">printf</span>(<span class="s">"[ "</span>);
      <span class="i">printValue</span>(*<span class="i">slot</span>);
      <span class="i">printf</span>(<span class="s">" ]"</span>);
    }
    <span class="i">printf</span>(<span class="s">"</span><span class="e">\n</span><span class="s">"</span>);
</pre><pre class="insert-after" translate="no">    disassembleInstruction(vm.chunk,
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p><font papago-translate="translated">우리는 배열의 각 값을 첫 번째(스택의 하단)에서 시작하여 상단에 도달하면 출력하는 루프를 반복합니다.</font><font papago-translate="translated"> 이를 통해 각 명령어가 스택에 미치는 영향을 관찰할 수 있습니다.</font><font papago-translate="translated"> 출력은 꽤 장황하지만, 통역사의 장에서 불쾌한 버그를 외과적으로 추출할 때 유용합니다.</font></p>
<p><font papago-translate="translated">손을 모아 두 가지 지침을 다시 살펴봅시다.</font><font papago-translate="translated"> 우선:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      case OP_CONSTANT: {
        Value constant = READ_CONSTANT();
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 두 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">        <span class="i">push</span>(<span class="i">constant</span>);
</pre><pre class="insert-after" translate="no">        break;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 2 lines</div>
<p><font papago-translate="splitted"><font papago-translate="translated">마지막 장에서 저는 손을 흔들며 다음과 같이 말했습니다 </font></font><code translate="no">OP_CONSTANT</code><font papago-translate="splitted"><font papago-translate="translated"> 명령어 "loads"는 상수입니다.</font><font papago-translate="translated"> 이제 스택이 생겼으니 실제로 값을 생성한다는 것이 무엇을 의미하는지 알 수 있습니다: 스택으로 밀려납니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      case OP_RETURN: {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font></div>
<pre class="insert" translate="no">        <span class="i">printValue</span>(<span class="i">pop</span>());
        <span class="i">printf</span>(<span class="s">"</span><span class="e">\n</span><span class="s">"</span>);
</pre><pre class="insert-after" translate="no">        return INTERPRET_OK;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">그러면 우리는 만듭니다 </font></font><code translate="no">OP_RETURN</code><font papago-translate="splitted"><font papago-translate="translated"> 스택을 열고 상단 값을 출력한 후 종료합니다.</font><font papago-translate="translated"> clox에 실제 함수에 대한 지원을 추가하면 이 코드를 변경할 것입니다.</font><font papago-translate="translated"> 하지만 지금은 VM이 간단한 명령어 시퀀스를 실행하고 결과를 표시할 수 있는 방법을 제공합니다.</font></font></p>
<h2><a href="https://youhogeon-meritz.github.io/a-virtual-machine.html#an-arithmetic-calculator" id="an-arithmetic-calculator"><small><font papago-translate="translated">15 . 3</font></small><font papago-translate="splitted"><font papago-translate="translated">산술 계산기</font></font></a></h2>
<p><font papago-translate="translated">우리 VM의 마음과 영혼은 이제 제자리에 있습니다.</font><font papago-translate="translated"> 바이트코드 루프는 명령어를 발송하고 실행합니다.</font><font papago-translate="translated"> 스택은 가치가 흐르면서 성장하고 축소됩니다.</font><font papago-translate="translated"> 두 절반은 효과가 있지만 지금까지 우리가 가지고 있는 두 가지 기본 지침만으로는 얼마나 영리하게 상호작용하는지 감을 잡기 어렵습니다.</font><font papago-translate="translated"> 그럼 통역사에게 산수를 가르쳐 보겠습니다.</font></p>
<p><font papago-translate="translated">가장 간단한 산술 연산인 단항 부정으로 시작하겠습니다.</font></p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="i">a</span> = <span class="n">1.2</span>;
<span class="k">print</span> -<span class="i">a</span>; <span class="c">// -1.2.</span>
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">접두사 </font></font><code translate="no">-</code><font papago-translate="splitted"><font papago-translate="translated"> 연산자는 부정할 값인 피연산자 하나를 취합니다.</font><font papago-translate="translated"> 그것은 하나의 결과를 만들어냅니다.</font><font papago-translate="translated"> 우리는 아직 파서에 대해 까다롭게 생각하지 않지만, 위의 구문이 컴파일할 바이트코드 명령어를 추가할 수 있습니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  OP_CONSTANT,
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">청크.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> enum O<em>pCode</em>에서</font></font></div>
<pre class="insert" translate="no">  <span class="a">OP_NEGATE</span>,
</pre><pre class="insert-after" translate="no">  OP_RETURN,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>
<p><font papago-translate="translated">우리는 이렇게 실행합니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      }
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font></div>
<pre class="insert" translate="no">      <span class="k">case</span> <span class="a">OP_NEGATE</span>:   <span class="i">push</span>(-<span class="i">pop</span>()); <span class="k">break</span>;
</pre><pre class="insert-after" translate="no">      case OP_RETURN: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p><font papago-translate="translated">명령어를 작동하려면 스택에서 튀어나와야 하는 값이 필요합니다.</font><font papago-translate="translated"> 이를 무효화한 다음 나중에 사용할 수 있도록 결과를 다시 밀어 넣습니다.</font><font papago-translate="translated"> 그것보다 훨씬 쉬워지지는 않습니다.</font><font papago-translate="translated"> 우리는 그것을 분해할 수도 있습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    case OP_CONSTANT:
      return constantInstruction("OP_CONSTANT", chunk, offset);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">debug.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>분해</em> 중 지침()</font></font></div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="a">OP_NEGATE</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">"OP_NEGATE"</span>, <span class="i">offset</span>);
</pre><pre class="insert-after" translate="no">    case OP_RETURN:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>
<p><font papago-translate="translated">그리고 테스트 청크에서 시도해 볼 수 있습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  writeChunk(&amp;chunk, constant, 123);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">주요.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>메인</em> ()에서</font></font></div>
<pre class="insert" translate="no">  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="a">OP_NEGATE</span>, <span class="n">123</span>);
</pre><pre class="insert-after" translate="no">
  writeChunk(&amp;chunk, OP_RETURN, 123);
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>main</em>()</div>
<p><font papago-translate="translated">상수를 로드한 후 다시 돌아가기 전에 부정 명령을 실행합니다.</font><font papago-translate="translated"> 그것은 스택의 상수를 음수로 대체합니다.</font><font papago-translate="translated"> 그러면 반환 명령이 이를 출력합니다:</font></p>
<div class="codehilite"><pre translate="no">-1.2
</pre></div>
<p><font papago-translate="translated">마법 같은!</font></p>
<h3><a href="https://youhogeon-meritz.github.io/a-virtual-machine.html#binary-operators" id="binary-operators"><small><font papago-translate="translated">15 . 3 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">이진 연산자</font></font></a></h3>
<p><font papago-translate="translated">좋아요, 단항 연산자는<em> 그다지</em> 인상적이지 않습니다.</font><font papago-translate="translated"> 우리는 여전히 스택에 단 하나의 값만 가지고 있습니다.</font><font papago-translate="translated"> 깊이를 제대로 보려면 이진 연산자가 필요합니다.</font><font papago-translate="translated"> Lox에는 덧셈, 뺄셈, 곱셈, 나눗셈의 네 가지 이진<span name="ops"> 산술</span> 연산자가 있습니다.</font><font papago-translate="translated"> 우리는 이 모든 것을 동시에 구현할 것입니다.</font></p>
<aside name="ops" style="top: 15891.5px;">
<p><font papago-translate="translated">Lox에는 비교 및 동등성과 같은 다른 이진 연산자가 있지만 결과적으로 숫자를 생성하지 않기 때문에<span class="em"></span><span class="em"></span> 아직 준비가 되지 않았습니다.</font></p>
</aside>
<div class="codehilite"><pre class="insert-before" translate="no">  OP_CONSTANT,
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">청크.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> enum O<em>pCode</em>에서</font></font></div>
<pre class="insert" translate="no">  <span class="a">OP_ADD</span>,
  <span class="a">OP_SUBTRACT</span>,
  <span class="a">OP_MULTIPLY</span>,
  <span class="a">OP_DIVIDE</span>,
</pre><pre class="insert-after" translate="no">  OP_NEGATE,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>
<p><font papago-translate="translated">바이트코드 루프에서는 다음과 같이 실행됩니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      }
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font></div>
<pre class="insert" translate="no">      <span class="k">case</span> <span class="a">OP_ADD</span>:      <span class="a">BINARY_OP</span>(+); <span class="k">break</span>;
      <span class="k">case</span> <span class="a">OP_SUBTRACT</span>: <span class="a">BINARY_OP</span>(-); <span class="k">break</span>;
      <span class="k">case</span> <span class="a">OP_MULTIPLY</span>: <span class="a">BINARY_OP</span>(*); <span class="k">break</span>;
      <span class="k">case</span> <span class="a">OP_DIVIDE</span>:   <span class="a">BINARY_OP</span>(/); <span class="k">break</span>;
</pre><pre class="insert-after" translate="no">      case OP_NEGATE:   push(-pop()); break;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p><font papago-translate="translated">이 네 가지 명령어의 유일한 차이점은 두 피연산자를 결합하기 위해 궁극적으로 어떤 기본 C 연산자를 사용하는지입니다.</font><font papago-translate="translated"> 그 핵심 산술 표현식 주변에는 값을 스택에서 끌어내어 결과를 밀어내는 보일러플레이트 코드가 있습니다.</font><font papago-translate="translated"> 나중에 동적 타이핑을 추가하면 보일러 플레이트가 커질 것입니다.</font><font papago-translate="translated"> 그 코드를 네 번 반복하지 않기 위해 매크로로 마무리했습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#define READ_CONSTANT() (vm.chunk-&gt;constants.values[READ_BYTE()])
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font></div>
<pre class="insert" translate="no"><span class="a">#define BINARY_OP(op) \</span>
<span class="a">    do { \</span>
<span class="a">      double b = pop(); \</span>
<span class="a">      double a = pop(); \</span>
<span class="a">      push(a op b); \</span>
<span class="a">    } while (false)</span>
</pre><pre class="insert-after" translate="no">
  for (;;) {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p><font papago-translate="translated">이것이 C 전처리기를 꽤<span name="operator"> 모험적</span>으로 사용한 것임을 인정합니다.</font><font papago-translate="translated"> 망설였지만 나중에 각 피연산자 등에 대한 유형 검사를 추가해야 할 때 기쁘게 생각할 것입니다.</font><font papago-translate="translated"> 같은 코드를 네 번이나 설명해 주는 것은 번거로울 것입니다.</font></p>
<aside name="operator" style="top: 16647.5px;">
<p><font papago-translate="translated"><em>매크로</em>에<em> 연산자</em>를 인수로 전달할 수 있다는 사실을 알고 계셨나요?</font><font papago-translate="translated"> 이제 너는 한다.</font><font papago-translate="translated"> 전처리기는 연산자가 C에서 일등석이 아니라는 점에 신경 쓰지 않습니다.</font><font papago-translate="translated"> 문자 토큰에 관한 한, 이 모든 것이 문자 토큰에 불과합니다.</font></p>
<p><font papago-translate="translated">알아요, 이걸 남용하고 싶은 유혹<em>을</em> 느낄 수 있죠?</font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">아직 그 요령에 익숙하지 않다면, 그 겉면은 </font></font><code translate="no">do while</code><font papago-translate="splitted"><font papago-translate="translated"> 루프는 아마도 정말 이상해 보일 것입니다.</font><font papago-translate="translated"> 이 매크로는 일련의 문장으로 확장되어야 합니다.</font><font papago-translate="translated"> 매크로 작성자를 주의 깊게 하기 위해 매크로를 확장할 때 이러한 진술이 모두 동일한 범위에 속하도록 하고 싶습니다.</font><font papago-translate="translated"> 정의한다고 상상해 보세요:</font></font></p>
<div class="codehilite"><pre translate="no"><span class="a">#define WAKE_UP() makeCoffee(); drinkCoffee();</span>
</pre></div>
<p><font papago-translate="translated">그리고 나서 이렇게 사용했습니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">if</span> (<span class="i">morning</span>) <span class="a">WAKE_UP</span>();
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">다음과 같은 경우에만 매크로 본문의 두 문장을 모두 실행하는 것이 목적입니다 </font></font><code translate="no">morning</code><font papago-translate="splitted"><font papago-translate="translated"> 사실입니다.</font><font papago-translate="translated"> 하지만 그 범위는 다음과 같습니다:</font></font></p>
<div class="codehilite"><pre translate="no"><span class="k">if</span> (<span class="i">morning</span>) <span class="i">makeCoffee</span>(); <span class="i">drinkCoffee</span>();;
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">어머나 </font></font><code translate="no">if</code><font papago-translate="splitted"><font papago-translate="translated"> <em>첫</em> 번째 문장에만 첨부됩니다.</font><font papago-translate="translated"> 블록을 사용하여 이 문제를 해결할 수 있다고 생각할 수도 있습니다.</font></font></p>
<div class="codehilite"><pre translate="no"><span class="a">#define WAKE_UP() { makeCoffee(); drinkCoffee(); }</span>
</pre></div>
<p><font papago-translate="translated">그게 더 낫지만 여전히 위험을 감수해야 합니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">if</span> (<span class="i">morning</span>)
  <span class="a">WAKE_UP</span>();
<span class="k">else</span>
  <span class="i">sleepIn</span>();
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">이제 컴파일 오류가 발생합니다 </font></font><code translate="no">else</code><font papago-translate="splitted"><font papago-translate="translated"> 그 후행 때문에 </font></font><code translate="no">;</code><font papago-translate="splitted"><font papago-translate="translated"> 매크로가 차단된 후에.</font><font papago-translate="translated"> 사용하기 </font></font><code translate="no">do while</code><font papago-translate="splitted"><font papago-translate="translated"> 매크로의 루프는 재미있어 보이지만 블록 안에 여러 개의 문을 포함할 수 있는 방법을 제공하여 끝에 세미콜론을 허용<em>하기도</em> 합니다.</font></font></p>
<p><font papago-translate="translated">우리가 어디까지 얘기했죠?</font><font papago-translate="translated"> 맞아요, 그래서 그 매크로 본문이 하는 일은 간단합니다.</font><font papago-translate="translated"> 이진 연산자는 두 개의 피연산자를 사용하므로 두 번 터집니다.</font><font papago-translate="translated"> 그 두 값에 대해 연산을 수행한 다음 결과를 푸시합니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">두 팝의<em> 순서</em>를 주의 깊게 살펴보세요.</font><font papago-translate="translated"> 첫 번째 팝업 피연산자를 다음에 할당합니다 </font></font><code translate="no">b</code><font papago-translate="splitted"><font papago-translate="translated">,것은 아니다. </font></font><code translate="no">a</code><font papago-translate="splitted"><font papago-translate="translated">. 거꾸로 보입니다.</font><font papago-translate="translated"> 피연산자 자체를 계산하면 왼쪽이 먼저 평가되고 오른쪽이 평가됩니다.</font><font papago-translate="translated"> 즉, 왼쪽 피연산자가 오른쪽 피연산자보다 먼저 밀려난다는 뜻입니다.</font><font papago-translate="translated"> 따라서 올바른 피연산자가 스택 위에 있습니다.</font><font papago-translate="translated"> 따라서 첫 번째 값은 다음과 같습니다 </font></font><code translate="no">b</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">예를 들어, 만약 우리가 </font></font><code translate="no">3 - 1</code><font papago-translate="splitted"><font papago-translate="translated">, 지침 간의 데이터 흐름은 다음과 같습니다:</font></font></p>
<p><img alt="A sequence of instructions
with the stack for each showing how pushing and then popping values reverses
their order." src="https://youhogeon-meritz.github.io/image/a-virtual-machine/reverse.png"></p>
<p><font papago-translate="splitted"><font papago-translate="translated">내부의 다른 매크로와 마찬가지로 </font></font><code translate="no">run()</code><font papago-translate="splitted"><font papago-translate="translated">, 기능이 끝나면 우리는 스스로를 정리합니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#undef READ_CONSTANT
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font></div>
<pre class="insert" translate="no"><span class="a">#undef BINARY_OP</span>
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p><font papago-translate="translated">마지막으로 분해기 지지대입니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    case OP_CONSTANT:
      return constantInstruction("OP_CONSTANT", chunk, offset);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">debug.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>분해</em> 중 지침()</font></font></div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="a">OP_ADD</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">"OP_ADD"</span>, <span class="i">offset</span>);
    <span class="k">case</span> <span class="a">OP_SUBTRACT</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">"OP_SUBTRACT"</span>, <span class="i">offset</span>);
    <span class="k">case</span> <span class="a">OP_MULTIPLY</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">"OP_MULTIPLY"</span>, <span class="i">offset</span>);
    <span class="k">case</span> <span class="a">OP_DIVIDE</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">"OP_DIVIDE"</span>, <span class="i">offset</span>);
</pre><pre class="insert-after" translate="no">    case OP_NEGATE:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">산술 명령 형식은 다음과 같이 간단합니다 </font></font><code translate="no">OP_RETURN</code><font papago-translate="splitted"><font papago-translate="translated">. 산술<em> 연산자</em>가 스택에서 발견되는 피연산자를 사용하더라도 산술<em> 바이트코드 명령어</em>는<span class="em"></span><span class="em"></span> 그렇지 않습니다.</font></font></p>
<p><font papago-translate="translated">새로운 지침 중 일부를 더 큰 표현을 평가하여 그들의 속도에 맞춰 보겠습니다:</font></p>
<p><img alt="The expression being
evaluated: -((1.2 + 3.4) / 5.6)" src="https://youhogeon-meritz.github.io/image/a-virtual-machine/chunk.png"></p>
<p><font papago-translate="translated">기존 예제 청크를 기반으로 AST를 바이트코드로 수작업으로 컴파일하는 데 필요한 추가 지침이 있습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  int constant = addConstant(&amp;chunk, 1.2);
  writeChunk(&amp;chunk, OP_CONSTANT, 123);
  writeChunk(&amp;chunk, constant, 123);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">주요.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>메인</em> ()에서</font></font></div>
<pre class="insert" translate="no">
  <span class="i">constant</span> = <span class="i">addConstant</span>(&amp;<span class="i">chunk</span>, <span class="n">3.4</span>);
  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="a">OP_CONSTANT</span>, <span class="n">123</span>);
  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="i">constant</span>, <span class="n">123</span>);

  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="a">OP_ADD</span>, <span class="n">123</span>);

  <span class="i">constant</span> = <span class="i">addConstant</span>(&amp;<span class="i">chunk</span>, <span class="n">5.6</span>);
  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="a">OP_CONSTANT</span>, <span class="n">123</span>);
  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="i">constant</span>, <span class="n">123</span>);

  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="a">OP_DIVIDE</span>, <span class="n">123</span>);
</pre><pre class="insert-after" translate="no">  writeChunk(&amp;chunk, OP_NEGATE, 123);

  writeChunk(&amp;chunk, OP_RETURN, 123);
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>main</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">덧셈이 먼저 이루어집니다.</font><font papago-translate="translated"> 왼쪽 상수에 대한 지침인 1.2는 이미 존재하므로 3.4에 대해 다른 지침을 추가합니다.</font><font papago-translate="translated"> 그런 다음 다음 다음을 사용하여 이 두 가지를 더합니다 </font></font><code translate="no">OP_ADD</code><font papago-translate="splitted"><font papago-translate="translated">, 스택에 그대로 두는 것.</font><font papago-translate="translated"> 그것은 사단의 왼쪽을 다룹니다.</font><font papago-translate="translated"> 다음으로 5.6을 누르고 덧셈의 결과를 그것으로 나눕니다.</font><font papago-translate="translated"> 마지막으로, 우리는 그것의 결과를 부정합니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">출력 방식 참고 </font></font><code translate="no">OP_ADD</code><font papago-translate="splitted"><font papago-translate="translated"> 암묵적으로 피연산자가 됩니다 </font></font><code translate="no">OP_DIVIDE</code><font papago-translate="splitted"><font papago-translate="translated"> 두 명령어가 서로 직접 연결되지 않은 상태에서.</font><font papago-translate="translated"> 그것이 바로 스택의 마법입니다.</font><font papago-translate="translated"> 그것은 우리가 데이터 흐름에 대한 복잡성이나 인식 없이 자유롭게 명령어를 작성할 수 있게 해줍니다.</font><font papago-translate="translated"> 스택은 그들이 모두 읽고 쓰는 공유 작업 공간처럼 작동합니다.</font></font></p>
<p><font papago-translate="translated">이 작은 예제 청크에서는 스택이 여전히 두 개의 값만 얻을 수 있지만, Lox 소스를 바이트코드로 컴파일하기 시작하면 스택을 훨씬 더 많이 사용하는 청크가 생길 것입니다.</font><font papago-translate="translated"> 그동안 이 손으로 쓴 청크를 가지고 다양한 중첩 산술 표현식을 계산하고 명령어와 스택을 통해 값이 어떻게 흐르는지 확인해 보세요.</font></p>
<p><font papago-translate="translated">지금 시스템에서 제거하는 것이 좋습니다.</font><font papago-translate="translated"> 이것이 우리가 손으로 만들 마지막 덩어리입니다.</font><font papago-translate="translated"> 다음에 바이트코드를 다시 검토할 때, 우리는 그것을 생성하기 위해 컴파일러를 작성할 것입니다.</font></p>
<div class="challenges">
<h2><a href="https://youhogeon-meritz.github.io/a-virtual-machine.html#challenges" id="challenges"><font papago-translate="translated">과제들</font></a></h2>
<ol>
<li>
<p><font papago-translate="translated">다음 식을 위해 생성할 바이트코드 명령어 시퀀스는 무엇입니까:</font></p>
<div class="codehilite"><pre translate="no"><span class="n">1</span> * <span class="n">2</span> + <span class="n">3</span>
<span class="n">1</span> + <span class="n">2</span> * <span class="n">3</span>
<span class="n">3</span> - <span class="n">2</span> - <span class="n">1</span>
<span class="n">1</span> + <span class="n">2</span> * <span class="n">3</span> - <span class="n">4</span> / -<span class="n">5</span>
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">Lox에는 음수 리터럴에 대한 구문이 없으므로 </font></font><code translate="no">-5</code><font papago-translate="splitted"><font papago-translate="translated"> 숫자 5를 부정하는 것입니다.)</font></font></p>
</li>
<li>
<p><font papago-translate="splitted"><font papago-translate="translated">만약 우리가 정말로 최소한의 명령어 집합을 원한다면, 둘 중 하나를 제거할 수 있습니다 </font></font><code translate="no">OP_NEGATE</code><font papago-translate="splitted"><font papago-translate="translated"> 또는 </font></font><code translate="no">OP_SUBTRACT</code><font papago-translate="splitted"><font papago-translate="translated">. 생성할 바이트코드 명령어 시퀀스를 표시합니다:</font></font></p>
<div class="codehilite"><pre translate="no"><span class="n">4</span> - <span class="n">3</span> * -<span class="n">2</span>
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">먼저, 사용하지 않고 </font></font><code translate="no">OP_NEGATE</code><font papago-translate="splitted"><font papago-translate="translated">. 그러면, 사용하지 않고 </font></font><code translate="no">OP_SUBTRACT</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p>
<p><font papago-translate="translated">위의 내용을 고려할 때, 두 가지 지침을 모두 포함하는 것이 합리적이라고 생각하십니까?</font><font papago-translate="translated"> 왜 그런가요? 혹은 왜 그렇지 않은가요?</font><font papago-translate="translated"> 포함시킬 다른 중복 지침이 있습니까?</font></p>
</li>
<li>
<p><font papago-translate="translated">우리 VM의 스택은 고정된 크기를 가지고 있으며, 값을 밀어도 넘치는지 확인하지 않습니다.</font><font papago-translate="translated"> 이는 잘못된 일련의 지침으로 인해 통역사가 충돌하거나 정의되지 않은 동작을 하게 될 수 있음을 의미합니다.</font><font papago-translate="translated"> 필요에 따라 스택을 동적으로 성장시켜 이를 방지합니다.</font></p>
<p><font papago-translate="translated">그렇게 함으로써 얻는 비용과 이점은 무엇입니까?</font></p>
</li>
<li>
<p><font papago-translate="splitted"><font papago-translate="translated">해석하기 </font></font><code translate="no">OP_NEGATE</code><font papago-translate="splitted"><font papago-translate="translated">, 피연산자를 터뜨리고 값을 무효화한 다음 결과를 누릅니다.</font><font papago-translate="translated"> 그것은 간단한 구현이지만, 점점 더 많아지고 줄어듭니다 </font></font><code translate="no">stackTop</code><font papago-translate="splitted"><font papago-translate="translated"> 결국 스택의 높이가 같기 때문에 불필요합니다.</font><font papago-translate="translated"> 스택의 값을 단순히 무효화하고 떠나는 것이 더 빠를 수 있습니다 </font></font><code translate="no">stackTop</code><font papago-translate="splitted"><font papago-translate="translated"> 홀로.</font><font papago-translate="translated"> 한번 시도해보고 성능 차이를 측정할 수 있는지 확인해 보세요.</font></font></p>
<p><font papago-translate="translated">비슷한 최적화를 수행할 수 있는 다른 지침이 있습니까?</font></p>
</li>
</ol>
</div>
<div class="design-note">
<h2><a href="https://youhogeon-meritz.github.io/a-virtual-machine.html#design-note" id="design-note"><font papago-translate="translated">디자인 노트:</font><font papago-translate="translated"> 레지스터 기반 바이트코드</font></a></h2>
<p><font papago-translate="translated">이 책의 나머지 부분에서는 스택 기반 바이트코드 명령어 집합을 중심으로 인터프리터를 꼼꼼하게 구현할 것입니다.</font><font papago-translate="translated"> <em>또</em> 다른 바이트코드 아키텍처 제품군<em>은 레지스터</em><span class="em"></span><em> 기반입니다</em>.</font><font papago-translate="translated"> 이름과는 달리, 이러한 바이트코드 명령어는 x<span name="x64">64</span>와 같은 실제 칩의 레지스터만큼 다루기 어렵지 않습니다.</font><font papago-translate="translated"> 실제 하드웨어 레지스터의 경우 일반적으로 전체 프로그램에 사용할 수 있는 수가 거의 없기 때문에<a href="https://en.wikipedia.org/wiki/Register_allocation"> 효율적으로 사용하기 위해</a> 많은 노력을 기울이고<a href="https://en.wikipedia.org/wiki/Register_allocation"> 항목을 주고받습니다</a>.</font></p>
<aside name="x64" style="top: 20821px;">
<p><font papago-translate="translated">레지스터 기반 바이트코드는 SPARC 칩이 지원하는<a href="https://en.wikipedia.org/wiki/Register_window"><em> 레지스터 창</em></a>에 조금 더 가깝습니다.</font></p>
</aside>
<p><font papago-translate="translated">레지스터 기반 VM에서는 여전히 스택이 있습니다.</font><font papago-translate="translated"> 일시적인 값은 여전히 더 이상 필요하지 않을 때 밀려나고 튀어나옵니다.</font><font papago-translate="translated"> 주요 차이점은 명령어가 스택 내 어디에서든 입력을 읽을 수 있고 출력을 특정 스택 슬롯에 저장할 수 있다는 점입니다.</font></p>
<p><font papago-translate="translated">이 작은 Lox 스크립트를 보세요:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="i">a</span> = <span class="n">1</span>;
<span class="k">var</span> <span class="i">b</span> = <span class="n">2</span>;
<span class="k">var</span> <span class="i">c</span> = <span class="i">a</span> + <span class="i">b</span>;
</pre></div>
<p><font papago-translate="translated">스택 기반 VM에서는 마지막 문장이 다음과 같은 내용으로 컴파일됩니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="i">load</span> &lt;<span class="i">a</span>&gt;  <span class="c">// Read local variable a and push onto stack.</span>
<span class="i">load</span> &lt;<span class="i">b</span>&gt;  <span class="c">// Read local variable b and push onto stack.</span>
<span class="i">add</span>       <span class="c">// Pop two values, add, push result.</span>
<span class="i">store</span> &lt;<span class="i">c</span>&gt; <span class="c">// Pop value and store in local variable c.</span>
</pre></div>
<p><font papago-translate="translated">(아직 로드 및 저장 지침을 완전히 이해하지 못하더라도 걱정하지 마세요.</font><font papago-translate="translated"> <a href="https://youhogeon-meritz.github.io/global-variables.html">변수를 구현할 때</a> 훨씬 더 자세히 살펴보겠습니다.)</font><font papago-translate="translated"> 네 가지 별도의 지침이 있습니다.</font><font papago-translate="translated"> 즉, 바이트코드 해석 루프를 네 번 반복하고 디코딩 및 디스패치하는 네 가지 명령을 의미합니다.</font><font papago-translate="translated"> 최소 7바이트의 코드입니다. 네 개는 opcode를 위한 코드이고, 다른 세 개는 opcode를 위한 코드이며, 다른 세 개는 어떤 로컬을 로드하고<span class="em"></span> 저장할지를 식별하는 피연산자를 위한 코드입니다.</font><font papago-translate="translated"> 세 번의 푸시와 세 번의 팝.</font><font papago-translate="translated"> 많은 일!</font></p>
<p><font papago-translate="translated">레지스터 기반 명령어 세트에서는 명령어를 읽고 로컬 변수에 직접 저장할 수 있습니다.</font><font papago-translate="translated"> 위의 마지막 문장의 바이트코드는 다음과 같습니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="i">add</span> &lt;<span class="i">a</span>&gt; &lt;<span class="i">b</span>&gt; &lt;<span class="i">c</span>&gt; <span class="c">// Read values from a and b, add, store in c.</span>
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">덧셈 명령어는 더 큽니다. 스택에서 입력을 읽고<span class="em"></span> 결과를 쓰는 위치를 정의하는 세 개의 명령어 피연산자가 있습니다.</font><font papago-translate="translated"> 하지만 로컬 변수가 스택에 존재하기 때문에 다음에서 직접 읽을 수 있습니다 </font></font><code translate="no">a</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">b</code><font papago-translate="splitted"><font papago-translate="translated"> 그런 다음 결과를 바로 저장합니다 </font></font><code translate="no">c</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p>
<p><font papago-translate="translated">디코딩하고 디스패치하는 명령어는 단 하나뿐이며, 전체가 4바이트 안에 들어갑니다.</font><font papago-translate="translated"> 디코딩은 추가 피연산자 때문에 더 복잡하지만, 여전히 순익입니다.</font><font papago-translate="translated"> 밀거나 터지거나 다른 스택 조작이 없습니다.</font></p>
<p><font papago-translate="translated">Lua의 주요 구현 방식은 스택 기반이었습니다.</font><font papago-translate="translated"> L<span name="lua">ua 5.</span>0의 경우, 구현자들은 레지스터 명령어 세트로 전환하고 속도 향상을 확인했습니다.</font><font papago-translate="translated"> 개선의 정도는 당연히 언어 의미론의 세부 사항, 특정 명령어 집합, 컴파일러 정교함에 크게 의존하지만, 이는 주의를 끌어야 합니다.</font></p>
<aside name="lua" style="top: 21797px;">
<p><font papago-translate="translated">루아 개발 팀인 로베르토 이루살림시, 발데마르 셀레스, 루이스 헨리케 드 피게이레<span class="em">도</span><span class="em"></span>는<em> 제</em>가 가장 좋아하는 컴퓨터 과학 논문 중 하나인<em> "</em><a href="https://www.lua.org/doc/jucs05.pdf">루아 5</a>.0의<a href="https://www.lua.org/doc/jucs05.pdf"> 구현</a>"(PDF)이라는<em> 환상</em>적인 논문을 작성했습니다.</font></p>
</aside>
<p><font papago-translate="translated">그것은 내가 왜 책의 나머지 부분을 스택 기반 바이트코드로 쓸 것인지에 대한 명백한 질문을 제기합니다.</font><font papago-translate="translated"> VM을 등록하는 것은 깔끔하지만 컴파일러를 작성하기가 상당히 어렵습니다.</font><font papago-translate="translated"> 당신의 첫 번째 컴파일러가 될 가능성이 높은 작업을 위해, 생성하기 쉽고 실행하기 쉬운 명령어 세트를 고수하고 싶었습니다.</font><font papago-translate="translated"> 스택 기반 바이트코드는 놀랍도록 간단합니다.</font></p>
<p><font papago-translate="translated">문헌과 커뮤니티에서도<em> 훨씬</em> 더 잘 알려져 있습니다.</font><font papago-translate="translated"> 비록 결국 더 발전된 것으로 전환할 수 있을지라도, 다른 언어 해커 동료들과 공유할 수 있는 좋은 공통점입니다.</font></p>
</div>
<footer>
<a class="next" href="https://youhogeon-meritz.github.io/scanning-on-demand.html"><font papago-translate="translated"> 다음 장: "주문형 스캔" → </font></a><font papago-translate="splitted"><font papago-translate="translated"> 로버트 니스트롬이 수작업으로 제작한 -<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE"> © 2015 ~ 2021</a></font></font>
</footer>
</article>
</div>


<div id="papagoTooltip" margin="5" style="display: none;">
        <h1 id="tooltipTitle">원문</h1>
        <p id="tooltipText"></p>
      </div>
      </body></html>