<!DOCTYPE html>

<html>
<head>
<meta content="text/html;charset=utf-8" http-equiv="Content-type"/>
<title>A Virtual Machine · Crafting Interpreters</title>
<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<link href="style.css" rel="stylesheet" type="text/css"/>
<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600" rel="stylesheet" type="text/css"/>
<link href="image/favicon.png" rel="icon" type="image/png">
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>
<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>
</link></head>
<body id="top">
<!-- <div class="scrim"></div> -->
<nav class="wide">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"/></a>
<div class="contents">
<h3><a href="#top">A Virtual Machine<small>15</small></a></h3>
<ul>
<li><a href="#an-instruction-execution-machine"><small>15.1</small> An Instruction Execution Machine</a></li>
<li><a href="#a-value-stack-manipulator"><small>15.2</small> A Value Stack Manipulator</a></li>
<li><a href="#an-arithmetic-calculator"><small>15.3</small> An Arithmetic Calculator</a></li>
<li class="divider"></li>
<li class="end-part"><a href="#challenges">Challenges</a></li>
<li class="end-part"><a href="#design-note"><small>note</small>Register-Based Bytecode</a></li>
</ul>
<div class="prev-next">
<a class="left" href="chunks-of-bytecode.html" title="Chunks of Bytecode">← Previous</a>
<a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">↑ Up</a>
<a class="right" href="scanning-on-demand.html" title="Scanning on Demand">Next →</a>
</div> </div>
</nav>
<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"/></a>
<a class="prev" href="chunks-of-bytecode.html" title="Chunks of Bytecode">←</a>
<a class="next" href="scanning-on-demand.html" title="Scanning on Demand">→</a>
</nav>
<div class="page">
<div class="nav-wrapper">
<nav class="floating">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"/></a>
<div class="expandable">
<h3><a href="#top">A Virtual Machine<small>15</small></a></h3>
<ul>
<li><a href="#an-instruction-execution-machine"><small>15.1</small> An Instruction Execution Machine</a></li>
<li><a href="#a-value-stack-manipulator"><small>15.2</small> A Value Stack Manipulator</a></li>
<li><a href="#an-arithmetic-calculator"><small>15.3</small> An Arithmetic Calculator</a></li>
<li class="divider"></li>
<li class="end-part"><a href="#challenges">Challenges</a></li>
<li class="end-part"><a href="#design-note"><small>note</small>Register-Based Bytecode</a></li>
</ul>
<div class="prev-next">
<a class="left" href="chunks-of-bytecode.html" title="Chunks of Bytecode">← Previous</a>
<a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">↑ Up</a>
<a class="right" href="scanning-on-demand.html" title="Scanning on Demand">Next →</a>
</div> </div>
<a id="expand-nav">≡</a>
</nav>
</div>
<article class="chapter">
<div class="number">15</div>
<h1>A Virtual Machine</h1>
<blockquote>
<p>Magicians protect their secrets not because the secrets are large and
important, but because they are so small and trivial. The wonderful effects
created on stage are often the result of a secret so absurd that the magician
would be embarrassed to admit that that was how it was done.</p>
<p><cite>Christopher Priest, <em>The Prestige</em></cite></p>
</blockquote>
<p>We’ve spent a lot of time talking about how to represent a program as a sequence
of bytecode instructions, but it feels like learning biology using only stuffed,
dead animals. We know what instructions are in theory, but we’ve never seen them
in action, so it’s hard to really understand what they <em>do</em>. It would be hard to
write a compiler that outputs bytecode when we don’t have a good understanding
of how that bytecode behaves.</p>
<p>So, before we go and build the front end of our new interpreter, we will begin
with the back end<span class="em">—</span>the virtual machine that executes instructions. It breathes
life into the bytecode. Watching the instructions prance around gives us a
clearer picture of how a compiler might translate the user’s source code into a
series of them.</p>
<h2><a href="#an-instruction-execution-machine" id="an-instruction-execution-machine"><small>15 . 1</small>An Instruction Execution Machine</a></h2>
<p>The virtual machine is one part of our interpreter’s internal architecture. You
hand it a chunk of code<span class="em">—</span>literally a Chunk<span class="em">—</span>and it runs it. The code and
data structures for the VM reside in a new module.</p>
<div class="codehilite"><div class="source-file"><em>vm.h</em><br/>
create new file</div>
<pre translate="no"><span class="a">#ifndef clox_vm_h</span>
<span class="a">#define clox_vm_h</span>

<span class="a">#include "chunk.h"</span>

<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">Chunk</span>* <span class="i">chunk</span>;
} <span class="a">VM</span>;

<span class="t">void</span> <span class="i">initVM</span>();
<span class="t">void</span> <span class="i">freeVM</span>();

<span class="a">#endif</span>
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, create new file</div>
<p>As usual, we start simple. The VM will gradually acquire a whole pile of state
it needs to keep track of, so we define a struct now to stuff that all in.
Currently, all we store is the chunk that it executes.</p>
<p>Like we do with most of the data structures we create, we also define functions
to create and tear down a VM. Here’s the implementation:</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br/>
create new file</div>
<pre translate="no"><span class="a">#include "common.h"</span>
<span class="a">#include "vm.h"</span>

<span class="a">VM</span> <span class="i">vm</span>;<span name="one"> </span>

<span class="t">void</span> <span class="i">initVM</span>() {
}

<span class="t">void</span> <span class="i">freeVM</span>() {
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, create new file</div>
<p>OK, calling those functions “implementations” is a stretch. We don’t have any
interesting state to initialize or free yet, so the functions are empty. Trust
me, we’ll get there.</p>
<p>The slightly more interesting line here is that declaration of <code translate="no">vm</code>. This module
is eventually going to have a slew of functions and it would be a chore to pass
around a pointer to the VM to all of them. Instead, we declare a single global
VM object. We need only one anyway, and this keeps the code in the book a little
lighter on the page.</p>
<aside name="one">
<p>The choice to have a static VM instance is a concession for the book, but not
necessarily a sound engineering choice for a real language implementation. If
you’re building a VM that’s designed to be embedded in other host applications,
it gives the host more flexibility if you <em>do</em> explicitly take a VM pointer
and pass it around.</p>
<p>That way, the host app can control when and where memory for the VM is
allocated, run multiple VMs in parallel, etc.</p>
<p>What I’m doing here is a global variable, and <a href="http://gameprogrammingpatterns.com/singleton.html">everything bad you’ve heard about
global variables</a> is still true when programming in the large. But when
keeping things small for a book<span class="ellipse"> . . . </span></p>
</aside>
<p>Before we start pumping fun code into our VM, let’s go ahead and wire it up to
the interpreter’s main entrypoint.</p>
<div class="codehilite"><pre class="insert-before" translate="no">int main(int argc, const char* argv[]) {
</pre><div class="source-file"><em>main.c</em><br/>
in <em>main</em>()</div>
<pre class="insert" translate="no">  <span class="i">initVM</span>();

</pre><pre class="insert-after" translate="no">  Chunk chunk;
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>main</em>()</div>
<p>We spin up the VM when the interpreter first starts. Then when we’re about to
exit, we wind it down.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  disassembleChunk(&amp;chunk, "test chunk");
</pre><div class="source-file"><em>main.c</em><br/>
in <em>main</em>()</div>
<pre class="insert" translate="no">  <span class="i">freeVM</span>();
</pre><pre class="insert-after" translate="no">  freeChunk(&amp;chunk);
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>main</em>()</div>
<p>One last ceremonial obligation:</p>
<div class="codehilite"><pre class="insert-before" translate="no">#include "debug.h"
</pre><div class="source-file"><em>main.c</em></div>
<pre class="insert" translate="no"><span class="a">#include "vm.h"</span>
</pre><pre class="insert-after" translate="no">

int main(int argc, const char* argv[]) {
</pre></div>
<div class="source-file-narrow"><em>main.c</em></div>
<p>Now when you run clox, it starts up the VM before it creates that hand-authored
chunk from the <a href="chunks-of-bytecode.html#disassembling-chunks">last chapter</a>. The VM is ready and waiting, so let’s teach it
to do something.</p>
<h3><a href="#executing-instructions" id="executing-instructions"><small>15 . 1 . 1</small>Executing instructions</a></h3>
<p>The VM springs into action when we command it to interpret a chunk of bytecode.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  disassembleChunk(&amp;chunk, "test chunk");
</pre><div class="source-file"><em>main.c</em><br/>
in <em>main</em>()</div>
<pre class="insert" translate="no">  <span class="i">interpret</span>(&amp;<span class="i">chunk</span>);
</pre><pre class="insert-after" translate="no">  freeVM();
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>main</em>()</div>
<p>This function is the main entrypoint into the VM. It’s declared like so:</p>
<div class="codehilite"><pre class="insert-before" translate="no">void freeVM();
</pre><div class="source-file"><em>vm.h</em><br/>
add after <em>freeVM</em>()</div>
<pre class="insert" translate="no"><span class="t">InterpretResult</span> <span class="i">interpret</span>(<span class="t">Chunk</span>* <span class="i">chunk</span>);
</pre><pre class="insert-after" translate="no">

#endif
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, add after <em>freeVM</em>()</div>
<p>The VM runs the chunk and then responds with a value from this enum:</p>
<div class="codehilite"><pre class="insert-before" translate="no">} VM;

</pre><div class="source-file"><em>vm.h</em><br/>
add after struct <em>VM</em></div>
<pre class="insert" translate="no"><span class="k">typedef</span> <span class="k">enum</span> {
  <span class="a">INTERPRET_OK</span>,
  <span class="a">INTERPRET_COMPILE_ERROR</span>,
  <span class="a">INTERPRET_RUNTIME_ERROR</span>
} <span class="t">InterpretResult</span>;

</pre><pre class="insert-after" translate="no">void initVM();
void freeVM();
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, add after struct <em>VM</em></div>
<p>We aren’t using the result yet, but when we have a compiler that reports static
errors and a VM that detects runtime errors, the interpreter will use this to
know how to set the exit code of the process.</p>
<p>We’re inching towards some actual implementation.</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br/>
add after <em>freeVM</em>()</div>
<pre translate="no"><span class="t">InterpretResult</span> <span class="i">interpret</span>(<span class="t">Chunk</span>* <span class="i">chunk</span>) {
  <span class="i">vm</span>.<span class="i">chunk</span> = <span class="i">chunk</span>;
  <span class="i">vm</span>.<span class="i">ip</span> = <span class="i">vm</span>.<span class="i">chunk</span>-&gt;<span class="i">code</span>;
  <span class="k">return</span> <span class="i">run</span>();
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>freeVM</em>()</div>
<p>First, we store the chunk being executed in the VM. Then we call <code translate="no">run()</code>, an
internal helper function that actually runs the bytecode instructions. Between
those two parts is an intriguing line. What is this <code translate="no">ip</code> business?</p>
<p>As the VM works its way through the bytecode, it keeps track of where it is<span class="em">—</span>the location of the instruction currently being executed. We don’t use a <span name="local">local</span> variable inside <code translate="no">run()</code> for this because eventually
other functions will need to access it. Instead, we store it as a field in VM.</p>
<aside name="local">
<p>If we were trying to squeeze every ounce of speed out of our bytecode
interpreter, we would store <code translate="no">ip</code> in a local variable. It gets modified so often
during execution that we want the C compiler to keep it in a register.</p>
</aside>
<div class="codehilite"><pre class="insert-before" translate="no">typedef struct {
  Chunk* chunk;
</pre><div class="source-file"><em>vm.h</em><br/>
in struct <em>VM</em></div>
<pre class="insert" translate="no">  <span class="t">uint8_t</span>* <span class="i">ip</span>;
</pre><pre class="insert-after" translate="no">} VM;
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, in struct <em>VM</em></div>
<p>Its type is a byte pointer. We use an actual real C pointer pointing right into
the middle of the bytecode array instead of something like an integer index
because it’s faster to dereference a pointer than look up an element in an array
by index.</p>
<p>The name “IP” is traditional, and<span class="em">—</span>unlike many traditional names in CS<span class="em">—</span>actually makes sense: it’s an <strong><a href="https://en.wikipedia.org/wiki/Program_counter">instruction pointer</a></strong>. Almost every
instruction set in the <span name="ip">world</span>, real and virtual, has a
register or variable like this.</p>
<aside name="ip">
<p>x86, x64, and the CLR call it “IP”. 68k, PowerPC, ARM, p-code, and the JVM call
it “PC”, for <strong>program counter</strong>.</p>
</aside>
<p>We initialize <code translate="no">ip</code> by pointing it at the first byte of code in the chunk. We
haven’t executed that instruction yet, so <code translate="no">ip</code> points to the instruction <em>about
to be executed</em>. This will be true during the entire time the VM is running: the
IP always points to the next instruction, not the one currently being handled.</p>
<p>The real fun happens in <code translate="no">run</code>().</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br/>
add after <em>freeVM</em>()</div>
<pre translate="no"><span class="k">static</span> <span class="t">InterpretResult</span> <span class="i">run</span>() {
<span class="a">#define READ_BYTE() (*vm.ip++)</span>

  <span class="k">for</span> (;;) {
    <span class="t">uint8_t</span> <span class="i">instruction</span>;
    <span class="k">switch</span> (<span class="i">instruction</span> = <span class="a">READ_BYTE</span>()) {
      <span class="k">case</span> <span class="a">OP_RETURN</span>: {
        <span class="k">return</span> <span class="a">INTERPRET_OK</span>;
      }
    }
  }

<span class="a">#undef READ_BYTE</span>
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>freeVM</em>()</div>
<p>This is the single most <span name="important">important</span> function in all
of clox, by far. When the interpreter executes a user’s program, it will spend
something like 90% of its time inside <code translate="no">run()</code>. It is the beating heart of the
VM.</p>
<aside name="important">
<p>Or, at least, it <em>will</em> be in a few chapters when it has enough content to be
useful. Right now, it’s not exactly a wonder of software wizardry.</p>
</aside>
<p>Despite that dramatic intro, it’s conceptually pretty simple. We have an outer
loop that goes and goes. Each turn through that loop, we read and execute a
single bytecode instruction.</p>
<p>To process an instruction, we first figure out what kind of instruction we’re
dealing with. The <code translate="no">READ_BYTE</code> macro reads the byte currently pointed at by <code translate="no">ip</code>
and then <span name="next">advances</span> the instruction pointer. The first
byte of any instruction is the opcode. Given a numeric opcode, we need to get to
the right C code that implements that instruction’s semantics. This process is
called <strong>decoding</strong> or <strong>dispatching</strong> the instruction.</p>
<aside name="next">
<p>Note that <code translate="no">ip</code> advances as soon as we read the opcode, before we’ve actually
started executing the instruction. So, again, <code translate="no">ip</code> points to the <em>next</em>
byte of code to be used.</p>
</aside>
<p>We do that process for every single instruction, every single time one is
executed, so this is the most performance critical part of the entire virtual
machine. Programming language lore is filled with <span name="dispatch">clever</span> techniques to do bytecode dispatch efficiently,
going all the way back to the early days of computers.</p>
<aside name="dispatch">
<p>If you want to learn some of these techniques, look up “direct threaded code”,
“jump table”, and “computed goto”.</p>
</aside>
<p>Alas, the fastest solutions require either non-standard extensions to C, or
handwritten assembly code. For clox, we’ll keep it simple. Just like our
disassembler, we have a single giant <code translate="no">switch</code> statement with a case for each
opcode. The body of each case implements that opcode’s behavior.</p>
<p>So far, we handle only a single instruction, <code translate="no">OP_RETURN</code>, and the only thing it
does is exit the loop entirely. Eventually, that instruction will be used to
return from the current Lox function, but we don’t have functions yet, so we’ll
repurpose it temporarily to end the execution.</p>
<p>Let’s go ahead and support our one other instruction.</p>
<div class="codehilite"><pre class="insert-before" translate="no">    switch (instruction = READ_BYTE()) {
</pre><div class="source-file"><em>vm.c</em><br/>
in <em>run</em>()</div>
<pre class="insert" translate="no">      <span class="k">case</span> <span class="a">OP_CONSTANT</span>: {
        <span class="t">Value</span> <span class="i">constant</span> = <span class="a">READ_CONSTANT</span>();
        <span class="i">printValue</span>(<span class="i">constant</span>);
        <span class="i">printf</span>(<span class="s">"</span><span class="e">\n</span><span class="s">"</span>);
        <span class="k">break</span>;
      }
</pre><pre class="insert-after" translate="no">      case OP_RETURN: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p>We don’t have enough machinery in place yet to do anything useful with a
constant. For now, we’ll just print it out so we interpreter hackers can see
what’s going on inside our VM. That call to <code translate="no">printf()</code> necessitates an include.</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br/>
add to top of file</div>
<pre class="insert" translate="no"><span class="a">#include &lt;stdio.h&gt;</span>

</pre><pre class="insert-after" translate="no">#include "common.h"
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add to top of file</div>
<p>We also have a new macro to define.</p>
<div class="codehilite"><pre class="insert-before" translate="no">#define READ_BYTE() (*vm.ip++)
</pre><div class="source-file"><em>vm.c</em><br/>
in <em>run</em>()</div>
<pre class="insert" translate="no"><span class="a">#define READ_CONSTANT() (vm.chunk-&gt;constants.values[READ_BYTE()])</span>
</pre><pre class="insert-after" translate="no">

  for (;;) {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p><code translate="no">READ_CONSTANT()</code> reads the next byte from the bytecode, treats the resulting
number as an index, and looks up the corresponding Value in the chunk’s constant
table. In later chapters, we’ll add a few more instructions with operands that
refer to constants, so we’re setting up this helper macro now.</p>
<p>Like the previous <code translate="no">READ_BYTE</code> macro, <code translate="no">READ_CONSTANT</code> is only used inside
<code translate="no">run()</code>. To make that scoping more explicit, the macro definitions themselves
are confined to that function. We <span name="macro">define</span> them at the
beginning and<span class="em">—</span>because we care<span class="em">—</span>undefine them at the end.</p>
<div class="codehilite"><pre class="insert-before" translate="no">#undef READ_BYTE
</pre><div class="source-file"><em>vm.c</em><br/>
in <em>run</em>()</div>
<pre class="insert" translate="no"><span class="a">#undef READ_CONSTANT</span>
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<aside name="macro">
<p>Undefining these macros explicitly might seem needlessly fastidious, but C tends
to punish sloppy users, and the C preprocessor doubly so.</p>
</aside>
<h3><a href="#execution-tracing" id="execution-tracing"><small>15 . 1 . 2</small>Execution tracing</a></h3>
<p>If you run clox now, it executes the chunk we hand-authored in the last chapter
and spits out <code translate="no">1.2</code> to your terminal. We can see that it’s working, but that’s
only because our implementation of <code translate="no">OP_CONSTANT</code> has temporary code to log the
value. Once that instruction is doing what it’s supposed to do and plumbing that
constant along to other operations that want to consume it, the VM will become a
black box. That makes our lives as VM implementers harder.</p>
<p>To help ourselves out, now is a good time to add some diagnostic logging to the
VM like we did with chunks themselves. In fact, we’ll even reuse the same code.
We don’t want this logging enabled all the time<span class="em">—</span>it’s just for us VM hackers,
not Lox users<span class="em">—</span>so first we create a flag to hide it behind.</p>
<div class="codehilite"><pre class="insert-before" translate="no">#include &lt;stdint.h&gt;
</pre><div class="source-file"><em>common.h</em></div>
<pre class="insert" translate="no">

<span class="a">#define DEBUG_TRACE_EXECUTION</span>
</pre><pre class="insert-after" translate="no">

#endif
</pre></div>
<div class="source-file-narrow"><em>common.h</em></div>
<p>When this flag is defined, the VM disassembles and prints each instruction right
before executing it. Where our previous disassembler walked an entire chunk
once, statically, this disassembles instructions dynamically, on the fly.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  for (;;) {
</pre><div class="source-file"><em>vm.c</em><br/>
in <em>run</em>()</div>
<pre class="insert" translate="no"><span class="a">#ifdef DEBUG_TRACE_EXECUTION</span>
    <span class="i">disassembleInstruction</span>(<span class="i">vm</span>.<span class="i">chunk</span>,
                           (<span class="t">int</span>)(<span class="i">vm</span>.<span class="i">ip</span> - <span class="i">vm</span>.<span class="i">chunk</span>-&gt;<span class="i">code</span>));
<span class="a">#endif</span>

</pre><pre class="insert-after" translate="no">    uint8_t instruction;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p>Since <code translate="no">disassembleInstruction()</code> takes an integer byte <em>offset</em> and we store the
current instruction reference as a direct pointer, we first do a little pointer
math to convert <code translate="no">ip</code> back to a relative offset from the beginning of the
bytecode. Then we disassemble the instruction that begins at that byte.</p>
<p>As ever, we need to bring in the declaration of the function before we can call
it.</p>
<div class="codehilite"><pre class="insert-before" translate="no">#include "common.h"
</pre><div class="source-file"><em>vm.c</em></div>
<pre class="insert" translate="no"><span class="a">#include "debug.h"</span>
</pre><pre class="insert-after" translate="no">#include "vm.h"
</pre></div>
<div class="source-file-narrow"><em>vm.c</em></div>
<p>I know this code isn’t super impressive so far<span class="em">—</span>it’s literally a switch
statement wrapped in a <code translate="no">for</code> loop but, believe it or not, this is one of the two
major components of our VM. With this, we can imperatively execute instructions.
Its simplicity is a virtue<span class="em">—</span>the less work it does, the faster it can do it.
Contrast this with all of the complexity and overhead we had in jlox with the
Visitor pattern for walking the AST.</p>
<h2><a href="#a-value-stack-manipulator" id="a-value-stack-manipulator"><small>15 . 2</small>A Value Stack Manipulator</a></h2>
<p>In addition to imperative side effects, Lox has expressions that produce,
modify, and consume values. Thus, our compiled bytecode needs a way to shuttle
values around between the different instructions that need them. For example:</p>
<div class="codehilite"><pre translate="no"><span class="k">print</span> <span class="n">3</span> - <span class="n">2</span>;
</pre></div>
<p>We obviously need instructions for the constants 3 and 2, the <code translate="no">print</code> statement,
and the subtraction. But how does the subtraction instruction know that 3 is
the <span name="word">minuend</span> and 2 is the subtrahend? How does the print
instruction know to print the result of that?</p>
<aside name="word">
<p>Yes, I did have to look up “subtrahend” and “minuend” in a dictionary. But
aren’t they delightful words? “Minuend” sounds like a kind of Elizabethan dance
and “subtrahend” might be some sort of underground Paleolithic monument.</p>
</aside>
<p>To put a finer point on it, look at this thing right here:</p>
<div class="codehilite"><pre translate="no"><span class="k">fun</span> <span class="i">echo</span>(<span class="i">n</span>) {
  <span class="k">print</span> <span class="i">n</span>;
  <span class="k">return</span> <span class="i">n</span>;
}

<span class="k">print</span> <span class="i">echo</span>(<span class="i">echo</span>(<span class="n">1</span>) + <span class="i">echo</span>(<span class="n">2</span>)) + <span class="i">echo</span>(<span class="i">echo</span>(<span class="n">4</span>) + <span class="i">echo</span>(<span class="n">5</span>));
</pre></div>
<p>I wrapped each subexpression in a call to <code translate="no">echo()</code> that prints and returns its
argument. That side effect means we can see the exact order of operations.</p>
<p>Don’t worry about the VM for a minute. Think about just the semantics of Lox
itself. The operands to an arithmetic operator obviously need to be evaluated
before we can perform the operation itself. (It’s pretty hard to add <code translate="no">a + b</code> if
you don’t know what <code translate="no">a</code> and <code translate="no">b</code> are.) Also, when we implemented expressions in
jlox, we <span name="undefined">decided</span> that the left operand must be
evaluated before the right.</p>
<aside name="undefined">
<p>We could have left evaluation order unspecified and let each implementation
decide. That leaves the door open for optimizing compilers to reorder arithmetic
expressions for efficiency, even in cases where the operands have visible side
effects. C and Scheme leave evaluation order unspecified. Java specifies
left-to-right evaluation like we do for Lox.</p>
<p>I think nailing down stuff like this is generally better for users. When
expressions are not evaluated in the order users intuit<span class="em">—</span>possibly in different
orders across different implementations!<span class="em">—</span>it can be a burning hellscape of
pain to figure out what’s going on.</p>
</aside>
<p>Here is the syntax tree for the <code translate="no">print</code> statement:</p>
<p><img alt="The AST for the example
statement, with numbers marking the order that the nodes are evaluated." src="image/a-virtual-machine/ast.png"/></p>
<p>Given left-to-right evaluation, and the way the expressions are nested, any
correct Lox implementation <em>must</em> print these numbers in this order:</p>
<div class="codehilite"><pre translate="no">1  // from echo(1)
2  // from echo(2)
3  // from echo(1 + 2)
4  // from echo(4)
5  // from echo(5)
9  // from echo(4 + 5)
12 // from print 3 + 9
</pre></div>
<p>Our old jlox interpreter accomplishes this by recursively traversing the AST. It
does a postorder traversal. First it recurses down the left operand branch,
then the right operand, then finally it evaluates the node itself.</p>
<p>After evaluating the left operand, jlox needs to store that result somewhere
temporarily while it’s busy traversing down through the right operand tree. We
use a local variable in Java for that. Our recursive tree-walk interpreter
creates a unique Java call frame for each node being evaluated, so we could have
as many of these local variables as we needed.</p>
<p>In clox, our <code translate="no">run()</code> function is not recursive<span class="em">—</span>the nested expression tree is
flattened out into a linear series of instructions. We don’t have the luxury of
using C local variables, so how and where should we store these temporary
values? You can probably <span name="guess">guess</span> already, but I want to
really drill into this because it’s an aspect of programming that we take for
granted, but we rarely learn <em>why</em> computers are architected this way.</p>
<aside name="guess">
<p>Hint: it’s in the name of this section, and it’s how Java and C manage recursive
calls to functions.</p>
</aside>
<p>Let’s do a weird exercise. We’ll walk through the execution of the above program
a step at a time:</p>
<p><img alt="The series of instructions with
bars showing which numbers need to be preserved across which instructions." src="image/a-virtual-machine/bars.png"/></p>
<p>On the left are the steps of code. On the right are the values we’re tracking.
Each bar represents a number. It starts when the value is first produced<span class="em">—</span>either a constant or the result of an addition. The length of the bar tracks
when a previously produced value needs to be kept around, and it ends when that
value finally gets consumed by an operation.</p>
<p>As you step through, you see values appear and then later get eaten. The
longest-lived ones are the values produced from the left-hand side of an
addition. Those stick around while we work through the right-hand operand
expression.</p>
<p>In the above diagram, I gave each unique number its own visual column. Let’s be
a little more parsimonious. Once a number is consumed, we allow its column to be
reused for another later value. In other words, we take all of those gaps
up there and fill them in, pushing in numbers from the right:</p>
<p><img alt="Like the previous
diagram, but with number bars pushed to the left, forming a stack." src="image/a-virtual-machine/bars-stacked.png"/></p>
<p>There’s some interesting stuff going on here. When we shift everything over,
each number still manages to stay in a single column for its entire life. Also,
there are no gaps left. In other words, whenever a number appears earlier than
another, then it will live at least as long as that second one. The first number
to appear is the last to be consumed. Hmm<span class="ellipse"> . . . </span>last-in, first-out<span class="ellipse"> . . . </span>why, that’s a
<span name="pancakes">stack</span>!</p>
<aside name="pancakes">
<p>This is also a stack:</p><img alt="A stack... of pancakes." src="image/a-virtual-machine/pancakes.png"/>
</aside>
<p>In the second diagram, each time we introduce a number, we push it onto the
stack from the right. When numbers are consumed, they are always popped off from
rightmost to left.</p>
<p>Since the temporary values we need to track naturally have stack-like behavior,
our VM will use a stack to manage them. When an instruction “produces” a value,
it pushes it onto the stack. When it needs to consume one or more values, it
gets them by popping them off the stack.</p>
<h3><a href="#the-vms-stack" id="the-vms-stack"><small>15 . 2 . 1</small>The VM’s Stack</a></h3>
<p>Maybe this doesn’t seem like a revelation, but I <em>love</em> stack-based VMs. When
you first see a magic trick, it feels like something actually magical. But then
you learn how it works<span class="em">—</span>usually some mechanical gimmick or misdirection<span class="em">—</span>and
the sense of wonder evaporates. There are a <span name="wonder">couple</span> of
ideas in computer science where even after I pulled them apart and learned all
the ins and outs, some of the initial sparkle remained. Stack-based VMs are one
of those.</p>
<aside name="wonder">
<p>Heaps<span class="em">—</span><a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">the data structure</a>, not <a href="https://en.wikipedia.org/wiki/Memory_management#HEAP">the memory management thing</a><span class="em">—</span>are another. And Vaughan Pratt’s top-down operator precedence parsing scheme,
which we’ll learn about <a href="compiling-expressions.html">in due time</a>.</p>
</aside>
<p>As you’ll see in this chapter, executing instructions in a stack-based VM is
dead <span name="cheat">simple</span>. In later chapters, you’ll also discover
that compiling a source language to a stack-based instruction set is a piece of
cake. And yet, this architecture is fast enough to be used by production
language implementations. It almost feels like cheating at the programming
language game.</p>
<aside name="cheat">
<p>To take a bit of the sheen off: stack-based interpreters aren’t a silver bullet.
They’re often <em>adequate</em>, but modern implementations of the JVM, the CLR, and
JavaScript all use sophisticated <a href="https://en.wikipedia.org/wiki/Just-in-time_compilation">just-in-time compilation</a> pipelines to
generate <em>much</em> faster native code on the fly.</p>
</aside>
<p>Alrighty, it’s codin’ time! Here’s the stack:</p>
<div class="codehilite"><pre class="insert-before" translate="no">typedef struct {
  Chunk* chunk;
  uint8_t* ip;
</pre><div class="source-file"><em>vm.h</em><br/>
in struct <em>VM</em></div>
<pre class="insert" translate="no">  <span class="t">Value</span> <span class="i">stack</span>[<span class="a">STACK_MAX</span>];
  <span class="t">Value</span>* <span class="i">stackTop</span>;
</pre><pre class="insert-after" translate="no">} VM;
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, in struct <em>VM</em></div>
<p>We implement the stack semantics ourselves on top of a raw C array. The bottom
of the stack<span class="em">—</span>the first value pushed and the last to be popped<span class="em">—</span>is at
element zero in the array, and later pushed values follow it. If we push the
letters of “crepe”<span class="em">—</span>my favorite stackable breakfast item<span class="em">—</span>onto the stack, in
order, the resulting C array looks like this:</p>
<p><img alt="An array containing the
letters in 'crepe' in order starting at element 0." src="image/a-virtual-machine/array.png"/></p>
<p>Since the stack grows and shrinks as values are pushed and popped, we need to
track where the top of the stack is in the array. As with <code translate="no">ip</code>, we use a direct
pointer instead of an integer index since it’s faster to dereference the pointer
than calculate the offset from the index each time we need it.</p>
<p>The pointer points at the array element just <em>past</em> the element containing the
top value on the stack. That seems a little odd, but almost every implementation
does this. It means we can indicate that the stack is empty by pointing at
element zero in the array.</p>
<p><img alt="An empty array with
stackTop pointing at the first element." src="image/a-virtual-machine/stack-empty.png"/></p>
<p>If we pointed to the top element, then for an empty stack we’d need to point at
element -1. That’s <span name="defined">undefined</span> in C. As we push values
onto the stack<span class="ellipse"> . . . </span></p>
<aside name="defined">
<p>What about when the stack is <em>full</em>, you ask, Clever Reader? The C standard is
one step ahead of you. It <em>is</em> allowed and well-specified to have an array
pointer that points just past the end of an array.</p>
</aside>
<p><img alt="An array with 'c' at element
zero." src="image/a-virtual-machine/stack-c.png"/></p>
<p><span class="ellipse"> . . . </span><code translate="no">stackTop</code> always points just past the last item.</p>
<p><img alt="An array with 'c', 'r',
'e', 'p', and 'e' in the first five elements." src="image/a-virtual-machine/stack-crepe.png"/></p>
<p>I remember it like this: <code translate="no">stackTop</code> points to where the next value to be pushed
will go. The maximum number of values we can store on the stack (for now, at
least) is:</p>
<div class="codehilite"><pre class="insert-before" translate="no">#include "chunk.h"
</pre><div class="source-file"><em>vm.h</em></div>
<pre class="insert" translate="no">

<span class="a">#define STACK_MAX 256</span>
</pre><pre class="insert-after" translate="no">

typedef struct {
</pre></div>
<div class="source-file-narrow"><em>vm.h</em></div>
<p>Giving our VM a fixed stack size means it’s possible for some sequence of
instructions to push too many values and run out of stack space<span class="em">—</span>the classic
“stack overflow”. We could grow the stack dynamically as needed, but for now
we’ll keep it simple. Since VM uses Value, we need to include its declaration.</p>
<div class="codehilite"><pre class="insert-before" translate="no">#include "chunk.h"
</pre><div class="source-file"><em>vm.h</em></div>
<pre class="insert" translate="no"><span class="a">#include "value.h"</span>
</pre><pre class="insert-after" translate="no">

#define STACK_MAX 256
</pre></div>
<div class="source-file-narrow"><em>vm.h</em></div>
<p>Now that VM has some interesting state, we get to initialize it.</p>
<div class="codehilite"><pre class="insert-before" translate="no">void initVM() {
</pre><div class="source-file"><em>vm.c</em><br/>
in <em>initVM</em>()</div>
<pre class="insert" translate="no">  <span class="i">resetStack</span>();
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>initVM</em>()</div>
<p>That uses this helper function:</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br/>
add after variable <em>vm</em></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">resetStack</span>() {
  <span class="i">vm</span>.<span class="i">stackTop</span> = <span class="i">vm</span>.<span class="i">stack</span>;
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after variable <em>vm</em></div>
<p>Since the stack array is declared directly inline in the VM struct, we don’t
need to allocate it. We don’t even need to clear the unused cells in the
array<span class="em">—</span>we simply won’t access them until after values have been stored in
them. The only initialization we need is to set <code translate="no">stackTop</code> to point to the
beginning of the array to indicate that the stack is empty.</p>
<p>The stack protocol supports two operations:</p>
<div class="codehilite"><pre class="insert-before" translate="no">InterpretResult interpret(Chunk* chunk);
</pre><div class="source-file"><em>vm.h</em><br/>
add after <em>interpret</em>()</div>
<pre class="insert" translate="no"><span class="t">void</span> <span class="i">push</span>(<span class="t">Value</span> <span class="i">value</span>);
<span class="t">Value</span> <span class="i">pop</span>();
</pre><pre class="insert-after" translate="no">

#endif
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, add after <em>interpret</em>()</div>
<p>You can push a new value onto the top of the stack, and you can pop the most
recently pushed value back off. Here’s the first function:</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br/>
add after <em>freeVM</em>()</div>
<pre translate="no"><span class="t">void</span> <span class="i">push</span>(<span class="t">Value</span> <span class="i">value</span>) {
  *<span class="i">vm</span>.<span class="i">stackTop</span> = <span class="i">value</span>;
  <span class="i">vm</span>.<span class="i">stackTop</span>++;
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>freeVM</em>()</div>
<p>If you’re rusty on your C pointer syntax and operations, this is a good warm-up.
The first line stores <code translate="no">value</code> in the array element at the top of the stack.
Remember, <code translate="no">stackTop</code> points just <em>past</em> the last used element, at the next
available one. This stores the value in that slot. Then we increment the pointer
itself to point to the next unused slot in the array now that the previous slot
is occupied.</p>
<p>Popping is the mirror image.</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br/>
add after <em>push</em>()</div>
<pre translate="no"><span class="t">Value</span> <span class="i">pop</span>() {
  <span class="i">vm</span>.<span class="i">stackTop</span>--;
  <span class="k">return</span> *<span class="i">vm</span>.<span class="i">stackTop</span>;
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>push</em>()</div>
<p>First, we move the stack pointer <em>back</em> to get to the most recent used slot in
the array. Then we look up the value at that index and return it. We don’t need
to explicitly “remove” it from the array<span class="em">—</span>moving <code translate="no">stackTop</code> down is enough to
mark that slot as no longer in use.</p>
<h3><a href="#stack-tracing" id="stack-tracing"><small>15 . 2 . 2</small>Stack tracing</a></h3>
<p>We have a working stack, but it’s hard to <em>see</em> that it’s working. When we start
implementing more complex instructions and compiling and running larger pieces
of code, we’ll end up with a lot of values crammed into that array. It would
make our lives as VM hackers easier if we had some visibility into the stack.</p>
<p>To that end, whenever we’re tracing execution, we’ll also show the current
contents of the stack before we interpret each instruction.</p>
<div class="codehilite"><pre class="insert-before" translate="no">#ifdef DEBUG_TRACE_EXECUTION
</pre><div class="source-file"><em>vm.c</em><br/>
in <em>run</em>()</div>
<pre class="insert" translate="no">    <span class="i">printf</span>(<span class="s">"          "</span>);
    <span class="k">for</span> (<span class="t">Value</span>* <span class="i">slot</span> = <span class="i">vm</span>.<span class="i">stack</span>; <span class="i">slot</span> &lt; <span class="i">vm</span>.<span class="i">stackTop</span>; <span class="i">slot</span>++) {
      <span class="i">printf</span>(<span class="s">"[ "</span>);
      <span class="i">printValue</span>(*<span class="i">slot</span>);
      <span class="i">printf</span>(<span class="s">" ]"</span>);
    }
    <span class="i">printf</span>(<span class="s">"</span><span class="e">\n</span><span class="s">"</span>);
</pre><pre class="insert-after" translate="no">    disassembleInstruction(vm.chunk,
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p>We loop, printing each value in the array, starting at the first (bottom of the
stack) and ending when we reach the top. This lets us observe the effect of each
instruction on the stack. The output is pretty verbose, but it’s useful when
we’re surgically extracting a nasty bug from the bowels of the interpreter.</p>
<p>Stack in hand, let’s revisit our two instructions. First up:</p>
<div class="codehilite"><pre class="insert-before" translate="no">      case OP_CONSTANT: {
        Value constant = READ_CONSTANT();
</pre><div class="source-file"><em>vm.c</em><br/>
in <em>run</em>()<br/>
replace 2 lines</div>
<pre class="insert" translate="no">        <span class="i">push</span>(<span class="i">constant</span>);
</pre><pre class="insert-after" translate="no">        break;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 2 lines</div>
<p>In the last chapter, I was hand-wavey about how the <code translate="no">OP_CONSTANT</code> instruction
“loads” a constant. Now that we have a stack you know what it means to actually
produce a value: it gets pushed onto the stack.</p>
<div class="codehilite"><pre class="insert-before" translate="no">      case OP_RETURN: {
</pre><div class="source-file"><em>vm.c</em><br/>
in <em>run</em>()</div>
<pre class="insert" translate="no">        <span class="i">printValue</span>(<span class="i">pop</span>());
        <span class="i">printf</span>(<span class="s">"</span><span class="e">\n</span><span class="s">"</span>);
</pre><pre class="insert-after" translate="no">        return INTERPRET_OK;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p>Then we make <code translate="no">OP_RETURN</code> pop the stack and print the top value before exiting.
When we add support for real functions to clox, we’ll change this code. But, for
now, it gives us a way to get the VM executing simple instruction sequences and
displaying the result.</p>
<h2><a href="#an-arithmetic-calculator" id="an-arithmetic-calculator"><small>15 . 3</small>An Arithmetic Calculator</a></h2>
<p>The heart and soul of our VM are in place now. The bytecode loop dispatches and
executes instructions. The stack grows and shrinks as values flow through it.
The two halves work, but it’s hard to get a feel for how cleverly they interact
with only the two rudimentary instructions we have so far. So let’s teach our
interpreter to do arithmetic.</p>
<p>We’ll start with the simplest arithmetic operation, unary negation.</p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="i">a</span> = <span class="n">1.2</span>;
<span class="k">print</span> -<span class="i">a</span>; <span class="c">// -1.2.</span>
</pre></div>
<p>The prefix <code translate="no">-</code> operator takes one operand, the value to negate. It produces a
single result. We aren’t fussing with a parser yet, but we can add the
bytecode instruction that the above syntax will compile to.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  OP_CONSTANT,
</pre><div class="source-file"><em>chunk.h</em><br/>
in enum <em>OpCode</em></div>
<pre class="insert" translate="no">  <span class="a">OP_NEGATE</span>,
</pre><pre class="insert-after" translate="no">  OP_RETURN,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>
<p>We execute it like so:</p>
<div class="codehilite"><pre class="insert-before" translate="no">      }
</pre><div class="source-file"><em>vm.c</em><br/>
in <em>run</em>()</div>
<pre class="insert" translate="no">      <span class="k">case</span> <span class="a">OP_NEGATE</span>:   <span class="i">push</span>(-<span class="i">pop</span>()); <span class="k">break</span>;
</pre><pre class="insert-after" translate="no">      case OP_RETURN: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p>The instruction needs a value to operate on, which it gets by popping from the
stack. It negates that, then pushes the result back on for later instructions to
use. Doesn’t get much easier than that. We can disassemble it too.</p>
<div class="codehilite"><pre class="insert-before" translate="no">    case OP_CONSTANT:
      return constantInstruction("OP_CONSTANT", chunk, offset);
</pre><div class="source-file"><em>debug.c</em><br/>
in <em>disassembleInstruction</em>()</div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="a">OP_NEGATE</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">"OP_NEGATE"</span>, <span class="i">offset</span>);
</pre><pre class="insert-after" translate="no">    case OP_RETURN:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>
<p>And we can try it out in our test chunk.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  writeChunk(&amp;chunk, constant, 123);
</pre><div class="source-file"><em>main.c</em><br/>
in <em>main</em>()</div>
<pre class="insert" translate="no">  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="a">OP_NEGATE</span>, <span class="n">123</span>);
</pre><pre class="insert-after" translate="no">

  writeChunk(&amp;chunk, OP_RETURN, 123);
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>main</em>()</div>
<p>After loading the constant, but before returning, we execute the negate
instruction. That replaces the constant on the stack with its negation. Then the
return instruction prints that out:</p>
<div class="codehilite"><pre translate="no">-1.2
</pre></div>
<p>Magical!</p>
<h3><a href="#binary-operators" id="binary-operators"><small>15 . 3 . 1</small>Binary operators</a></h3>
<p>OK, unary operators aren’t <em>that</em> impressive. We still only ever have a single
value on the stack. To really see some depth, we need binary operators. Lox has
four binary <span name="ops">arithmetic</span> operators: addition, subtraction,
multiplication, and division. We’ll go ahead and implement them all at the same
time.</p>
<aside name="ops">
<p>Lox has some other binary operators<span class="em">—</span>comparison and equality<span class="em">—</span>but those
don’t produce numbers as a result, so we aren’t ready for them yet.</p>
</aside>
<div class="codehilite"><pre class="insert-before" translate="no">  OP_CONSTANT,
</pre><div class="source-file"><em>chunk.h</em><br/>
in enum <em>OpCode</em></div>
<pre class="insert" translate="no">  <span class="a">OP_ADD</span>,
  <span class="a">OP_SUBTRACT</span>,
  <span class="a">OP_MULTIPLY</span>,
  <span class="a">OP_DIVIDE</span>,
</pre><pre class="insert-after" translate="no">  OP_NEGATE,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>
<p>Back in the bytecode loop, they are executed like this:</p>
<div class="codehilite"><pre class="insert-before" translate="no">      }
</pre><div class="source-file"><em>vm.c</em><br/>
in <em>run</em>()</div>
<pre class="insert" translate="no">      <span class="k">case</span> <span class="a">OP_ADD</span>:      <span class="a">BINARY_OP</span>(+); <span class="k">break</span>;
      <span class="k">case</span> <span class="a">OP_SUBTRACT</span>: <span class="a">BINARY_OP</span>(-); <span class="k">break</span>;
      <span class="k">case</span> <span class="a">OP_MULTIPLY</span>: <span class="a">BINARY_OP</span>(*); <span class="k">break</span>;
      <span class="k">case</span> <span class="a">OP_DIVIDE</span>:   <span class="a">BINARY_OP</span>(/); <span class="k">break</span>;
</pre><pre class="insert-after" translate="no">      case OP_NEGATE:   push(-pop()); break;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p>The only difference between these four instructions is which underlying C
operator they ultimately use to combine the two operands. Surrounding that core
arithmetic expression is some boilerplate code to pull values off the stack and
push the result. When we later add dynamic typing, that boilerplate will grow.
To avoid repeating that code four times, I wrapped it up in a macro.</p>
<div class="codehilite"><pre class="insert-before" translate="no">#define READ_CONSTANT() (vm.chunk-&gt;constants.values[READ_BYTE()])
</pre><div class="source-file"><em>vm.c</em><br/>
in <em>run</em>()</div>
<pre class="insert" translate="no"><span class="a">#define BINARY_OP(op) \</span>
<span class="a">    do { \</span>
<span class="a">      double b = pop(); \</span>
<span class="a">      double a = pop(); \</span>
<span class="a">      push(a op b); \</span>
<span class="a">    } while (false)</span>
</pre><pre class="insert-after" translate="no">

  for (;;) {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p>I admit this is a fairly <span name="operator">adventurous</span> use of the C
preprocessor. I hesitated to do this, but you’ll be glad in later chapters when
we need to add the type checking for each operand and stuff. It would be a chore
to walk you through the same code four times.</p>
<aside name="operator">
<p>Did you even know you can pass an <em>operator</em> as an argument to a macro? Now you
do. The preprocessor doesn’t care that operators aren’t first class in C. As far
as it’s concerned, it’s all just text tokens.</p>
<p>I know, you can just <em>feel</em> the temptation to abuse this, can’t you?</p>
</aside>
<p>If you aren’t familiar with the trick already, that outer <code translate="no">do while</code> loop
probably looks really weird. This macro needs to expand to a series of
statements. To be careful macro authors, we want to ensure those statements all
end up in the same scope when the macro is expanded. Imagine if you defined:</p>
<div class="codehilite"><pre translate="no"><span class="a">#define WAKE_UP() makeCoffee(); drinkCoffee();</span>
</pre></div>
<p>And then used it like:</p>
<div class="codehilite"><pre translate="no"><span class="k">if</span> (<span class="i">morning</span>) <span class="a">WAKE_UP</span>();
</pre></div>
<p>The intent is to execute both statements of the macro body only if <code translate="no">morning</code> is
true. But it expands to:</p>
<div class="codehilite"><pre translate="no"><span class="k">if</span> (<span class="i">morning</span>) <span class="i">makeCoffee</span>(); <span class="i">drinkCoffee</span>();;
</pre></div>
<p>Oops. The <code translate="no">if</code> attaches only to the <em>first</em> statement. You might think you could
fix this using a block.</p>
<div class="codehilite"><pre translate="no"><span class="a">#define WAKE_UP() { makeCoffee(); drinkCoffee(); }</span>
</pre></div>
<p>That’s better, but you still risk:</p>
<div class="codehilite"><pre translate="no"><span class="k">if</span> (<span class="i">morning</span>)
  <span class="a">WAKE_UP</span>();
<span class="k">else</span>
  <span class="i">sleepIn</span>();
</pre></div>
<p>Now you get a compile error on the <code translate="no">else</code> because of that trailing <code translate="no">;</code> after the
macro’s block. Using a <code translate="no">do while</code> loop in the macro looks funny, but it gives
you a way to contain multiple statements inside a block that <em>also</em> permits a
semicolon at the end.</p>
<p>Where were we? Right, so what the body of that macro does is straightforward. A
binary operator takes two operands, so it pops twice. It performs the operation
on those two values and then pushes the result.</p>
<p>Pay close attention to the <em>order</em> of the two pops. Note that we assign the
first popped operand to <code translate="no">b</code>, not <code translate="no">a</code>. It looks backwards. When the operands
themselves are calculated, the left is evaluated first, then the right. That
means the left operand gets pushed before the right operand. So the right
operand will be on top of the stack. Thus, the first value we pop is <code translate="no">b</code>.</p>
<p>For example, if we compile <code translate="no">3 - 1</code>, the data flow between the instructions looks
like so:</p>
<p><img alt="A sequence of instructions
with the stack for each showing how pushing and then popping values reverses
their order." src="image/a-virtual-machine/reverse.png"/></p>
<p>As we did with the other macros inside <code translate="no">run()</code>, we clean up after ourselves at
the end of the function.</p>
<div class="codehilite"><pre class="insert-before" translate="no">#undef READ_CONSTANT
</pre><div class="source-file"><em>vm.c</em><br/>
in <em>run</em>()</div>
<pre class="insert" translate="no"><span class="a">#undef BINARY_OP</span>
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p>Last is disassembler support.</p>
<div class="codehilite"><pre class="insert-before" translate="no">    case OP_CONSTANT:
      return constantInstruction("OP_CONSTANT", chunk, offset);
</pre><div class="source-file"><em>debug.c</em><br/>
in <em>disassembleInstruction</em>()</div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="a">OP_ADD</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">"OP_ADD"</span>, <span class="i">offset</span>);
    <span class="k">case</span> <span class="a">OP_SUBTRACT</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">"OP_SUBTRACT"</span>, <span class="i">offset</span>);
    <span class="k">case</span> <span class="a">OP_MULTIPLY</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">"OP_MULTIPLY"</span>, <span class="i">offset</span>);
    <span class="k">case</span> <span class="a">OP_DIVIDE</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">"OP_DIVIDE"</span>, <span class="i">offset</span>);
</pre><pre class="insert-after" translate="no">    case OP_NEGATE:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>
<p>The arithmetic instruction formats are simple, like <code translate="no">OP_RETURN</code>. Even though the
arithmetic <em>operators</em> take operands<span class="em">—</span>which are found on the stack<span class="em">—</span>the
arithmetic <em>bytecode instructions</em> do not.</p>
<p>Let’s put some of our new instructions through their paces by evaluating a
larger expression:</p>
<p><img alt="The expression being
evaluated: -((1.2 + 3.4) / 5.6)" src="image/a-virtual-machine/chunk.png"/></p>
<p>Building on our existing example chunk, here’s the additional instructions we
need to hand-compile that AST to bytecode.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  int constant = addConstant(&amp;chunk, 1.2);
  writeChunk(&amp;chunk, OP_CONSTANT, 123);
  writeChunk(&amp;chunk, constant, 123);
</pre><div class="source-file"><em>main.c</em><br/>
in <em>main</em>()</div>
<pre class="insert" translate="no">

  <span class="i">constant</span> = <span class="i">addConstant</span>(&amp;<span class="i">chunk</span>, <span class="n">3.4</span>);
  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="a">OP_CONSTANT</span>, <span class="n">123</span>);
  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="i">constant</span>, <span class="n">123</span>);

  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="a">OP_ADD</span>, <span class="n">123</span>);

  <span class="i">constant</span> = <span class="i">addConstant</span>(&amp;<span class="i">chunk</span>, <span class="n">5.6</span>);
  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="a">OP_CONSTANT</span>, <span class="n">123</span>);
  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="i">constant</span>, <span class="n">123</span>);

  <span class="i">writeChunk</span>(&amp;<span class="i">chunk</span>, <span class="a">OP_DIVIDE</span>, <span class="n">123</span>);
</pre><pre class="insert-after" translate="no">  writeChunk(&amp;chunk, OP_NEGATE, 123);

  writeChunk(&amp;chunk, OP_RETURN, 123);
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>main</em>()</div>
<p>The addition goes first. The instruction for the left constant, 1.2, is already
there, so we add another for 3.4. Then we add those two using <code translate="no">OP_ADD</code>, leaving
it on the stack. That covers the left side of the division. Next we push the
5.6, and divide the result of the addition by it. Finally, we negate the result
of that.</p>
<p>Note how the output of the <code translate="no">OP_ADD</code> implicitly flows into being an operand of
<code translate="no">OP_DIVIDE</code> without either instruction being directly coupled to each other.
That’s the magic of the stack. It lets us freely compose instructions without
them needing any complexity or awareness of the data flow. The stack acts like a
shared workspace that they all read from and write to.</p>
<p>In this tiny example chunk, the stack still only gets two values tall, but when
we start compiling Lox source to bytecode, we’ll have chunks that use much more
of the stack. In the meantime, try playing around with this hand-authored chunk
to calculate different nested arithmetic expressions and see how values flow
through the instructions and stack.</p>
<p>You may as well get it out of your system now. This is the last chunk we’ll
build by hand. When we next revisit bytecode, we will be writing a compiler to
generate it for us.</p>
<div class="challenges">
<h2><a href="#challenges" id="challenges">Challenges</a></h2>
<ol>
<li>
<p>What bytecode instruction sequences would you generate for the following
expressions:</p>
<div class="codehilite"><pre translate="no"><span class="n">1</span> * <span class="n">2</span> + <span class="n">3</span>
<span class="n">1</span> + <span class="n">2</span> * <span class="n">3</span>
<span class="n">3</span> - <span class="n">2</span> - <span class="n">1</span>
<span class="n">1</span> + <span class="n">2</span> * <span class="n">3</span> - <span class="n">4</span> / -<span class="n">5</span>
</pre></div>
<p>(Remember that Lox does not have a syntax for negative number literals, so
the <code translate="no">-5</code> is negating the number 5.)</p>
</li>
<li>
<p>If we really wanted a minimal instruction set, we could eliminate either
<code translate="no">OP_NEGATE</code> or <code translate="no">OP_SUBTRACT</code>. Show the bytecode instruction sequence you
would generate for:</p>
<div class="codehilite"><pre translate="no"><span class="n">4</span> - <span class="n">3</span> * -<span class="n">2</span>
</pre></div>
<p>First, without using <code translate="no">OP_NEGATE</code>. Then, without using <code translate="no">OP_SUBTRACT</code>.</p>
<p>Given the above, do you think it makes sense to have both instructions? Why
or why not? Are there any other redundant instructions you would consider
including?</p>
</li>
<li>
<p>Our VM’s stack has a fixed size, and we don’t check if pushing a value
overflows it. This means the wrong series of instructions could cause our
interpreter to crash or go into undefined behavior. Avoid that by
dynamically growing the stack as needed.</p>
<p>What are the costs and benefits of doing so?</p>
</li>
<li>
<p>To interpret <code translate="no">OP_NEGATE</code>, we pop the operand, negate the value, and then
push the result. That’s a simple implementation, but it increments and
decrements <code translate="no">stackTop</code> unnecessarily, since the stack ends up the same height
in the end. It might be faster to simply negate the value in place on the
stack and leave <code translate="no">stackTop</code> alone. Try that and see if you can measure a
performance difference.</p>
<p>Are there other instructions where you can do a similar optimization?</p>
</li>
</ol>
</div>
<div class="design-note">
<h2><a href="#design-note" id="design-note">Design Note: Register-Based Bytecode</a></h2>
<p>For the remainder of this book, we’ll meticulously implement an interpreter
around a stack-based bytecode instruction set. There’s another family of
bytecode architectures out there<span class="em">—</span><em>register-based</em>. Despite the name, these
bytecode instructions aren’t quite as difficult to work with as the registers in
an actual chip like <span name="x64">x64</span>. With real hardware registers,
you usually have only a handful for the entire program, so you spend a lot of
effort <a href="https://en.wikipedia.org/wiki/Register_allocation">trying to use them efficiently and shuttling stuff in and out of
them</a>.</p>
<aside name="x64">
<p>Register-based bytecode is a little closer to the <a href="https://en.wikipedia.org/wiki/Register_window"><em>register windows</em></a>
supported by SPARC chips.</p>
</aside>
<p>In a register-based VM, you still have a stack. Temporary values still get
pushed onto it and popped when no longer needed. The main difference is that
instructions can read their inputs from anywhere in the stack and can store
their outputs into specific stack slots.</p>
<p>Take this little Lox script:</p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="i">a</span> = <span class="n">1</span>;
<span class="k">var</span> <span class="i">b</span> = <span class="n">2</span>;
<span class="k">var</span> <span class="i">c</span> = <span class="i">a</span> + <span class="i">b</span>;
</pre></div>
<p>In our stack-based VM, the last statement will get compiled to something like:</p>
<div class="codehilite"><pre translate="no"><span class="i">load</span> &lt;<span class="i">a</span>&gt;  <span class="c">// Read local variable a and push onto stack.</span>
<span class="i">load</span> &lt;<span class="i">b</span>&gt;  <span class="c">// Read local variable b and push onto stack.</span>
<span class="i">add</span>       <span class="c">// Pop two values, add, push result.</span>
<span class="i">store</span> &lt;<span class="i">c</span>&gt; <span class="c">// Pop value and store in local variable c.</span>
</pre></div>
<p>(Don’t worry if you don’t fully understand the load and store instructions yet.
We’ll go over them in much greater detail <a href="global-variables.html">when we implement
variables</a>.) We have four separate instructions. That means four
times through the bytecode interpret loop, four instructions to decode and
dispatch. It’s at least seven bytes of code<span class="em">—</span>four for the opcodes and another
three for the operands identifying which locals to load and store. Three pushes
and three pops. A lot of work!</p>
<p>In a register-based instruction set, instructions can read from and store
directly into local variables. The bytecode for the last statement above looks
like:</p>
<div class="codehilite"><pre translate="no"><span class="i">add</span> &lt;<span class="i">a</span>&gt; &lt;<span class="i">b</span>&gt; &lt;<span class="i">c</span>&gt; <span class="c">// Read values from a and b, add, store in c.</span>
</pre></div>
<p>The add instruction is bigger<span class="em">—</span>it has three instruction operands that define
where in the stack it reads its inputs from and writes the result to. But since
local variables live on the stack, it can read directly from <code translate="no">a</code> and <code translate="no">b</code> and
then store the result right into <code translate="no">c</code>.</p>
<p>There’s only a single instruction to decode and dispatch, and the whole thing
fits in four bytes. Decoding is more complex because of the additional operands,
but it’s still a net win. There’s no pushing and popping or other stack
manipulation.</p>
<p>The main implementation of Lua used to be stack-based. For <span name="lua">Lua
5.0</span>, the implementers switched to a register instruction set and noted a
speed improvement. The amount of improvement, naturally, depends heavily on the
details of the language semantics, specific instruction set, and compiler
sophistication, but that should get your attention.</p>
<aside name="lua">
<p>The Lua dev team<span class="em">—</span>Roberto Ierusalimschy, Waldemar Celes, and Luiz Henrique de
Figueiredo<span class="em">—</span>wrote a <em>fantastic</em> paper on this, one of my all time favorite
computer science papers, “<a href="https://www.lua.org/doc/jucs05.pdf">The Implementation of Lua 5.0</a>” (PDF).</p>
</aside>
<p>That raises the obvious question of why I’m going to spend the rest of the book
doing a stack-based bytecode. Register VMs are neat, but they are quite a bit
harder to write a compiler for. For what is likely to be your very first
compiler, I wanted to stick with an instruction set that’s easy to generate and
easy to execute. Stack-based bytecode is marvelously simple.</p>
<p>It’s also <em>much</em> better known in the literature and the community. Even though
you may eventually move to something more advanced, it’s a good common ground to
share with the rest of your language hacker peers.</p>
</div>
<footer>
<a class="next" href="scanning-on-demand.html">
  Next Chapter: “Scanning on Demand” →
</a>
Handcrafted by Robert Nystrom — <a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">© 2015 – 2021</a>
</footer>
</article>
</div>
</body>
</html>
