<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link rel="stylesheet" type="text/css" href="cid:css-6e33e78c-7e06-4d97-b493-d5217fb5c57a@mhtml.blink" />

<title>Global Variables · Crafting Interpreters</title>
<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta content="width=device-width, initial-scale=1" name="viewport">
<link href="https://youhogeon-meritz.github.io/style.css" rel="stylesheet" type="text/css">
<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600" rel="stylesheet" type="text/css">
<link href="https://youhogeon-meritz.github.io/image/favicon.png" rel="icon" type="image/png">


<!-- Google analytics -->

</head>
<body id="top">
<!-- <div class="scrim"></div> -->
<nav class="wide">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<div class="contents">
<h3><a href="https://youhogeon-meritz.github.io/global-variables.html#top"><font papago-translate="splitted"><font papago-translate="translated">글로벌 변수</font></font><small>21</small></a></h3>
<ul>
<li><a href="https://youhogeon-meritz.github.io/global-variables.html#statements"><small>21.1</small><font papago-translate="splitted"><font papago-translate="translated"> 진술들</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/global-variables.html#variable-declarations"><small>21.2</small><font papago-translate="splitted"><font papago-translate="translated"> 변수 선언</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/global-variables.html#reading-variables"><small>21.3</small><font papago-translate="splitted"><font papago-translate="translated"> 변수 읽기</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/global-variables.html#assignment"><small>21.4</small><font papago-translate="splitted"><font papago-translate="translated"> 과제</font></font></a></li>
<li class="divider"></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/global-variables.html#challenges"><font papago-translate="translated">과제들</font></a></li>
</ul>
<div class="prev-next">
<a class="left" href="https://youhogeon-meritz.github.io/hash-tables.html" title="해시 테이블" papago-attr-id="1"><font papago-translate="translated">← 이전</font></a>
<a href="https://youhogeon-meritz.github.io/a-bytecode-virtual-machine.html" title="바이트코드 가상 머신" papago-attr-id="2"><font papago-translate="translated">↑ 위로</font></a>
<a class="right" href="https://youhogeon-meritz.github.io/local-variables.html" title="지역 변수" papago-attr-id="3"><font papago-translate="translated">다음 →</font></a>
</div> </div>
</nav>
<nav class="narrow">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<a class="prev" href="https://youhogeon-meritz.github.io/hash-tables.html" title="Hash Tables">←</a>
<a class="next" href="https://youhogeon-meritz.github.io/local-variables.html" title="Local Variables">→</a>
</nav>
<div class="page">
<div class="nav-wrapper">
<nav class="floating pinned">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<div class="expandable">
<h3><a href="https://youhogeon-meritz.github.io/global-variables.html#top"><font papago-translate="splitted"><font papago-translate="translated">글로벌 변수</font></font><small>21</small></a></h3>
<ul>
<li><a href="https://youhogeon-meritz.github.io/global-variables.html#statements"><small>21.1</small><font papago-translate="splitted"><font papago-translate="translated"> 진술들</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/global-variables.html#variable-declarations"><small>21.2</small><font papago-translate="splitted"><font papago-translate="translated"> 변수 선언</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/global-variables.html#reading-variables"><small>21.3</small><font papago-translate="splitted"><font papago-translate="translated"> 변수 읽기</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/global-variables.html#assignment"><small>21.4</small><font papago-translate="splitted"><font papago-translate="translated"> 과제</font></font></a></li>
<li class="divider"></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/global-variables.html#challenges">Challenges</a></li>
</ul>
<div class="prev-next">
<a class="left" href="https://youhogeon-meritz.github.io/hash-tables.html" title="Hash Tables">←&nbsp;Previous</a>
<a href="https://youhogeon-meritz.github.io/a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">↑&nbsp;Up</a>
<a class="right" href="https://youhogeon-meritz.github.io/local-variables.html" title="Local Variables">Next&nbsp;→</a>
</div> </div>
<a id="expand-nav">≡</a>
</nav>
</div>
<article class="chapter">
<div class="number">21</div>
<h1><font papago-translate="translated">글로벌 변수</font></h1>
<blockquote>
<p><font papago-translate="translated">향기와 같은 기억을 병에 담는 발명품이 있다면 좋겠습니다.</font><font papago-translate="translated"> 그리고 그것은 결코 사라지지 않았고, 결코 낡지 않았습니다.</font><font papago-translate="translated"> 그리고 나서 원할 때 병의 코르크를 풀면 마치 그 순간을 다시 사는 것과 같을 것입니다.</font></p>
<p><cite>Daphne du Maurier, <em>Rebecca</em></cite></p>
</blockquote>
<p><font papago-translate="translated"><a href="https://youhogeon-meritz.github.io/hash-tables.html">이전 장에서는</a> 하나의 크고 깊은 기본적인 컴퓨터 과학 데이터 구조에 대한 긴 탐구를 진행했습니다.</font><font papago-translate="translated"> 이론과 개념에 중점을 둡니다.</font><font papago-translate="translated"> 빅오 표기법과 알고리즘에 대한 논의가 있었을 수 있습니다.</font><font papago-translate="translated"> 이 장은 지적인 가식이 적습니다.</font><font papago-translate="translated"> 배울 만한 큰 아이디어가 없습니다.</font><font papago-translate="translated"> 대신, 몇 가지 간단한 엔지니어링 작업입니다.</font><font papago-translate="translated"> 완료되면 가상 머신이 변수를 지원합니다.</font></p>
<p><font papago-translate="translated">사실<em>, 그것</em>은<em> 글로벌</em> 변수들만 지원할 것입니다.</font><font papago-translate="translated"> 다음<a href="https://youhogeon-meritz.github.io/local-variables.html"> 장</a>에서는 현지인들이 참석할 예정입니다.</font><font papago-translate="translated"> Jlox에서는 모든 변수에 동일한 구현 기법을 사용했기 때문에 두 변수를 하나의 장에 통합하는 데 성공했습니다.</font><font papago-translate="translated"> 우리는 각 범위마다 하나씩, 꼭대기까지 일련의 환경을 구축했습니다.</font><font papago-translate="translated"> 그것은 상태를 관리하는 방법을 배우는 간단하고 깨끗한 방법이었습니다.</font></p>
<p><font papago-translate="translated">하지만 속도도<em> 느</em>립니다.</font><font papago-translate="translated"> 블록을 입력하거나 함수를 호출할 때마다 새 해시 테이블을 할당하는 것은 빠른 VM으로 가는 길이 아닙니다.</font><font papago-translate="translated"> 변수를 사용하는 데 얼마나 많은 코드가 관련되어 있는지를 고려할 때, 변수가 느려지면 모든 것이 느려집니다.</font><font papago-translate="translated"> clox의 경우<span name="different">, 지역</span> 변수에 대해 훨씬 더 효율적인 전략을 사용하여 이를 개선할 것이지만, 전역 변수는 쉽게 최적화되지 않습니다.</font></p>
<aside name="different" style="top: 832px;">
<p><font papago-translate="splitted"><font papago-translate="translated">이것은 정교한 언어 구현에서 흔히 사용되는 메타 전략입니다.</font><font papago-translate="translated"> 종종 동일한 언어 기능에는 여러 가지 구현 기법이 있으며, 각각 다른 사용 패턴에 맞게 조정됩니다.</font><font papago-translate="translated"> 예를 들어, JavaScript VM은 속성 집합이 더 자유롭게 수정되는 다른 객체에 비해 클래스 인스턴스처럼 더 많이 사용되는 객체에 대해 더 빠른 표현을 가지는 경우가 많습니다.</font><font papago-translate="translated"> C 컴파일러와 C++ 컴파일러는 일반적으로 다양한 컴파일 방법을 가지고 있습니다 </font></font><code translate="no">switch</code><font papago-translate="splitted"><font papago-translate="translated"> 사례 수와 사례 값이 얼마나 밀집되어 있는지를 기준으로 한 진술.</font></font></p>
</aside>
<p><font papago-translate="translated">Lox 의미론에 대한 간단한 업데이트:</font><font papago-translate="translated"> Lox의 전역 변수는 "지연 경계" 또는 동적으로 해결됩니다.</font><font papago-translate="translated"> 즉, 전역 변수가 정의되기 전에 코드 덩어리를 컴파일할 수 있습니다.</font><font papago-translate="translated"> 정의가 이루어지기 전에 코드<em>가 실행되지</em> 않는 한, 모든 것이 괜찮습니다.</font><font papago-translate="translated"> 실제로는 함수 본문 내부의 나중 변수를 참조할 수 있다는 뜻입니다.</font></p>
<div class="codehilite"><pre translate="no"><span class="k">fun</span> <span class="i">showVariable</span>() {
  <span class="k">print</span> <span class="i">global</span>;
}

<span class="k">var</span> <span class="i">global</span> = <span class="s">"after"</span>;
<span class="i">showVariable</span>();
</pre></div>
<p><font papago-translate="translated">이와 같은 코드는 이상하게 보일 수 있지만 상호 재귀 함수를 정의하는 데 유용합니다.</font><font papago-translate="translated"> 그것은 또한 REPL과 더 잘 어울립니다.</font><font papago-translate="translated"> 한 줄에 작은 함수를 작성한 다음 다음에 사용하는 변수를 정의할 수 있습니다.</font></p>
<p><font papago-translate="translated">지역 변수는 다르게 작동합니다.</font><font papago-translate="translated"> 로컬 변수의 선언은<em> 항상</em> 사용되기 전에 발생하기 때문에, VM은 컴파일 시 간단한 단일 패스 컴파일러에서도 이를 해결할 수 있습니다.</font><font papago-translate="translated"> 그렇게 하면 현지인들에게 더 스마트한 표현을 사용할 수 있을 것입니다.</font><font papago-translate="translated"> 하지만 다음 장은 여기까지입니다.</font><font papago-translate="translated"> 지금은 글로벌에 대해 걱정해 보겠습니다.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/global-variables.html#statements" id="statements"><small><font papago-translate="translated">21 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">진술들</font></font></a></h2>
<p><font papago-translate="translated">변수는 변수 선언을 사용하여 생성되며, 이는 지금이 우리 컴파일러에 문에 대한 지원을 추가할 때임을 의미합니다.</font><font papago-translate="translated"> 기억하시겠지만, Lox는 진술을 두 가지 범주로 나눕니다.</font><font papago-translate="translated"> "선언문"은 새로운 이름을 값에 묶는 문장입니다.</font><font papago-translate="translated"> 다른 종류의 진술—제어 흐름, 인쇄<span class="em"></span> 등.</font><font papago-translate="translated"><span class="em"></span>- 그냥 "문"이라고 불립니다.</font><font papago-translate="translated"> 다음과 같이 제어 흐름 문 내부의 선언을 직접 허용하지 않습니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">if</span> (<span class="i">monday</span>) <span class="k">var</span> <span class="i">croissant</span> = <span class="s">"yes"</span>; <span class="c">// Error.</span>
</pre></div>
<p><font papago-translate="translated">허용하면 변수의 범위에 대한 혼란스러운 질문이 제기될 수 있습니다.</font><font papago-translate="translated"> 따라서 다른 언어와 마찬가지로 제어 흐름<em></em> 본문 내에서 허용되는 문장의 하위 집합에 대해 별도의 문법 규칙을 두어 구문적으로 금지합니다.</font></p>
<div class="codehilite"><pre translate="no"><span class="i">statement</span>      → <span class="i">exprStmt</span>
               | <span class="i">forStmt</span>
               | <span class="i">ifStmt</span>
               | <span class="i">printStmt</span>
               | <span class="i">returnStmt</span>
               | <span class="i">whileStmt</span>
               | <span class="i">block</span> ;
</pre></div>
<p><font papago-translate="translated">그런 다음 스크립트의 최상위 레벨과 블록 내부에 대해 별도의 규칙을 사용합니다.</font></p>
<div class="codehilite"><pre translate="no"><span class="i">declaration</span>    → <span class="i">classDecl</span>
               | <span class="i">funDecl</span>
               | <span class="i">varDecl</span>
               | <span class="i">statement</span> ;
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">그 </font></font><code translate="no">declaration</code><font papago-translate="splitted"><font papago-translate="translated"> 규칙에는 이름을 선언하는 문장이 포함되어 있으며 다음과 같은 내용도 포함됩니다 </font></font><code translate="no">statement</code><font papago-translate="splitted"><font papago-translate="translated"> 모든 문 유형이 허용되도록 합니다.</font><font papago-translate="translated"> 부터 </font></font><code translate="no">block</code><font papago-translate="splitted"><font papago-translate="translated"> 그 자체는 </font></font><code translate="no">statement</code><font papago-translate="splitted"><font papago-translate="translated">, 선언문을 블록 안에 중첩하여 제어 흐름 구성 요소<span name="parens"> 안에</span> 넣을 수 있습니다.</font></font></p>
<aside name="parens" style="top: 2224px;">
<p><font papago-translate="translated">블록 작업은 괄호가 표현에 사용하는 것과 비슷합니다.</font><font papago-translate="translated"> 블록을 사용하면 "우선순위가 낮은" 선언문을 "우선순위가 높은" 비선언문만 허용되는 곳에 배치할 수 있습니다.</font></p>
</aside>
<p><font papago-translate="translated">이 장에서는 몇 가지 진술과 하나의 선언만을 다룰 것입니다.</font></p>
<div class="codehilite"><pre translate="no"><span class="i">statement</span>      → <span class="i">exprStmt</span>
               | <span class="i">printStmt</span> ;

<span class="i">declaration</span>    → <span class="i">varDecl</span>
               | <span class="i">statement</span> ;
</pre></div>
<p><font papago-translate="translated">지금까지 우리의 VM은 "프로그램"을 단일 표현식으로 간주했습니다. 왜냐하면 그것이 우리가 구문 분석하고 컴파일할 수 있는 전부였기 때문입니다.</font><font papago-translate="translated"> 전체 Lox 구현에서 프로그램은 선언의 연속입니다.</font><font papago-translate="translated"> 이제 우리는 그것을 지원할 준비가 되었습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  advance();
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>컴파일</em> ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 두 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">
  <span class="k">while</span> (!<span class="i">match</span>(<span class="a">TOKEN_EOF</span>)) {
    <span class="i">declaration</span>();
  }

</pre><pre class="insert-after" translate="no">  endCompiler();
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>compile</em>(), replace 2 lines</div>
<p><font papago-translate="translated">소스 파일의 끝에 도달할 때까지 선언문을 계속 컴파일합니다.</font><font papago-translate="translated"> 우리는 이것을 사용하여 하나의 선언문을 작성합니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 식<em></em> () 뒤에 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">declaration</span>() {
  <span class="i">statement</span>();
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>expression</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">이 장의 뒷부분에서 변수 선언에 대해 다룰 예정이므로 지금은 다음과 같이 간단히 설명하겠습니다 </font></font><code translate="no">statement()</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>선언</em> 후 () 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">statement</span>() {
  <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_PRINT</span>)) {
    <span class="i">printStatement</span>();
  }
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>declaration</em>()</div>
<p><font papago-translate="translated">블록에는 선언문이 포함될 수 있으며, 제어 흐름 문에는 다른 문이 포함될 수 있습니다.</font><font papago-translate="translated"> 즉, 이 두 함수는 결국 재귀적일 것입니다.</font><font papago-translate="translated"> 지금 당장 전진 선언문을 작성하는 것이 좋습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">static void expression();
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 식<em></em> () 뒤에 추가</font></font></div>
<pre class="insert" translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">statement</span>();
<span class="k">static</span> <span class="t">void</span> <span class="i">declaration</span>();
</pre><pre class="insert-after" translate="no">static ParseRule* getRule(TokenType type);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>expression</em>()</div>
<h3><a href="https://youhogeon-meritz.github.io/global-variables.html#print-statements" id="print-statements"><small><font papago-translate="translated">21 . 1 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">명세서 인쇄</font></font></a></h3>
<p><font papago-translate="splitted"><font papago-translate="translated">이 장에서 뒷받침할 두 가지 진술 유형이 있습니다.</font><font papago-translate="translated"> 먼저 시작하겠습니다 </font></font><code translate="no">print</code><font papago-translate="splitted"><font papago-translate="translated"> 자연스럽게 다음과 같이 시작되는 진술 </font></font><code translate="no">print</code><font papago-translate="splitted"><font papago-translate="translated"> 상품권.</font><font papago-translate="translated"> 이 도우미 기능을 사용하여 이를 감지합니다:</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>소비</em> 후 () 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">bool</span> <span class="i">match</span>(<span class="t">TokenType</span> <span class="i">type</span>) {
  <span class="k">if</span> (!<span class="i">check</span>(<span class="i">type</span>)) <span class="k">return</span> <span class="k">false</span>;
  <span class="i">advance</span>();
  <span class="k">return</span> <span class="k">true</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>consume</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">Jlox에서 알아볼 수 있습니다.</font><font papago-translate="translated"> 현재 토큰의 유형이 지정된 경우 토큰을 소비하고 반환합니다 </font></font><code translate="no">true</code><font papago-translate="splitted"><font papago-translate="translated">. 그렇지 않으면 토큰을 그대로 두고 반환합니다 </font></font><code translate="no">false</code><font papago-translate="splitted"><font papago-translate="translated">. <span name="turtles">이 도우미</span> 기능은 다른 도우미의 관점에서 구현됩니다:</font></font></p>
<aside name="turtles" style="top: 3596px;">
<p><font papago-translate="translated">끝까지 도우미입니다!</font></p>
</aside>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>소비</em> 후 () 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">bool</span> <span class="i">check</span>(<span class="t">TokenType</span> <span class="i">type</span>) {
  <span class="k">return</span> <span class="i">parser</span>.<span class="i">current</span>.<span class="i">type</span> == <span class="i">type</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>consume</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">그 </font></font><code translate="no">check()</code><font papago-translate="splitted"><font papago-translate="translated"> 함수 반환 </font></font><code translate="no">true</code><font papago-translate="splitted"><font papago-translate="translated"> 현재 토큰이 지정된 유형을 가지고 있는 경우.</font><font papago-translate="translated"> 이것을 함수로 포장하는 것은<span name="read"> 조금 어리석</span>게 보이지만, 나중에 더 많이 사용할 것이고, 이렇게 짧은 동사 이름 함수가 파서를 더 쉽게 읽을 수 있게 해준다고 생각합니다.</font></font></p>
<aside name="read" style="top: 3776px;">
<p><font papago-translate="translated">사소한 것처럼 들리지만 장난감이 아닌 언어에 대한 손글씨 파서는 꽤 커집니다.</font><font papago-translate="translated"> 수천 줄의 코드가 있을 때, 두 줄을 하나로 변환하여 결과를 조금 더 쉽게 읽을 수 있게 해주는 유틸리티 함수가 유지됩니다.</font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">만약 우리가 일치한다면 </font></font><code translate="no">print</code><font papago-translate="splitted"><font papago-translate="translated"> 토큰을 사용한 다음 나머지 문장을 여기에 컴파일합니다:</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 식<em></em> () 뒤에 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">printStatement</span>() {
  <span class="i">expression</span>();
  <span class="i">consume</span>(<span class="a">TOKEN_SEMICOLON</span>, <span class="s">"Expect ';' after value."</span>);
  <span class="i">emitByte</span>(<span class="a">OP_PRINT</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>expression</em>()</div>
<p><font papago-translate="splitted">A </font><code translate="no">print</code><font papago-translate="splitted"><font papago-translate="translated"> 문은 표현식을 평가하고 결과를 출력하므로 먼저 해당 표현식을 구문 분석하고 컴파일합니다.</font><font papago-translate="translated"> 문법은 그 후에 세미콜론을 기대하기 때문에 우리는 그것을 소비합니다.</font><font papago-translate="translated"> 마지막으로, 결과를 출력하라는 새로운 지침을 발표합니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  OP_NEGATE,
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">청크.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> enum O<em>pCode</em>에서</font></font></div>
<pre class="insert" translate="no">  <span class="a">OP_PRINT</span>,
</pre><pre class="insert-after" translate="no">  OP_RETURN,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>
<p><font papago-translate="translated">런타임에 다음과 같이 이 명령을 실행합니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">        break;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font></div>
<pre class="insert" translate="no">      <span class="k">case</span> <span class="a">OP_PRINT</span>: {
        <span class="i">printValue</span>(<span class="i">pop</span>());
        <span class="i">printf</span>(<span class="s">"</span><span class="e">\n</span><span class="s">"</span>);
        <span class="k">break</span>;
      }
</pre><pre class="insert-after" translate="no">      case OP_RETURN: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p><font papago-translate="translated">인터프리터가 이 명령어에 도달하면 이미 표현식의 코드를 실행하여 결과 값을 스택 위에 남깁니다.</font><font papago-translate="translated"> 이제 간단히 팝업하여 인쇄합니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">그 후에는 다른 것을 강요하지 않습니다.</font><font papago-translate="translated"> 이것은 VM의 표현식과 문장 간의 주요 차이점입니다.</font><font papago-translate="translated"> 모든 바이트코드 명령어는<span name="effect"><strong> 명령</strong></span>어가 스택을 어떻게 수정하는지를 설명하는<span name="effect"><strong> 스택 효과</strong></span>를 가지고 있습니다.</font><font papago-translate="translated"> 예를들면, </font></font><code translate="no">OP_ADD</code><font papago-translate="splitted"><font papago-translate="translated"> 두 값을 터뜨리고 하나를 밀면 스택의 요소가 이전보다 작아집니다.</font></font></p>
<aside name="effect" style="top: 4556px;">
<p><font papago-translate="splitted"><font papago-translate="translated">스택은 다음과 같은 요소 중 하나가 더 짧습니다 </font></font><code translate="no">OP_ADD</code><font papago-translate="splitted"><font papago-translate="translated">, 그래서 그 효과는 -1입니다:</font></font></p><img alt="The stack effect of an OP_ADD instruction." src="https://youhogeon-meritz.github.io/image/global-variables/stack-effect.png">
</aside>
<p><font papago-translate="translated">일련의 지침의 스택 효과를 합산하여 총 효과를 얻을 수 있습니다.</font><font papago-translate="translated"> 완전한 표현식에서 컴파일된 일련의 명령어의 스택 효과를 더하면 총 1이 됩니다.</font><font papago-translate="translated"> 각 표현식은 스택에 하나의 결과 값을 남깁니다.</font></p>
<p><font papago-translate="translated">전체 문의 바이트코드는 총 스택 효과가 0입니다.</font><font papago-translate="translated"> 문장은 값을 생성하지 않기 때문에 궁극적으로 스택을 변경하지 않고 그대로 둡니다. 물론 스택이 작업을 수행하는 동안에도 스택을 사용합니다.</font><font papago-translate="translated"> 이것은 중요합니다. 왜냐하면 우리가 흐름과 순환을 제어하게 되면, 프로그램이 긴 일련의 문장들을 실행할 수 있기 때문입니다.</font><font papago-translate="translated"> 각 문장이 스택을 늘리거나 축소하면 결국 오버플로우 또는 언더플로우가 발생할 수 있습니다.</font></p>
<p><font papago-translate="translated">인터프리터 루프에 있는 동안 코드를 조금 삭제해야 합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      case OP_RETURN: {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 두 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">        <span class="c">// Exit interpreter.</span>
</pre><pre class="insert-after" translate="no">        return INTERPRET_OK;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 2 lines</div>
<p><font papago-translate="splitted"><font papago-translate="translated">VM이 단일 표현식만 컴파일하고 평가했을 때, 우리는 임시 코드를 가지고 있었습니다 </font></font><code translate="no">OP_RETURN</code><font papago-translate="splitted"><font papago-translate="translated"> 값을 출력합니다.</font><font papago-translate="translated"> 이제 성명서와 </font></font><code translate="no">print</code><font papago-translate="splitted"><font papago-translate="translated">, 더 이상 그럴 필요가 없습니다.</font><font papago-translate="translated"> 우리는 clox의 완전한 구현에 한<span name="return"> 걸음</span> 더 가까워졌습니다.</font></font></p>
<aside name="return" style="top: 5120px;">
<p><font papago-translate="splitted"><font papago-translate="translated">하지만 우리는 한 걸음 더 가까워졌습니다.</font><font papago-translate="translated"> 다시 방문하겠습니다 </font></font><code translate="no">OP_RETURN</code><font papago-translate="splitted"><font papago-translate="translated"> 함수를 추가할 때 다시 한 번.</font><font papago-translate="translated"> 지금은 전체 인터프리터 루프를 종료합니다.</font></font></p>
</aside>
<p><font papago-translate="translated">평소와 마찬가지로, 새로운 지침은 분해기의 지원이 필요합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      return simpleInstruction("OP_NEGATE", offset);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">debug.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>분해</em> 중 지침()</font></font></div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="a">OP_PRINT</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">"OP_PRINT"</span>, <span class="i">offset</span>);
</pre><pre class="insert-after" translate="no">    case OP_RETURN:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">그게 우리의 </font></font><code translate="no">print</code><font papago-translate="splitted"><font papago-translate="translated"> 진술.</font><font papago-translate="translated"> 원하시면 한 번 돌려보세요:</font></font></p>
<div class="codehilite"><pre translate="no"><span class="k">print</span> <span class="n">1</span> + <span class="n">2</span>;
<span class="k">print</span> <span class="n">3</span> * <span class="n">4</span>;
</pre></div>
<p><font papago-translate="translated">신난다!</font><font papago-translate="translated"> 좋아요, 스릴 넘치지는 않겠지만, 지금은 원하는 만큼의 문장이 포함된 스크립트를 만들 수 있습니다. 이는 마치 진행 중인 것처럼 느껴집니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/global-variables.html#expression-statements" id="expression-statements"><small><font papago-translate="translated">21 . 1 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">표현 문</font></font></a></h3>
<p><font papago-translate="splitted"><font papago-translate="translated">다음 문장을 볼 때까지 기다리세요.</font><font papago-translate="translated"> <em></em>우리가 보지 못하면 </font></font><code translate="no">print</code><font papago-translate="splitted"><font papago-translate="translated"> 키워드, 그러면 우리는 표현문을 보고 있어야 합니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    printStatement();
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>성명</em>서 ()에서</font></font></div>
<pre class="insert" translate="no">  } <span class="k">else</span> {
    <span class="i">expressionStatement</span>();
</pre><pre class="insert-after" translate="no">  }
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>statement</em>()</div>
<p><font papago-translate="translated">이렇게 표현됩니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 식<em></em> () 뒤에 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">expressionStatement</span>() {
  <span class="i">expression</span>();
  <span class="i">consume</span>(<span class="a">TOKEN_SEMICOLON</span>, <span class="s">"Expect ';' after expression."</span>);
  <span class="i">emitByte</span>(<span class="a">OP_POP</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>expression</em>()</div>
<p><font papago-translate="translated">"표현문"은 단순히 세미콜론 뒤에 오는 표현입니다.</font><font papago-translate="translated"> 그것들은 문장이 예상되는 상황에서 표현을 쓰는 방법입니다.</font><font papago-translate="translated"> 일반적으로 함수를 호출하거나 과제의 부작용을 평가하기 위해 이렇게 합니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="i">brunch</span> = <span class="s">"quiche"</span>;
<span class="i">eat</span>(<span class="i">brunch</span>);
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">의미론적으로 표현식 문장은 표현식을 평가하고 결과를 폐기합니다.</font><font papago-translate="translated"> 컴파일러는 해당 동작을 직접 인코딩합니다.</font><font papago-translate="translated"> 표현식을 컴파일한 다음 다음 다음을 방출합니다 </font></font><code translate="no">OP_POP</code><font papago-translate="splitted"><font papago-translate="translated"> 설명.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  OP_FALSE,
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">청크.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> enum O<em>pCode</em>에서</font></font></div>
<pre class="insert" translate="no">  <span class="a">OP_POP</span>,
</pre><pre class="insert-after" translate="no">  OP_EQUAL,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>
<p><font papago-translate="translated">이름에서 알 수 있듯이, 그 명령어는 상위 값을 스택에서 튀어나와 잊어버립니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      case OP_FALSE: push(BOOL_VAL(false)); break;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font></div>
<pre class="insert" translate="no">      <span class="k">case</span> <span class="a">OP_POP</span>: <span class="i">pop</span>(); <span class="k">break</span>;
</pre><pre class="insert-after" translate="no">      case OP_EQUAL: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p><font papago-translate="translated">우리는 그것을 분해할 수도 있습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      return simpleInstruction("OP_FALSE", offset);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">debug.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>분해</em> 중 지침()</font></font></div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="a">OP_POP</span>:
      <span class="k">return</span> <span class="i">simpleInstruction</span>(<span class="s">"OP_POP"</span>, <span class="i">offset</span>);
</pre><pre class="insert-after" translate="no">    case OP_EQUAL:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>
<p><font papago-translate="translated">표현식 문장은 부작용이 있는 표현을 만들 수 없기 때문에 아직 유용하지 않지만<a href="https://youhogeon-meritz.github.io/calls-and-functions.html">, 나중에 함수를 추가</a>할 때 필수적인 표현이 될 것입니다.</font><font papago-translate="translated"> C와 같은 언어의 실제 코드에서 대부분의 문장은 표현<span name="majority"></span> 문장입니다.</font></p>
<aside name="majority" style="top: 6668px;">
<p><font papago-translate="translated">제 계산에 따르면, 이 장의 마지막에 있는 "compiler.c" 버전의 149개 문장 중 80개가 표현 문장입니다.</font></p>
</aside>
<h3><a href="https://youhogeon-meritz.github.io/global-variables.html#error-synchronization" id="error-synchronization"><small><font papago-translate="translated">21 . 1 . 3</font></small><font papago-translate="splitted"><font papago-translate="translated">오류 동기화</font></font></a></h3>
<p><font papago-translate="translated">컴파일러에서 초기 작업을 수행하는 동안<a href="https://youhogeon-meritz.github.io/compiling-expressions.html#handling-syntax-errors"> 여러 장을 남겨</a>둔 느슨한 끝을 묶을 수 있습니다.</font><font papago-translate="translated"> jlox와 마찬가지로 clox는 패닉 모드 오류 복구를 사용하여 보고하는 계단식 컴파일 오류의 수를 최소화합니다.</font><font papago-translate="translated"> 컴파일러는 동기화 지점에 도달하면 패닉 모드를 종료합니다.</font><font papago-translate="translated"> Lox의 경우, 우리는 진술 경계를 그 지점으로 선택했습니다.</font><font papago-translate="translated"> 이제 문이 생겼으니 동기화를 구현할 수 있습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  statement();
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>선언</em>문 ()에서</font></font></div>
<pre class="insert" translate="no">
  <span class="k">if</span> (<span class="i">parser</span>.<span class="i">panicMode</span>) <span class="i">synchronize</span>();
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>declaration</em>()</div>
<p><font papago-translate="translated">이전 문장을 구문 분석하는 동안 컴파일 오류가 발생하면 패닉 모드로 들어갑니다.</font><font papago-translate="translated"> 그런 일이 발생하면, 그 문장 이후에 우리는 동기화를 시작합니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>print</em>St<em>atement</em>() 후에 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">synchronize</span>() {
  <span class="i">parser</span>.<span class="i">panicMode</span> = <span class="k">false</span>;

  <span class="k">while</span> (<span class="i">parser</span>.<span class="i">current</span>.<span class="i">type</span> != <span class="a">TOKEN_EOF</span>) {
    <span class="k">if</span> (<span class="i">parser</span>.<span class="i">previous</span>.<span class="i">type</span> == <span class="a">TOKEN_SEMICOLON</span>) <span class="k">return</span>;
    <span class="k">switch</span> (<span class="i">parser</span>.<span class="i">current</span>.<span class="i">type</span>) {
      <span class="k">case</span> <span class="a">TOKEN_CLASS</span>:
      <span class="k">case</span> <span class="a">TOKEN_FUN</span>:
      <span class="k">case</span> <span class="a">TOKEN_VAR</span>:
      <span class="k">case</span> <span class="a">TOKEN_FOR</span>:
      <span class="k">case</span> <span class="a">TOKEN_IF</span>:
      <span class="k">case</span> <span class="a">TOKEN_WHILE</span>:
      <span class="k">case</span> <span class="a">TOKEN_PRINT</span>:
      <span class="k">case</span> <span class="a">TOKEN_RETURN</span>:
        <span class="k">return</span>;

      <span class="k">default</span>:
        ; <span class="c">// Do nothing.</span>
    }

    <span class="i">advance</span>();
  }
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>printStatement</em>()</div>
<p><font papago-translate="translated">우리는 문장 경계처럼 보이는 무언가에 도달할 때까지 토큰을 무차별적으로 건너뛸 수 있습니다.</font><font papago-translate="translated"> 우리는 세미콜론과 같이 문장을 끝낼 수 있는 선행 토큰을 찾아 경계를 인식합니다.</font><font papago-translate="translated"> 또는 일반적으로 제어 흐름 또는 선언 키워드 중 하나인 문장을 시작하는 후속 토큰을 찾을 수 있습니다.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/global-variables.html#variable-declarations" id="variable-declarations"><small><font papago-translate="translated">21 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">변수 선언</font></font></a></h2>
<p><font papago-translate="translated"><em>단순히 인쇄</em>할 수 있다고 해서 프로그래밍 언어<span name="fair"> 박람회</span>에서 당신의 언어가 상을 받을 수 있는 것은 아닙니다. 그러니 조금 더 야심찬 주제로 넘어가서 변수를 풀어보겠습니다.</font><font papago-translate="translated"> 지원해야 할 세 가지 작업이 있습니다:</font></p>
<aside name="fair" style="top: 7928px;">
<p><font papago-translate="translated">저는 어떤 나라의 4H와 같은 "언어 박람회"를 상상하지 않을 수 없습니다.</font><font papago-translate="translated"> 아기 언어들로 가득 찬 짚단 가판대들이<em> 서로를 향해 웅성</em>거리고<em> 짖</em>는 소리로 가득합니다.</font></p>
</aside>
<ul>
<li><font papago-translate="splitted"><font papago-translate="translated">다음을 사용하여 새 변수 선언 </font></font><code translate="no">var</code><font papago-translate="splitted"><font papago-translate="translated"> 진술.</font></font></li>
<li><font papago-translate="translated">식별자 표현을 사용하여 변수 값에 접근하기.</font></li>
<li><font papago-translate="translated">할당 표현식을 사용하여 기존 변수에 새 값을 저장합니다.</font></li>
</ul>
<p><font papago-translate="translated">변수가 생기기 전까지는 마지막 두 가지 중 어느 것도 할 수 없으므로 선언문부터 시작합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">static void declaration() {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>선언</em>문 ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">  <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_VAR</span>)) {
    <span class="i">varDeclaration</span>();
  } <span class="k">else</span> {
    <span class="i">statement</span>();
  }
</pre><pre class="insert-after" translate="no">
  if (parser.panicMode) synchronize();
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>declaration</em>(), replace 1 line</div>
<p><font papago-translate="splitted"><font papago-translate="translated">선언 문법 규칙을 위해 스케치한 자리 표시자 구문 분석 기능이 이제 실제 작동 중입니다.</font><font papago-translate="translated"> 일치하는 경우 </font></font><code translate="no">var</code><font papago-translate="splitted"><font papago-translate="translated"> 토큰, 여기로 점프합니다:</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 식<em></em> () 뒤에 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">varDeclaration</span>() {
  <span class="t">uint8_t</span> <span class="i">global</span> = <span class="i">parseVariable</span>(<span class="s">"Expect variable name."</span>);

  <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_EQUAL</span>)) {
    <span class="i">expression</span>();
  } <span class="k">else</span> {
    <span class="i">emitByte</span>(<span class="a">OP_NIL</span>);
  }
  <span class="i">consume</span>(<span class="a">TOKEN_SEMICOLON</span>,
          <span class="s">"Expect ';' after variable declaration."</span>);

  <span class="i">defineVariable</span>(<span class="i">global</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>expression</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">키워드 뒤에 변수 이름이 이어집니다.</font><font papago-translate="translated"> 다음에 의해 컴파일됩니다 </font></font><code translate="no">parseVariable()</code><font papago-translate="splitted"><font papago-translate="translated">, 곧 도착할 것입니다.</font><font papago-translate="translated"> 그런 다음 </font></font><code translate="no">=</code><font papago-translate="splitted"><font papago-translate="translated"> 이니셜라이저 표현식이 이어집니다.</font><font papago-translate="translated"> 사용자가 변수를 초기화하지 않으면 컴파일러는 암묵적으로<span name="nil"></span> 다음과 같이 초기화합니다 </font></font><code translate="no">OP_NIL</code><font papago-translate="splitted"><font papago-translate="translated"> 설명.</font><font papago-translate="translated"> 어느 쪽이든, 우리는 그 문장이 세미콜론으로 끝날 것으로 예상합니다.</font></font></p>
<aside class="bottom" name="nil" style="top: 8605px;">
<p><font papago-translate="translated">기본적으로 컴파일러는 다음과 같은 변수 선언을 생략합니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="i">a</span>;
</pre></div>
<p><font papago-translate="translated">안으로:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="i">a</span> = <span class="k">nil</span>;
</pre></div>
<p><font papago-translate="translated">전자를 위해 생성되는 코드는 후자를 위해 생성되는 코드와 동일합니다.</font></p>
</aside>
<p><font papago-translate="translated">변수와 식별자를 다루는 두 가지 새로운 기능이 있습니다.</font><font papago-translate="translated"> 첫 번째는 다음과 같습니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">static void parsePrecedence(Precedence precedence);

</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>parse</em>P<em>recedence</em>() 다음에 추가</font></font></div>
<pre class="insert" translate="no"><span class="k">static</span> <span class="t">uint8_t</span> <span class="i">parseVariable</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">errorMessage</span>) {
  <span class="i">consume</span>(<span class="a">TOKEN_IDENTIFIER</span>, <span class="i">errorMessage</span>);
  <span class="k">return</span> <span class="i">identifierConstant</span>(&amp;<span class="i">parser</span>.<span class="i">previous</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>parsePrecedence</em>()</div>
<p><font papago-translate="translated">다음 토큰은 식별자여야 하며, 이를 소비하고 여기로 보냅니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">static void parsePrecedence(Precedence precedence);

</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>parse</em>P<em>recedence</em>() 다음에 추가</font></font></div>
<pre class="insert" translate="no"><span class="k">static</span> <span class="t">uint8_t</span> <span class="i">identifierConstant</span>(<span class="t">Token</span>* <span class="i">name</span>) {
  <span class="k">return</span> <span class="i">makeConstant</span>(<span class="a">OBJ_VAL</span>(<span class="i">copyString</span>(<span class="i">name</span>-&gt;<span class="i">start</span>,
                                         <span class="i">name</span>-&gt;<span class="i">length</span>)));
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>parsePrecedence</em>()</div>
<p><font papago-translate="translated">이 함수는 주어진 토큰을 가져와서 해당 어휘를 문자열로 청크의 상수 테이블에 추가합니다.</font><font papago-translate="translated"> 그런 다음 상수 테이블에 있는 해당 상수의 인덱스를 반환합니다.</font></p>
<p><font papago-translate="translated">글로벌 변수는 런타임 시<em> 이름으로</em> 조회됩니다.</font><font papago-translate="translated"> 즉, 바이트코드 인터프리터 루프인 VM은<span class="em"></span><span class="em"></span> 이름에 대한 액세스가 필요합니다.</font><font papago-translate="translated"> 문자열 전체가 너무 커서 바이트코드 스트림에 피연산자로 넣을 수 없습니다.</font><font papago-translate="translated"> 대신, 문자열을 상수 테이블에 저장하고 명령어는 테이블의 인덱스 이름을 참조합니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">이 함수는 해당 인덱스를 다음과 같이 반환합니다 </font></font><code translate="no">varDeclaration()</code><font papago-translate="splitted"><font papago-translate="translated"> 나중에 여기로 넘겨줍니다:</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>parse</em>V<em>ariable</em>() 후에 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">defineVariable</span>(<span class="t">uint8_t</span> <span class="i">global</span>) {
  <span class="i">emitBytes</span>(<span class="a">OP_DEFINE_GLOBAL</span>, <span class="i">global</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>parseVariable</em>()</div>
<p><font papago-translate="translated"><span name="helper">이렇게</span> 하면 새 변수를 정의하고 초기 값을 저장하는 바이트코드 명령어가 출력됩니다<span name="helper">.</span></font><font papago-translate="translated"> 상수 테이블에 있는 변수 이름의 인덱스는 명령어의 피연산자입니다.</font><font papago-translate="translated"> 스택 기반 VM에서는 일반적으로 이 명령어를 마지막으로 전송합니다.</font><font papago-translate="translated"> 런타임 시 변수의 초기화 코드를 먼저 실행합니다.</font><font papago-translate="translated"> 그러면 스택에 값이 남습니다.</font><font papago-translate="translated"> 그런 다음 이 명령은 해당 값을 가져와 나중에 저장합니다.</font></p>
<aside name="helper" style="top: 9656px;">
<p><font papago-translate="translated">지금 이 기능들 중 일부가 꽤 무의미해 보인다는 것을 알고 있습니다.</font><font papago-translate="translated"> 하지만 이름을 다룰 때 더 많은 언어 기능을 추가하면 더 많은 마일리지를 얻을 수 있습니다.</font><font papago-translate="translated"> 함수와 클래스 선언은 모두 새로운 변수를 선언하며, 변수와 할당 표현식은 이를 접근합니다.</font></p>
</aside>
<p><font papago-translate="translated">런타임이 끝나면 이 새로운 명령어로 시작합니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  OP_POP,
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">청크.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> enum O<em>pCode</em>에서</font></font></div>
<pre class="insert" translate="no">  <span class="a">OP_DEFINE_GLOBAL</span>,
</pre><pre class="insert-after" translate="no">  OP_EQUAL,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>
<p><font papago-translate="translated">핸디 댄디 해시 테이블 덕분에 구현이 그리 어렵지 않습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      case OP_POP: pop(); break;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font></div>
<pre class="insert" translate="no">      <span class="k">case</span> <span class="a">OP_DEFINE_GLOBAL</span>: {
        <span class="t">ObjString</span>* <span class="i">name</span> = <span class="a">READ_STRING</span>();
        <span class="i">tableSet</span>(&amp;<span class="i">vm</span>.<span class="i">globals</span>, <span class="i">name</span>, <span class="i">peek</span>(<span class="n">0</span>));
        <span class="i">pop</span>();
        <span class="k">break</span>;
      }
</pre><pre class="insert-after" translate="no">      case OP_EQUAL: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p><font papago-translate="translated">상수 테이블에서 변수의 이름을 얻습니다.</font><font papago-translate="translated"> 그런 다음 스택 상단의 값을<span name="pop"> 가져와</span> 해당 이름을 키로 하는 해시 테이블에 저장합니다.</font></p>
<aside name="pop" style="top: 10188px;">
<p><font papago-translate="translated">해시 테이블에 값을 추가한<em> 후</em>에야<em> 값을 터뜨릴</em> 수 있다는 점에 유의하세요.</font><font papago-translate="translated"> 이는 해시 테이블에 값을 추가하는 도중에 가비지 컬렉션이 트리거되더라도 VM이 여전히 값을 찾을 수 있도록 보장합니다.</font><font papago-translate="translated"> 해시 테이블이 크기를 조정할 때 동적 할당이 필요하기 때문에 이는 별개의 가능성입니다.</font></p>
</aside>
<p><font papago-translate="translated">이 코드는 키가 이미 테이블에 있는지 확인하지 않습니다.</font><font papago-translate="translated"> Lox는 전역 변수에 대해 매우 느슨하기 때문에 오류 없이 재정의할 수 있습니다.</font><font papago-translate="translated"> 이는 REPL 세션에서 유용하므로, 키가 해시 테이블에 이미 있을 경우 VM은 단순히 값을 덮어쓰는 방식으로 이를 지원합니다.</font></p>
<p><font papago-translate="translated">또 다른 작은 도우미 매크로가 있습니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#define READ_CONSTANT() (vm.chunk-&gt;constants.values[READ_BYTE()])
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font></div>
<pre class="insert" translate="no"><span class="a">#define READ_STRING() AS_STRING(READ_CONSTANT())</span>
</pre><pre class="insert-after" translate="no">#define BINARY_OP(valueType, op) \
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p><font papago-translate="translated">바이트 코드 청크에서 1바이트 피연산자를 읽습니다.</font><font papago-translate="translated"> 그것은 그것을 청크의 상수 테이블에 있는 인덱스로 취급하고, 그 인덱스에 있는 문자열을 반환합니다.</font><font papago-translate="translated"> 값이 문자열인지 확인하는 것이 아니라 무분별<span class="em"></span><em></em>하게 문자열을 캐스팅할 뿐입니다.</font><font papago-translate="translated"> 컴파일러가 비스트링 상수를 참조하는 명령어를 절대로 방출하지 않기 때문에 안전합니다.</font></p>
<p><font papago-translate="translated">우리는 어휘 위생에 신경 쓰기 때문에 해석 함수의 끝에서 이 매크로를 정의 해제합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#undef READ_CONSTANT
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font></div>
<pre class="insert" translate="no"><span class="a">#undef READ_STRING</span>
</pre><pre class="insert-after" translate="no">#undef BINARY_OP
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p><font papago-translate="translated">저는 계속해서 "해시 테이블"이라고 말하지만, 실제로는 아직 해시 테이블이 없습니다.</font><font papago-translate="translated"> 이 글로벌들을 보관할 장소가 필요합니다.</font><font papago-translate="translated"> clox가 실행되는 한 지속되기를 원하기 때문에 VM에 바로 저장합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  Value* stackTop;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">VM.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em></em>구조 VM에서</font></font></div>
<pre class="insert" translate="no">  <span class="t">Table</span> <span class="i">globals</span>;
</pre><pre class="insert-after" translate="no">  Table strings;
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, in struct <em>VM</em></div>
<p><font papago-translate="translated">문자열 테이블과 마찬가지로 VM이 부팅될 때 해시 테이블을 유효한 상태로 초기화해야 합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  vm.objects = NULL;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>initVM</em>()에서</font></font></div>
<pre class="insert" translate="no">
  <span class="i">initTable</span>(&amp;<span class="i">vm</span>.<span class="i">globals</span>);
</pre><pre class="insert-after" translate="no">  initTable(&amp;vm.strings);
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>initVM</em>()</div>
<p><font papago-translate="translated">그리고 우리가 나갈 때<span name="tear"> 그것</span>을<span name="tear"> 분해</span>합니다.</font></p>
<aside name="tear" style="top: 11168px;">
<p><font papago-translate="translated">이 과정을 통해 모든 것이 종료될 수 있지만, 운영 체제가 우리의 혼란을 해결하도록 요구하는 것은 품위 없는 일로 느껴집니다.</font></p>
</aside>
<div class="codehilite"><pre class="insert-before" translate="no">void freeVM() {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>무료</em> VM()에서</font></font></div>
<pre class="insert" translate="no">  <span class="i">freeTable</span>(&amp;<span class="i">vm</span>.<span class="i">globals</span>);
</pre><pre class="insert-after" translate="no">  freeTable(&amp;vm.strings);
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>freeVM</em>()</div>
<p><font papago-translate="translated">평소처럼 새로운 명령어도 분해할 수 있기를 원합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      return simpleInstruction("OP_POP", offset);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">debug.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>분해</em> 중 지침()</font></font></div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="a">OP_DEFINE_GLOBAL</span>:
      <span class="k">return</span> <span class="i">constantInstruction</span>(<span class="s">"OP_DEFINE_GLOBAL"</span>, <span class="i">chunk</span>,
                                 <span class="i">offset</span>);
</pre><pre class="insert-after" translate="no">    case OP_EQUAL:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>
<p><font papago-translate="translated">이를 통해 전역 변수를 정의할 수 있습니다.</font><font papago-translate="translated"> 사용자가 실제로<em> 사용할</em> 수 없기 때문에<em> 그렇게 했다는 것을 알</em> 수 있는 것은 아닙니다.</font><font papago-translate="translated"> 그럼 다음에 이 문제를 해결해 보겠습니다.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/global-variables.html#reading-variables" id="reading-variables"><small><font papago-translate="translated">21 . 3</font></small><font papago-translate="splitted"><font papago-translate="translated">변수 읽기</font></font></a></h2>
<p><font papago-translate="translated">모든 프로그래밍 언어에서와 마찬가지로, 우리는 변수의 이름을 사용하여 변수의 값에 접근합니다.</font><font papago-translate="translated"> 여기서는 식별자 토큰을 표현식 파서에 연결합니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  [TOKEN_LESS_EQUAL]    = {NULL,     binary, PREC_COMPARISON},
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">  [<span class="a">TOKEN_IDENTIFIER</span>]    = {<span class="i">variable</span>, <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
</pre><pre class="insert-after" translate="no">  [TOKEN_STRING]        = {string,   NULL,   PREC_NONE},
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, replace 1 line</div>
<p><font papago-translate="translated">이를 새로운 파서 함수라고 합니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>문자열</em> () 뒤에 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">variable</span>() {
  <span class="i">namedVariable</span>(<span class="i">parser</span>.<span class="i">previous</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>string</em>()</div>
<p><font papago-translate="translated">선언문과 마찬가지로 지금은 무의미해 보이지만 나중 장에서 더 유용해질 몇 가지 작은 도우미 함수가 있습니다.</font><font papago-translate="translated"> 약속해요.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>문자열</em> () 뒤에 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">namedVariable</span>(<span class="t">Token</span> <span class="i">name</span>) {
  <span class="t">uint8_t</span> <span class="i">arg</span> = <span class="i">identifierConstant</span>(&amp;<span class="i">name</span>);
  <span class="i">emitBytes</span>(<span class="a">OP_GET_GLOBAL</span>, <span class="i">arg</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>string</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">이것은 같은 이름입니다 </font></font><code translate="no">identifierConstant()</code><font papago-translate="splitted"><font papago-translate="translated"> 이전에 주어진 식별자 토큰을 가져와서 그 어휘를 문자열로 청크의 상수 테이블에 추가하는 함수.</font><font papago-translate="translated"> 남은 것은 그 이름으로 전역 변수를 로드하는 명령어를 보내는 것뿐입니다.</font><font papago-translate="translated"> 다음은 지침입니다:</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  OP_POP,
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">청크.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> enum O<em>pCode</em>에서</font></font></div>
<pre class="insert" translate="no">  <span class="a">OP_GET_GLOBAL</span>,
</pre><pre class="insert-after" translate="no">  OP_DEFINE_GLOBAL,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>
<p><font papago-translate="splitted"><font papago-translate="translated">인터프리터를 통해 구현이 미러링됩니다 </font></font><code translate="no">OP_DEFINE_GLOBAL</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      case OP_POP: pop(); break;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font></div>
<pre class="insert" translate="no">      <span class="k">case</span> <span class="a">OP_GET_GLOBAL</span>: {
        <span class="t">ObjString</span>* <span class="i">name</span> = <span class="a">READ_STRING</span>();
        <span class="t">Value</span> <span class="i">value</span>;
        <span class="k">if</span> (!<span class="i">tableGet</span>(&amp;<span class="i">vm</span>.<span class="i">globals</span>, <span class="i">name</span>, &amp;<span class="i">value</span>)) {
          <span class="i">runtimeError</span>(<span class="s">"Undefined variable '%s'."</span>, <span class="i">name</span>-&gt;<span class="i">chars</span>);
          <span class="k">return</span> <span class="a">INTERPRET_RUNTIME_ERROR</span>;
        }
        <span class="i">push</span>(<span class="i">value</span>);
        <span class="k">break</span>;
      }
</pre><pre class="insert-after" translate="no">      case OP_DEFINE_GLOBAL: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p><font papago-translate="translated">우리는 명령어의 피연산자에서 상수 테이블 인덱스를 가져와서 변수 이름을 얻습니다.</font><font papago-translate="translated"> 그런 다음 이를 키로 사용하여 전역 해시 테이블에서 변수의 값을 찾습니다.</font></p>
<p><font papago-translate="translated">해시 테이블에 키가 없으면 전역 변수가 정의된 적이 없다는 뜻입니다.</font><font papago-translate="translated"> 이는 Lox의 런타임 오류이므로 보고하고 그런 일이 발생하면 인터프리터 루프를 종료합니다.</font><font papago-translate="translated"> 그렇지 않으면 값을 가져와서 스택에 밀어 넣습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      return simpleInstruction("OP_POP", offset);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">debug.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>분해</em> 중 지침()</font></font></div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="a">OP_GET_GLOBAL</span>:
      <span class="k">return</span> <span class="i">constantInstruction</span>(<span class="s">"OP_GET_GLOBAL"</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
</pre><pre class="insert-after" translate="no">    case OP_DEFINE_GLOBAL:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>
<p><font papago-translate="translated">조금만 분해하면 끝입니다.</font><font papago-translate="translated"> 우리 통역사는 이제 다음과 같은 코드를 실행할 수 있습니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="i">beverage</span> = <span class="s">"cafe au lait"</span>;
<span class="k">var</span> <span class="i">breakfast</span> = <span class="s">"beignets with "</span> + <span class="i">beverage</span>;
<span class="k">print</span> <span class="i">breakfast</span>;
</pre></div>
<p><font papago-translate="translated">수술이 하나밖에 남지 않았습니다.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/global-variables.html#assignment" id="assignment"><small><font papago-translate="translated">21 . 4</font></small><font papago-translate="splitted"><font papago-translate="translated">과제</font></font></a></h2>
<p><font papago-translate="translated">이 책을 읽는 동안, 저는 여러분을 꽤 안전하고 쉬운 길로 이끌기 위해 노력했습니다.</font><font papago-translate="translated"> 저는 어려운<em> 문제</em>를 피하지는 않지만<em>, 해결책을</em> 필요 이상으로 복잡하게 만들지 않으려고 노력합니다.</font><font papago-translate="translated"> 안타깝게도<span name="jlox"> 바이트코드</span> 컴파일러의 다른 디자인 선택 사항은 할당을 구현하기 어렵게 만듭니다.</font></p>
<aside name="jlox" style="top: 13264px;">
<p><font papago-translate="translated">기억하시겠지만, Jlox에서는 과제가 꽤 쉬웠습니다.</font></p>
</aside>
<p><font papago-translate="translated">바이트코드 VM은 단일 패스 컴파일러를 사용합니다.</font><font papago-translate="translated"> 중간 AST 없이 즉석에서 바이트코드를 파싱하고 생성합니다.</font><font papago-translate="translated"> 구문을 인식하는 즉시 해당 구문에 대한 코드를 방출합니다.</font><font papago-translate="translated"> 과제는 자연스럽게 그것에 맞지 않습니다.</font><font papago-translate="translated"> 고려:</font></p>
<div class="codehilite"><pre translate="no"><span class="i">menu</span>.<span class="i">brunch</span>(<span class="i">sunday</span>).<span class="i">beverage</span> = <span class="s">"mimosa"</span>;
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">이 코드에서 파서는 다음을 인식하지 못합니다 </font></font><code translate="no">menu.brunch(sunday).beverage</code><font papago-translate="splitted"><font papago-translate="translated"> 할당의 대상이며 도달할 때까지 정규 표현식이 아닙니다 </font></font><code translate="no">=</code><font papago-translate="splitted"><font papago-translate="translated">, 첫 번째 토큰 이후의 많은 토큰 </font></font><code translate="no">menu</code><font papago-translate="splitted"><font papago-translate="translated">. 그때쯤이면 컴파일러는 이미 전체 바이트코드를 공개했습니다.</font></font></p>
<p><font papago-translate="translated">하지만 문제는 생각만큼 심각하지 않습니다.</font><font papago-translate="translated"> 파서가 그 예시를 어떻게 보는지 보세요:</font></p><img alt="The 'menu.brunch(sunday).beverage = &quot;mimosa&quot;' statement, showing that 'menu.brunch(sunday)' is an expression." src="https://youhogeon-meritz.github.io/image/global-variables/setter.png">
<p><font papago-translate="splitted"><font papago-translate="translated">비록 </font></font><code translate="no">.beverage</code><font papago-translate="splitted"><font papago-translate="translated"> 부분은 get 식으로 컴파일해서는 안 되며, 모든 부분은 왼쪽에 있습니다 </font></font><code translate="no">.</code><font papago-translate="splitted"><font papago-translate="translated"> 는 정상적인 표현 의미를 가진 표현입니다.</font><font papago-translate="translated"> 그 </font></font><code translate="no">menu.brunch(sunday)</code><font papago-translate="splitted"><font papago-translate="translated"> 부품은 평소처럼 컴파일하고 실행할 수 있습니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">다행히도 할당의 왼쪽에 있는 유일한 의미론적 차이는 토큰의 맨 오른쪽 끝, 바로 앞에 나타납니다 </font></font><code translate="no">=</code><font papago-translate="splitted"><font papago-translate="translated">. 세터의 수신기가 임의로 긴 표현일 수 있지만, 동작이 get 표현과 다른 부분은 바로 앞에 있는 후행 식별자일 뿐입니다 </font></font><code translate="no">=</code><font papago-translate="splitted"><font papago-translate="translated">. 우리는 깨닫는 데 많은 미래가 필요하지 않습니다 </font></font><code translate="no">beverage</code><font papago-translate="splitted"><font papago-translate="translated"> 가터가 아닌 집합 표현식으로 컴파일해야 합니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">변수는 단순히 하나의 맨 식별자 앞에 있기 때문에 훨씬 더 쉽습니다 </font></font><code translate="no">=</code><font papago-translate="splitted"><font papago-translate="translated">. 그러면 아이디어는 할당 대상으로도 사용할 수 있는 표현식을 컴파일<em>하기</em> 직전에 후속 표현식을 찾는 것입니다 </font></font><code translate="no">=</code><font papago-translate="splitted"><font papago-translate="translated"> 상품권.</font><font papago-translate="translated"> 하나를 보면 변수 접근이나 게터 대신 할당이나 세터로 컴파일합니다.</font></font></p>
<p><font papago-translate="translated">아직 걱정할 세터가 없어서 변수만 처리하면 됩니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  uint8_t arg = identifierConstant(&amp;name);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>명명</em>된 변수()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">
  <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_EQUAL</span>)) {
    <span class="i">expression</span>();
    <span class="i">emitBytes</span>(<span class="a">OP_SET_GLOBAL</span>, <span class="i">arg</span>);
  } <span class="k">else</span> {
    <span class="i">emitBytes</span>(<span class="a">OP_GET_GLOBAL</span>, <span class="i">arg</span>);
  }
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>namedVariable</em>(), replace 1 line</div>
<p><font papago-translate="translated">식별자 표현식의 구문 분석 함수에서 식별자 뒤에 등호를 찾습니다.</font><font papago-translate="translated"> 변수 접근을 위한 코드를 방출하는 대신 할당된 값을 컴파일한 다음 할당 명령을 방출합니다.</font></p>
<p><font papago-translate="translated">이것이 이 장에서 추가해야 할 마지막 지침입니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  OP_DEFINE_GLOBAL,
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">청크.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> enum O<em>pCode</em>에서</font></font></div>
<pre class="insert" translate="no">  <span class="a">OP_SET_GLOBAL</span>,
</pre><pre class="insert-after" translate="no">  OP_EQUAL,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>
<p><font papago-translate="translated">예상하셨겠지만, 런타임 동작은 새로운 변수를 정의하는 것과 비슷합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      }
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font></div>
<pre class="insert" translate="no">      <span class="k">case</span> <span class="a">OP_SET_GLOBAL</span>: {
        <span class="t">ObjString</span>* <span class="i">name</span> = <span class="a">READ_STRING</span>();
        <span class="k">if</span> (<span class="i">tableSet</span>(&amp;<span class="i">vm</span>.<span class="i">globals</span>, <span class="i">name</span>, <span class="i">peek</span>(<span class="n">0</span>))) {
          <span class="i">tableDelete</span>(&amp;<span class="i">vm</span>.<span class="i">globals</span>, <span class="i">name</span>);<span name="delete"> </span>
          <span class="i">runtimeError</span>(<span class="s">"Undefined variable '%s'."</span>, <span class="i">name</span>-&gt;<span class="i">chars</span>);
          <span class="k">return</span> <span class="a">INTERPRET_RUNTIME_ERROR</span>;
        }
        <span class="k">break</span>;
      }
</pre><pre class="insert-after" translate="no">      case OP_EQUAL: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p><font papago-translate="translated">주요 차이점은 키가 글로벌 해시 테이블에 이미 존재하지 않을 때 어떤 일이 일어나는지입니다.</font><font papago-translate="translated"> 변수가 아직 정의되지 않았다면, 변수에 할당하려고 시도하는 것은 런타임 오류입니다.</font><font papago-translate="translated"> Lox<a href="https://youhogeon-meritz.github.io/statements-and-state.html#design-note">는 암묵적 변수 선언을 하지</a> 않습니다.</font></p>
<aside name="delete" style="top: 14767px;">
<p><font papago-translate="splitted"><font papago-translate="translated">로의 부름 </font></font><code translate="no">tableSet()</code><font papago-translate="splitted"><font papago-translate="translated"> 변수가 이전에 정의되지 않았더라도 글로벌 변수 테이블에 값을 저장합니다.</font><font papago-translate="translated"> 그 사실은 런타임 오류가 보고된 후에도 계속 실행되기 때문에 REPL 세션에서 확인할 수 있습니다.</font><font papago-translate="translated"> 그래서 우리는 또한 그 좀비 값을 테이블에서 삭제하도록 주의합니다.</font></font></p>
</aside>
<p><font papago-translate="translated">다른 차이점은 변수를 설정해도 스택에서 값이 튀어나오지 않는다는 것입니다.</font><font papago-translate="translated"> 기억하세요, 할당은 표현식이므로 할당이 더 큰 표현식 안에 포함될 경우 해당 값을 그대로 두어야 합니다.</font></p>
<p><font papago-translate="translated">분해를 약간 추가합니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      return constantInstruction("OP_DEFINE_GLOBAL", chunk,
                                 offset);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">debug.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>분해</em> 중 지침()</font></font></div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="a">OP_SET_GLOBAL</span>:
      <span class="k">return</span> <span class="i">constantInstruction</span>(<span class="s">"OP_SET_GLOBAL"</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
</pre><pre class="insert-after" translate="no">    case OP_EQUAL:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>
<p><font papago-translate="translated">이제 끝났죠?</font><font papago-translate="translated"> 글쎄요<span class="ellipse">...</span> 그렇지 않습니다.</font><font papago-translate="translated"> 실수를 저질렀습니다!</font><font papago-translate="translated"> 갠더를 살펴보세요:</font></p>
<div class="codehilite"><pre translate="no"><span class="i">a</span> * <span class="i">b</span> = <span class="i">c</span> + <span class="i">d</span>;
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">록스의 문법에 따르면, </font></font><code translate="no">=</code><font papago-translate="splitted"><font papago-translate="translated"> 우선순위가 가장 낮기 때문에 대략 다음과 같이 해석해야 합니다:</font></font></p><img alt="The expected parse, like '(a * b) = (c + d)'." src="https://youhogeon-meritz.github.io/image/global-variables/ast-good.png">
<p><font papago-translate="splitted"><font papago-translate="translated">물론. 뻔하지. </font></font><code translate="no">a * b</code><font papago-translate="splitted"><font papago-translate="translated"> <span name="do">유효</span>한 할당 대상이 아니므로 구문 오류여야 합니다.</font><font papago-translate="translated"> 하지만 우리 파서가 하는 일은 다음과 같습니다:</font></font></p>
<aside name="do" style="top: 15619px;">
<p><font papago-translate="splitted"><font papago-translate="translated">야생적이지 않을까요 </font></font><code translate="no">a * b</code> <font papago-translate="splitted"><font papago-translate="translated">하지만 유효한 과제 목표<em>였습니까?</em></font><font papago-translate="translated"> 할당된 값을 합리적인 방식으로 나누어 분배하려는 대수학과 같은 언어를 상상할 수 있습니다 </font></font><code translate="no">a</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">b</code><font papago-translate="splitted"><font papago-translate="translated"><span class="ellipse"> . . .</span> 그건 아마 끔찍한 생각일 겁니다<span class="ellipse">.</span></font></font></p>
</aside>
<ol>
<li><font papago-translate="splitted"><font papago-translate="translated">첫번째, </font></font><code translate="no">parsePrecedence()</code><font papago-translate="splitted"><font papago-translate="translated"> 구문 분석 </font></font><code translate="no">a</code><font papago-translate="splitted"><font papago-translate="translated"> 사용 </font></font><code translate="no">variable()</code><font papago-translate="splitted"><font papago-translate="translated"> 접두사 파서.</font></font></li>
<li><font papago-translate="translated">그 후, 그것은 infix 구문 분석 루프에 들어갑니다.</font></li>
<li><font papago-translate="splitted"><font papago-translate="translated">도달합니다 </font></font><code translate="no">*</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고 전화 </font></font><code translate="no">binary()</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></li>
<li><font papago-translate="splitted"><font papago-translate="translated">그것은 재귀적으로 호출합니다 </font></font><code translate="no">parsePrecedence()</code><font papago-translate="splitted"><font papago-translate="translated"> 오른쪽 피연산자를 구문 분석합니다.</font></font></li>
<li><font papago-translate="splitted"><font papago-translate="translated">그것은 전화입니다 </font></font><code translate="no">variable()</code><font papago-translate="splitted"><font papago-translate="translated"> 구문 분석을 위해 다시 한 번 </font></font><code translate="no">b</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></li>
<li><font papago-translate="splitted"><font papago-translate="translated">그 부름 속에서 </font></font><code translate="no">variable()</code><font papago-translate="splitted"><font papago-translate="translated">, 후행을 찾습니다 </font></font><code translate="no">=</code><font papago-translate="splitted"><font papago-translate="translated">. 하나를 보고 나머지 줄을 과제로 해석합니다.</font></font></li>
</ol>
<p><font papago-translate="translated">다시 말해, 파서는 위의 코드를 다음과 같이 봅니다:</font></p><img alt="The actual parse, like 'a * (b = c + d)'." src="https://youhogeon-meritz.github.io/image/global-variables/ast-bad.png">
<p><font papago-translate="splitted"><font papago-translate="translated">다음과 같은 이유로 우선순위 처리를 잘못했습니다 </font></font><code translate="no">variable()</code><font papago-translate="splitted"><font papago-translate="translated"> 변수를 포함하는 주변 표현의 우선순위를 고려하지 않습니다.</font><font papago-translate="translated"> 변수가 인픽스 연산자의 오른쪽 또는 단항 연산자의 피연산자라면, 해당 표현식은 너무 높은 우선순위로 허용되지 않습니다 </font></font><code translate="no">=</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">이 문제를 해결하기 위해, </font></font><code translate="no">variable()</code><font papago-translate="splitted"><font papago-translate="translated"> 찾고 소비해야 합니다 </font></font><code translate="no">=</code><font papago-translate="splitted"><font papago-translate="translated"> 우선순위가 낮은 표현의 맥락에서만 가능합니다.</font><font papago-translate="translated"> 현재의 우선순위를 알고 있는 코드는 논리적으로 충분히, </font></font><code translate="no">parsePrecedence()</code><font papago-translate="splitted"><font papago-translate="translated">.그 </font></font><code translate="no">variable()</code><font papago-translate="splitted"><font papago-translate="translated"> 함수는 실제 수준을 알 필요가 없습니다.</font><font papago-translate="translated"> 우선순위가 할당을 허용할 만큼 낮다는 점만 신경 쓰기 때문에 그 사실을 부울로 전달합니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    error("Expect expression.");
    return;
  }

</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>parse</em>P<em>recedence</em>()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">  <span class="t">bool</span> <span class="i">canAssign</span> = <span class="i">precedence</span> &lt;= <span class="a">PREC_ASSIGNMENT</span>;
  <span class="i">prefixRule</span>(<span class="i">canAssign</span>);
</pre><pre class="insert-after" translate="no">
  while (precedence &lt;= getRule(parser.current.type)-&gt;precedence) {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>parsePrecedence</em>(), replace 1 line</div>
<p><font papago-translate="translated">할당이 가장 낮은 우선순위 표현식이기 때문에 할당을 허용하는 유일한 경우는 표현식 문에서와 같이 할당 표현식이나 최상위 표현식을 구문 분석할 때입니다.</font><font papago-translate="translated"> 그 깃발은 여기서 파서 함수로 이동합니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 함수<em> 변수</em> ()</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 3줄 교체</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">variable</span>(<span class="t">bool</span> <span class="i">canAssign</span>) {
  <span class="i">namedVariable</span>(<span class="i">parser</span>.<span class="i">previous</span>, <span class="i">canAssign</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, function <em>variable</em>(), replace 3 lines</div>
<p><font papago-translate="translated">새로운 매개변수를 통과합니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>변수(</em>)<em>라는</em> 함수</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">namedVariable</span>(<span class="t">Token</span> <span class="i">name</span>, <span class="t">bool</span> <span class="i">canAssign</span>) {
</pre><pre class="insert-after" translate="no">  uint8_t arg = identifierConstant(&amp;name);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, function <em>namedVariable</em>(), replace 1 line</div>
<p><font papago-translate="translated">그리고 마침내 여기에 사용합니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  uint8_t arg = identifierConstant(&amp;name);

</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>명명</em>된 변수()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">  <span class="k">if</span> (<span class="i">canAssign</span> &amp;&amp; <span class="i">match</span>(<span class="a">TOKEN_EQUAL</span>)) {
</pre><pre class="insert-after" translate="no">    expression();
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>namedVariable</em>(), replace 1 line</div>
<p><font papago-translate="splitted"><font papago-translate="translated">컴파일러에서 말 그대로 한 비트의 데이터를 올바른 위치로 가져오는 데는 많은 배관 작업이 필요하지만, 실제로 도착했습니다.</font><font papago-translate="translated"> 변수가 더 높은 우선순위로 어떤 식 안에 내포되어 있다면, </font></font><code translate="no">canAssign</code><font papago-translate="splitted"><font papago-translate="translated"> 될 것이다 </font></font><code translate="no">false</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고 이것은 무시할 것입니다 </font></font><code translate="no">=</code><font papago-translate="splitted"><font papago-translate="translated"> 설령 거기에 있다 하더라도.</font><font papago-translate="translated"> 그리고나서 </font></font><code translate="no">namedVariable()</code><font papago-translate="splitted"><font papago-translate="translated"> 반환되고 실행은 결국 다음과 같은 방식으로 돌아갑니다 </font></font><code translate="no">parsePrecedence()</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">그럼 뭐예요?</font><font papago-translate="translated"> 컴파일러는 이전의 깨진 예제를 어떻게 처리합니까?</font><font papago-translate="translated"> 지금 당장. </font></font><code translate="no">variable()</code><font papago-translate="splitted"><font papago-translate="translated"> 소비하지 않을 것입니다 </font></font><code translate="no">=</code><font papago-translate="splitted"><font papago-translate="translated">, 그래서 그게 현재 토큰이 될 것입니다.</font><font papago-translate="translated"> 컴파일러는 다음으로 돌아갑니다 </font></font><code translate="no">parsePrecedence()</code><font papago-translate="splitted"><font papago-translate="translated"> 에서 </font></font><code translate="no">variable()</code><font papago-translate="splitted"><font papago-translate="translated"> 접두사 파서를 사용한 다음 infix 파싱 루프로 들어가려고 합니다.</font><font papago-translate="translated"> 다음과 관련된 구문 분석 기능이 없습니다 </font></font><code translate="no">=</code><font papago-translate="splitted"><font papago-translate="translated">, 그래서 그 루프를 건너뛰게 됩니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">그리고나서 </font></font><code translate="no">parsePrecedence()</code><font papago-translate="splitted"><font papago-translate="translated"> 발신자에게 조용히 돌아갑니다.</font><font papago-translate="translated"> 그것도 옳지 않습니다.</font><font papago-translate="translated"> 만약 </font></font><code translate="no">=</code><font papago-translate="splitted"><font papago-translate="translated"> 표현의 일부로 소비되는 것이 아니라 다른 어떤 것도 소비하지 않을 것입니다.</font><font papago-translate="translated"> 그것은 오류이므로 보고해야 합니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    infixRule();
  }
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>parse</em>P<em>recedence</em>()에서</font></font></div>
<pre class="insert" translate="no">
  <span class="k">if</span> (<span class="i">canAssign</span> &amp;&amp; <span class="i">match</span>(<span class="a">TOKEN_EQUAL</span>)) {
    <span class="i">error</span>(<span class="s">"Invalid assignment target."</span>);
  }
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>parsePrecedence</em>()</div>
<p><font papago-translate="translated">이를 통해 이전의 불량 프로그램은 컴파일 시 오류가 발생합니다.</font><font papago-translate="translated"> 자<em>, 이제</em> 끝났나요?</font><font papago-translate="translated"> 아직은 그렇지 않습니다.</font><font papago-translate="translated"> 분석 함수 중 하나에 인수를 전달하고 있습니다.</font><font papago-translate="translated"> 하지만 이러한 함수는 함수 포인터 테이블에 저장되므로 모든 구문 분석 함수는 동일한 유형을 가져야 합니다.</font><font papago-translate="translated"> 대부분의 구문 분석 함수는 할당 대상으로 사용되는 것을 지원하지 않지만, 세터만이 유일한 다른 함수입니다. 우리의 친근한 C 컴파일러는 모든 함수가<em></em><span class="em"></span><span name="index"></span><span class="em"></span> 매개변수를 받아들여야 합니다.</font></p>
<aside name="index" style="top: 17746px;">
<p><font papago-translate="splitted"><font papago-translate="translated">Lox에 다음과 같은 배열 및 구독 연산자가 있는 경우 </font></font><code translate="no">array[index]</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고 나서 접두사 </font></font><code translate="no">[</code><font papago-translate="splitted"><font papago-translate="translated"> 또한 지원 할당을 허용합니다 </font></font><code translate="no">array[index] = value</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p>
</aside>
<p><font papago-translate="translated">그래서 우리는 이 장을 약간의 불평으로 마무리하려고 합니다.</font><font papago-translate="translated"> 먼저, 플래그를 infix 구문 분석 함수로 전달해 보겠습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    ParseFn infixRule = getRule(parser.previous.type)-&gt;infix;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>parse</em>P<em>recedence</em>()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">    <span class="i">infixRule</span>(<span class="i">canAssign</span>);
</pre><pre class="insert-after" translate="no">  }
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>parsePrecedence</em>(), replace 1 line</div>
<p><font papago-translate="translated">우리는 결국 세터들에게 그것이 필요할 것입니다.</font><font papago-translate="translated"> 그런 다음 함수 유형에 대한 typedef를 수정합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">} Precedence;

</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> enum<em> Precedence</em> 뒤에 추가</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no"><span class="k">typedef</span> <span class="t">void</span> (*<span class="t">ParseFn</span>)(<span class="t">bool</span> <span class="i">canAssign</span>);
</pre><pre class="insert-after" translate="no">
typedef struct {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after enum <em>Precedence</em>, replace 1 line</div>
<p><font papago-translate="translated">그리고 기존의 모든 구문 분석 함수에서 이 매개변수를 받아들이기에는 완전히 지루한 코드가 있습니다.</font><font papago-translate="translated"> 여기:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 함수<em> 이진</em> ()</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">binary</span>(<span class="t">bool</span> <span class="i">canAssign</span>) {
</pre><pre class="insert-after" translate="no">  TokenType operatorType = parser.previous.type;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, function <em>binary</em>(), replace 1 line</div>
<p><font papago-translate="translated">그리고 여기:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 함수<em> 리터럴</em> ()</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">literal</span>(<span class="t">bool</span> <span class="i">canAssign</span>) {
</pre><pre class="insert-after" translate="no">  switch (parser.previous.type) {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, function <em>literal</em>(), replace 1 line</div>
<p><font papago-translate="translated">그리고 여기:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 함수<em> 그룹</em>화 ()</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">grouping</span>(<span class="t">bool</span> <span class="i">canAssign</span>) {
</pre><pre class="insert-after" translate="no">  expression();
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, function <em>grouping</em>(), replace 1 line</div>
<p><font papago-translate="translated">그리고 여기:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 함수<em> 번호</em> ()</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">number</span>(<span class="t">bool</span> <span class="i">canAssign</span>) {
</pre><pre class="insert-after" translate="no">  double value = strtod(parser.previous.start, NULL);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, function <em>number</em>(), replace 1 line</div>
<p><font papago-translate="translated">그리고 여기도:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 함수<em> 문자열</em> ()</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">string</span>(<span class="t">bool</span> <span class="i">canAssign</span>) {
</pre><pre class="insert-after" translate="no">  emitConstant(OBJ_VAL(copyString(parser.previous.start + 1,
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, function <em>string</em>(), replace 1 line</div>
<p><font papago-translate="translated">그리고 마침내:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 함수<em> 단항</em> ()</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">unary</span>(<span class="t">bool</span> <span class="i">canAssign</span>) {
</pre><pre class="insert-after" translate="no">  TokenType operatorType = parser.previous.type;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, function <em>unary</em>(), replace 1 line</div>
<p><font papago-translate="translated">휴! 컴파일할 수 있는 C 프로그램으로 돌아왔습니다.</font><font papago-translate="translated"> 이제 실행하면 됩니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="i">breakfast</span> = <span class="s">"beignets"</span>;
<span class="k">var</span> <span class="i">beverage</span> = <span class="s">"cafe au lait"</span>;
<span class="i">breakfast</span> = <span class="s">"beignets with "</span> + <span class="i">beverage</span>;

<span class="k">print</span> <span class="i">breakfast</span>;
</pre></div>
<p><font papago-translate="translated">실제 언어의 실제 코드처럼 보이기 시작했습니다!</font></p>
<div class="challenges">
<h2><a href="https://youhogeon-meritz.github.io/global-variables.html#challenges" id="challenges"><font papago-translate="translated">과제들</font></a></h2>
<ol>
<li>
<p><font papago-translate="translated">컴파일러는 식별자가 발견될 때마다 글로벌 변수의 이름을 문자열로 상수 테이블에 추가합니다.</font><font papago-translate="translated"> 변수 이름이 상수 테이블의 이전 슬롯에 이미 있는 경우에도 매번 새로운 상수를 생성합니다.</font><font papago-translate="translated"> 같은 변수를 같은 함수로 여러 번 참조하는 경우에는 낭비입니다.</font><font papago-translate="translated"> 이는 단일 청크에 256개의 상수만 허용하기 때문에 상수 테이블을 채우고 슬롯이 부족할 확률을 높입니다.</font></p>
<p><font papago-translate="translated">이것을 최적화하세요.</font><font papago-translate="translated"> 최적화가 런타임과 비교했을 때 컴파일러의 성능에 어떤 영향을 미치나요?</font><font papago-translate="translated"> 이것이 올바른 절충안인가요?</font></p>
</li>
<li>
<p><font papago-translate="translated">해시 테이블을 사용할 때마다 글로벌 변수를 이름별로 찾는 것은 좋은 해시 테이블을 사용하더라도 꽤 느립니다.</font><font papago-translate="translated"> 의미론을 바꾸지 않고 전역 변수를 저장하고 접근하는 더 효율적인 방법을 생각해낼 수 있습니까?</font></p>
</li>
<li>
<p><font papago-translate="translated">REPL에서 실행할 때 사용자는 알 수 없는 전역 변수를 참조하는 함수를 작성할 수 있습니다.</font><font papago-translate="translated"> 그런 다음 다음 줄에서 변수를 선언합니다.</font><font papago-translate="translated"> Lox는 함수가 처음 정의될 때 "알 수 없는 변수" 컴파일 오류를 보고하지 않음으로써 이 문제를 우아하게 처리해야 합니다.</font></p>
<p><font papago-translate="translated">그러나 사용자가 L<em>ox 스크립트</em>를 실행하면 컴파일러는 코드가 실행되기 전에 전체 프로그램의 전체 텍스트에 접근할 수 있습니다.</font><font papago-translate="translated"> 이 프로그램을 고려해 보세요:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">fun</span> <span class="i">useVar</span>() {
  <span class="k">print</span> <span class="i">oops</span>;
}

<span class="k">var</span> <span class="i">ooops</span> = <span class="s">"too many o's!"</span>;
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">여기서 우리는 정적으로 다음과 같이 말할 수 있습니다 </font></font><code translate="no">oops</code><font papago-translate="splitted"><font papago-translate="translated"> <em></em>프로그램 어디에도 해당 글로벌 선언이 없기 때문에 정의되지 않습니다.</font><font papago-translate="translated"> 참고로 </font></font><code translate="no">useVar()</code><font papago-translate="splitted"><font papago-translate="translated"> 는 둘 다 호출되지 않으므로 변수가 정의되지 않더라도 사용된 적이 없기 때문에 런타임 오류가 발생하지 않습니다.</font></font></p>
<p><font papago-translate="translated">우리는 적어도 스크립트에서 실행될 때 이와 같은 실수를 컴파일 오류로 보고할 수 있습니다.</font><font papago-translate="translated"> 우리가 해야 한다고 생각하세요?</font><font papago-translate="translated"> 답변을 정당화하세요.</font><font papago-translate="translated" class=""> 당신이 아는 다른 스크립팅 언어들은 무엇을 하나요?</font></p>
</li>
</ol>
</div>
<footer>
<a class="next" href="https://youhogeon-meritz.github.io/local-variables.html"><font papago-translate="translated"> 다음 장: "지역 변수" → </font></a><font papago-translate="splitted"><font papago-translate="translated"> 로버트 니스트롬이 수작업으로 제작한 -<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE"> © 2015 ~ 2021</a></font></font>
</footer>
</article>
</div>


<div id="papagoTooltip" margin="5" style="display: none;">
        <h1 id="tooltipTitle">원문</h1>
        <p id="tooltipText"></p>
      </div>
      </body></html>