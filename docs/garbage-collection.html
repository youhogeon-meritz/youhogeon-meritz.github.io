<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>Garbage Collection · Crafting Interpreters</title>
<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta content="width=device-width, initial-scale=1" name="viewport">
<link href="https://youhogeon-meritz.github.io/style.css" rel="stylesheet" type="text/css">
<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600" rel="stylesheet" type="text/css">
<link href="https://youhogeon-meritz.github.io/image/favicon.png" rel="icon" type="image/png">


<!-- Google analytics -->

</head>
<body id="top">
<!-- <div class="scrim"></div> -->
<nav class="wide">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<div class="contents">
<h3><a href="https://youhogeon-meritz.github.io/garbage-collection.html#top"><font papago-translate="splitted"><font papago-translate="translated">쓰레기 수거</font></font><small>26</small></a></h3>
<ul>
<li><a href="https://youhogeon-meritz.github.io/garbage-collection.html#reachability"><small>26.1</small><font papago-translate="splitted"><font papago-translate="translated"> 도달 가능성</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/garbage-collection.html#mark-sweep-garbage-collection"><small>26.2</small><font papago-translate="splitted"><font papago-translate="translated"> 마크 스윕 쓰레기 컬렉션</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/garbage-collection.html#marking-the-roots"><small>26.3</small><font papago-translate="splitted"><font papago-translate="translated"> 뿌리 표시하기</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/garbage-collection.html#tracing-object-references"><small>26.4</small><font papago-translate="splitted"><font papago-translate="translated"> 객체 참조 추적</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/garbage-collection.html#sweeping-unused-objects"><small>26.5</small><font papago-translate="splitted"><font papago-translate="translated"> 사용하지 않는 객체 정리하기</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/garbage-collection.html#when-to-collect"><small>26.6</small><font papago-translate="splitted"><font papago-translate="translated"> 수집 시기</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/garbage-collection.html#garbage-collection-bugs"><small>26.7</small><font papago-translate="splitted"><font papago-translate="translated"> 쓰레기 수거 버그</font></font></a></li>
<li class="divider"></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/garbage-collection.html#challenges"><font papago-translate="translated">과제들</font></a></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/garbage-collection.html#design-note"><small><font papago-translate="translated">메모</font></small><font papago-translate="splitted"><font papago-translate="translated">세대 수집가</font></font></a></li>
</ul>
<div class="prev-next">
<a class="left" href="https://youhogeon-meritz.github.io/closures.html" title="폐쇄" papago-attr-id="1"><font papago-translate="translated">← 이전</font></a>
<a href="https://youhogeon-meritz.github.io/a-bytecode-virtual-machine.html" title="바이트코드 가상 머신" papago-attr-id="2"><font papago-translate="translated">↑ 위로</font></a>
<a class="right" href="https://youhogeon-meritz.github.io/classes-and-instances.html" title="클래스 및 인스턴스" papago-attr-id="3"><font papago-translate="translated">다음 →</font></a>
</div> </div>
</nav>
<nav class="narrow">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<a class="prev" href="https://youhogeon-meritz.github.io/closures.html" title="Closures">←</a>
<a class="next" href="https://youhogeon-meritz.github.io/classes-and-instances.html" title="Classes and Instances">→</a>
</nav>
<div class="page">
<div class="nav-wrapper">
<nav class="floating pinned">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<div class="expandable">
<h3><a href="https://youhogeon-meritz.github.io/garbage-collection.html#top"><font papago-translate="splitted"><font papago-translate="translated">쓰레기 수거</font></font><small>26</small></a></h3>
<ul>
<li><a href="https://youhogeon-meritz.github.io/garbage-collection.html#reachability"><small>26.1</small><font papago-translate="splitted"><font papago-translate="translated"> 도달 가능성</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/garbage-collection.html#mark-sweep-garbage-collection"><small>26.2</small><font papago-translate="splitted"><font papago-translate="translated"> 마크 스윕 쓰레기 컬렉션</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/garbage-collection.html#marking-the-roots"><small>26.3</small><font papago-translate="splitted"><font papago-translate="translated"> 뿌리 표시하기</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/garbage-collection.html#tracing-object-references"><small>26.4</small><font papago-translate="splitted"><font papago-translate="translated"> 객체 참조 추적</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/garbage-collection.html#sweeping-unused-objects"><small>26.5</small><font papago-translate="splitted"><font papago-translate="translated"> 사용하지 않는 객체 정리하기</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/garbage-collection.html#when-to-collect"><small>26.6</small><font papago-translate="splitted"><font papago-translate="translated"> 수집 시기</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/garbage-collection.html#garbage-collection-bugs"><small>26.7</small><font papago-translate="splitted"><font papago-translate="translated"> 쓰레기 수거 버그</font></font></a></li>
<li class="divider"></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/garbage-collection.html#challenges">Challenges</a></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/garbage-collection.html#design-note"><small>note</small><font papago-translate="splitted"><font papago-translate="translated">세대 수집가</font></font></a></li>
</ul>
<div class="prev-next">
<a class="left" href="https://youhogeon-meritz.github.io/closures.html" title="Closures">←&nbsp;Previous</a>
<a href="https://youhogeon-meritz.github.io/a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">↑&nbsp;Up</a>
<a class="right" href="https://youhogeon-meritz.github.io/classes-and-instances.html" title="Classes and Instances">Next&nbsp;→</a>
</div> </div>
<a id="expand-nav">≡</a>
</nav>
</div>
<article class="chapter">
<div class="number">26</div>
<h1><font papago-translate="translated">쓰레기 수거</font></h1>
<blockquote>
<p><font papago-translate="splitted"><font papago-translate="translated">저는, 저는,</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 저는, 저는,</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 쓰레기가 되고 싶어요.</font></font><br></p>
<p><cite>The Whip, “Trash”</cite></p>
</blockquote>
<p><font papago-translate="translated">우리는 Lox가 프로그래머들이 해결하고 있는 문제와 무관한 세부 사항에 대해 걱정하지 않도록 해주기 때문에 "고급" 언어라고 말합니다.</font><font papago-translate="translated"> 사용자는 경영진이 되어 기계에게 추상적인 목표를 부여하고 낮은 컴퓨터가 그 목표를 달성하는 방법을 알아내도록 합니다.</font></p>
<p><font papago-translate="translated">동적 메모리 할당은 자동화를 위한 완벽한 후보입니다.</font><font papago-translate="translated"> 작업 프로그램에는 손으로 하는 것이 번거로우면서도 여전히 오류가 발생하기 쉬운 작업 프로그램이 필요합니다.</font><font papago-translate="translated"> 불가피한 실수는 치명적일 수 있으며, 이는 충돌, 메모리 손상 또는 보안 위반으로 이어질 수 있습니다.</font><font papago-translate="translated"> 기계가 인간보다 뛰어난 위험하면서도 지루한 작업입니다.</font></p>
<p><font papago-translate="translated">이것이 바로 Lox가<strong> 관리 언어</strong>인 이유입니다. 이는 언어 구현이 메모리 할당과 사용자의 자유를 대신하여 관리한다는 것을 의미합니다.</font><font papago-translate="translated"> 사용자가 동적 메모리가 필요한 작업을 수행하면 VM이 자동으로 할당합니다.</font><font papago-translate="translated"> 프로그래머는 할당 해제에 대해 전혀 걱정하지 않습니다.</font><font papago-translate="translated"> 이 기계는 프로그램이 스틱을 사용하는 모든 메모리를 필요한 만큼 오래 유지하도록 보장합니다.</font></p>
<p><font papago-translate="translated">Lox는 컴퓨터에 무한한 양의 메모리가 있다는 착각을 불러일으킵니다.</font><font papago-translate="translated"> 사용자는 이 모든 바이트가 어디에서 오는지 한 번도 생각하지 않고 할당하고 할당할 수 있습니다.</font><font papago-translate="translated"> 물론 컴퓨터는 아직 무한한 메모리<em>를 가지고</em> 있지 않습니다.</font><font papago-translate="translated"> 따라서 관리 언어가 이러한 환상을 유지하는 방법은 프로그래머의 등 뒤로 가서 프로그램이 더 이상 필요하지 않은 메모리를 되찾는 것입니다.</font><font papago-translate="translated"> 이 작업을 수행하는 구성 요소를<strong> 쓰레기<span name="recycle"> 수거</span></strong>기라고 합니다.</font></p>
<aside name="recycle" style="top: 928px;">
<p><font papago-translate="translated">재활용이 이에 대한 더 나은 비유가 될 것입니다.</font><font papago-translate="translated"> GC는 메모리를<em> 버리는</em> 것이 아니라 새로운 데이터에 재사용하기 위해 메모리를 회수합니다.</font><font papago-translate="translated"> 하지만 관리 언어는 지구의 날보다 오래되었기 때문에 발명가들은 자신들이 알고 있는 비유를 사용했습니다.</font></p><img alt="A recycle bin full of bits." class="above" src="https://youhogeon-meritz.github.io/image/garbage-collection/recycle.png">
</aside>
<h2><a href="https://youhogeon-meritz.github.io/garbage-collection.html#reachability" id="reachability"><small><font papago-translate="translated">26 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">도달 가능성</font></font></a></h2>
<p><font papago-translate="translated">이것은 놀랍게도 어려운 질문을 제기합니다: VM이 필요<em>하지</em> 않은 메모리를 어떻게 알려줄 수 있을까요?</font><font papago-translate="translated"> 메모리는 미래에 읽을 때만 필요하지만, 타임머신이 없는 한 구현체는 프로그램이 실행<em>할</em> 코드와<em></em> 사용할 데이터를 어떻게 알 수 있을까요?</font><font papago-translate="translated"> 스포일러 경고: VM은 미래로 이동할 수 없습니다.</font><font papago-translate="translated"> 대신, 언어는<span name="conservative"> 보수</span>적인 근사치를 제시합니다: 기억의 일부가 미래에 읽을<em> 수</em> 있다면 여전히 사용 중인 것으로 간주합니다.</font></p>
<aside name="conservative" style="top: 1168px;">
<p><font papago-translate="translated">저는 일반적인 의미에서 "보수적"이라는 표현을 사용하고 있습니다.</font><font papago-translate="translated"> "보수적인 쓰레기 수집가"라는 것은 더 구체적인 것을 의미합니다.</font><font papago-translate="translated"> 모든 쓰레기 수집기는 메모리에 접근할 수 있는 경우 메모리를 유지한다는 점에서 "보수적"입니다. 대신, 어떤 데이터<em></em>에 더 정확하게 접근<em>할지</em> 알 수 있는 매직 8볼을 가지고 있습니다.</font></p>
<p><font papago-translate="translated"><strong>보수</strong>적인 G<strong>C</strong>는 메모리의 값이 주소처럼 보일 경우 포인터로 간주하는 특별한 종류의 수집기입니다.</font><font papago-translate="translated"> 이것은 메모리에서 어떤 단어가 포인터인지 정확히 알고 숫자나<span class="em"></span><span class="em"></span> 문자열과 같은 다른 종류의 값을 저장하는<strong> 정확</strong>한 G<strong>C</strong>와는 대조적입니다.</font></p>
</aside>
<p><font papago-translate="translated"><em>그건 너무</em> 보수적으로 들립니다.</font><font papago-translate="translated"> 잠재적으로 메모리를 조금이라도 읽을 수<em> 없을까</em>요?</font><font papago-translate="translated"> 사실, 아니요, 적어도 Lox처럼 기억에 안전한 언어는 아닙니다.</font><font papago-translate="translated"> 다음은 예시입니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="i">a</span> = <span class="s">"first value"</span>;
<span class="i">a</span> = <span class="s">"updated"</span>;
<span class="c">// GC here.</span>
<span class="k">print</span> <span class="i">a</span>;
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">두 번째 줄에서 과제가 완료된 후 GC를 실행한다고 가정해 보겠습니다.</font><font papago-translate="translated"> 문자열 "첫 번째 값"은 여전히 메모리에 저장되어 있지만, 사용자의 프로그램이 이 값에 도달할 방법이 없습니다.</font><font papago-translate="translated"> 한번만 </font></font><code translate="no">a</code><font papago-translate="splitted"><font papago-translate="translated"> 프로그램이 다시 할당되었지만 해당 문자열에 대한 참조가 손실되었습니다.</font><font papago-translate="translated"> 안전하게 해제할 수 있습니다.</font><font papago-translate="translated"> 사용자 프로그램이 이를 참조할 수 있는 방법이 있다면 값<strong>에 도달</strong>할 수 있습니다.</font><font papago-translate="translated"> 그렇지 않으면 여기서 "첫 번째 값"이라는 문자열처럼<strong> 도달할 수 없습니다</strong>.</font></font></p>
<p><font papago-translate="translated">많은 값들이 VM에 의해 직접 접근될 수 있습니다.</font><font papago-translate="translated"> 살펴보세요:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="i">global</span> = <span class="s">"string"</span>;
{
  <span class="k">var</span> <span class="i">local</span> = <span class="s">"another"</span>;
  <span class="k">print</span> <span class="i">global</span> + <span class="i">local</span>;
}
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">두 문자열이 연결된 직후에 프로그램을 일시 중지합니다 </font></font><code translate="no">print</code><font papago-translate="splitted"><font papago-translate="translated"> 문이 실행되었습니다.</font><font papago-translate="translated"> VM이 도달할 수 있습니다 </font></font><code translate="no">"string"</code><font papago-translate="splitted"><font papago-translate="translated"> 글로벌 변수 테이블을 살펴보고 항목을 찾아봄으로써 </font></font><code translate="no">global</code><font papago-translate="splitted"><font papago-translate="translated">. 찾을 수 있습니다 </font></font><code translate="no">"another"</code><font papago-translate="splitted"><font papago-translate="translated"> 값 스택을 걷고 로컬 변수의 슬롯을 누름으로써 </font></font><code translate="no">local</code><font papago-translate="splitted"><font papago-translate="translated">. 연결된 문자열도 찾을 수 있습니다 </font></font><code translate="no">"stringanother"</code><font papago-translate="splitted"><font papago-translate="translated"> 프로그램을 일시 중지한 시점에서 해당 임시 값도 VM의 스택에 저장되어 있기 때문입니다.</font></font></p>
<p><font papago-translate="translated">이 모든 값을<strong> 루트</strong>라고 합니다.</font><font papago-translate="translated"> 루트는 VM이 다른 객체의 참조를 거치지 않고 직접 도달할 수 있는 모든 객체입니다.</font><font papago-translate="translated"> 대부분의 루트는 전역 변수이거나 스택 위에 있지만, 앞으로 살펴본 바와 같이 VM이 객체에 대한 참조를 저장하는 다른 몇 가지 장소가 있습니다.</font></p>
<p><font papago-translate="translated">다른 값들은 다른 값 안의 참조를 통해 찾을 수 있습니다.</font><font papago-translate="translated"> 수업 인스턴스<span name="class">에 대한 필드가</span> 가장 명확한 경우이지만, 아직 그런<span name="class"> 경우</span>는 없습니다<span name="class">.</span></font><font papago-translate="translated"> 그것들이 없더라도, 우리의 VM은 여전히 간접적인 참조를 가지고 있습니다.</font><font papago-translate="translated"> 고려:</font></p>
<aside name="class" style="top: 2068px;">
<p><font papago-translate="translated"><a href="https://youhogeon-meritz.github.io/classes-and-instances.html">그래도 곧</a> 도착할 거예요!</font></p>
</aside>
<div class="codehilite"><pre translate="no"><span class="k">fun</span> <span class="i">makeClosure</span>() {
  <span class="k">var</span> <span class="i">a</span> = <span class="s">"data"</span>;

  <span class="k">fun</span> <span class="i">f</span>() { <span class="k">print</span> <span class="i">a</span>; }
  <span class="k">return</span> <span class="i">f</span>;
}

{
  <span class="k">var</span> <span class="i">closure</span> = <span class="i">makeClosure</span>();
  <span class="c">// GC here.</span>
  <span class="i">closure</span>();
}
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">표시된 선에서 프로그램을 일시 중지하고 쓰레기 수거기를 실행한다고 가정해 보겠습니다.</font><font papago-translate="translated"> 수집기가 완료되고 프로그램이 재개되면 종료를 호출하여 인쇄됩니다 </font></font><code translate="no">"data"</code><font papago-translate="splitted"><font papago-translate="translated">. 따라서 수집가는 해당 문자열을 해제<em>할</em> 필요<em>가</em> 없습니다.</font><font papago-translate="translated"> 하지만 프로그램을 일시 중지할 때 스택은 다음과 같습니다:</font></font></p><img alt="The stack, containing only the script and closure." src="https://youhogeon-meritz.github.io/image/garbage-collection/stack.png">
<p><font papago-translate="splitted"><font papago-translate="translated">그 </font></font><code translate="no">"data"</code><font papago-translate="splitted"><font papago-translate="translated"> 문자열은 어디에도 없습니다.</font><font papago-translate="translated"> 이미 스택에서 들어 올려져 폐쇄가 사용하는 닫힌 업값으로 이동했습니다.</font><font papago-translate="translated"> 폐쇄 자체가 스택에 있습니다.</font><font papago-translate="translated"> 하지만 문자열에 도달하려면 클로저와 그 업밸류 배열을 추적해야 합니다.</font><font papago-translate="translated"> 사용자의 프로그램이 그렇게 할 수 있기 때문에, 이러한 모든 간접적으로 접근 가능한 객체들도<em></em> 도달 가능한 것으로 간주됩니다.</font></font></p><img alt="All of the referenced objects from the closure, and the path to the 'data' string from the stack." class="wide" src="https://youhogeon-meritz.github.io/image/garbage-collection/reachable.png">
<p><font papago-translate="translated">이것은 도달 가능성에 대한 귀납적 정의를 제공합니다:</font></p>
<ul>
<li>
<p><font papago-translate="translated">모든 뿌리에 도달할 수 있습니다.</font></p>
</li>
<li>
<p><font papago-translate="translated">도달 가능한 물체에서 언급된 모든 물체는 그 자체로 도달할 수 있습니다.</font></p>
</li>
</ul>
<p><font papago-translate="translated">이것들은 여전히 "살아있고" 기억에 남아 있어야 할 가치들입니다.</font><font papago-translate="translated"> 이 정의를 충족하지 못하는 모든 가치는 수집가<em></em>가 얻을 수 있는 공정한 게임입니다.</font><font papago-translate="translated"> 그 재귀적 규칙 쌍은 불필요한 메모리를 확보하는 데 사용할 수 있는 재귀적 알고리즘을 암시합니다:</font></p>
<ol>
<li>
<p><font papago-translate="translated">루트부터 객체 참조를 통해 도달 가능한 전체 객체 집합을 찾습니다.</font></p>
</li>
<li>
<p><font papago-translate="translated">해당 집합<em>에 포함되지 않은</em> 모든 객체를 해방합니다.</font></p>
</li>
</ol>
<p><font papago-translate="translated">오늘날 많은<span name="handbook"> 다양한</span> 쓰레기 수거 알고리즘이 사용되고 있지만, 이들은 대체로 동일한 구조를 따릅니다.</font><font papago-translate="translated"> 일부는 단계를 중단하거나 혼합할 수 있지만, 두 가지 기본 연산이 있습니다.</font><font papago-translate="translated"> 그들은 대부분 각 단계를 수행<em>하는 방식</em>에서 다릅니다.</font></p>
<aside name="handbook" style="top: 3418.97px;">
<p><font papago-translate="translated">다른 GC 알고리즘을 탐구하고 싶다면, The<a href="http://gchandbook.org/"><em> Garbage Collection Handbook</em></a> (Jones 등)이 표준 참고 자료입니다.</font><font papago-translate="translated"> 깊고 좁은 주제의 큰 책이라면 꽤 재미있게 읽을 수 있습니다.</font><font papago-translate="translated"> 아니면 재미에 대한 이상한 생각이 들 수도 있습니다.</font></p>
</aside>
<h2><a href="https://youhogeon-meritz.github.io/garbage-collection.html#mark-sweep-garbage-collection" id="mark-sweep-garbage-collection"><small><font papago-translate="translated">26 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">마크 스윕 쓰레기 컬렉션</font></font></a></h2>
<p><font papago-translate="translated">첫 번째 관리 언어는 포트란 바로 다음으로 발명된 두 번째 "고급" 언어인 리스프였습니다.</font><font papago-translate="translated"> 존 맥카시는 수동 메모리 관리나 참조 카운팅을 고려했지만<span name="procrastination">, 결국</span> 가비지 컬렉션에 합의하고 프로그램의 메모리가 부족하면 다시 돌아가서 재사용할 수 있는 사용되지 않는<span class="em"></span> 저장소를 찾게 되었습니다.</font></p>
<aside name="procrastination" style="top: 3682.97px;">
<p><font papago-translate="translated">존 맥카시의 "리스프의 역사"에서 그는 다음과 같이 언급합니다: "쓰레기 수거를 결정한 후에는 장난감 예시만 진행되었기 때문에 실제 시행이 연기될 수 있습니다."</font><font papago-translate="translated"> GC를 클론에 추가하는 것을 미루기로 한 우리의 선택은 거인들의 발자취를 따릅니다.</font></p>
</aside>
<p><font papago-translate="translated">그는<strong> 마크 앤 스위프</strong> 또는 그냥<strong> 마크 스위프</strong>라고 불리는 최초의 가장 간단한 쓰레기 수거 알고리즘을 설계했습니다.</font><font papago-translate="translated"> 그 설명은 리스프에 관한 초기 논문의 세 개의 짧은 단락에 들어맞습니다.</font><font papago-translate="translated"> 나이와 단순함에도 불구하고, 동일한 기본 알고리즘이 많은 현대 메모리 관리자들의 기초가 됩니다.</font><font papago-translate="translated"> CS의 일부 모서리는 시대를 초월하는 것처럼 보입니다.</font></p>
<p><font papago-translate="translated">이름에서 알 수 있듯이 마크 스위프는 두 단계로 작동합니다:</font></p>
<ul>
<li>
<p><font papago-translate="translated"><strong>표시:</strong></font><font papago-translate="translated"> 우리는 뿌리부터 시작하여 그 뿌리가 가리키는 모든 대상을 가로지르거나<span name="trace"><em> 추적합니다</em></span>.</font><font papago-translate="translated"> 이것은 도달 가능한 모든 객체의 고전적인 그래프 횡단입니다.</font><font papago-translate="translated"> 우리가 물체를 방문할 때마다<em> 어떤</em> 식으로든<em> 표시를</em> 합니다. (구현 방식은 표시를 기록하는 방식에 따라 다릅니다.)</font></p>
</li>
<li>
<p><font papago-translate="translated"><strong>쓸어내리기:</strong></font><font papago-translate="translated"> 마크 단계가 완료되면 힙에 있는 모든 도달 가능한 객체가 표시됩니다.</font><font papago-translate="translated"> 즉, 표시되지 않은 물체는 손이 닿지 않고 회수할 수 있는 상태입니다.</font><font papago-translate="translated"> 우리는 표시되지 않은 모든 물체를 살펴보고 각각을 해방시킵니다.</font></p>
</li>
</ul>
<p><font papago-translate="translated">다음과 같이 보입니다:</font></p><img alt="Starting from a graph of objects, first the reachable ones are marked, the remaining are swept, and then only the reachable remain." class="wide" src="https://youhogeon-meritz.github.io/image/garbage-collection/mark-sweep.png">
<aside name="trace" style="top: 3970.97px;">
<p><font papago-translate="translated"><strong>추적 가비지 컬렉터</strong>는 객체 참조 그래프를 통해 추적하는 모든 알고리즘입니다.</font><font papago-translate="translated"> 이는 도달 가능한 객체를 추적하는 다른 전략을 가진 참조 카운팅과는 대조적입니다.</font></p>
</aside>
<p><font papago-translate="translated">그것이 우리가 구현할 것입니다.</font><font papago-translate="translated"> 바이트를 회수할 때가 되었다고 결정할 때마다 모든 것을 추적하여 도달 가능한 모든 객체를 표시하고, 표시되지 않은 항목을 해제한 다음 사용자의 프로그램을 재개합니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/garbage-collection.html#collecting-garbage" id="collecting-garbage"><small><font papago-translate="translated">26 . 2 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">쓰레기 수집</font></font></a></h3>
<p><font papago-translate="translated">이 전체 장에서는 이 한<span name="one"> 가지 기능</span>을 구현하는 것에 대해 다룹니다:</font></p>
<aside name="one" style="top: 4744.97px;">
<p><font papago-translate="translated">물론 도우미 기능도 추가하게 될 것입니다.</font></p>
</aside>
<div class="codehilite"><pre class="insert-before" translate="no">void* reallocate(void* pointer, size_t oldSize, size_t newSize);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">기억.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> ()<em>를 재할당</em>한 후 추가</font></font></div>
<pre class="insert" translate="no"><span class="t">void</span> <span class="i">collectGarbage</span>();
</pre><pre class="insert-after" translate="no">void freeObjects();
</pre></div>
<div class="source-file-narrow"><em>memory.h</em>, add after <em>reallocate</em>()</div>
<p><font papago-translate="translated">우리는 이 빈 셸을 시작으로 완전한 구현을 위해 노력할 것입니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>free</em>O<em>bject</em>() 다음에 추가</font></font></div>
<pre translate="no"><span class="t">void</span> <span class="i">collectGarbage</span>() {
}
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, add after <em>freeObject</em>()</div>
<p><font papago-translate="translated">가장 먼저 물어볼 수 있는 질문은 이 함수는 언제 호출되나요?</font><font papago-translate="translated"> 알고 보니 이 질문은 나중에 장에서 다룰 미묘한 질문입니다.</font><font papago-translate="translated"> 지금은 문제를 피하고 그 과정에서 편리한 진단 도구를 만들겠습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#define DEBUG_TRACE_EXECUTION
</pre><div class="source-file"><em><font papago-translate="translated">일반적인.h</font></em></div>
<pre class="insert" translate="no">
<span class="a">#define DEBUG_STRESS_GC</span>
</pre><pre class="insert-after" translate="no">
#define UINT8_COUNT (UINT8_MAX + 1)
</pre></div>
<div class="source-file-narrow"><em>common.h</em></div>
<p><font papago-translate="translated">쓰레기 수거기를 위한 선택적인 "스트레스 테스트" 모드를 추가할 예정입니다.</font><font papago-translate="translated"> 이 플래그가 정의되면 GC는 가능한 한 자주 실행됩니다.</font><font papago-translate="translated"> 이것은 분명히 성능 면에서 끔찍한 일입니다.</font><font papago-translate="translated"> 하지만 적절한 순간에 GC가 트리거될 때만 발생하는 메모리 관리 버그를 제거하는 데 매우 좋습니다.</font><font papago-translate="translated"> <em>매</em> 순간 GC가 발생하면, 그 버그들을 발견할 가능성이 높습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">void* reallocate(void* pointer, size_t oldSize, size_t newSize) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> ()<em> 재할당</em>에서</font></font></div>
<pre class="insert" translate="no">  <span class="k">if</span> (<span class="i">newSize</span> &gt; <span class="i">oldSize</span>) {
<span class="a">#ifdef DEBUG_STRESS_GC</span>
    <span class="i">collectGarbage</span>();
<span class="a">#endif</span>
  }

</pre><pre class="insert-after" translate="no">  if (newSize == 0) {
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>reallocate</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">우리가 전화할 때마다 </font></font><code translate="no">reallocate()</code><font papago-translate="splitted"><font papago-translate="translated"> 더 많은 메모리를 확보하기 위해 컬렉션을 강제 실행합니다.</font><font papago-translate="translated"> if 체크는 다음과 같습니다 </font></font><code translate="no">reallocate()</code><font papago-translate="splitted"><font papago-translate="translated"> 할당을 해제하거나 축소하기 위해 호출되기도 합니다.</font><font papago-translate="translated"> 우리는 그것을 위해 GC를 트리거하고 싶지 않습니다 - 특히 GC 자체<span class="em"></span>가 호출하기 때문입니다 </font></font><code translate="no">reallocate()</code><font papago-translate="splitted"><font papago-translate="translated"> 기억을 해방시키기 위해.</font></font></p>
<p><font papago-translate="translated"><span name="demand">할당</span> 직전에 수집하는 것은 GC를 VM에 연결하는 고전적인 방법입니다.</font><font papago-translate="translated"> 이미 메모리 관리자를 호출하고 있으니 코드를 쉽게 연결할 수 있는 곳입니다.</font><font papago-translate="translated"> 또한 할당은 재사용할 수 있도록 여유 메모리가 정말<em> 필요</em>한 유일한 시기입니다.</font><font papago-translate="translated"> 할당을 사용하여 GC를 트리거하지 않는 경우, 메모리를 루프하고 할당할 수 있는 코드의 모든 가능한 위치에<em></em> 수집기를 트리거할 수 있는 방법이 있는지 확인해야 합니다.</font><font papago-translate="translated"> 그렇지 않으면 VM은 더 많은 메모리가 필요하지만 전혀 수집하지 않는 굶주린 상태가 될 수 있습니다.</font></p>
<aside name="demand" style="top: 5704.97px;">
<p><font papago-translate="translated">더 정교한 수집기는 별도의 스레드에서 실행되거나 프로그램 실행 중에 주기적으로 인터리빙될 수 있습니다. 종종 함수 호출 경계에서 실행되거나 후진 점프<span class="em"></span>가 발생할 때 그렇습니다.</font></p>
</aside>
<h3><a href="https://youhogeon-meritz.github.io/garbage-collection.html#debug-logging" id="debug-logging"><small><font papago-translate="translated">26 . 2 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">디버그 로깅</font></font></a></h3>
<p><font papago-translate="translated">진단에 대해 이야기하는 동안, 좀 더 자세히 살펴보겠습니다.</font><font papago-translate="translated"> 제가 쓰레기 수거기에서 발견한 진짜 문제는 불투명하다는 것입니다.</font><font papago-translate="translated"> 지금<em></em>까지 GC 없이도 많은 Lox 프로그램을 정상적으로 운영해 왔습니다.</font><font papago-translate="translated"> 하나를 추가하면 유용한 기능을 하고 있는지 어떻게 알 수 있을까요?</font><font papago-translate="translated"> 우리가 수많은 기억을 관통하는 프로그램을 작성해야만 알 수 있을까요?</font><font papago-translate="translated"> 어떻게 디버깅하나요?</font></p>
<p><font papago-translate="translated">GC의 내부 작업에 빛을 비추는 쉬운 방법은 약간의 로깅을 사용하는 것입니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#define DEBUG_STRESS_GC
</pre><div class="source-file"><em><font papago-translate="translated">일반적인.h</font></em></div>
<pre class="insert" translate="no"><span class="a">#define DEBUG_LOG_GC</span>
</pre><pre class="insert-after" translate="no">
#define UINT8_COUNT (UINT8_MAX + 1)
</pre></div>
<div class="source-file-narrow"><em>common.h</em></div>
<p><font papago-translate="translated">이 기능이 활성화되면 clox는 동적 메모리로 작업할 때 콘솔에 정보를 출력합니다.</font></p>
<p><font papago-translate="translated">몇 가지 포함 사항이 필요합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#include "vm.h"
</pre><div class="source-file"><em><font papago-translate="translated">메모리.c</font></em></div>
<pre class="insert" translate="no">
<span class="a">#ifdef DEBUG_LOG_GC</span>
<span class="a">#include &lt;stdio.h&gt;</span>
<span class="a">#include "debug.h"</span>
<span class="a">#endif</span>
</pre><pre class="insert-after" translate="no">
void* reallocate(void* pointer, size_t oldSize, size_t newSize) {
</pre></div>
<div class="source-file-narrow"><em>memory.c</em></div>
<p><font papago-translate="translated">아직 수집가는 없지만 지금 벌목 작업을 시작할 수 있습니다.</font><font papago-translate="translated"> 컬렉션 실행이 언제 시작되는지 알고 싶습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">void collectGarbage() {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>수집</em> 쓰레기()에서</font></font></div>
<pre class="insert" translate="no"><span class="a">#ifdef DEBUG_LOG_GC</span>
  <span class="i">printf</span>(<span class="s">"-- gc begin</span><span class="e">\n</span><span class="s">"</span>);
<span class="a">#endif</span>
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>collectGarbage</em>()</div>
<p><font papago-translate="translated">결국 우리는 컬렉션 중에 몇 가지 다른 작업들을 기록할 것입니다. 그래서 쇼가 언제 끝나는지도 알고 싶을 것입니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  printf("-- gc begin\n");
#endif
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>수집</em> 쓰레기()에서</font></font></div>
<pre class="insert" translate="no">
<span class="a">#ifdef DEBUG_LOG_GC</span>
  <span class="i">printf</span>(<span class="s">"-- gc end</span><span class="e">\n</span><span class="s">"</span>);
<span class="a">#endif</span>
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>collectGarbage</em>()</div>
<p><font papago-translate="translated">아직 수집기에 대한 코드는 없지만 할당 및 해제 기능이 있으므로 지금 바로 사용할 수 있습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  vm.objects = object;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>allocate</em>O<em>bject</em>()</font></font></div>
<pre class="insert" translate="no">
<span class="a">#ifdef DEBUG_LOG_GC</span>
  <span class="i">printf</span>(<span class="s">"%p allocate %zu for %d</span><span class="e">\n</span><span class="s">"</span>, (<span class="t">void</span>*)<span class="i">object</span>, <span class="i">size</span>, <span class="i">type</span>);
<span class="a">#endif</span>

</pre><pre class="insert-after" translate="no">  return object;
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>allocateObject</em>()</div>
<p><font papago-translate="translated">그리고 물체의 수명이 끝날 때:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">static void freeObject(Obj* object) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>free</em>O<em>bject</em>()에서</font></font></div>
<pre class="insert" translate="no"><span class="a">#ifdef DEBUG_LOG_GC</span>
  <span class="i">printf</span>(<span class="s">"%p free type %d</span><span class="e">\n</span><span class="s">"</span>, (<span class="t">void</span>*)<span class="i">object</span>, <span class="i">object</span>-&gt;<span class="i">type</span>);
<span class="a">#endif</span>

</pre><pre class="insert-after" translate="no">  switch (object-&gt;type) {
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>freeObject</em>()</div>
<p><font papago-translate="translated">이 두 가지 깃발을 통해 나머지 장을 진행하면서 진전을 이루고 있음을 알 수 있을 것입니다.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/garbage-collection.html#marking-the-roots" id="marking-the-roots"><small><font papago-translate="translated">26 . 3</font></small><font papago-translate="splitted"><font papago-translate="translated">뿌리 표시하기</font></font></a></h2>
<p><font papago-translate="translated">물체들이 밤하늘의 별처럼 더미 위에 흩어져 있습니다.</font><font papago-translate="translated"> 한 객체에서 다른 객체로의 참조는 연결을 형성하며, 이러한 별자리는 마크 단계가 통과하는 그래프입니다.</font><font papago-translate="translated"> 표시는 뿌리에서 시작됩니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#ifdef DEBUG_LOG_GC
  printf("-- gc begin\n");
#endif
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>수집</em> 쓰레기()에서</font></font></div>
<pre class="insert" translate="no">
  <span class="i">markRoots</span>();
</pre><pre class="insert-after" translate="no">
#ifdef DEBUG_LOG_GC
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>collectGarbage</em>()</div>
<p><font papago-translate="translated">대부분의 루트는 VM의 스택 바로 위에 위치한 로컬 변수나 임시 변수이므로, 우리는 그것을 걷는 것부터 시작합니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>free</em>O<em>bject</em>() 다음에 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">markRoots</span>() {
  <span class="k">for</span> (<span class="t">Value</span>* <span class="i">slot</span> = <span class="i">vm</span>.<span class="i">stack</span>; <span class="i">slot</span> &lt; <span class="i">vm</span>.<span class="i">stackTop</span>; <span class="i">slot</span>++) {
    <span class="i">markValue</span>(*<span class="i">slot</span>);
  }
}
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, add after <em>freeObject</em>()</div>
<p><font papago-translate="translated">Lox 값을 표시하려면 이 새로운 함수를 사용합니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">void* reallocate(void* pointer, size_t oldSize, size_t newSize);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">기억.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> ()<em>를 재할당</em>한 후 추가</font></font></div>
<pre class="insert" translate="no"><span class="t">void</span> <span class="i">markValue</span>(<span class="t">Value</span> <span class="i">value</span>);
</pre><pre class="insert-after" translate="no">void collectGarbage();
</pre></div>
<div class="source-file-narrow"><em>memory.h</em>, add after <em>reallocate</em>()</div>
<p><font papago-translate="translated">구현은 여기에 있습니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> ()<em>를 재할당</em>한 후 추가</font></font></div>
<pre translate="no"><span class="t">void</span> <span class="i">markValue</span>(<span class="t">Value</span> <span class="i">value</span>) {
  <span class="k">if</span> (<span class="a">IS_OBJ</span>(<span class="i">value</span>)) <span class="i">markObject</span>(<span class="a">AS_OBJ</span>(<span class="i">value</span>));
}
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, add after <em>reallocate</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">일부 Lox 값—숫자, 부울,<span class="em"></span> 그리고 </font></font><code translate="no">nil</code><font papago-translate="splitted"><font papago-translate="translated">-값에 직접 인라인으로 저장되며 힙 할당이 필요하지<span class="em"> 않습니다.</span></font><font papago-translate="translated"> 쓰레기 수집가는 그것들에 대해 전혀 걱정할 필요가 없으므로, 우리가 가장 먼저 하는 일은 그 값이 실제 힙 객체인지 확인하는 것입니다.</font><font papago-translate="translated"> 그렇다면 실제 작업은 이 함수에서 이루어집니다:</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">void* reallocate(void* pointer, size_t oldSize, size_t newSize);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">기억.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> ()<em>를 재할당</em>한 후 추가</font></font></div>
<pre class="insert" translate="no"><span class="t">void</span> <span class="i">markObject</span>(<span class="t">Obj</span>* <span class="i">object</span>);
</pre><pre class="insert-after" translate="no">void markValue(Value value);
</pre></div>
<div class="source-file-narrow"><em>memory.h</em>, add after <em>reallocate</em>()</div>
<p><font papago-translate="translated">여기서 정의된 내용:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> ()<em>를 재할당</em>한 후 추가</font></font></div>
<pre translate="no"><span class="t">void</span> <span class="i">markObject</span>(<span class="t">Obj</span>* <span class="i">object</span>) {
  <span class="k">if</span> (<span class="i">object</span> == <span class="a">NULL</span>) <span class="k">return</span>;
  <span class="i">object</span>-&gt;<span class="i">isMarked</span> = <span class="k">true</span>;
}
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, add after <em>reallocate</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">그 </font></font><code translate="no">NULL</code><font papago-translate="splitted"><font papago-translate="translated"> 다음에서 호출할 때 검사가 필요하지 않습니다 </font></font><code translate="no">markValue()</code><font papago-translate="splitted"><font papago-translate="translated">. Obj 유형의 Lox 값에는 항상 유효한 포인터가 있습니다.</font><font papago-translate="translated"> 하지만 나중에 다른 코드에서 직접 이 함수를 호출할 것이며, 그 중 일부에서는 가리키는 객체가 선택 사항입니다.</font></font></p>
<p><font papago-translate="translated">유효한 객체가 있다고 가정하고 플래그를 설정하여 표시합니다.</font><font papago-translate="translated"> 그 새로운 필드는 모든 객체가 공유하는 Obj 헤더 구조에 존재합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  ObjType type;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em></em>구조 Obj에서</font></font></div>
<pre class="insert" translate="no">  <span class="t">bool</span> <span class="i">isMarked</span>;
</pre><pre class="insert-after" translate="no">  struct Obj* next;
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, in struct <em>Obj</em></div>
<p><font papago-translate="translated">모든 새로운 물체는 아직 도달 가능한지 여부를 결정하지 않았기 때문에 표시되지 않은 채로 생명을 시작합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  object-&gt;type = type;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>allocate</em>O<em>bject</em>()</font></font></div>
<pre class="insert" translate="no">  <span class="i">object</span>-&gt;<span class="i">isMarked</span> = <span class="k">false</span>;
</pre><pre class="insert-after" translate="no">
  object-&gt;next = vm.objects;
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>allocateObject</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">더 나아가기 전에 다음에 로깅을 추가해 보겠습니다 </font></font><code translate="no">markObject()</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">void markObject(Obj* object) {
  if (object == NULL) return;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>mark</em>O<em>bject</em>()에서</font></font></div>
<pre class="insert" translate="no"><span class="a">#ifdef DEBUG_LOG_GC</span>
  <span class="i">printf</span>(<span class="s">"%p mark "</span>, (<span class="t">void</span>*)<span class="i">object</span>);
  <span class="i">printValue</span>(<span class="a">OBJ_VAL</span>(<span class="i">object</span>));
  <span class="i">printf</span>(<span class="s">"</span><span class="e">\n</span><span class="s">"</span>);
<span class="a">#endif</span>

</pre><pre class="insert-after" translate="no">  object-&gt;isMarked = true;
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>markObject</em>()</div>
<p><font papago-translate="translated">이렇게 하면 마크 단계가 무엇을 하고 있는지 볼 수 있습니다.</font><font papago-translate="translated"> 스택을 표시하는 것은 지역 변수와 임시 변수를 처리합니다.</font><font papago-translate="translated"> 다른 주요 근원은 전역 변수입니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    markValue(*slot);
  }
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>마크루츠</em>()에서</font></font></div>
<pre class="insert" translate="no">
  <span class="i">markTable</span>(&amp;<span class="i">vm</span>.<span class="i">globals</span>);
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>markRoots</em>()</div>
<p><font papago-translate="translated">이들은 VM이 소유한 해시 테이블에 있으므로 테이블의 모든 객체를 표시하는 또 다른 도우미 함수를 선언하겠습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">ObjString* tableFindString(Table* table, const char* chars,
                           int length, uint32_t hash);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">테이블.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>테이블</em> 뒤에 추가F<em>indString</em>()</font></font></div>
<pre class="insert" translate="no"><span class="t">void</span> <span class="i">markTable</span>(<span class="t">Table</span>* <span class="i">table</span>);
</pre><pre class="insert-after" translate="no">
#endif
</pre></div>
<div class="source-file-narrow"><em>table.h</em>, add after <em>tableFindString</em>()</div>
<p><font papago-translate="translated">여기 "테이블" 모듈에서 이를 구현합니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">테이블.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>테이블</em> 뒤에 추가F<em>indString</em>()</font></font></div>
<pre translate="no"><span class="t">void</span> <span class="i">markTable</span>(<span class="t">Table</span>* <span class="i">table</span>) {
  <span class="k">for</span> (<span class="t">int</span> <span class="i">i</span> = <span class="n">0</span>; <span class="i">i</span> &lt; <span class="i">table</span>-&gt;<span class="i">capacity</span>; <span class="i">i</span>++) {
    <span class="t">Entry</span>* <span class="i">entry</span> = &amp;<span class="i">table</span>-&gt;<span class="i">entries</span>[<span class="i">i</span>];
    <span class="i">markObject</span>((<span class="t">Obj</span>*)<span class="i">entry</span>-&gt;<span class="i">key</span>);
    <span class="i">markValue</span>(<span class="i">entry</span>-&gt;<span class="i">value</span>);
  }
}
</pre></div>
<div class="source-file-narrow"><em>table.c</em>, add after <em>tableFindString</em>()</div>
<p><font papago-translate="translated">꽤 간단합니다.</font><font papago-translate="translated"> 우리는 입장 배열을 걷습니다.</font><font papago-translate="translated"> 각각의 값을 표시합니다.</font><font papago-translate="translated"> 각 항목의 키 문자열도 GC가 관리하기 때문에 표시합니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/garbage-collection.html#less-obvious-roots" id="less-obvious-roots"><small><font papago-translate="translated">26 . 3 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">덜 명확한 근</font></font></a></h3>
<p><font papago-translate="translated">그것들은 우리가 일반적으로 생각하는 뿌리, 즉 사용자 프로그램이<span class="em"></span> 볼 수 있는 변수에 저장되어 있기 때문에 분명히 도달할 수 있는 값들을 다룹니다.</font><font papago-translate="translated"> 하지만 VM에는 몇 가지 숨겨진 구멍이 있어 직접 접근하는 값에 대한 참조를 제거합니다.</font></p>
<p><font papago-translate="translated">대부분의 함수 호출 상태는 값 스택에 존재하지만, VM은 별도의 호출 프레임 스택을 유지합니다.</font><font papago-translate="translated"> 각 콜프레임에는 호출 중인 클로저에 대한 포인터가 포함되어 있습니다.</font><font papago-translate="translated"> VM은 이러한 포인터를 사용하여 상수와 업값에 접근하므로 이러한 폐쇄도 유지해야 합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  }
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>마크루츠</em>()에서</font></font></div>
<pre class="insert" translate="no">
  <span class="k">for</span> (<span class="t">int</span> <span class="i">i</span> = <span class="n">0</span>; <span class="i">i</span> &lt; <span class="i">vm</span>.<span class="i">frameCount</span>; <span class="i">i</span>++) {
    <span class="i">markObject</span>((<span class="t">Obj</span>*)<span class="i">vm</span>.<span class="i">frames</span>[<span class="i">i</span>].<span class="i">closure</span>);
  }
</pre><pre class="insert-after" translate="no">
  markTable(&amp;vm.globals);
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>markRoots</em>()</div>
<p><font papago-translate="translated">업값에 대해 말하자면, 오픈 업값 목록은 VM이 직접 도달할 수 있는 또 다른 값 집합입니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  for (int i = 0; i &lt; vm.frameCount; i++) {
    markObject((Obj*)vm.frames[i].closure);
  }
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>마크루츠</em>()에서</font></font></div>
<pre class="insert" translate="no">
  <span class="k">for</span> (<span class="t">ObjUpvalue</span>* <span class="i">upvalue</span> = <span class="i">vm</span>.<span class="i">openUpvalues</span>;
       <span class="i">upvalue</span> != <span class="a">NULL</span>;
       <span class="i">upvalue</span> = <span class="i">upvalue</span>-&gt;<span class="i">next</span>) {
    <span class="i">markObject</span>((<span class="t">Obj</span>*)<span class="i">upvalue</span>);
  }
</pre><pre class="insert-after" translate="no">
  markTable(&amp;vm.globals);
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>markRoots</em>()</div>
<p><font papago-translate="translated">또한 할당 중<em>에</em> 컬렉션을 시작할 수 있다는 점도 기억하세요.</font><font papago-translate="translated"> 이러한 할당은 사용자의 프로그램이 실행되는 동안에만 발생하는 것이 아닙니다.</font><font papago-translate="translated"> 컴파일러 자체는 리터럴과 상수 테이블을 위해 주기적으로 힙에서 메모리를 가져옵니다.</font><font papago-translate="translated"> 컴파일 중에 GC가 실행되면 컴파일러가 직접 접근하는 모든 값도 루트로 처리해야 합니다.</font></p>
<p><font papago-translate="translated">컴파일러 모듈을 VM의 나머지 부분과 깔끔하게 분리하기 위해 별도의 함수에서 이 작업을 수행합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  markTable(&amp;vm.globals);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>마크루츠</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="i">markCompilerRoots</span>();
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>markRoots</em>()</div>
<p><font papago-translate="translated">여기에 선언되었습니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">ObjFunction* compile(const char* source);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>컴파일</em> 후 () 추가</font></font></div>
<pre class="insert" translate="no"><span class="t">void</span> <span class="i">markCompilerRoots</span>();
</pre><pre class="insert-after" translate="no">
#endif
</pre></div>
<div class="source-file-narrow"><em>compiler.h</em>, add after <em>compile</em>()</div>
<p><font papago-translate="translated">즉, "메모리" 모듈에 포함이 필요합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#include &lt;stdlib.h&gt;

</pre><div class="source-file"><em><font papago-translate="translated">메모리.c</font></em></div>
<pre class="insert" translate="no"><span class="a">#include "compiler.h"</span>
</pre><pre class="insert-after" translate="no">#include "memory.h"
</pre></div>
<div class="source-file-narrow"><em>memory.c</em></div>
<p><font papago-translate="translated">그리고 정의는 "컴파일러" 모듈에서 끝났습니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>컴파일</em> 후 () 추가</font></font></div>
<pre translate="no"><span class="t">void</span> <span class="i">markCompilerRoots</span>() {
  <span class="t">Compiler</span>* <span class="i">compiler</span> = <span class="i">current</span>;
  <span class="k">while</span> (<span class="i">compiler</span> != <span class="a">NULL</span>) {
    <span class="i">markObject</span>((<span class="t">Obj</span>*)<span class="i">compiler</span>-&gt;<span class="i">function</span>);
    <span class="i">compiler</span> = <span class="i">compiler</span>-&gt;<span class="i">enclosing</span>;
  }
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>compile</em>()</div>
<p><font papago-translate="translated">다행히도 컴파일러에는 너무 많은 값이 붙어 있지 않습니다.</font><font papago-translate="translated"> 그것이 사용하는 유일한 객체는 컴파일 중인 ObjFunction입니다.</font><font papago-translate="translated"> 함수 선언이 중첩될 수 있기 때문에 컴파일러는 이러한 선언들의 링크된 목록을 가지고 있으며, 우리는 전체 목록을 살펴봅니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">"컴파일러" 모듈이 호출 중이므로 </font></font><code translate="no">markObject()</code><font papago-translate="splitted"><font papago-translate="translated">, 또한 포함이 필요합니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#include "compiler.h"
</pre><div class="source-file"><em><font papago-translate="translated">컴파일러.c</font></em></div>
<pre class="insert" translate="no"><span class="a">#include "memory.h"</span>
</pre><pre class="insert-after" translate="no">#include "scanner.h"
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em></div>
<p><font papago-translate="translated">그것들이 모두 뿌리입니다.</font><font papago-translate="translated"> 이 작업을 실행한 후, VM(런타임 및 컴파일러)이 다른 객체<em>를</em> 거치지<em> 않고</em> 도달할 수 있는 모든 객체에는 마크 비트<span class="em"></span><span class="em"></span>가 설정됩니다.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/garbage-collection.html#tracing-object-references" id="tracing-object-references"><small><font papago-translate="translated">26 . 4</font></small><font papago-translate="splitted"><font papago-translate="translated">객체 참조 추적</font></font></a></h2>
<p><font papago-translate="translated">마킹 프로세스의 다음 단계는 객체 간 참조 그래프를 통해 간접적으로 도달할 수 있는 값을 찾는 것입니다.</font><font papago-translate="translated"> 아직 필드가 있는 인스턴스가 없기 때문에 참조를 포함하는 개체는 많지 않지만<span name="some"> 일부 개체는</span> 있습니다.</font><font papago-translate="translated"> 특히 ObjClosure는 닫히는 ObjUpvalue 목록과 포장하는 원시 ObjFunction에 대한 참조를 제공합니다.</font><font papago-translate="translated"> ObjFunction은 함수의 본문에서 생성된 모든 리터럴에 대한 참조를 포함하는 일정한 표를 가지고 있습니다.</font><font papago-translate="translated"> 이 정도면 수집가가 기어 다닐 수 있는 꽤 복잡한 물체 그물망을 만들기에 충분합니다.</font></p>
<aside name="some" style="top: 12249px;">
<p><font papago-translate="translated">이 장을 바로 여기 책에 삽입<em>한 이유는</em> 이제 쓰레기 수집가가 처리할 수 있는 흥미로운 물건들이 생겼<em>기 때문입니다</em>.</font></p>
</aside>
<p><font papago-translate="translated">이제 그 횡단을 구현할 때입니다.</font><font papago-translate="translated"> 너비 우선, 깊이 우선 또는 다른 순서로 진행할 수 있습니다.</font><font papago-translate="translated"> 모든 도달 가능한 객체<em>의 집합</em>을 찾기만 하면 되기 때문에, 우리가 방문하는 순서<span name="dfs">는 대부분</span> 중요하지 않습니다.</font></p>
<aside name="dfs" style="top: 12441px;">
<p><font papago-translate="translated">제가 "대부분"이라고 말하는 이유는 일부 쓰레기 수집가들이 방문한 순서대로 객체를 이동시키기 때문입니다. 따라서 이동 순서에 따라 메모리에 인접하게 되는 객체가 결정되기 때문입니다.</font><font papago-translate="translated"> CPU가 로컬리티를 사용하여 캐시에 미리 로드할 메모리를 결정하기 때문에 성능에 영향을 미칩니다.</font></p>
<p><font papago-translate="translated">횡단 순서가 중요하더라도 어떤 순서가<em> 가장 좋은지</em>는 명확하지 않습니다.</font><font papago-translate="translated"> 미래에 어떤 순서의 객체가 사용될지 결정하는 것은 매우 어렵기 때문에 GC는 어떤 순서가 성능에 도움이 될지 알기 어렵습니다.</font></p>
</aside>
<h3><a href="https://youhogeon-meritz.github.io/garbage-collection.html#the-tricolor-abstraction" id="the-tricolor-abstraction"><small><font papago-translate="translated">26 . 4 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">삼색 추상화</font></font></a></h3>
<p><font papago-translate="translated">수집기가 물체의 그래프를 헤매는 동안, 우리는 수집기가 어디에 있는지 길을 잃거나 원을 그리며 움직이지 않도록 해야 합니다.</font><font papago-translate="translated"> 이는 특히 사용자 프로그램의 실행 중인 부분과 표시를 교차시키는 증분 GC와 같은 고급 구현에서 우려됩니다.</font><font papago-translate="translated"> 수집기는 잠시 멈췄다가 나중에 멈춘 위치를 포착할 수 있어야 합니다.</font></p>
<p><font papago-translate="translated">우리가 이 복잡한 과정에 대해 부드러운 두뇌를 가진 인간들이 추론할 수 있도록 돕기 위해, VM 해커들은<strong> 삼색 추상</strong><span name="color"></span><strong>화</strong>라는 은유를 생각해냈습니다.</font><font papago-translate="translated"> 각 객체는 객체가 어떤 상태에 있는지, 그리고 어떤 작업이 남아 있는지 추적하는 개념적 "색"을 가지고 있습니다.</font></p>
<aside name="color" style="top: 12753px;">
<p><font papago-translate="translated">고급 가비지 컬렉션 알고리즘은 종종 추상화에 다른 색상을 추가합니다.</font><font papago-translate="translated"> 저는 여러 가지 회색 음영을 보았고, 심지어 몇몇 디자인에서는 보라색도 보았습니다.</font><font papago-translate="translated"> 제 푸스차트뢰즈-푸치아-말라카이트 수집 논문은 출판이 승인되지 않았습니다.</font></p>
</aside>
<ul>
<li>
<p><font papago-translate="translated"><strong><img alt="흰색 원." class="dot" src="https://youhogeon-meritz.github.io/image/garbage-collection/white.png" papago-attr-id="10"> 흰색</strong>: 쓰레기 수거의 시작 부분에는 모든 물건이 흰색입니다<strong>.</strong></font><font papago-translate="translated"> 이 색상은 우리가 객체에 전혀 도달하거나 처리하지 않았음을 의미합니다.</font></p>
</li>
<li>
<p><font papago-translate="translated"><strong><img alt="회색 원." class="dot" src="https://youhogeon-meritz.github.io/image/garbage-collection/gray.png" papago-attr-id="11"> 회색</strong>: 표시하는 동안 물체에 처음 도달하면 회색으로 어둡게 표시<strong>합니다.</strong></font><font papago-translate="translated"> 이 색상은 물체 자체에 도달할 수 있으며 수집해서는 안 된다는 것을 의미합니다.</font><font papago-translate="translated"> 그러나 우리는 아직<em> 그것이</em> 참조<em>하는 다른</em> 물체들이 무엇인지 알아보기 위해 그것<em>을</em> 추적하지 않았습니다.</font><font papago-translate="translated"> 그래프 알고리즘 용어로<em> 말하자면, 이것</em>은<em> 우리</em>가 알고 있지만<span class="em"></span> 아직 처리하지 않은 객체들의 집합<em>인 작업 목록</em>입니다.</font></p>
</li>
<li>
<p><font papago-translate="translated"><strong><img alt="검은 원." class="dot" src="https://youhogeon-meritz.github.io/image/garbage-collection/black.png" papago-attr-id="12"> 검정색:</strong></font><font papago-translate="translated"> 회색 물체를 가져와서 참조하는 모든 물체에 표시하면 회색 물체를 검은색으로 바꿉니다.</font><font papago-translate="translated"> 이 색상은 해당 객체를 처리하는 마크 단계가 완료되었음을 의미합니다.</font></p>
</li>
</ul>
<p><font papago-translate="translated">추상화 측면에서 표시 프로세스는 이제 다음과 같습니다:</font></p>
<ol>
<li>
<p><font papago-translate="translated">모든 객체를 흰색으로 시작하세요.</font></p>
</li>
<li>
<p><font papago-translate="translated">모든 뿌리를 찾아서 회색으로 표시하세요.</font></p>
</li>
<li>
<p><font papago-translate="translated">회색 물체가 남아 있는 한 반복합니다:</font></p>
<ol>
<li>
<p><font papago-translate="translated">회색 객체를 선택합니다.</font><font papago-translate="translated"> 물체가 언급한 흰색 물체를 회색으로 바꿉니다.</font></p>
</li>
<li>
<p><font papago-translate="translated">원래 회색 객체를 검은색으로 표시합니다.</font></p>
</li>
</ol>
</li>
</ol>
<p><font papago-translate="translated">이것을 시각화하는 데 도움이 된다고 생각합니다.</font><font papago-translate="translated"> 참조를 포함한 객체들의 웹이 있습니다.</font><font papago-translate="translated"> 처음에는 모두 작은 흰색 점들입니다.</font><font papago-translate="translated"> 측면에는 루트를 가리키는 VM에서 들어오는 일부 가장자리가 있습니다.</font><font papago-translate="translated"> 그 뿌리들은 회색으로 변합니다.</font><font papago-translate="translated"> 그런 다음 각 회색 물체의 형제자매는 회색으로 변하고 물체 자체는 검은색으로 변합니다.</font><font papago-translate="translated"> 전체 효과는 그래프를 통과하는 회색 파면으로, 그 뒤에 도달할 수 있는 검은 물체의 필드가 남습니다.</font><font papago-translate="translated"> 도달할 수 없는 물체는 파면에 닿지 않고 하얗게 유지됩니다.</font></p><img alt="A gray wavefront working through a graph of nodes." class="wide" src="https://youhogeon-meritz.github.io/image/garbage-collection/tricolor-trace.png">
<p><font papago-translate="translated"><span name="invariant">결국</span>, 당신은 손이 닿아 있고 하얀 물체들이 섬처럼 흩어져 있는 검은 물체들의 바다를 보게 됩니다.</font><font papago-translate="translated"> 도달할 수 없는 객체들이 해제되면, 나머지 객체들(모두 검은색)은 다음 쓰레기 수거<span class="em"></span><span class="em"></span> 주기 동안 흰색으로 재설정됩니다.</font></p>
<aside name="invariant" style="top: 13845px;">
<p><font papago-translate="translated">이 과정의 모든 단계에서 어떤 검은 노드도 흰 노드를 가리키지 않는다는 점에 유의하세요.</font><font papago-translate="translated"> 이 속성을<strong> 삼색 불변량</strong>이라고 합니다.</font><font papago-translate="translated"> 트래버스 프로세스는 도달 가능한 객체가 수집되지 않도록 이 불변성을 유지합니다.</font></p>
</aside>
<h3><a href="https://youhogeon-meritz.github.io/garbage-collection.html#a-worklist-for-gray-objects" id="a-worklist-for-gray-objects"><small><font papago-translate="translated">26 . 4 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">회색 객체에 대한 작업 목록</font></font></a></h3>
<p><font papago-translate="translated">우리의 구현에서 우리는 이미 뿌리를 표시했습니다.</font><font papago-translate="translated"> 모두 회색입니다.</font><font papago-translate="translated"> 다음 단계는 그것들을 선택하고 참조를 탐색하기 시작하는 것입니다.</font><font papago-translate="translated"> 하지만 쉽게 찾을 수 있는 방법이 없습니다.</font><font papago-translate="translated"> 우리는 그 물체에 필드를 설정했지만, 그게 다입니다.</font><font papago-translate="translated"> 우리는 필드 세트가 있는 객체를 찾기 위해 전체 객체 목록을 탐색할 필요가 없습니다.</font></p>
<p><font papago-translate="translated">대신, 모든 회색 객체를 추적하기 위해 별도의 작업 목록을 만들겠습니다.</font><font papago-translate="translated"> 객체가 회색으로 변하면 마크 필드를 설정하는 것 외에도 작업 목록에 추가됩니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  object-&gt;isMarked = true;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>mark</em>O<em>bject</em>()에서</font></font></div>
<pre class="insert" translate="no">
  <span class="k">if</span> (<span class="i">vm</span>.<span class="i">grayCapacity</span> &lt; <span class="i">vm</span>.<span class="i">grayCount</span> + <span class="n">1</span>) {
    <span class="i">vm</span>.<span class="i">grayCapacity</span> = <span class="a">GROW_CAPACITY</span>(<span class="i">vm</span>.<span class="i">grayCapacity</span>);
    <span class="i">vm</span>.<span class="i">grayStack</span> = (<span class="t">Obj</span>**)<span class="i">realloc</span>(<span class="i">vm</span>.<span class="i">grayStack</span>,
                                  <span class="k">sizeof</span>(<span class="t">Obj</span>*) * <span class="i">vm</span>.<span class="i">grayCapacity</span>);
  }

  <span class="i">vm</span>.<span class="i">grayStack</span>[<span class="i">vm</span>.<span class="i">grayCount</span>++] = <span class="i">object</span>;
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>markObject</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">물건을 넣고 쉽게 꺼낼 수 있는 모든 종류의 데이터 구조를 사용할 수 있습니다.</font><font papago-translate="translated"> 저는 스택을 선택했습니다. 왜냐하면 그것이 C의 동적 배열로 구현하기 가장 간단하기 때문입니다.</font><font papago-translate="translated"> Lox에서 구축한 다른 동적 어레이와 마찬가지로 대부분 작동하지만<em></em><em>, 시스템</em>을 호출한다는 점에 유의하세요</font></font> <code translate="no">realloc()</code><font papago-translate="splitted"><font papago-translate="translated"> 우리만의 기능이 아닌 기능 </font></font><code translate="no">reallocate()</code><font papago-translate="splitted"><font papago-translate="translated"> 포장지.</font><font papago-translate="translated"> 회색 스택 자체의 메모리는 쓰레기 수집기에 의해 관리<em>되지 않습니다</em>.</font><font papago-translate="translated"> GC 동안 회색 스택을 성장시켜 GC가 새로운 GC를 재귀적으로 시작하는 것을 원하지 않습니다.</font><font papago-translate="translated"> 그것은 시공간 연속체에 구멍을 뚫을 수 있습니다.</font></font></p>
<p><font papago-translate="translated">우리는 그것의 기억을 명시적으로 직접 관리할 것입니다.</font><font papago-translate="translated"> VM은 회색 스택을 소유합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  Obj* objects;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">VM.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em></em>구조 VM에서</font></font></div>
<pre class="insert" translate="no">  <span class="t">int</span> <span class="i">grayCount</span>;
  <span class="t">int</span> <span class="i">grayCapacity</span>;
  <span class="t">Obj</span>** <span class="i">grayStack</span>;
</pre><pre class="insert-after" translate="no">} VM;
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, in struct <em>VM</em></div>
<p><font papago-translate="translated">비어 있는 상태로 시작합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  vm.objects = NULL;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>initVM</em>()에서</font></font></div>
<pre class="insert" translate="no">
  <span class="i">vm</span>.<span class="i">grayCount</span> = <span class="n">0</span>;
  <span class="i">vm</span>.<span class="i">grayCapacity</span> = <span class="n">0</span>;
  <span class="i">vm</span>.<span class="i">grayStack</span> = <span class="a">NULL</span>;
</pre><pre class="insert-after" translate="no">
  initTable(&amp;vm.globals);
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>initVM</em>()</div>
<p><font papago-translate="translated">그리고 VM이 종료되면 이를 해제해야 합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    object = next;
  }
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>freeObject</em>s()에서</font></font></div>
<pre class="insert" translate="no">
  <span class="i">free</span>(<span class="i">vm</span>.<span class="i">grayStack</span>);
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>freeObjects</em>()</div>
<p><font papago-translate="translated">우리<span name="robust">는</span> 이 배열에 대해 전적인 책임을 집<span name="robust">니다.</span></font><font papago-translate="translated"> 여기에는 할당 실패가 포함됩니다.</font><font papago-translate="translated"> 회색 스택을 만들거나 키울 수 없다면 쓰레기 수거를 완료할 수 없습니다.</font><font papago-translate="translated"> 이것은 VM에게 나쁜 소식이지만, 다행히도 회색 스택이 꽤 작은 경향이 있기 때문에 드뭅니다.</font><font papago-translate="translated"> 좀 더 우아한 일을 하면 좋겠지만, 이 책의 코드를 간단하게 유지하기 위해 우리는 그냥 중단합니다.</font></p>
<aside name="robust" style="top: 15273px;">
<p><font papago-translate="translated">더 견고하게 하기 위해, VM을 시작할 때 "비 오는 날 기금" 메모리 블록을 할당할 수 있습니다.</font><font papago-translate="translated"> 회색 스택 할당이 실패하면 비 오는 날 블록을 해제하고 다시 시도합니다.</font><font papago-translate="translated"> 그렇게 하면 회색 스택을 생성하고, GC를 완료하고, 더 많은 메모리를 확보할 수 있는 충분한 공간이 생길 수 있습니다.</font></p>
</aside>
<div class="codehilite"><pre class="insert-before" translate="no">    vm.grayStack = (Obj**)realloc(vm.grayStack,
                                  sizeof(Obj*) * vm.grayCapacity);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>mark</em>O<em>bject</em>()에서</font></font></div>
<pre class="insert" translate="no">
    <span class="k">if</span> (<span class="i">vm</span>.<span class="i">grayStack</span> == <span class="a">NULL</span>) <span class="i">exit</span>(<span class="n">1</span>);
</pre><pre class="insert-after" translate="no">  }
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>markObject</em>()</div>
<h3><a href="https://youhogeon-meritz.github.io/garbage-collection.html#processing-gray-objects" id="processing-gray-objects"><small><font papago-translate="translated">26 . 4 . 3</font></small><font papago-translate="splitted"><font papago-translate="translated">회색 객체 처리</font></font></a></h3>
<p><font papago-translate="translated">자, 이제 루트 표시를 마치면 여러 필드를 설정하고 작업 목록을 씹을 수 있는 객체로 채웠습니다.</font><font papago-translate="translated"> 다음 단계로 넘어갈 시간입니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  markRoots();
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>수집</em> 쓰레기()에서</font></font></div>
<pre class="insert" translate="no">  <span class="i">traceReferences</span>();
</pre><pre class="insert-after" translate="no">
#ifdef DEBUG_LOG_GC
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>collectGarbage</em>()</div>
<p><font papago-translate="translated">구현은 다음과 같습니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>markRoot</em>s() 뒤에 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">traceReferences</span>() {
  <span class="k">while</span> (<span class="i">vm</span>.<span class="i">grayCount</span> &gt; <span class="n">0</span>) {
    <span class="t">Obj</span>* <span class="i">object</span> = <span class="i">vm</span>.<span class="i">grayStack</span>[--<span class="i">vm</span>.<span class="i">grayCount</span>];
    <span class="i">blackenObject</span>(<span class="i">object</span>);
  }
}
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, add after <em>markRoots</em>()</div>
<p><font papago-translate="translated">그것은 가능한 한 그 텍스트 알고리즘에 가깝습니다.</font><font papago-translate="translated"> 스택이 비워질 때까지 회색 객체를 계속 꺼내어 참조를 탐색한 다음 검은색으로 표시합니다.</font><font papago-translate="translated"> 객체의 참조를 탐색하면 회색으로 표시되고 스택에 추가되는 새로운 흰색 객체가 나타날 수 있습니다.</font><font papago-translate="translated"> 따라서 이 함수는 흰색 물체를 회색과 회색 물체를 검은색으로 바꾸는 것 사이를 왔다 갔다 하며, 점차 전체 파면을 앞으로 전진시킵니다.</font></p>
<p><font papago-translate="translated">다음은 단일 객체의 참조를 탐색하는 곳입니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>markValue</em>() 뒤에 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">blackenObject</span>(<span class="t">Obj</span>* <span class="i">object</span>) {
  <span class="k">switch</span> (<span class="i">object</span>-&gt;<span class="i">type</span>) {
    <span class="k">case</span> <span class="a">OBJ_NATIVE</span>:
    <span class="k">case</span> <span class="a">OBJ_STRING</span>:
      <span class="k">break</span>;
  }
}
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, add after <em>markValue</em>()</div>
<p><font papago-translate="translated">각 객체<span name="leaf"> 유형마다</span> 다른 객체를 참조할 수 있는 필드가 다르기 때문에 각 유형에 맞는 특정 코드 블롭이 필요합니다.</font><font papago-translate="translated"> 문자열과 네이티브 함수 객체에는 나가는 참조가 없으므로<span class="em"></span> 탐색할 내용이 없습니다.</font></p>
<aside name="leaf" style="top: 16409px;">
<p><font papago-translate="splitted"><font papago-translate="translated">우리가 할 수 있는 쉬운 최적화 </font></font><code translate="no">markObject()</code><font papago-translate="splitted"><font papago-translate="translated"> 문자열과 네이티브 함수를 처리할 필요가 없다는 것을 알기 때문에 회색 스택에 추가하는 것을 건너뛰는 것입니다.</font><font papago-translate="translated"> 대신 흰색 직선에서 검은색으로 어둡게 할 수 있습니다.</font></font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">우리는 탐색된 객체 자체에 어떤 상태도 설정하지 않는다는 점에 유의하세요.</font><font papago-translate="translated"> 객체의 상태에는 "블랙"이라는 직접적인 인코딩이 없습니다.</font><font papago-translate="translated"> 검은색 물체는 다음과 같은 물체입니다 </font></font><code translate="no">isMarked</code><font papago-translate="splitted"><font papago-translate="translated"> 필드<span name="field">가 설정</span>되어 더 이상 회색 스택에 없습니다.</font></font></p>
<aside name="field" style="top: 16577px;">
<p><font papago-translate="splitted"><font papago-translate="translated">왜 우리가 그것을 가지고 있는지 궁금할 것입니다 </font></font><code translate="no">isMarked</code><font papago-translate="splitted"><font papago-translate="translated"> 전혀 현장에.</font><font papago-translate="translated"> 좋은 시간이에요, 친구.</font></font></p>
</aside>
<p><font papago-translate="translated">이제 다른 객체 유형에 추가하기 시작하겠습니다.</font><font papago-translate="translated"> 가장 간단한 것은 업밸류입니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">static void blackenObject(Obj* object) {
  switch (object-&gt;type) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>blacken</em>O<em>bject</em>()에서</font></font></div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="a">OBJ_UPVALUE</span>:
      <span class="i">markValue</span>(((<span class="t">ObjUpvalue</span>*)<span class="i">object</span>)-&gt;<span class="i">closed</span>);
      <span class="k">break</span>;
</pre><pre class="insert-after" translate="no">    case OBJ_NATIVE:
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>blackenObject</em>()</div>
<p><font papago-translate="translated">업값이 닫힐 때, 그것은 닫힌 값에 대한 참조를 포함합니다.</font><font papago-translate="translated"> 값이 더 이상 스택에 존재하지 않으므로, 업값에서 참조를 추적해야 합니다.</font></p>
<p><font papago-translate="translated">다음은 함수입니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  switch (object-&gt;type) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>blacken</em>O<em>bject</em>()에서</font></font></div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="a">OBJ_FUNCTION</span>: {
      <span class="t">ObjFunction</span>* <span class="i">function</span> = (<span class="t">ObjFunction</span>*)<span class="i">object</span>;
      <span class="i">markObject</span>((<span class="t">Obj</span>*)<span class="i">function</span>-&gt;<span class="i">name</span>);
      <span class="i">markArray</span>(&amp;<span class="i">function</span>-&gt;<span class="i">chunk</span>.<span class="i">constants</span>);
      <span class="k">break</span>;
    }
</pre><pre class="insert-after" translate="no">    case OBJ_UPVALUE:
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>blackenObject</em>()</div>
<p><font papago-translate="translated">각 함수에는 함수 이름이 포함된 ObjString에 대한 참조가 있습니다.</font><font papago-translate="translated"> 더 중요한 것은 함수에 다른 객체에 대한 참조로 가득 찬 상수 테이블이 있다는 점입니다.</font><font papago-translate="translated"> 이 도우미를 사용하여 모든 사람을 추적합니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>markValue</em>() 뒤에 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">markArray</span>(<span class="t">ValueArray</span>* <span class="i">array</span>) {
  <span class="k">for</span> (<span class="t">int</span> <span class="i">i</span> = <span class="n">0</span>; <span class="i">i</span> &lt; <span class="i">array</span>-&gt;<span class="i">count</span>; <span class="i">i</span>++) {
    <span class="i">markValue</span>(<span class="i">array</span>-&gt;<span class="i">values</span>[<span class="i">i</span>]);
  }
}
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, add after <em>markValue</em>()</div>
<p><font papago-translate="translated">현재 마지막 객체 유형은<span class="em"></span><span class="em"></span> 나중 장에서 더 추가할 것입니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  switch (object-&gt;type) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>blacken</em>O<em>bject</em>()에서</font></font></div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="a">OBJ_CLOSURE</span>: {
      <span class="t">ObjClosure</span>* <span class="i">closure</span> = (<span class="t">ObjClosure</span>*)<span class="i">object</span>;
      <span class="i">markObject</span>((<span class="t">Obj</span>*)<span class="i">closure</span>-&gt;<span class="i">function</span>);
      <span class="k">for</span> (<span class="t">int</span> <span class="i">i</span> = <span class="n">0</span>; <span class="i">i</span> &lt; <span class="i">closure</span>-&gt;<span class="i">upvalueCount</span>; <span class="i">i</span>++) {
        <span class="i">markObject</span>((<span class="t">Obj</span>*)<span class="i">closure</span>-&gt;<span class="i">upvalues</span>[<span class="i">i</span>]);
      }
      <span class="k">break</span>;
    }
</pre><pre class="insert-after" translate="no">    case OBJ_FUNCTION: {
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>blackenObject</em>()</div>
<p><font papago-translate="translated">각 클로저에는 랩하는 베어 함수에 대한 참조와 캡처하는 업값에 대한 포인터 배열이 있습니다.</font><font papago-translate="translated"> 우리는 그것들을 모두 추적합니다.</font></p>
<p><font papago-translate="translated">그것이 회색 물체를 처리하는 기본 메커니즘이지만, 연결하기에는 두 가지 느슨한 끝이 있습니다.</font><font papago-translate="translated"> 먼저, 약간의 벌목.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">static void blackenObject(Obj* object) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>blacken</em>O<em>bject</em>()에서</font></font></div>
<pre class="insert" translate="no"><span class="a">#ifdef DEBUG_LOG_GC</span>
  <span class="i">printf</span>(<span class="s">"%p blacken "</span>, (<span class="t">void</span>*)<span class="i">object</span>);
  <span class="i">printValue</span>(<span class="a">OBJ_VAL</span>(<span class="i">object</span>));
  <span class="i">printf</span>(<span class="s">"</span><span class="e">\n</span><span class="s">"</span>);
<span class="a">#endif</span>

</pre><pre class="insert-after" translate="no">  switch (object-&gt;type) {
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>blackenObject</em>()</div>
<p><font papago-translate="translated">이렇게 하면 객체 그래프를 통해 추적이 침투하는 것을 볼 수 있습니다.</font><font papago-translate="translated"> 말이 나와서<em> 말</em>인데<em>, 제가 그래프</em>라고 말한 것을 주목하세요.</font><font papago-translate="translated"> 객체 간의 참조는 방향성이 있지만<em>,</em> 그렇다고<em> 해서 그것</em>들이<em> 비순환적</em>이라는 의미는 아닙니다!</font><font papago-translate="translated"> 물체의 주기를 갖는 것은 전적으로 가능합니다.</font><font papago-translate="translated"> 그런 일이 발생하면 수집기가 계속해서 동일한 일련의 객체를 회색 스택에 다시 추가하기 때문에 무한 루프에 갇히지 않도록 해야 합니다.</font></p>
<p><font papago-translate="translated">수정은 쉽습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  if (object == NULL) return;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>mark</em>O<em>bject</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="k">if</span> (<span class="i">object</span>-&gt;<span class="i">isMarked</span>) <span class="k">return</span>;

</pre><pre class="insert-after" translate="no">#ifdef DEBUG_LOG_GC
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>markObject</em>()</div>
<p><font papago-translate="translated">객체가 이미 표시되어 있으면 다시 표시하지 않으므로 회색 스택에 추가하지 않습니다.</font><font papago-translate="translated"> 이렇게 하면 이미 회색으로 표시된 객체가 중복적으로 추가되지 않고 검은색 객체가 의도치 않게 회색으로 되돌아가지 않습니다.</font><font papago-translate="translated"> 다시 말해, 그것은 오직 흰색 물체들 사이에서만 파면을 앞으로 나아가게 합니다.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/garbage-collection.html#sweeping-unused-objects" id="sweeping-unused-objects"><small><font papago-translate="translated">26 . 5</font></small><font papago-translate="splitted"><font papago-translate="translated">사용하지 않는 객체 정리하기</font></font></a></h2>
<p><font papago-translate="splitted"><font papago-translate="translated">루프 인이 발생할 때 </font></font><code translate="no">traceReferences()</code><font papago-translate="splitted"><font papago-translate="translated"> 우리는 손에 넣을 수 있는 모든 물건을 처리했습니다.</font><font papago-translate="translated"> 회색 스택은 비어 있으며 힙의 모든 개체는 검은색 또는 흰색입니다.</font><font papago-translate="translated"> 검은 물체는 손이 닿아 있고, 우리는 그것들을 붙잡고 싶습니다.</font><font papago-translate="translated"> 여전히 흰색인 것은 흔적에 닿지 않아 쓰레기입니다.</font><font papago-translate="translated"> 남은 것은 그것들을 되찾는 것뿐입니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  traceReferences();
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>수집</em> 쓰레기()에서</font></font></div>
<pre class="insert" translate="no">  <span class="i">sweep</span>();
</pre><pre class="insert-after" translate="no">
#ifdef DEBUG_LOG_GC
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>collectGarbage</em>()</div>
<p><font papago-translate="translated">모든 논리는 한 가지 기능으로 살아갑니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>추적</em> 후 추가참<em>조</em>()</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">sweep</span>() {
  <span class="t">Obj</span>* <span class="i">previous</span> = <span class="a">NULL</span>;
  <span class="t">Obj</span>* <span class="i">object</span> = <span class="i">vm</span>.<span class="i">objects</span>;
  <span class="k">while</span> (<span class="i">object</span> != <span class="a">NULL</span>) {
    <span class="k">if</span> (<span class="i">object</span>-&gt;<span class="i">isMarked</span>) {
      <span class="i">previous</span> = <span class="i">object</span>;
      <span class="i">object</span> = <span class="i">object</span>-&gt;<span class="i">next</span>;
    } <span class="k">else</span> {
      <span class="t">Obj</span>* <span class="i">unreached</span> = <span class="i">object</span>;
      <span class="i">object</span> = <span class="i">object</span>-&gt;<span class="i">next</span>;
      <span class="k">if</span> (<span class="i">previous</span> != <span class="a">NULL</span>) {
        <span class="i">previous</span>-&gt;<span class="i">next</span> = <span class="i">object</span>;
      } <span class="k">else</span> {
        <span class="i">vm</span>.<span class="i">objects</span> = <span class="i">object</span>;
      }

      <span class="i">freeObject</span>(<span class="i">unreached</span>);
    }
  }
}
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, add after <em>traceReferences</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">그것이 코드와 포인터에 대한 설명이 많다는 것을 알고 있지만, 한 번 해보면 별다른 의미가 없습니다.</font><font papago-translate="translated"> 바깥쪽 </font></font><code translate="no">while</code><font papago-translate="splitted"><font papago-translate="translated"> 루프는 힙에 있는 모든 객체의 연결된 목록을 걸어 표시 비트를 확인합니다.</font><font papago-translate="translated"> 물체가 (검은색) 표시되어 있으면, 우리는 그것을 그냥 두고 지나갑니다.</font><font papago-translate="translated"> 표시되지 않은 경우(흰색), 목록에서 링크를 해제하고 다음을 사용하여 무료로 제공합니다 </font></font><code translate="no">freeObject()</code><font papago-translate="splitted"><font papago-translate="translated"> 우리가 이미 작성한 함수.</font></font></p><img alt="A recycle bin full of bits." src="https://youhogeon-meritz.github.io/image/garbage-collection/unlink.png">
<p><font papago-translate="translated">여기 있는 대부분의 다른 코드는 단일 링크 목록에서 노드를 제거하는 것이 번거롭다는 사실을 다룹니다.</font><font papago-translate="translated"> 이전 노드를 지속적으로 기억해야 다음 포인터의 연결을 해제할 수 있으며, 첫 번째 노드를 해제하는 엣지 케이스를 처리해야 합니다.</font><font papago-translate="translated"> 하지만 그렇지 않으면 링크 목록에 비트<span class="em"></span>가 설정되지 않은 모든 노드를 삭제하는 것이 매우 간단합니다.</font></p>
<p><font papago-translate="translated">작은 추가 사항이 하나 있습니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    if (object-&gt;isMarked) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>스윕</em> ()에서</font></font></div>
<pre class="insert" translate="no">      <span class="i">object</span>-&gt;<span class="i">isMarked</span> = <span class="k">false</span>;
</pre><pre class="insert-after" translate="no">      previous = object;
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>sweep</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">끝나고 </font></font><code translate="no">sweep()</code><font papago-translate="splitted"><font papago-translate="translated"> 완료하면 남은 개체는 마크 비트가 설정된 라이브 블랙 개체뿐입니다.</font><font papago-translate="translated"> 맞습니다만<em>, 다음</em> 수집 주기가 시작되면 모든 물체가 흰색이어야 합니다.</font><font papago-translate="translated"> 그래서 우리가 검은 물체에 도달할 때마다, 다음 실행을 기대하며 지금 바로 비트를 클리어합니다.</font></font></p>
<h3><a href="https://youhogeon-meritz.github.io/garbage-collection.html#weak-references-and-the-string-pool" id="weak-references-and-the-string-pool"><small><font papago-translate="translated">26 . 5 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">약한 참조와 문자열 풀</font></font></a></h3>
<p><font papago-translate="translated">수집이 거의 끝났습니다.</font><font papago-translate="translated"> VM에는 메모리와 관련된 몇 가지 특이한 요구 사항이 남아 있는 모서리가 하나 남아 있습니다.</font><font papago-translate="translated"> clox에 문자열을 추가할 때 VM이 모든 문자열을 삽입하도록 했다는 점을 기억하세요.</font><font papago-translate="translated"> 즉, VM에는 힙의 모든 문자열에 대한 포인터가 포함된 해시 테이블이 있습니다.</font><font papago-translate="translated"> VM은 이를 사용하여 문자열 중복을 제거합니다.</font></p>
<p><font papago-translate="translated">마크 단계에서는 VM의 문자열 테이블을 루트 소스로 의도적으로 취급<em>하지 않았습니다</em>.</font><font papago-translate="translated"> 만약 우리가 그렇게 했다면<span name="intern">, 어떤 문자열</span>도 수집<em>되지</em> 않았을 것입니다.</font><font papago-translate="translated"> 문자열 테이블은 점점 더 커지며 운영 체제에 단 한 바이트의 메모리도 다시 제공하지 않습니다.</font><font papago-translate="translated"> 안 좋을 것 같습니다.</font></p>
<aside name="intern" style="top: 20448px;">
<p><font papago-translate="splitted"><font papago-translate="translated">이것은 진짜 문제가 될 수 있습니다.</font><font papago-translate="translated"> Java는<em> 모든</em> 문자열을 삽입하지는 않지만<em>, 문자열 리터럴</em>을 삽입합니다.</font><font papago-translate="translated"> 문자열 테이블에 문자열을 추가할 수 있는 API도 제공합니다.</font><font papago-translate="translated"> 수년 동안 그 테이블의 용량은 고정되어 있었고, 추가된 문자열은 절대 제거할 수 없었습니다.</font><font papago-translate="translated"> 사용자가 사용에 주의하지 않았다면 </font></font><code translate="no">String.intern()</code><font papago-translate="splitted"><font papago-translate="translated">, 메모리가 부족하여 충돌할 수 있습니다.</font></font></p>
<p><font papago-translate="translated">루비는 수년 동안 비슷한 문제를 겪었는데, 여기서 기호—즉, 삽입된 문자열 같은 값들이 쓰레기<span class="em"></span><span class="em"></span>로 수집되지 않았습니다.</font><font papago-translate="translated"> 둘 다 결국 GC가 이러한 문자열을 수집할 수 있게 했습니다.</font></p>
</aside>
<p><font papago-translate="translated">동시에 GC를 자유 문자열로 허용<em>하면</em> VM의 문자열 테이블에는 자유 메모리에 대한 매달린 포인터가 남게 됩니다.</font><font papago-translate="translated"> 그것은 더 나쁠 것입니다.</font></p>
<p><font papago-translate="translated">줄 테이블은 특별하며 특별한 지원이 필요합니다.</font><font papago-translate="translated"> 특히, 그것은 특별한 종류의 참조가 필요합니다.</font><font papago-translate="translated"> 테이블은 문자열을 참조할 수 있어야 하지만, 도달 가능성을 판단할 때 해당 링크를 루트로 간주해서는 안 됩니다.</font><font papago-translate="translated"> 이는 참조된 객체가 해방될 수 있음을 의미합니다.</font><font papago-translate="translated"> 그렇게 되면, 매달린 기준도 마치 마법 같은 자기 클리어 포인터처럼 고정되어야 합니다.</font><font papago-translate="translated"> 이 특정 의미론 세트는<a href="https://en.wikipedia.org/wiki/Weak_reference"><strong> 이름이 있을</strong></a> 정도로 자주 등장합니다:<a href="https://en.wikipedia.org/wiki/Weak_reference"><strong> 약한 참조입니다</strong></a>.</font></p>
<p><font papago-translate="translated">우리는 이미 마킹 중에 문자열 테이블을 통과하지<em> 않기</em> 때문에 문자열 테이블의 고유한 동작의 절반을 암묵적으로 구현했습니다.</font><font papago-translate="translated"> 즉, 문자열에 도달할 수 있도록 강제하지 않습니다.</font><font papago-translate="translated"> 남은 부분은 풀린 문자열에 대한 매달린 포인터를 지우는 것입니다.</font></p>
<p><font papago-translate="translated">도달할 수 없는 문자열에 대한 참조를 제거하려면<em></em> 어떤 문자열이 도달할 수 없는지 알아야 합니다.</font><font papago-translate="translated"> 마크 단계가 완료되기 전까지는 알 수 없습니다.</font><font papago-translate="translated"> 하지만 스윕 단계가 끝날 때까지 기다릴 수는 없습니다. 그때쯤이면 객체와 그들의 마크 비트가<span class="em"></span><span class="em"></span> 더 이상 확인할 수 없기 때문입니다.</font><font papago-translate="translated"> 따라서 적절한 시기는 표시 단계와 스위핑 단계 사이입니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  traceReferences();
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>수집</em> 쓰레기()에서</font></font></div>
<pre class="insert" translate="no">  <span class="i">tableRemoveWhite</span>(&amp;<span class="i">vm</span>.<span class="i">strings</span>);
</pre><pre class="insert-after" translate="no">  sweep();
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>collectGarbage</em>()</div>
<p><font papago-translate="translated">삭제할 문자열을 제거하는 논리는 "테이블" 모듈의 새로운 함수에 존재합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">ObjString* tableFindString(Table* table, const char* chars,
                           int length, uint32_t hash);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">테이블.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>테이블</em> 뒤에 추가F<em>indString</em>()</font></font></div>
<pre class="insert" translate="no">
<span class="t">void</span> <span class="i">tableRemoveWhite</span>(<span class="t">Table</span>* <span class="i">table</span>);
</pre><pre class="insert-after" translate="no">void markTable(Table* table);

</pre></div>
<div class="source-file-narrow"><em>table.h</em>, add after <em>tableFindString</em>()</div>
<p><font papago-translate="translated">구현은 여기에 있습니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">테이블.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>테이블</em> 뒤에 추가F<em>indString</em>()</font></font></div>
<pre translate="no"><span class="t">void</span> <span class="i">tableRemoveWhite</span>(<span class="t">Table</span>* <span class="i">table</span>) {
  <span class="k">for</span> (<span class="t">int</span> <span class="i">i</span> = <span class="n">0</span>; <span class="i">i</span> &lt; <span class="i">table</span>-&gt;<span class="i">capacity</span>; <span class="i">i</span>++) {
    <span class="t">Entry</span>* <span class="i">entry</span> = &amp;<span class="i">table</span>-&gt;<span class="i">entries</span>[<span class="i">i</span>];
    <span class="k">if</span> (<span class="i">entry</span>-&gt;<span class="i">key</span> != <span class="a">NULL</span> &amp;&amp; !<span class="i">entry</span>-&gt;<span class="i">key</span>-&gt;<span class="i">obj</span>.<span class="i">isMarked</span>) {
      <span class="i">tableDelete</span>(<span class="i">table</span>, <span class="i">entry</span>-&gt;<span class="i">key</span>);
    }
  }
}
</pre></div>
<div class="source-file-narrow"><em>table.c</em>, add after <em>tableFindString</em>()</div>
<p><font papago-translate="translated">우리는 테이블의 모든 항목을 걷습니다.</font><font papago-translate="translated"> 문자열 인턴 테이블은 각 항목의 키만 사용합니다. 기본적으로 해시<span class="em"></span><em> 맵</em>이 아닌 해시<em> 집합입니다</em>.</font><font papago-translate="translated"> 키 문자열 객체의 마크 비트가 설정되지 않은 경우, 그것은 쓸려나간 순간에 나타나는 흰색 객체입니다.</font><font papago-translate="translated"> 해시 테이블에서 먼저 삭제하므로 달링 포인터가 보이지 않도록 합니다.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/garbage-collection.html#when-to-collect" id="when-to-collect"><small><font papago-translate="translated">26 . 6</font></small><font papago-translate="splitted"><font papago-translate="translated">수집 시기</font></font></a></h2>
<p><font papago-translate="translated">저희는 이제 완벽하게 작동하는 마크 스윕 쓰레기 수거기를 보유하고 있습니다.</font><font papago-translate="translated"> 스트레스 테스트 플래그가 활성화되면 항상 호출되며, 로깅도 활성화되면 그 플래그가 제대로 작동하는 것을 보고 실제로 메모리를 되찾고 있는 것을 확인할 수 있습니다.</font><font papago-translate="translated"> 하지만 스트레스 테스트 플래그가 꺼져 있으면 전혀 실행되지 않습니다.</font><font papago-translate="translated"> 정상적인 프로그램 실행 중에 수집기를 언제 호출해야 할지 결정할 시간입니다.</font></p>
<p><font papago-translate="translated">제가 아는 한, 이 질문은 문헌에서 제대로 답변되지 않았습니다.</font><font papago-translate="translated"> 쓰레기 수거기가 처음 발명되었을 때, 컴퓨터는 작고 고정된 양의 메모리를 가지고 있었습니다.</font><font papago-translate="translated"> 초기 GC 논문의 많은 부분은 수천 단어의 기억, 즉 대부분의 기억을 따로 남겨두었다고 가정하고<span class="em"></span><span class="em"></span>, 부족할 때마다 수집가를 호출했습니다.</font><font papago-translate="translated"> 간단하죠.</font></p>
<p><font papago-translate="translated">현대의 기계들은 운영 체제의 더 큰 가상 메모리 추상화 뒤에 숨겨진 물리적 RAM을 가지고 있으며, 이는 메모리 덩어리를 차지하기 위해 싸우는 수많은 다른 프로그램들 사이에서 공유됩니다.</font><font papago-translate="translated"> 운영 체제는 프로그램이 원하는 만큼 요청할 수 있도록 허용한 다음 물리적 메모리가 가득 차면 디스크에서 페이지를 열고 나갈 것입니다.</font><font papago-translate="translated"> 기억력이 정말로 "떨어지는" 일은 없고, 점점 더 느려질 뿐입니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/garbage-collection.html#latency-and-throughput" id="latency-and-throughput"><small><font papago-translate="translated">26 . 6 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">지연 시간 및 처리량</font></font></a></h3>
<p><font papago-translate="translated">GC를 실행하기 위해 "해야 할 때까지 기다리는 것은 더 이상 의미가 없으므로 보다 미묘한 타이밍 전략이 필요합니다."</font><font papago-translate="translated"> 이를 보다 정확하게 추론하기 위해 메모리 관리자의 성능을 측정할 때 사용되는 두 가지 기본 수치<em>인 처리량</em>과<em> 지연 시간</em>을 소개할 때입니다.</font></p>
<p><font papago-translate="translated">모든 관리 언어는 명시적이고 사용자가 작성한 할당 해제와 비교하여 성능 대가를 지불합니다.</font><font papago-translate="translated"> 실제로 메모리를 확보하는 데 걸리는 시간은 동일하지만, GC는 어떤 메모리<em></em>를 확보할지 주기적으로 결정합니다.</font><font papago-translate="translated"> 그것은 사용자 코드를 실행하고 유용<em></em>한 작업을 수행하는 데 사용되지 않는 시간입니다.</font><font papago-translate="translated"> 우리의 구현에서는 그것이 마크 단계의 전부입니다.</font><font papago-translate="translated"> 정교한 쓰레기 수거기의 목표는 이러한 부담을 최소화하는 것입니다.</font></p>
<p><font papago-translate="translated">비용을 더 잘 이해하기 위해 사용할 수 있는 두 가지 주요 지표가 있습니다:</font></p>
<ul>
<li>
<p><font papago-translate="splitted"><font papago-translate="translated"><strong>처리량</strong>은 사용자 코드를 실행하는 데 소요된 시간과 쓰레기 수거 작업을 수행하는 데 소요된 시간의 총 비율입니다<strong>.</strong></font><font papago-translate="translated"> 클록스 프로그램을 10초 동안 실행하면 그 1초를 안에서 보낸다고 가정해 보겠습니다 </font></font><code translate="no">collectGarbage()</code><font papago-translate="splitted"><font papago-translate="translated">. 즉, 처리량<span class="em">이</span> 90<span class="em">%</span>라는 뜻입니다. 프로그램 실행 시간의 90%를 차지하고 GC 오버헤드에 10%를 투자했습니다.</font></font></p>
<p><font papago-translate="translated">처리량은 총 수집 비용을 추적하기 때문에 가장 근본적인 측정 기준입니다.</font><font papago-translate="translated"> 다른 모든 것이 동일하다면 처리량을 최대화하고 싶을 것입니다.</font><font papago-translate="translated"> 이 장까지 clox는 GC가 전혀 없어서 처리량<span name="hundred">이 100</span>%였습니다.</font><font papago-translate="translated"> 그건 꽤 어려운 일입니다.</font><font papago-translate="translated"> 물론 사용자의 프로그램이 충분히 오래 실행되면 메모리가 부족해지고 충돌할 수 있다는 약간의 비용이 들었습니다.</font><font papago-translate="translated"> GC의 목표를 가능한 한 적은 처리량을 희생하면서 '결함'을 수정하는 것으로 볼 수 있습니다.</font></p>
</li>
</ul>
<aside name="hundred" style="top: 22924px;">
<p><font papago-translate="translated"><em>글쎄요, 정확히</em> 100%는 아닙니다.</font><font papago-translate="translated"> 할당된 객체를 여전히 연결된 목록에 넣었기 때문에 포인터를 설정하는 데 약간의 오버헤드가 있었습니다.</font></p>
</aside>
<ul>
<li>
<p><font papago-translate="translated"><strong>지연 시간</strong>은 사용자의 프로그램이 완전히 일시 정지된 상태에서 쓰레기 수거가 이루어지는 가장 긴<em> 연속</em> 시간입니다<strong>.</strong></font><font papago-translate="translated"> 수집가가 얼마나 '청키'한지를 측정하는 척도입니다.</font><font papago-translate="translated"> 지연 시간은 처리량과는 완전히 다른 지표입니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">두 번 모두 10초가 걸리는 클록스 프로그램을 두 번 실행한다고 가정해 보겠습니다.</font><font papago-translate="translated"> 첫 번째 실행에서 GC는 한 번 시작하여 1초 동안 견고하게 시간을 보냅니다 </font></font><code translate="no">collectGarbage()</code><font papago-translate="splitted"><font papago-translate="translated"> 하나의 대규모 컬렉션에서.</font><font papago-translate="translated"> 두 번째 실행에서는 GC가 5분의 1초 동안 각각 5번 호출됩니다.</font><font papago-translate="translated"> 수집하는 데 소요되는<em> 총</em> 시간은 여전히 1초이므로 두 경우 모두 처리량이 90%입니다.</font><font papago-translate="translated"> 하지만 두 번째 실행에서는 지연 시간이 1/5초에 불과하여 첫 번째 실행보다 5배 적습니다.</font></font></p>
</li>
</ul>
<p><span name="latency"></span></p><img alt="A bar representing execution time with slices for running user code and running the GC. The largest GC slice is latency. The size of all of the user code slices is throughput." src="https://youhogeon-meritz.github.io/image/garbage-collection/latency-throughput.png">
<aside name="latency" style="top: 23354px;">
<p><font papago-translate="translated">막대는 프로그램 실행을 나타내며, 사용자 코드를 실행하는 데 소요되는 시간과 GC에서 소요되는 시간으로 나뉩니다.</font><font papago-translate="translated"> GC를 실행하는 가장 큰 단일 시간 조각의 크기는 지연 시간입니다.</font><font papago-translate="translated"> 모든 사용자 코드 조각의 크기는 처리량입니다.</font></p>
</aside>
<p><font papago-translate="translated">비유를 좋아하신다면, 귀하의 프로그램이 신선하게 구운 빵을 고객에게 판매하는 베이커리라고 상상해 보세요.</font><font papago-translate="translated"> 처리량은 하루에 고객에게 제공할 수 있는 따뜻하고 딱딱한 바게트의 총 개수입니다.</font><font papago-translate="translated"> 지연 시간은 운이 좋지 않은 고객이 서비스를 받기까지 줄을 서서 기다려야 하는 시간을 말합니다.</font></p>
<p><font papago-translate="translated">쓰레기 수거<span name="dishwasher">기를 운영하는 것</span>은 빵집을 일시적으로 폐쇄하여 모든 설거지를 하고, 깨끗한 곳에서 더러운 것을 골라낸 다음, 사용한 것을 씻는 것과 같습니다<span name="dishwasher">.</span></font><font papago-translate="translated"> 비유하자면, 저희는 전용 식기세척기가 없기 때문에 이 과정에서는 베이킹이 이루어지지 않습니다.</font><font papago-translate="translated"> 제빵사가 씻고 있습니다.</font></p>
<aside name="dishwasher" style="top: 23823.5px;">
<p><font papago-translate="translated">각 사람이 스레드를 나타낸다면, 명백한 최적화는 별도의 스레드가 가비지 컬렉션을 실행하도록 하여<strong> 동시에 가비지 컬렉터</strong>를 제공하는 것입니다.</font><font papago-translate="translated"> 다시 말해, 일부 식기세척기를 고용하여 청소하고 다른 식기세척기는 구우세요.</font><font papago-translate="translated"> 이것이 매우 정교한 GC가 작동하는 이유입니다. 왜냐하면 작업자 스레드인 제빵사들이 사용자 코드를 거의<span class="em"></span><span class="em"></span> 중단 없이 계속 실행할 수 있게 하기 때문입니다.</font></p>
<p><font papago-translate="translated">그러나 조정이 필요합니다.</font><font papago-translate="translated"> 식기세척기가 제빵사의 손에서 그릇을 꺼내는 것을 원하지 않으실 겁니다!</font><font papago-translate="translated"> 이 조정은 오버헤드와 많은 복잡성을 추가합니다.</font><font papago-translate="translated"> 동시 수집기는 빠르지만 올바르게 구현하기는 어렵습니다.</font></p><img alt="Un baguette." class="above" src="https://youhogeon-meritz.github.io/image/garbage-collection/baguette.png">
</aside>
<p><font papago-translate="translated">하루에 빵을 덜 파는 것은 나쁜 일이며, 모든 설거지를 하는 동안 특정 고객을 앉아서 기다리게 하는 것도 마찬가지입니다.</font><font papago-translate="translated"> 목표는 처리량을 극대화하고 지연 시간을 최소화하는 것이지만, 빵집 안에서도 무료 점심은 없습니다.</font><font papago-translate="translated"> 쓰레기 수집가들은 희생하는 처리량과 허용하는 지연 시간 사이에서 서로 다른 절충안을 제시합니다.</font></p>
<p><font papago-translate="translated">이러한 절충안을 만들 수 있는 것은 사용자 프로그램마다 필요한 것이 다르기 때문에 유용합니다.</font><font papago-translate="translated"> 테라바이트의 데이터에서 보고서를 생성하는 야간 배치 작업은 가능한 한 빨리 많은 작업을 완료하기만 하면 됩니다.</font><font papago-translate="translated"> 처리량은 여왕입니다.</font><font papago-translate="translated"> 한편, 사용자의 스마트폰에서 실행되는 앱은 화면을 드래그하는<span name="butter"></span> 것이 부드럽게 느껴질 수 있도록 항상 사용자 입력에 즉시 응답해야 합니다.</font><font papago-translate="translated"> 앱이 몇 초 동안 멈춰지지 않고 GC가 더미 속을 맴돌고 있습니다.</font></p>
<aside name="butter" style="top: 24207.5px;">
<p><font papago-translate="translated">분명히 베이킹 비유가 머릿속에 떠오를 것입니다.</font></p>
</aside>
<p><font papago-translate="translated">쓰레기 수거 작업자로서, 당신은 선택한 수거 알고리즘을 통해 처리량과 지연 시간 사이의 균형을 일부 조절할 수 있습니다.</font><font papago-translate="translated"> 하지만 단일 알고리즘 내에서도 수집기가 얼마나<em> 자주</em> 실행되는지에 대한 많은 제어가 가능합니다.</font></p>
<p><font papago-translate="translated">저희 수집기는<span name="incremental"><strong> 스톱 더 월드</strong></span> G<span name="incremental"><strong>C</strong></span>로, 전체 쓰레기 수거 과정이 완료될 때까지 사용자의 프로그램이 일시 중지됩니다.</font><font papago-translate="translated"> 수집기를 작동시키기 전에 오랜 시간을 기다리면 많은 죽은 물체가 쌓이게 됩니다.</font><font papago-translate="translated"> 이로 인해 수집기가 실행되는 동안 매우 긴 일시 중지가 발생하여 지연 시간이 길어집니다.</font><font papago-translate="translated"> 그래서 분명히, 우리는 수집기를 정말 자주 실행하고 싶습니다.</font></p>
<aside name="incremental" style="top: 24399.5px;">
<p><font papago-translate="translated">반면<strong>에, 점진적인 쓰레기 수집</strong>기는 약간의 수집을 하고, 사용자 코드를 실행한 다음, 조금 더 수집하는 등의 작업을 수행할 수 있습니다.</font></p>
</aside>
<p><font papago-translate="translated">하지만 수집가가 달릴 때마다 살아있는 물체를 방문하는 데 시간을 보냅니다.</font><font papago-translate="translated"> 그것<em></em>은 실제로 유용한 기능을 하지 않습니다 (잘못 삭제되지 않도록 하는 것 외에는).</font><font papago-translate="translated"> 라이브 객체를 방문하는 시간은 메모리를 자유롭게 하지 않는 시간이자 사용자 코드를 실행하지 않는 시간입니다.</font><font papago-translate="translated"> GC를<em> 자주</em> 실행하면 사용자 프로그램이 VM이 수집할 새 쓰레기를 생성할 시간조차 충분하지 않습니다.</font><font papago-translate="translated"> VM은 동일한 라이브 객체 세트를 반복해서 강박적으로 재검토하는 데 모든 시간을 할애하며 처리량에 문제를 일으킬 것입니다.</font><font papago-translate="translated"> 그래서 분명히, 우리는 수집기를 정말<em> 드물게</em> 실행하고 싶습니다.</font></p>
<p><font papago-translate="translated">사실, 우리는 중간에 무언가를 원하고 있으며, 수집기가 실행되는 빈도는 지연 시간과 처리량 간의 균형을 조정하는 주요 손잡이 중 하나입니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/garbage-collection.html#self-adjusting-heap" id="self-adjusting-heap"><small><font papago-translate="translated">26 . 6 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">자동 조정 힙</font></font></a></h3>
<p><font papago-translate="translated">우리는 GC가 지연 시간을 최소화할 만큼 자주 실행되기를 원하지만, 적절한 처리량을 유지할 만큼 드물게 실행되기를 원합니다.</font><font papago-translate="translated"> 하지만 사용자의 프로그램에 얼마나 많은 메모리가 필요하고 얼마나 자주 할당되는지 알 수 없는데, 이들 사이의 균형을 어떻게 찾을 수 있을까요?</font><font papago-translate="translated"> 사용자에게 문제를 맡기고 GC 튜닝 매개변수를 노출하여 선택하도록 강요할 수 있습니다.</font><font papago-translate="translated"> 많은 VM이 이 작업을 수행합니다.</font><font papago-translate="translated"> 하지만 GC 저자들이 잘 조정하는 방법을 모른다면, 대부분의 사용자들도 조정하지 못할 가능성이 높습니다.</font><font papago-translate="translated"> 그들은 합리적인 기본 행동을 취할 자격이 있습니다.</font></p>
<p><font papago-translate="translated">솔직히 말씀드리자면, 이건 제 전문 분야가 아닙니다.</font><font papago-translate="translated"> 저는 여러 전문 GC 해커들과 이야기를 나눴는데, 이는 전체 경력을 쌓을 수 있는 일입니다. 많은 문헌을 읽었는데, 제가 받은 모든 답변은<span class="ellipse"></span><span class="em"></span><span class="em"></span> . . . 모호했습니다.</font><font papago-translate="translated"> 제가 선택한 전략은 흔하고 꽤 간단하며, 대부분의 용도에 충분히 적합하기를 바랍니다.</font></p>
<p><font papago-translate="translated">아이디어는 힙의 라이브 크기에 따라 수집 빈도가 자동으로 조정된다는 것입니다.</font><font papago-translate="translated"> VM이 할당한 관리 메모리의 총 바이트 수를 추적합니다.</font><font papago-translate="translated"> 임계값을 초과하면 GC를 트리거합니다.</font><font papago-translate="translated"> 그 후, 얼마나 많은 메모리가 남아 있는지,<span class="em"></span> 즉 얼마나 많은 메모리가 해방<em>되지 않았는지</em>를 기록합니다.</font><font papago-translate="translated"> 그런 다음 임계값을 그보다 큰 값으로 조정합니다.</font></p>
<p><font papago-translate="translated">그 결과, 라이브 메모리의 양이 증가함에 따라 증가하는 라이브 객체 더미를 다시 이동시켜 처리량을 희생하지 않기 위해 수집 빈도가 줄어듭니다.</font><font papago-translate="translated"> 라이브 메모리의 양이 줄어들수록 너무 오래 기다리면 지연 시간이 너무 길어지지 않도록 더 자주 수집합니다.</font></p>
<p><font papago-translate="translated">구현에는 VM에 두 개의 새로운 부기 필드가 필요합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  ObjUpvalue* openUpvalues;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">VM.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em></em>구조 VM에서</font></font></div>
<pre class="insert" translate="no">
  <span class="t">size_t</span> <span class="i">bytesAllocated</span>;
  <span class="t">size_t</span> <span class="i">nextGC</span>;
</pre><pre class="insert-after" translate="no">  Obj* objects;
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, in struct <em>VM</em></div>
<p><font papago-translate="translated">첫 번째는 VM이 할당한 관리 메모리의 바이트 수에 대한 실행 중인 합계입니다.</font><font papago-translate="translated"> 두 번째는 다음 컬렉션을 트리거하는 임계값입니다.</font><font papago-translate="translated"> VM이 시작되면 초기화합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  vm.objects = NULL;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>initVM</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="i">vm</span>.<span class="i">bytesAllocated</span> = <span class="n">0</span>;
  <span class="i">vm</span>.<span class="i">nextGC</span> = <span class="n">1024</span> * <span class="n">1024</span>;
</pre><pre class="insert-after" translate="no">
  vm.grayCount = 0;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>initVM</em>()</div>
<p><font papago-translate="translated">여기서 시작 임계값<span name="lab">은 임의입니다</span>.</font><font papago-translate="translated"> 우리가 다양한 동적 배열을 위해 선택한 초기 용량과 비슷합니다.</font><font papago-translate="translated"> 목표는 처음 몇 번의 GC를<em> 너무</em> 빨리 트리거하지 않고 너무 오래 기다리지 않는 것입니다.</font><font papago-translate="translated"> 실제 Lox 프로그램이 있다면 프로파일링하여 이를 조정할 수 있습니다.</font><font papago-translate="translated"> 하지만 장난감 프로그램만 있기 때문에 숫자를 선택했습니다.</font></p>
<aside name="lab" style="top: 25943.5px;">
<p><font papago-translate="translated">쓰레기 수거기 학습의 어려움 중 하나는 고립된 실험실 환경에서 모범 사례를 발견하는 것<em>이 매우</em> 어렵다는 점입니다.</font><font papago-translate="translated"> 수집가가 실제로 의도한 크고 복잡한 실제 프로그램에서 실행하지 않으면 실제로 어떤 성능을 발휘하는지 알 수 없습니다.</font><font papago-translate="translated"> 랠리카를 튜닝하는 것과 같아서<span class="em"></span> 코스에서 꺼내야 합니다.</font></p>
</aside>
<p><font papago-translate="translated">메모리를 할당하거나 해제할 때마다 카운터를 해당 델타로 조정합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">void* reallocate(void* pointer, size_t oldSize, size_t newSize) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> ()<em> 재할당</em>에서</font></font></div>
<pre class="insert" translate="no">  <span class="i">vm</span>.<span class="i">bytesAllocated</span> += <span class="i">newSize</span> - <span class="i">oldSize</span>;
</pre><pre class="insert-after" translate="no">  if (newSize &gt; oldSize) {
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>reallocate</em>()</div>
<p><font papago-translate="translated">합계가 한도를 초과하면 수집기를 실행합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    collectGarbage();
#endif
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> ()<em> 재할당</em>에서</font></font></div>
<pre class="insert" translate="no">
    <span class="k">if</span> (<span class="i">vm</span>.<span class="i">bytesAllocated</span> &gt; <span class="i">vm</span>.<span class="i">nextGC</span>) {
      <span class="i">collectGarbage</span>();
    }
</pre><pre class="insert-after" translate="no">  }
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>reallocate</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">마지막으로, 사용자가 숨겨진 진단 플래그를 활성화하지 않은 상태에서 프로그램을 실행하면 쓰레기 수집기가 실제로 무언가를 수행합니다.</font><font papago-translate="translated"> 스위프 단계는 호출을 통해 객체를 자유롭게 합니다 </font></font><code translate="no">reallocate()</code><font papago-translate="splitted"><font papago-translate="translated">, 가치를 낮추는 </font></font><code translate="no">bytesAllocated</code><font papago-translate="splitted"><font papago-translate="translated">, 따라서 컬렉션이 완료된 후에는 얼마나 많은 라이브 바이트가 남아 있는지 알 수 있습니다.</font><font papago-translate="translated"> 이를 바탕으로 다음 GC의 임계값을 조정합니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  sweep();
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>수집</em> 쓰레기()에서</font></font></div>
<pre class="insert" translate="no">
  <span class="i">vm</span>.<span class="i">nextGC</span> = <span class="i">vm</span>.<span class="i">bytesAllocated</span> * <span class="a">GC_HEAP_GROW_FACTOR</span>;
</pre><pre class="insert-after" translate="no">
#ifdef DEBUG_LOG_GC
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>collectGarbage</em>()</div>
<p><font papago-translate="translated">임계값은 힙 크기의 배수입니다.</font><font papago-translate="translated"> 이렇게 하면 프로그램이 사용하는 메모리의 양이 증가함에 따라 임계값이 더 멀리 이동하여 더 큰 라이브 세트를 다시 이동하는 데 소요되는 총 시간을 제한할 수 있습니다.</font><font papago-translate="translated"> 이 장의 다른 숫자들처럼, 스케일링 계수는 기본적으로 임의적입니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#endif
</pre><div class="source-file"><em><font papago-translate="translated">메모리.c</font></em></div>
<pre class="insert" translate="no">
<span class="a">#define GC_HEAP_GROW_FACTOR 2</span>
</pre><pre class="insert-after" translate="no">
void* reallocate(void* pointer, size_t oldSize, size_t newSize) {
</pre></div>
<div class="source-file-narrow"><em>memory.c</em></div>
<p><font papago-translate="translated">실제 벤치마킹할 프로그램이 있으면 구현에서 이를 조정하고 싶을 것입니다.</font><font papago-translate="translated"> 지금 당장은 적어도 일부 통계를 기록할 수 있습니다.</font><font papago-translate="translated"> 수집 전에 힙 크기를 캡처합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  printf("-- gc begin\n");
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>수집</em> 쓰레기()에서</font></font></div>
<pre class="insert" translate="no">  <span class="t">size_t</span> <span class="i">before</span> = <span class="i">vm</span>.<span class="i">bytesAllocated</span>;
</pre><pre class="insert-after" translate="no">#endif
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>collectGarbage</em>()</div>
<p><font papago-translate="translated">그리고 마지막에 결과를 인쇄합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  printf("-- gc end\n");
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>수집</em> 쓰레기()에서</font></font></div>
<pre class="insert" translate="no">  <span class="i">printf</span>(<span class="s">"   collected %zu bytes (from %zu to %zu) next at %zu</span><span class="e">\n</span><span class="s">"</span>,
         <span class="i">before</span> - <span class="i">vm</span>.<span class="i">bytesAllocated</span>, <span class="i">before</span>, <span class="i">vm</span>.<span class="i">bytesAllocated</span>,
         <span class="i">vm</span>.<span class="i">nextGC</span>);
</pre><pre class="insert-after" translate="no">#endif
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>collectGarbage</em>()</div>
<p><font papago-translate="translated">이렇게 하면 쓰레기 수거기가 작동하는 동안 얼마나 많은 성과를 이루었는지 알 수 있습니다.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/garbage-collection.html#garbage-collection-bugs" id="garbage-collection-bugs"><small><font papago-translate="translated">26 . 7</font></small><font papago-translate="splitted"><font papago-translate="translated">쓰레기 수거 버그</font></font></a></h2>
<p><font papago-translate="translated">이론적으로 우리는 이제 모두 끝났습니다.</font><font papago-translate="translated"> GC가 있습니다.</font><font papago-translate="translated"> 주기적으로 시작하여 할 수 있는 것을 모으고 나머지는 남깁니다.</font><font papago-translate="translated"> 이것이 일반적인 교과서라면, 우리는 손에서 먼지를 닦아내고 우리가 만든 완벽한 대리석 장식물의 부드러운 빛을 만끽할 것입니다.</font></p>
<p><font papago-translate="translated">하지만 저는 프로그래밍 언어 이론뿐만 아니라 때로는 고통스러운 현실도 가르쳐드리고자 합니다.</font><font papago-translate="translated"> 썩은 통나무를 굴려서 그 밑에 사는 지저분한 벌레들을 보여드리겠습니다. 쓰레기 수거 벌레들은 정말로 가장 끔찍한 무척추동물 중 하나입니다.</font></p>
<p><font papago-translate="translated">수집가의 임무는 죽은 물체를 풀어주고 살아있는 물체를 보존하는 것입니다.</font><font papago-translate="translated"> 실수는 양방향으로 쉽게 발생할 수 있습니다.</font><font papago-translate="translated"> VM이 필요하지 않은 객체를 해제하지 못하면 메모리가 서서히 유출됩니다.</font><font papago-translate="translated"> 사용 중인 객체를 해제하면 사용자의 프로그램이 잘못된 메모리에 액세스할 수 있습니다.</font><font papago-translate="translated"> 이러한 실패는 종종 즉시 충돌을 일으키지 않기 때문에 버그를 찾기 위해 시간을 거슬러 추적하기가 어렵습니다.</font></p>
<p><font papago-translate="translated">이것은 수집기가 언제 작동할지 모르기 때문에 더 어려워집니다.</font><font papago-translate="translated"> 결국 메모리를 할당하는 모든 호출은 VM에서 수집이 이루어질 수 있는 장소입니다.</font><font papago-translate="translated"> 그것은 마치 음악 의자와 같습니다.</font><font papago-translate="translated"> 언제든지 GC가 음악을 멈출 수 있습니다.</font><font papago-translate="translated"> 우리가 보관하고자 하는 힙 할당된 모든 객체는 스윕 단계가 시작되기 전에 빠르게 의자를 찾아야 합니다. 즉, 루트로 표시되거나 다른 객체에 참조로 저장되어야<span class="em"></span><span class="em"></span> 합니다.</font></p>
<p><font papago-translate="translated">VM이 나중에 GC 자체가<span class="em"></span> 보지 못하는 객체를 어떻게 사용할 수 있습니까?</font><font papago-translate="translated"> VM이 어떻게 찾을 수 있나요?</font><font papago-translate="translated"> 가장 일반적인 답변은 C 스택의 일부 로컬 변수에 저장된 포인터를 통해서입니다.</font><font papago-translate="translated"> GC는 VM의 값과 CallFrame 스택을 이동하지만, C 스택<em></em>은<span name="c"> 그</span> 안<span name="c">에 숨겨져</span> 있습니다.</font></p>
<aside name="c" style="top: 28111.5px;">
<p><font papago-translate="translated">우리 GC는 C 스택에서 주소를 찾을 수 없지만, 많은 주소가 찾을 수 있습니다.</font><font papago-translate="translated"> 보수적인 쓰레기 수집가들은 네이티브 스택을 포함한 모든 메모리를 살펴봅니다.</font><font papago-translate="translated"> 이 품종 중 가장 잘 알려진 것은 보<a href="https://en.wikipedia.org/wiki/Boehm_garbage_collector"><strong>엠-데머스</strong></a>입니다</font><font papago-translate="translated"><a href="https://en.wikipedia.org/wiki/Boehm_garbage_collector"><strong>와이저 쓰레기 수집</strong></a>기는 보통 "보엠 수집기"라고 불립니다.</font><font papago-translate="translated"> CS에서 명성을 얻기 위한 가장 짧은 경로는 알파벳 순서로 이른 성으로, 정렬된 이름 목록에서 가장 먼저 나타납니다</font></p>
<p><font papago-translate="translated">많은 정밀한 GC들도 C 스택을 걷습니다.</font><font papago-translate="translated"> CPU<em> 레지스터</em>에만 존재하는 살아있는 객체에 대한 포인터에 대해서도 주의해야 합니다.</font></p>
</aside>
<p><font papago-translate="translated">이전 장에서 우리는 대상을 VM의 가치 스택에 밀어 넣고, 약간의 작업을 한 다음 바로 꺼내는 무의미해 보이는 코드를 작성했습니다.</font><font papago-translate="translated"> 대부분의 경우, 저는 이것이 GC의 이익을 위한 것이라고 말했습니다.</font><font papago-translate="translated"> 이제 이유를 알겠군요.</font><font papago-translate="translated"> 푸시와 팝핑 사이의 코드는 잠재적으로 메모리를 할당하여 GC를 트리거할 수 있습니다.</font><font papago-translate="translated"> 수집가의 마크 단계에서 객체를 찾아서 유지할 수 있도록 객체가 가치 스택에 있는지 확인해야 했습니다.</font></p>
<p><font papago-translate="translated">저는 클록스 구현 전체를 작성한 후 챕터로 나누고 산문을 작성했습니다. 그래서 이 모든 코너를 찾아서 대부분의 버그를 제거할 시간이 충분했습니다.</font><font papago-translate="translated"> 이 장의 처음에 입력한 스트레스 테스트 코드와 꽤 좋은 테스트 모음은 매우 도움이 되었습니다.</font></p>
<p><font papago-translate="translated">하지만<em> 대부분</em>만 고쳤습니다.</font><font papago-translate="translated"> 야생에서 이러한 벌레를 접하는 것이 어떤 느낌인지 알려드리고 싶어서 몇 가지를 남겼습니다.</font><font papago-translate="translated"> 스트레스 테스트 플래그를 활성화하고 장난감 Lox 프로그램을 실행하면 몇 가지를 발견할 수 있습니다.</font><font papago-translate="translated"> <em>직접 고쳐볼 수 있는지 한번</em> 시도해 보세요.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/garbage-collection.html#adding-to-the-constant-table" id="adding-to-the-constant-table"><small><font papago-translate="translated">26 . 7 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">상수 테이블에 추가하기</font></font></a></h3>
<p><font papago-translate="translated">첫 번째 버그를 발생시킬 가능성이 매우 높습니다.</font><font papago-translate="translated"> 각 청크가 소유한 상수 테이블은 동적 배열입니다.</font><font papago-translate="translated"> 컴파일러가 현재 함수의 테이블에 새 상수를 추가하면 해당 배열이 확장되어야 할 수도 있습니다.</font><font papago-translate="translated"> 상수 자체는 문자열이나 중첩 함수와 같은 힙 할당된 객체일 수도 있습니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">상수 테이블에 추가되는 새 개체는 다음에 전달됩니다 </font></font><code translate="no">addConstant()</code><font papago-translate="splitted"><font papago-translate="translated">. 그 순간 객체는 C 스택의 해당 함수에 대한 매개변수에서만 찾을 수 있습니다.</font><font papago-translate="translated"> 그 함수는 객체를 상수 테이블에 추가합니다.</font><font papago-translate="translated"> 테이블의 용량이 충분하지 않아 확장이 필요한 경우 다음과 같이 호출합니다 </font></font><code translate="no">reallocate()</code><font papago-translate="splitted"><font papago-translate="translated">. 그러면 GC가 발생하여 새로운 상수 객체를 표시하지 못하고 테이블에 추가할 기회가 생기기 직전에 해당 객체를 쓸어버립니다.</font><font papago-translate="translated"> 충돌.</font></font></p>
<p><font papago-translate="translated">다른 곳에서 보셨듯이, 해결책은 상수를 일시적으로 스택 위에 밀어 넣는 것입니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">int addConstant(Chunk* chunk, Value value) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">청크</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> ad<em>dConstant</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="i">push</span>(<span class="i">value</span>);
</pre><pre class="insert-after" translate="no">  writeValueArray(&amp;chunk-&gt;constants, value);
</pre></div>
<div class="source-file-narrow"><em>chunk.c</em>, in <em>addConstant</em>()</div>
<p><font papago-translate="translated">상수 테이블에 객체가 포함되면, 우리는 그것을 스택에서 꺼냅니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  writeValueArray(&amp;chunk-&gt;constants, value);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">청크</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> ad<em>dConstant</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="i">pop</span>();
</pre><pre class="insert-after" translate="no">  return chunk-&gt;constants.count - 1;
</pre></div>
<div class="source-file-narrow"><em>chunk.c</em>, in <em>addConstant</em>()</div>
<p><font papago-translate="translated">GC가 루트를 표시할 때 컴파일러 체인을 걸어 다니며 각 함수를 표시하므로 이제 새로운 상수에 도달할 수 있습니다.</font><font papago-translate="translated"> "청크" 모듈에서 VM을 호출하려면 포함 항목이 필요합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#include "memory.h"
</pre><div class="source-file"><em><font papago-translate="translated">청크</font></em></div>
<pre class="insert" translate="no"><span class="a">#include "vm.h"</span>
</pre><pre class="insert-after" translate="no">
void initChunk(Chunk* chunk) {
</pre></div>
<div class="source-file-narrow"><em>chunk.c</em></div>
<h3><a href="https://youhogeon-meritz.github.io/garbage-collection.html#interning-strings" id="interning-strings"><small><font papago-translate="translated">26 . 7 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">인터닝 스트링</font></font></a></h3>
<p><font papago-translate="translated">여기 또 비슷한 것이 있습니다.</font><font papago-translate="translated"> 모든 문자열은 clox에 삽입되므로 새 문자열을 만들 때마다 인턴 테이블에 추가합니다.</font><font papago-translate="translated"> 이게 어디로 가는지 알 수 있습니다.</font><font papago-translate="translated"> 문자열이 새 것이기 때문에 어디에도 도달할 수 없습니다.</font><font papago-translate="translated"> 문자열 풀의 크기를 조정하면 컬렉션을 트리거할 수 있습니다.</font><font papago-translate="translated"> 다시 말씀드리지만, 먼저 문자열을 스택에 저장합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  string-&gt;chars = chars;
  string-&gt;hash = hash;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>allocateString</em>()에서</font></font></div>
<pre class="insert" translate="no">
  <span class="i">push</span>(<span class="a">OBJ_VAL</span>(<span class="i">string</span>));
</pre><pre class="insert-after" translate="no">  tableSet(&amp;vm.strings, string, NIL_VAL);
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>allocateString</em>()</div>
<p><font papago-translate="translated">그런 다음 테이블에 안전하게 고정되면 다시 꺼냅니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  tableSet(&amp;vm.strings, string, NIL_VAL);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>allocateString</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="i">pop</span>();

</pre><pre class="insert-after" translate="no">  return string;
}
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>allocateString</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">이렇게 하면 테이블 크기를 조정하는 동안 끈이 안전해집니다.</font><font papago-translate="translated"> 일단 그것이 살아남으면, </font></font><code translate="no">allocateString()</code><font papago-translate="splitted"><font papago-translate="translated"> 다음 힙 할당이 발생하기 전에 문자열이 여전히 도달할 수 있도록 책임을 지는 발신자에게 반환합니다.</font></font></p>
<h3><a href="https://youhogeon-meritz.github.io/garbage-collection.html#concatenating-strings" id="concatenating-strings"><small><font papago-translate="translated">26 . 7 . 3</font></small><font papago-translate="splitted"><font papago-translate="translated">끈 연결하기</font></font></a></h3>
<p><font papago-translate="splitted"><font papago-translate="translated">마지막 예시 하나:</font><font papago-translate="translated"> 통역사 너머에서 </font></font><code translate="no">OP_ADD</code><font papago-translate="splitted"><font papago-translate="translated"> 명령어는 두 문자열을 연결하는 데 사용할 수 있습니다.</font><font papago-translate="translated"> 숫자와 마찬가지로 스택에서 두 피연산자를 터뜨리고 결과를 계산한 다음 새로운 값을 다시 스택으로 밀어 넣습니다.</font><font papago-translate="translated"> 숫자로는 완벽하게 안전합니다.</font></font></p>
<p><font papago-translate="translated">그러나 두 문자열을 연결하려면 힙에 새로운 문자 배열을 할당해야 하며, 이는 다시 GC를 트리거할 수 있습니다.</font><font papago-translate="translated"> 이미 그 시점에서 피연산자 문자열을 터뜨렸기 때문에 마크 단계에서 놓쳐서 휩쓸릴 수 있습니다.</font><font papago-translate="translated"> 그것들을 열심히 쌓아 올리는 대신, 우리는 그것들을 엿봅니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">static void concatenate() {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>연결</em>된 ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 두 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">  <span class="t">ObjString</span>* <span class="i">b</span> = <span class="a">AS_STRING</span>(<span class="i">peek</span>(<span class="n">0</span>));
  <span class="t">ObjString</span>* <span class="i">a</span> = <span class="a">AS_STRING</span>(<span class="i">peek</span>(<span class="n">1</span>));
</pre><pre class="insert-after" translate="no">
  int length = a-&gt;length + b-&gt;length;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>concatenate</em>(), replace 2 lines</div>
<p><font papago-translate="translated">그렇게 하면 결과 문자열을 만들 때에도 스택에 여전히 남아 있습니다.</font><font papago-translate="translated"> 완료되면 안전하게 출발시켜 결과로 대체할 수 있습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  ObjString* result = takeString(chars, length);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>연결</em>된 ()에서</font></font></div>
<pre class="insert" translate="no">  <span class="i">pop</span>();
  <span class="i">pop</span>();
</pre><pre class="insert-after" translate="no">  push(OBJ_VAL(result));
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>concatenate</em>()</div>
<p><font papago-translate="translated">그것들은 모두 꽤 쉬웠습니다. 특히 제가 해결책을<em> 보여</em>드렸기 때문입니다.</font><font papago-translate="translated"> 실제로 그것들<em>을 찾는</em> 것이 어려운 부분입니다.</font><font papago-translate="translated"> 당신이 보는 것은 존재해야 하지만 존재<em></em>하지 않는 물체뿐입니다.</font><font papago-translate="translated"> 문제<em>를 일으키는</em> 코드를 찾는 다른 버그와는 다릅니다.</font><font papago-translate="translated"> 문제<em>를 예방</em>하지 못하는 코드<em>의 부재</em>를 찾고 있으며, 이는 훨씬 더 어려운 검색입니다.</font></p>
<p><font papago-translate="translated">하지만 적어도 지금은 안심하셔도 됩니다.</font><font papago-translate="translated"> 제가 아는 한, 우리는 clox에서 모든 수집 버그를 발견했고, 이제 작동하고 견고하며 자동 조정이 가능한 마크 스위핑 쓰레기 수집기를 갖게 되었습니다.</font></p>
<div class="challenges">
<h2><a href="https://youhogeon-meritz.github.io/garbage-collection.html#challenges" id="challenges"><font papago-translate="translated">과제들</font></a></h2>
<ol>
<li>
<p><font papago-translate="splitted"><font papago-translate="translated">각 객체의 상단에 있는 Obj 헤더 구조에는 이제 세 개의 필드가 있습니다: </font></font><code translate="no">type</code><font papago-translate="splitted"><font papago-translate="translated">, </font></font><code translate="no">isMarked</code><font papago-translate="splitted"><font papago-translate="translated">,그리고. </font></font><code translate="no">next</code><font papago-translate="splitted"><font papago-translate="translated">. 그것들이 (당신의 기기에서) 얼마나 많은 메모리를 차지합니까?</font><font papago-translate="translated"> 좀 더 컴팩트한 것을 생각해낼 수 있나요?</font><font papago-translate="translated"> 그렇게 하는 데 런타임 비용이 있나요?</font></font></p>
</li>
<li>
<p><font papago-translate="splitted"><font papago-translate="translated">스위프 단계가 활성 객체를 통과할 때 다음을 지웁니다 </font></font><code translate="no">isMarked</code><font papago-translate="splitted"><font papago-translate="translated"> 다음 수집 주기를 준비하기 위한 필드.</font><font papago-translate="translated"> 더 효율적인 접근 방식을 생각해낼 수 있나요?</font></font></p>
</li>
<li>
<p><font papago-translate="translated">마크 스위프는 다양한 쓰레기 수거 알고리즘 중 하나일 뿐입니다.</font><font papago-translate="translated"> 전류 수집기를 다른 수집기로 교체하거나 보강하여 이를 탐구합니다.</font><font papago-translate="translated"> 고려해야 할 좋은 후보로는 참조 카운팅, 체니 알고리즘, 또는 리스프 2 마크 콤팩트 알고리즘이 있습니다.</font></p>
</li>
</ol>
</div>
<div class="design-note">
<h2><a href="https://youhogeon-meritz.github.io/garbage-collection.html#design-note" id="design-note"><font papago-translate="translated">디자인 노트:</font><font papago-translate="translated"> 세대 수집가</font></a></h2>
<p><font papago-translate="translated">수집가가 아직 살아있는 객체를 다시 방문하는 데 오랜 시간을 보내면 처리량이 감소합니다.</font><font papago-translate="translated"> 하지만 수거를 피하고 많은 쓰레기를 쌓아두면 지연 시간이 늘어날 수 있습니다.</font><font papago-translate="translated"> 어떤 물체가 오래 살 가능성이 높고 어떤 물체가 살지 구분할 수 있는 방법이 있었다면 좋았을 것입니다.</font><font papago-translate="translated"> 그러면 GC는 오래 지속된 것들을 자주 다시 방문하지 않고 일시적인 것들을 더 자주 정리할 수 있습니다.</font></p>
<p><font papago-translate="translated">알고 보니 그런 것 같습니다.</font><font papago-translate="translated"> 수년 전, GC 연구자들은 실제 실행 중인 프로그램에서 객체의 수명에 대한 지표를 수집했습니다.</font><font papago-translate="translated"> 그들은 모든 물체가 할당되었을 때와 결국 더 이상 필요하지 않을 때를 추적한 다음, 물체의 수명을 그래프로 표시했습니다.</font></p>
<p><font papago-translate="translated">그들은<strong> 세대 가설</strong> 또는 훨씬 덜 재치 있는 용어<strong>인 영아 사망률</strong>이라는 것을 발견했습니다.</font><font papago-translate="translated"> 그들의 관찰에 따르면 대부분의 물체는 수명이 매우 짧지만, 일단 특정 연령을 넘어서 생존하면 꽤 오랜 시간 동안 머무르는 경향이 있습니다.</font><font papago-translate="translated"> 물체가 오래 살수록<em> 더</em> 오래<em></em> 살 가능성이 높습니다.</font><font papago-translate="translated"> 이 관찰은 객체를 자주 수집하는 그룹과 그렇지 않은 그룹으로 나누는 방법에 대한 핸들링을 제공했기 때문에 강력합니다.</font></p>
<p><font papago-translate="translated">그들은<strong> 세대 쓰레기 수거</strong>라는 기술을 설계했습니다.</font><font papago-translate="translated"> 다음과 같이 작동합니다:</font><font papago-translate="translated"> 새로운 객체가 할당될 때마다, 그것은 "양육 시설"이라고 불리는 특별하고 비교적 작은 힙 영역으로 들어갑니다.</font><font papago-translate="translated"> 물건들이 일찍 죽는 경향이 있기 때문에, 쓰레기 수거기는 이 지역의 물건들 위에서<span name="nursery"> 자주</span> 호출됩니다.</font></p>
<aside name="nursery" style="top: 31893.5px;">
<p><font papago-translate="translated">보육원은 일반적으로 복사 수집기를 사용하여 관리되며, 이는 마크 스위핑 수집기보다 객체를 할당하고 자유롭게 하는 데 더 빠릅니다.</font></p>
</aside>
<p><font papago-translate="translated">GC가 보육원을 지나갈 때마다 이를 "세대"라고 합니다.</font><font papago-translate="translated"> 더 이상 필요하지 않은 모든 물체는 해방됩니다.</font><font papago-translate="translated"> 살아남은 개체는 이제 한 세대 더 오래된 것으로 간주되며, GC는 각 개체에 대해 이를 추적합니다.</font><font papago-translate="translated"> 객체가 특정 세대(종종 단일 컬렉션) 동안 살아남으면<em>, 그</em> 객체<span class="em"></span><span class="em"></span><em>는 영구적</em>으로<em> 유지</em>됩니다.</font><font papago-translate="translated"> 이 시점에서, 그것은 오래 사는 물건들을 위해 훨씬 더 큰 더미 영역으로 복사됩니다.</font><font papago-translate="translated"> 쓰레기 수집기도 그 지역을 가로지르지만, 대부분의 물건이 여전히 살아 있을 확률이 높기 때문에 훨씬 덜 자주 사용됩니다.</font></p>
<p><font papago-translate="translated">세대 수집가는 객체 수명이 고르게 분포<em>되지 않는다는</em> 관찰과 그<span class="em"></span><span class="em"></span> 사실을 활용한 영리한 알고리즘 설계라는 경험적 데이터의 아름다운 결합입니다.</font><font papago-translate="translated"> 그것들은 또한 개념적으로 꽤 간단합니다.</font><font papago-translate="translated"> 하나는 두 개의 개별적으로 조정된 GC와 객체를 하나에서 다른 하나로 이동시키는 매우 간단한 정책으로 생각할 수 있습니다.</font></p>
</div>
<footer>
<a class="next" href="https://youhogeon-meritz.github.io/classes-and-instances.html"><font papago-translate="translated"> 다음 장: "클래스와 인스턴스" → </font></a><font papago-translate="splitted"><font papago-translate="translated"> 로버트 니스트롬이 수작업으로 제작한 -<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE"> © 2015 ~ 2021</a></font></font>
</footer>
</article>
</div>


</body></html>