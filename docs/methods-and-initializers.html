<!DOCTYPE html>

<html>
<head>
<meta content="text/html;charset=utf-8" http-equiv="Content-type"/>
<title>Methods and Initializers · Crafting Interpreters</title>
<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<link href="style.css" rel="stylesheet" type="text/css"/>
<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600" rel="stylesheet" type="text/css"/>
<link href="image/favicon.png" rel="icon" type="image/png">
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>
<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>
</link></head>
<body id="top">
<!-- <div class="scrim"></div> -->
<nav class="wide">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"/></a>
<div class="contents">
<h3><a href="#top">Methods and Initializers<small>28</small></a></h3>
<ul>
<li><a href="#method-declarations"><small>28.1</small> Method Declarations</a></li>
<li><a href="#method-references"><small>28.2</small> Method References</a></li>
<li><a href="#this"><small>28.3</small> This</a></li>
<li><a href="#instance-initializers"><small>28.4</small> Instance Initializers</a></li>
<li><a href="#optimized-invocations"><small>28.5</small> Optimized Invocations</a></li>
<li class="divider"></li>
<li class="end-part"><a href="#challenges">Challenges</a></li>
<li class="end-part"><a href="#design-note"><small>note</small>Novelty Budget</a></li>
</ul>
<div class="prev-next">
<a class="left" href="classes-and-instances.html" title="Classes and Instances">← Previous</a>
<a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">↑ Up</a>
<a class="right" href="superclasses.html" title="Superclasses">Next →</a>
</div> </div>
</nav>
<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"/></a>
<a class="prev" href="classes-and-instances.html" title="Classes and Instances">←</a>
<a class="next" href="superclasses.html" title="Superclasses">→</a>
</nav>
<div class="page">
<div class="nav-wrapper">
<nav class="floating">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"/></a>
<div class="expandable">
<h3><a href="#top">Methods and Initializers<small>28</small></a></h3>
<ul>
<li><a href="#method-declarations"><small>28.1</small> Method Declarations</a></li>
<li><a href="#method-references"><small>28.2</small> Method References</a></li>
<li><a href="#this"><small>28.3</small> This</a></li>
<li><a href="#instance-initializers"><small>28.4</small> Instance Initializers</a></li>
<li><a href="#optimized-invocations"><small>28.5</small> Optimized Invocations</a></li>
<li class="divider"></li>
<li class="end-part"><a href="#challenges">Challenges</a></li>
<li class="end-part"><a href="#design-note"><small>note</small>Novelty Budget</a></li>
</ul>
<div class="prev-next">
<a class="left" href="classes-and-instances.html" title="Classes and Instances">← Previous</a>
<a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">↑ Up</a>
<a class="right" href="superclasses.html" title="Superclasses">Next →</a>
</div> </div>
<a id="expand-nav">≡</a>
</nav>
</div>
<article class="chapter">
<div class="number">28</div>
<h1>Methods and Initializers</h1>
<blockquote>
<p>When you are on the dancefloor, there is nothing to do but dance.</p>
<p><cite>Umberto Eco, <em>The Mysterious Flame of Queen Loana</em></cite></p>
</blockquote>
<p>It is time for our virtual machine to bring its nascent objects to life with
behavior. That means methods and method calls. And, since they are a special
kind of method, initializers too.</p>
<p>All of this is familiar territory from our previous jlox interpreter. What’s new
in this second trip is an important optimization we’ll implement to make method
calls over seven times faster than our baseline performance. But before we get
to that fun, we gotta get the basic stuff working.</p>
<h2><a href="#method-declarations" id="method-declarations"><small>28 . 1</small>Method Declarations</a></h2>
<p>We can’t optimize method calls before we have method calls, and we can’t call
methods without having methods to call, so we’ll start with declarations.</p>
<h3><a href="#representing-methods" id="representing-methods"><small>28 . 1 . 1</small>Representing methods</a></h3>
<p>We usually start in the compiler, but let’s knock the object model out first
this time. The runtime representation for methods in clox is similar to that of
jlox. Each class stores a hash table of methods. Keys are method names, and each
value is an ObjClosure for the body of the method.</p>
<div class="codehilite"><pre class="insert-before" translate="no">typedef struct {
  Obj obj;
  ObjString* name;
</pre><div class="source-file"><em>object.h</em><br/>
in struct <em>ObjClass</em></div>
<pre class="insert" translate="no">  <span class="t">Table</span> <span class="i">methods</span>;
</pre><pre class="insert-after" translate="no">} ObjClass;
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, in struct <em>ObjClass</em></div>
<p>A brand new class begins with an empty method table.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  klass-&gt;name = name;<span name="klass"> </span>
</pre><div class="source-file"><em>object.c</em><br/>
in <em>newClass</em>()</div>
<pre class="insert" translate="no">  <span class="i">initTable</span>(&amp;<span class="i">klass</span>-&gt;<span class="i">methods</span>);
</pre><pre class="insert-after" translate="no">  return klass;
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>newClass</em>()</div>
<p>The ObjClass struct owns the memory for this table, so when the memory manager
deallocates a class, the table should be freed too.</p>
<div class="codehilite"><pre class="insert-before" translate="no">    case OBJ_CLASS: {
</pre><div class="source-file"><em>memory.c</em><br/>
in <em>freeObject</em>()</div>
<pre class="insert" translate="no">      <span class="t">ObjClass</span>* <span class="i">klass</span> = (<span class="t">ObjClass</span>*)<span class="i">object</span>;
      <span class="i">freeTable</span>(&amp;<span class="i">klass</span>-&gt;<span class="i">methods</span>);
</pre><pre class="insert-after" translate="no">      FREE(ObjClass, object);
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>freeObject</em>()</div>
<p>Speaking of memory managers, the GC needs to trace through classes into the
method table. If a class is still reachable (likely through some instance),
then all of its methods certainly need to stick around too.</p>
<div class="codehilite"><pre class="insert-before" translate="no">      markObject((Obj*)klass-&gt;name);
</pre><div class="source-file"><em>memory.c</em><br/>
in <em>blackenObject</em>()</div>
<pre class="insert" translate="no">      <span class="i">markTable</span>(&amp;<span class="i">klass</span>-&gt;<span class="i">methods</span>);
</pre><pre class="insert-after" translate="no">      break;
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>blackenObject</em>()</div>
<p>We use the existing <code translate="no">markTable()</code> function, which traces through the key string
and value in each table entry.</p>
<p>Storing a class’s methods is pretty familiar coming from jlox. The different
part is how that table gets populated. Our previous interpreter had access to
the entire AST node for the class declaration and all of the methods it
contained. At runtime, the interpreter simply walked that list of declarations.</p>
<p>Now every piece of information the compiler wants to shunt over to the runtime
has to squeeze through the interface of a flat series of bytecode instructions.
How do we take a class declaration, which can contain an arbitrarily large set
of methods, and represent it as bytecode? Let’s hop over to the compiler and
find out.</p>
<h3><a href="#compiling-method-declarations" id="compiling-method-declarations"><small>28 . 1 . 2</small>Compiling method declarations</a></h3>
<p>The last chapter left us with a compiler that parses classes but allows only an
empty body. Now we insert a little code to compile a series of method
declarations between the braces.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  consume(TOKEN_LEFT_BRACE, "Expect '{' before class body.");
</pre><div class="source-file"><em>compiler.c</em><br/>
in <em>classDeclaration</em>()</div>
<pre class="insert" translate="no">  <span class="k">while</span> (!<span class="i">check</span>(<span class="a">TOKEN_RIGHT_BRACE</span>) &amp;&amp; !<span class="i">check</span>(<span class="a">TOKEN_EOF</span>)) {
    <span class="i">method</span>();
  }
</pre><pre class="insert-after" translate="no">  consume(TOKEN_RIGHT_BRACE, "Expect '}' after class body.");
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>classDeclaration</em>()</div>
<p>Lox doesn’t have field declarations, so anything before the closing brace at the
end of the class body must be a method. We stop compiling methods when we hit
that final curly or if we reach the end of the file. The latter check ensures
our compiler doesn’t get stuck in an infinite loop if the user accidentally
forgets the closing brace.</p>
<p>The tricky part with compiling a class declaration is that a class may declare
any number of methods. Somehow the runtime needs to look up and bind all of
them. That would be a lot to pack into a single <code translate="no">OP_CLASS</code> instruction. Instead,
the bytecode we generate for a class declaration will split the process into a
<span name="series"><em>series</em></span> of instructions. The compiler already emits
an <code translate="no">OP_CLASS</code> instruction that creates a new empty ObjClass object. Then it
emits instructions to store the class in a variable with its name.</p>
<aside name="series">
<p>We did something similar for closures. The <code translate="no">OP_CLOSURE</code> instruction needs to
know the type and index for each captured upvalue. We encoded that using a
series of pseudo-instructions following the main <code translate="no">OP_CLOSURE</code> instruction<span class="em">—</span>basically a variable number of operands. The VM processes all of those extra
bytes immediately when interpreting the <code translate="no">OP_CLOSURE</code> instruction.</p>
<p>Here our approach is a little different because from the VM’s perspective, each
instruction to define a method is a separate stand-alone operation. Either
approach would work. A variable-sized pseudo-instruction is possibly marginally
faster, but class declarations are rarely in hot loops, so it doesn’t matter
much.</p>
</aside>
<p>Now, for each method declaration, we emit a new <code translate="no">OP_METHOD</code> instruction that
adds a single method to that class. When all of the <code translate="no">OP_METHOD</code> instructions
have executed, we’re left with a fully formed class. While the user sees a class
declaration as a single atomic operation, the VM implements it as a series of
mutations.</p>
<p>To define a new method, the VM needs three things:</p>
<ol>
<li>
<p>The name of the method.</p>
</li>
<li>
<p>The closure for the method body.</p>
</li>
<li>
<p>The class to bind the method to.</p>
</li>
</ol>
<p>We’ll incrementally write the compiler code to see how those all get through to
the runtime, starting here:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br/>
add after <em>function</em>()</div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">method</span>() {
  <span class="i">consume</span>(<span class="a">TOKEN_IDENTIFIER</span>, <span class="s">"Expect method name."</span>);
  <span class="t">uint8_t</span> <span class="i">constant</span> = <span class="i">identifierConstant</span>(&amp;<span class="i">parser</span>.<span class="i">previous</span>);
  <span class="i">emitBytes</span>(<span class="a">OP_METHOD</span>, <span class="i">constant</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>function</em>()</div>
<p>Like <code translate="no">OP_GET_PROPERTY</code> and other instructions that need names at runtime, the
compiler adds the method name token’s lexeme to the constant table, getting back
a table index. Then we emit an <code translate="no">OP_METHOD</code> instruction with that index as the
operand. That’s the name. Next is the method body:</p>
<div class="codehilite"><pre class="insert-before" translate="no">  uint8_t constant = identifierConstant(&amp;parser.previous);
</pre><div class="source-file"><em>compiler.c</em><br/>
in <em>method</em>()</div>
<pre class="insert" translate="no">

  <span class="t">FunctionType</span> <span class="i">type</span> = <span class="a">TYPE_FUNCTION</span>;
  <span class="i">function</span>(<span class="i">type</span>);
</pre><pre class="insert-after" translate="no">  emitBytes(OP_METHOD, constant);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>method</em>()</div>
<p>We use the same <code translate="no">function()</code> helper that we wrote for compiling function
declarations. That utility function compiles the subsequent parameter list and
function body. Then it emits the code to create an ObjClosure and leave it on
top of the stack. At runtime, the VM will find the closure there.</p>
<p>Last is the class to bind the method to. Where can the VM find that?
Unfortunately, by the time we reach the <code translate="no">OP_METHOD</code> instruction, we don’t know
where it is. It <span name="global">could</span> be on the stack, if the user
declared the class in a local scope. But a top-level class declaration ends up
with the ObjClass in the global variable table.</p>
<aside name="global">
<p>If Lox supported declaring classes only at the top level, the VM could assume
that any class could be found by looking it up directly from the global
variable table. Alas, because we support local classes, we need to handle that
case too.</p>
</aside>
<p>Fear not. The compiler does know the <em>name</em> of the class. We can capture it
right after we consume its token.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  consume(TOKEN_IDENTIFIER, "Expect class name.");
</pre><div class="source-file"><em>compiler.c</em><br/>
in <em>classDeclaration</em>()</div>
<pre class="insert" translate="no">  <span class="t">Token</span> <span class="i">className</span> = <span class="i">parser</span>.<span class="i">previous</span>;
</pre><pre class="insert-after" translate="no">  uint8_t nameConstant = identifierConstant(&amp;parser.previous);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>classDeclaration</em>()</div>
<p>And we know that no other declaration with that name could possibly shadow the
class. So we do the easy fix. Before we start binding methods, we emit whatever
code is necessary to load the class back on top of the stack.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  defineVariable(nameConstant);

</pre><div class="source-file"><em>compiler.c</em><br/>
in <em>classDeclaration</em>()</div>
<pre class="insert" translate="no">  <span class="i">namedVariable</span>(<span class="i">className</span>, <span class="k">false</span>);
</pre><pre class="insert-after" translate="no">  consume(TOKEN_LEFT_BRACE, "Expect '{' before class body.");
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>classDeclaration</em>()</div>
<p>Right before compiling the class body, we <span name="load">call</span>
<code translate="no">namedVariable()</code>. That helper function generates code to load a variable with
the given name onto the stack. Then we compile the methods.</p>
<aside name="load">
<p>The preceding call to <code translate="no">defineVariable()</code> pops the class, so it seems silly to
call <code translate="no">namedVariable()</code> to load it right back onto the stack. Why not simply
leave it on the stack in the first place? We could, but in the <a href="superclasses.html">next
chapter</a> we will insert code between these two calls to support
inheritance. At that point, it will be simpler if the class isn’t sitting around
on the stack.</p>
</aside>
<p>This means that when we execute each <code translate="no">OP_METHOD</code> instruction, the stack has the
method’s closure on top with the class right under it. Once we’ve reached the
end of the methods, we no longer need the class and tell the VM to pop it off
the stack.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  consume(TOKEN_RIGHT_BRACE, "Expect '}' after class body.");
</pre><div class="source-file"><em>compiler.c</em><br/>
in <em>classDeclaration</em>()</div>
<pre class="insert" translate="no">  <span class="i">emitByte</span>(<span class="a">OP_POP</span>);
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>classDeclaration</em>()</div>
<p>Putting all of that together, here is an example class declaration to throw at
the compiler:</p>
<div class="codehilite"><pre translate="no"><span class="k">class</span> <span class="t">Brunch</span> {
  <span class="i">bacon</span>() {}
  <span class="i">eggs</span>() {}
}
</pre></div>
<p>Given that, here is what the compiler generates and how those instructions
affect the stack at runtime:</p><img alt="The series of bytecode instructions for a class declaration with two methods." src="image/methods-and-initializers/method-instructions.png">
<p>All that remains for us is to implement the runtime for that new <code translate="no">OP_METHOD</code>
instruction.</p>
<h3><a href="#executing-method-declarations" id="executing-method-declarations"><small>28 . 1 . 3</small>Executing method declarations</a></h3>
<p>First we define the opcode.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  OP_CLASS,
</pre><div class="source-file"><em>chunk.h</em><br/>
in enum <em>OpCode</em></div>
<pre class="insert" translate="no">  <span class="a">OP_METHOD</span>
</pre><pre class="insert-after" translate="no">} OpCode;
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>
<p>We disassemble it like other instructions that have string constant operands.</p>
<div class="codehilite"><pre class="insert-before" translate="no">    case OP_CLASS:
      return constantInstruction("OP_CLASS", chunk, offset);
</pre><div class="source-file"><em>debug.c</em><br/>
in <em>disassembleInstruction</em>()</div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="a">OP_METHOD</span>:
      <span class="k">return</span> <span class="i">constantInstruction</span>(<span class="s">"OP_METHOD"</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
</pre><pre class="insert-after" translate="no">    default:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>
<p>And over in the interpreter, we add a new case too.</p>
<div class="codehilite"><pre class="insert-before" translate="no">        break;
</pre><div class="source-file"><em>vm.c</em><br/>
in <em>run</em>()</div>
<pre class="insert" translate="no">      <span class="k">case</span> <span class="a">OP_METHOD</span>:
        <span class="i">defineMethod</span>(<span class="a">READ_STRING</span>());
        <span class="k">break</span>;
</pre><pre class="insert-after" translate="no">    }
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p>There, we read the method name from the constant table and pass it here:</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br/>
add after <em>closeUpvalues</em>()</div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">defineMethod</span>(<span class="t">ObjString</span>* <span class="i">name</span>) {
  <span class="t">Value</span> <span class="i">method</span> = <span class="i">peek</span>(<span class="n">0</span>);
  <span class="t">ObjClass</span>* <span class="i">klass</span> = <span class="a">AS_CLASS</span>(<span class="i">peek</span>(<span class="n">1</span>));
  <span class="i">tableSet</span>(&amp;<span class="i">klass</span>-&gt;<span class="i">methods</span>, <span class="i">name</span>, <span class="i">method</span>);
  <span class="i">pop</span>();
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>closeUpvalues</em>()</div>
<p>The method closure is on top of the stack, above the class it will be bound to.
We read those two stack slots and store the closure in the class’s method table.
Then we pop the closure since we’re done with it.</p>
<p>Note that we don’t do any runtime type checking on the closure or class object.
That <code translate="no">AS_CLASS()</code> call is safe because the compiler itself generated the code
that causes the class to be in that stack slot. The VM <span name="verify">trusts</span> its own compiler.</p>
<aside name="verify">
<p>The VM trusts that the instructions it executes are valid because the <em>only</em> way
to get code to the bytecode interpreter is by going through clox’s own compiler.
Many bytecode VMs, like the JVM and CPython, support executing bytecode that has
been compiled separately. That leads to a different security story. Maliciously
crafted bytecode could crash the VM or worse.</p>
<p>To prevent that, the JVM does a bytecode verification pass before it executes
any loaded code. CPython says it’s up to the user to ensure any bytecode they
run is safe.</p>
</aside>
<p>After the series of <code translate="no">OP_METHOD</code> instructions is done and the <code translate="no">OP_POP</code> has popped
the class, we will have a class with a nicely populated method table, ready to
start doing things. The next step is pulling those methods back out and using
them.</p>
<h2><a href="#method-references" id="method-references"><small>28 . 2</small>Method References</a></h2>
<p>Most of the time, methods are accessed and immediately called, leading to this
familiar syntax:</p>
<div class="codehilite"><pre translate="no"><span class="i">instance</span>.<span class="i">method</span>(<span class="i">argument</span>);
</pre></div>
<p>But remember, in Lox and some other languages, those two steps are distinct and
can be separated.</p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="i">closure</span> = <span class="i">instance</span>.<span class="i">method</span>;
<span class="i">closure</span>(<span class="i">argument</span>);
</pre></div>
<p>Since users <em>can</em> separate the operations, we have to implement them separately.
The first step is using our existing dotted property syntax to access a method
defined on the instance’s class. That should return some kind of object that the
user can then call like a function.</p>
<p>The obvious approach is to look up the method in the class’s method table and
return the ObjClosure associated with that name. But we also need to remember
that when you access a method, <code translate="no">this</code> gets bound to the instance the method was
accessed from. Here’s the example from <a href="classes.html#methods-on-classes">when we added methods to jlox</a>:</p>
<div class="codehilite"><pre translate="no"><span class="k">class</span> <span class="t">Person</span> {
  <span class="i">sayName</span>() {
    <span class="k">print</span> <span class="k">this</span>.<span class="i">name</span>;
  }
}

<span class="k">var</span> <span class="i">jane</span> = <span class="t">Person</span>();
<span class="i">jane</span>.<span class="i">name</span> = <span class="s">"Jane"</span>;

<span class="k">var</span> <span class="i">method</span> = <span class="i">jane</span>.<span class="i">sayName</span>;
<span class="i">method</span>(); <span class="c">// ?</span>
</pre></div>
<p>This should print “Jane”, so the object returned by <code translate="no">.sayName</code> somehow needs to
remember the instance it was accessed from when it later gets called. In jlox,
we implemented that “memory” using the interpreter’s existing heap-allocated
Environment class, which handled all variable storage.</p>
<p>Our bytecode VM has a more complex architecture for storing state. <a href="local-variables.html#representing-local-variables">Local
variables and temporaries</a> are on the stack, <a href="global-variables.html#variable-declarations">globals</a> are in a hash
table, and variables in closures use <a href="closures.html#upvalues">upvalues</a>. That necessitates a somewhat
more complex solution for tracking a method’s receiver in clox, and a new
runtime type.</p>
<h3><a href="#bound-methods" id="bound-methods"><small>28 . 2 . 1</small>Bound methods</a></h3>
<p>When the user executes a method access, we’ll find the closure for that method
and wrap it in a new <span name="bound">“bound method”</span> object that tracks
the instance that the method was accessed from. This bound object can be called
later like a function. When invoked, the VM will do some shenanigans to wire up
<code translate="no">this</code> to point to the receiver inside the method’s body.</p>
<aside name="bound">
<p>I took the name “bound method” from CPython. Python behaves similar to Lox here,
and I used its implementation for inspiration.</p>
</aside>
<p>Here’s the new object type:</p>
<div class="codehilite"><pre class="insert-before" translate="no">} ObjInstance;

</pre><div class="source-file"><em>object.h</em><br/>
add after struct <em>ObjInstance</em></div>
<pre class="insert" translate="no"><span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">Obj</span> <span class="i">obj</span>;
  <span class="t">Value</span> <span class="i">receiver</span>;
  <span class="t">ObjClosure</span>* <span class="i">method</span>;
} <span class="t">ObjBoundMethod</span>;

</pre><pre class="insert-after" translate="no">ObjClass* newClass(ObjString* name);
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after struct <em>ObjInstance</em></div>
<p>It wraps the receiver and the method closure together. The receiver’s type is
Value even though methods can be called only on ObjInstances. Since the VM
doesn’t care what kind of receiver it has anyway, using Value means we don’t
have to keep converting the pointer back to a Value when it gets passed to more
general functions.</p>
<p>The new struct implies the usual boilerplate you’re used to by now. A new case
in the object type enum:</p>
<div class="codehilite"><pre class="insert-before" translate="no">typedef enum {
</pre><div class="source-file"><em>object.h</em><br/>
in enum <em>ObjType</em></div>
<pre class="insert" translate="no">  <span class="a">OBJ_BOUND_METHOD</span>,
</pre><pre class="insert-after" translate="no">  OBJ_CLASS,
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, in enum <em>ObjType</em></div>
<p>A macro to check a value’s type:</p>
<div class="codehilite"><pre class="insert-before" translate="no">#define OBJ_TYPE(value)        (AS_OBJ(value)-&gt;type)

</pre><div class="source-file"><em>object.h</em></div>
<pre class="insert" translate="no"><span class="a">#define IS_BOUND_METHOD(value) isObjType(value, OBJ_BOUND_METHOD)</span>
</pre><pre class="insert-after" translate="no">#define IS_CLASS(value)        isObjType(value, OBJ_CLASS)
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>
<p>Another macro to cast the value to an ObjBoundMethod pointer:</p>
<div class="codehilite"><pre class="insert-before" translate="no">#define IS_STRING(value)       isObjType(value, OBJ_STRING)

</pre><div class="source-file"><em>object.h</em></div>
<pre class="insert" translate="no"><span class="a">#define AS_BOUND_METHOD(value) ((ObjBoundMethod*)AS_OBJ(value))</span>
</pre><pre class="insert-after" translate="no">#define AS_CLASS(value)        ((ObjClass*)AS_OBJ(value))
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>
<p>A function to create a new ObjBoundMethod:</p>
<div class="codehilite"><pre class="insert-before" translate="no">} ObjBoundMethod;

</pre><div class="source-file"><em>object.h</em><br/>
add after struct <em>ObjBoundMethod</em></div>
<pre class="insert" translate="no"><span class="t">ObjBoundMethod</span>* <span class="i">newBoundMethod</span>(<span class="t">Value</span> <span class="i">receiver</span>,
                               <span class="t">ObjClosure</span>* <span class="i">method</span>);
</pre><pre class="insert-after" translate="no">ObjClass* newClass(ObjString* name);
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after struct <em>ObjBoundMethod</em></div>
<p>And an implementation of that function here:</p>
<div class="codehilite"><div class="source-file"><em>object.c</em><br/>
add after <em>allocateObject</em>()</div>
<pre translate="no"><span class="t">ObjBoundMethod</span>* <span class="i">newBoundMethod</span>(<span class="t">Value</span> <span class="i">receiver</span>,
                               <span class="t">ObjClosure</span>* <span class="i">method</span>) {
  <span class="t">ObjBoundMethod</span>* <span class="i">bound</span> = <span class="a">ALLOCATE_OBJ</span>(<span class="t">ObjBoundMethod</span>,
                                       <span class="a">OBJ_BOUND_METHOD</span>);
  <span class="i">bound</span>-&gt;<span class="i">receiver</span> = <span class="i">receiver</span>;
  <span class="i">bound</span>-&gt;<span class="i">method</span> = <span class="i">method</span>;
  <span class="k">return</span> <span class="i">bound</span>;
}
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, add after <em>allocateObject</em>()</div>
<p>The constructor-like function simply stores the given closure and receiver. When
the bound method is no longer needed, we free it.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  switch (object-&gt;type) {
</pre><div class="source-file"><em>memory.c</em><br/>
in <em>freeObject</em>()</div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="a">OBJ_BOUND_METHOD</span>:
      <span class="a">FREE</span>(<span class="t">ObjBoundMethod</span>, <span class="i">object</span>);
      <span class="k">break</span>;
</pre><pre class="insert-after" translate="no">    case OBJ_CLASS: {
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>freeObject</em>()</div>
<p>The bound method has a couple of references, but it doesn’t <em>own</em> them, so it
frees nothing but itself. However, those references do get traced by the garbage
collector.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  switch (object-&gt;type) {
</pre><div class="source-file"><em>memory.c</em><br/>
in <em>blackenObject</em>()</div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="a">OBJ_BOUND_METHOD</span>: {
      <span class="t">ObjBoundMethod</span>* <span class="i">bound</span> = (<span class="t">ObjBoundMethod</span>*)<span class="i">object</span>;
      <span class="i">markValue</span>(<span class="i">bound</span>-&gt;<span class="i">receiver</span>);
      <span class="i">markObject</span>((<span class="t">Obj</span>*)<span class="i">bound</span>-&gt;<span class="i">method</span>);
      <span class="k">break</span>;
    }
</pre><pre class="insert-after" translate="no">    case OBJ_CLASS: {
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>blackenObject</em>()</div>
<p>This <span name="trace">ensures</span> that a handle to a method keeps the
receiver around in memory so that <code translate="no">this</code> can still find the object when you
invoke the handle later. We also trace the method closure.</p>
<aside name="trace">
<p>Tracing the method closure isn’t really necessary. The receiver is an
ObjInstance, which has a pointer to its ObjClass, which has a table for all of
the methods. But it feels dubious to me in some vague way to have ObjBoundMethod
rely on that.</p>
</aside>
<p>The last operation all objects support is printing.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  switch (OBJ_TYPE(value)) {
</pre><div class="source-file"><em>object.c</em><br/>
in <em>printObject</em>()</div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="a">OBJ_BOUND_METHOD</span>:
      <span class="i">printFunction</span>(<span class="a">AS_BOUND_METHOD</span>(<span class="i">value</span>)-&gt;<span class="i">method</span>-&gt;<span class="i">function</span>);
      <span class="k">break</span>;
</pre><pre class="insert-after" translate="no">    case OBJ_CLASS:
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>printObject</em>()</div>
<p>A bound method prints exactly the same way as a function. From the user’s
perspective, a bound method <em>is</em> a function. It’s an object they can call. We
don’t expose that the VM implements bound methods using a different object type.</p>
<aside name="party"><img alt="A party hat." src="image/methods-and-initializers/party-hat.png">
</img></aside>
<p>Put on your <span name="party">party</span> hat because we just reached a little
milestone. ObjBoundMethod is the very last runtime type to add to clox. You’ve
written your last <code translate="no">IS_</code> and <code translate="no">AS_</code> macros. We’re only a few chapters from the end
of the book, and we’re getting close to a complete VM.</p>
<h3><a href="#accessing-methods" id="accessing-methods"><small>28 . 2 . 2</small>Accessing methods</a></h3>
<p>Let’s get our new object type doing something. Methods are accessed using the
same “dot” property syntax we implemented in the last chapter. The compiler
already parses the right expressions and emits <code translate="no">OP_GET_PROPERTY</code> instructions
for them. The only changes we need to make are in the runtime.</p>
<p>When a property access instruction executes, the instance is on top of the
stack. The instruction’s job is to find a field or method with the given name
and replace the top of the stack with the accessed property.</p>
<p>The interpreter already handles fields, so we simply extend the
<code translate="no">OP_GET_PROPERTY</code> case with another section.</p>
<div class="codehilite"><pre class="insert-before" translate="no">          pop(); // Instance.
          push(value);
          break;
        }

</pre><div class="source-file"><em>vm.c</em><br/>
in <em>run</em>()<br/>
replace 2 lines</div>
<pre class="insert" translate="no">        <span class="k">if</span> (!<span class="i">bindMethod</span>(<span class="i">instance</span>-&gt;<span class="i">klass</span>, <span class="i">name</span>)) {
          <span class="k">return</span> <span class="a">INTERPRET_RUNTIME_ERROR</span>;
        }
        <span class="k">break</span>;
</pre><pre class="insert-after" translate="no">      }
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 2 lines</div>
<p>We insert this after the code to look up a field on the receiver instance.
Fields take priority over and shadow methods, so we look for a field first. If
the instance does not have a field with the given property name, then the name
may refer to a method.</p>
<p>We take the instance’s class and pass it to a new <code translate="no">bindMethod()</code> helper. If that
function finds a method, it places the method on the stack and returns <code translate="no">true</code>.
Otherwise it returns <code translate="no">false</code> to indicate a method with that name couldn’t be
found. Since the name also wasn’t a field, that means we have a runtime error,
which aborts the interpreter.</p>
<p>Here is the good stuff:</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br/>
add after <em>callValue</em>()</div>
<pre translate="no"><span class="k">static</span> <span class="t">bool</span> <span class="i">bindMethod</span>(<span class="t">ObjClass</span>* <span class="i">klass</span>, <span class="t">ObjString</span>* <span class="i">name</span>) {
  <span class="t">Value</span> <span class="i">method</span>;
  <span class="k">if</span> (!<span class="i">tableGet</span>(&amp;<span class="i">klass</span>-&gt;<span class="i">methods</span>, <span class="i">name</span>, &amp;<span class="i">method</span>)) {
    <span class="i">runtimeError</span>(<span class="s">"Undefined property '%s'."</span>, <span class="i">name</span>-&gt;<span class="i">chars</span>);
    <span class="k">return</span> <span class="k">false</span>;
  }

  <span class="t">ObjBoundMethod</span>* <span class="i">bound</span> = <span class="i">newBoundMethod</span>(<span class="i">peek</span>(<span class="n">0</span>),
                                         <span class="a">AS_CLOSURE</span>(<span class="i">method</span>));
  <span class="i">pop</span>();
  <span class="i">push</span>(<span class="a">OBJ_VAL</span>(<span class="i">bound</span>));
  <span class="k">return</span> <span class="k">true</span>;
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>callValue</em>()</div>
<p>First we look for a method with the given name in the class’s method table. If
we don’t find one, we report a runtime error and bail out. Otherwise, we take
the method and wrap it in a new ObjBoundMethod. We grab the receiver from its
home on top of the stack. Finally, we pop the instance and replace the top of
the stack with the bound method.</p>
<p>For example:</p>
<div class="codehilite"><pre translate="no"><span class="k">class</span> <span class="t">Brunch</span> {
  <span class="i">eggs</span>() {}
}

<span class="k">var</span> <span class="i">brunch</span> = <span class="t">Brunch</span>();
<span class="k">var</span> <span class="i">eggs</span> = <span class="i">brunch</span>.<span class="i">eggs</span>;
</pre></div>
<p>Here is what happens when the VM executes the <code translate="no">bindMethod()</code> call for the
<code translate="no">brunch.eggs</code> expression:</p><img alt="The stack changes caused by bindMethod()." src="image/methods-and-initializers/bind-method.png">
<p>That’s a lot of machinery under the hood, but from the user’s perspective, they
simply get a function that they can call.</p>
<h3><a href="#calling-methods" id="calling-methods"><small>28 . 2 . 3</small>Calling methods</a></h3>
<p>Users can declare methods on classes, access them on instances, and get bound
methods onto the stack. They just can’t <span name="do"><em>do</em></span> anything
useful with those bound method objects. The operation we’re missing is calling
them. Calls are implemented in <code translate="no">callValue()</code>, so we add a case there for the new
object type.</p>
<aside name="do">
<p>A bound method <em>is</em> a first-class value, so they can store it in variables, pass
it to functions, and otherwise do “value”-y stuff with it.</p>
</aside>
<div class="codehilite"><pre class="insert-before" translate="no">    switch (OBJ_TYPE(callee)) {
</pre><div class="source-file"><em>vm.c</em><br/>
in <em>callValue</em>()</div>
<pre class="insert" translate="no">      <span class="k">case</span> <span class="a">OBJ_BOUND_METHOD</span>: {
        <span class="t">ObjBoundMethod</span>* <span class="i">bound</span> = <span class="a">AS_BOUND_METHOD</span>(<span class="i">callee</span>);
        <span class="k">return</span> <span class="i">call</span>(<span class="i">bound</span>-&gt;<span class="i">method</span>, <span class="i">argCount</span>);
      }
</pre><pre class="insert-after" translate="no">      case OBJ_CLASS: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>callValue</em>()</div>
<p>We pull the raw closure back out of the ObjBoundMethod and use the existing
<code translate="no">call()</code> helper to begin an invocation of that closure by pushing a CallFrame
for it onto the call stack. That’s all it takes to be able to run this Lox
program:</p>
<div class="codehilite"><pre translate="no"><span class="k">class</span> <span class="t">Scone</span> {
  <span class="i">topping</span>(<span class="i">first</span>, <span class="i">second</span>) {
    <span class="k">print</span> <span class="s">"scone with "</span> + <span class="i">first</span> + <span class="s">" and "</span> + <span class="i">second</span>;
  }
}

<span class="k">var</span> <span class="i">scone</span> = <span class="t">Scone</span>();
<span class="i">scone</span>.<span class="i">topping</span>(<span class="s">"berries"</span>, <span class="s">"cream"</span>);
</pre></div>
<p>That’s three big steps. We can declare, access, and invoke methods. But
something is missing. We went to all that trouble to wrap the method closure in
an object that binds the receiver, but when we invoke the method, we don’t use
that receiver at all.</p>
<h2><a href="#this" id="this"><small>28 . 3</small>This</a></h2>
<p>The reason bound methods need to keep hold of the receiver is so that it can be
accessed inside the body of the method. Lox exposes a method’s receiver through
<code translate="no">this</code> expressions. It’s time for some new syntax. The lexer already treats
<code translate="no">this</code> as a special token type, so the first step is wiring that token up in the
parse table.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  [TOKEN_SUPER]         = {NULL,     NULL,   PREC_NONE},
</pre><div class="source-file"><em>compiler.c</em><br/>
replace 1 line</div>
<pre class="insert" translate="no">  [<span class="a">TOKEN_THIS</span>]          = {<span class="i">this_</span>,    <span class="a">NULL</span>,   <span class="a">PREC_NONE</span>},
</pre><pre class="insert-after" translate="no">  [TOKEN_TRUE]          = {literal,  NULL,   PREC_NONE},
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, replace 1 line</div>
<aside name="this">
<p>The underscore at the end of the name of the parser function is because <code translate="no">this</code>
is a reserved word in C++ and we support compiling clox as C++.</p>
</aside>
<p>When the parser encounters a <code translate="no">this</code> in prefix position, it dispatches to a new
parser function.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br/>
add after <em>variable</em>()</div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">this_</span>(<span class="t">bool</span> <span class="i">canAssign</span>) {
  <span class="i">variable</span>(<span class="k">false</span>);
}<span name="this"> </span>
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>variable</em>()</div>
<p>We’ll apply the same implementation technique for <code translate="no">this</code> in clox that we used in
jlox. We treat <code translate="no">this</code> as a lexically scoped local variable whose value gets
magically initialized. Compiling it like a local variable means we get a lot of
behavior for free. In particular, closures inside a method that reference <code translate="no">this</code>
will do the right thing and capture the receiver in an upvalue.</p>
<p>When the parser function is called, the <code translate="no">this</code> token has just been consumed and
is stored as the previous token. We call our existing <code translate="no">variable()</code> function
which compiles identifier expressions as variable accesses. It takes a single
Boolean parameter for whether the compiler should look for a following <code translate="no">=</code>
operator and parse a setter. You can’t assign to <code translate="no">this</code>, so we pass <code translate="no">false</code> to
disallow that.</p>
<p>The <code translate="no">variable()</code> function doesn’t care that <code translate="no">this</code> has its own token type and
isn’t an identifier. It is happy to treat the lexeme “this” as if it were a
variable name and then look it up using the existing scope resolution machinery.
Right now, that lookup will fail because we never declared a variable whose name
is “this”. It’s time to think about where the receiver should live in memory.</p>
<p>At least until they get captured by closures, clox stores every local variable
on the VM’s stack. The compiler keeps track of which slots in the function’s
stack window are owned by which local variables. If you recall, the compiler
sets aside stack slot zero by declaring a local variable whose name is an empty
string.</p>
<p>For function calls, that slot ends up holding the function being called. Since
the slot has no name, the function body never accesses it. You can guess where
this is going. For <em>method</em> calls, we can repurpose that slot to store the
receiver. Slot zero will store the instance that <code translate="no">this</code> is bound to. In order to
compile <code translate="no">this</code> expressions, the compiler simply needs to give the correct name
to that local variable.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  local-&gt;isCaptured = false;
</pre><div class="source-file"><em>compiler.c</em><br/>
in <em>initCompiler</em>()<br/>
replace 2 lines</div>
<pre class="insert" translate="no">  <span class="k">if</span> (<span class="i">type</span> != <span class="a">TYPE_FUNCTION</span>) {
    <span class="i">local</span>-&gt;<span class="i">name</span>.<span class="i">start</span> = <span class="s">"this"</span>;
    <span class="i">local</span>-&gt;<span class="i">name</span>.<span class="i">length</span> = <span class="n">4</span>;
  } <span class="k">else</span> {
    <span class="i">local</span>-&gt;<span class="i">name</span>.<span class="i">start</span> = <span class="s">""</span>;
    <span class="i">local</span>-&gt;<span class="i">name</span>.<span class="i">length</span> = <span class="n">0</span>;
  }
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>initCompiler</em>(), replace 2 lines</div>
<p>We want to do this only for methods. Function declarations don’t have a <code translate="no">this</code>.
And, in fact, they <em>must not</em> declare a variable named “this”, so that if you
write a <code translate="no">this</code> expression inside a function declaration which is itself inside a
method, the <code translate="no">this</code> correctly resolves to the outer method’s receiver.</p>
<div class="codehilite"><pre translate="no"><span class="k">class</span> <span class="t">Nested</span> {
  <span class="i">method</span>() {
    <span class="k">fun</span> <span class="i">function</span>() {
      <span class="k">print</span> <span class="k">this</span>;
    }

    <span class="i">function</span>();
  }
}

<span class="t">Nested</span>().<span class="i">method</span>();
</pre></div>
<p>This program should print “Nested instance”. To decide what name to give to
local slot zero, the compiler needs to know whether it’s compiling a function or
method declaration, so we add a new case to our FunctionType enum to distinguish
methods.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  TYPE_FUNCTION,
</pre><div class="source-file"><em>compiler.c</em><br/>
in enum <em>FunctionType</em></div>
<pre class="insert" translate="no">  <span class="a">TYPE_METHOD</span>,
</pre><pre class="insert-after" translate="no">  TYPE_SCRIPT
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in enum <em>FunctionType</em></div>
<p>When we compile a method, we use that type.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  uint8_t constant = identifierConstant(&amp;parser.previous);

</pre><div class="source-file"><em>compiler.c</em><br/>
in <em>method</em>()<br/>
replace 1 line</div>
<pre class="insert" translate="no">  <span class="t">FunctionType</span> <span class="i">type</span> = <span class="a">TYPE_METHOD</span>;
</pre><pre class="insert-after" translate="no">  function(type);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>method</em>(), replace 1 line</div>
<p>Now we can correctly compile references to the special “this” variable, and the
compiler will emit the right <code translate="no">OP_GET_LOCAL</code> instructions to access it. Closures
can even capture <code translate="no">this</code> and store the receiver in upvalues. Pretty cool.</p>
<p>Except that at runtime, the receiver isn’t actually <em>in</em> slot zero. The
interpreter isn’t holding up its end of the bargain yet. Here is the fix:</p>
<div class="codehilite"><pre class="insert-before" translate="no">      case OBJ_BOUND_METHOD: {
        ObjBoundMethod* bound = AS_BOUND_METHOD(callee);
</pre><div class="source-file"><em>vm.c</em><br/>
in <em>callValue</em>()</div>
<pre class="insert" translate="no">        <span class="i">vm</span>.<span class="i">stackTop</span>[-<span class="i">argCount</span> - <span class="n">1</span>] = <span class="i">bound</span>-&gt;<span class="i">receiver</span>;
</pre><pre class="insert-after" translate="no">        return call(bound-&gt;method, argCount);
      }
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>callValue</em>()</div>
<p>When a method is called, the top of the stack contains all of the arguments, and
then just under those is the closure of the called method. That’s where slot
zero in the new CallFrame will be. This line of code inserts the receiver into
that slot. For example, given a method call like this:</p>
<div class="codehilite"><pre translate="no"><span class="i">scone</span>.<span class="i">topping</span>(<span class="s">"berries"</span>, <span class="s">"cream"</span>);
</pre></div>
<p>We calculate the slot to store the receiver like so:</p><img alt="Skipping over the argument stack slots to find the slot containing the closure." src="image/methods-and-initializers/closure-slot.png"/>
<p>The <code translate="no">-argCount</code> skips past the arguments and the <code translate="no">- 1</code> adjusts for the fact that
<code translate="no">stackTop</code> points just <em>past</em> the last used stack slot.</p>
<h3><a href="#misusing-this" id="misusing-this"><small>28 . 3 . 1</small>Misusing this</a></h3>
<p>Our VM now supports users <em>correctly</em> using <code translate="no">this</code>, but we also need to make
sure it properly handles users <em>mis</em>using <code translate="no">this</code>. Lox says it is a compile
error for a <code translate="no">this</code> expression to appear outside of the body of a method. These
two wrong uses should be caught by the compiler:</p>
<div class="codehilite"><pre translate="no"><span class="k">print</span> <span class="k">this</span>; <span class="c">// At top level.</span>

<span class="k">fun</span> <span class="i">notMethod</span>() {
  <span class="k">print</span> <span class="k">this</span>; <span class="c">// In a function.</span>
}
</pre></div>
<p>So how does the compiler know if it’s inside a method? The obvious answer is to
look at the FunctionType of the current Compiler. We did just add an enum case
there to treat methods specially. However, that wouldn’t correctly handle code
like the earlier example where you are inside a function which is, itself,
nested inside a method.</p>
<p>We could try to resolve “this” and then report an error if it wasn’t found in
any of the surrounding lexical scopes. That would work, but would require us to
shuffle around a bunch of code, since right now the code for resolving a
variable implicitly considers it a global access if no declaration is found.</p>
<p>In the next chapter, we will need information about the nearest enclosing class.
If we had that, we could use it here to determine if we are inside a method. So
we may as well make our future selves’ lives a little easier and put that
machinery in place now.</p>
<div class="codehilite"><pre class="insert-before" translate="no">Compiler* current = NULL;
</pre><div class="source-file"><em>compiler.c</em><br/>
add after variable <em>current</em></div>
<pre class="insert" translate="no"><span class="t">ClassCompiler</span>* <span class="i">currentClass</span> = <span class="a">NULL</span>;
</pre><pre class="insert-after" translate="no">

static Chunk* currentChunk() {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after variable <em>current</em></div>
<p>This module variable points to a struct representing the current, innermost
class being compiled. The new type looks like this:</p>
<div class="codehilite"><pre class="insert-before" translate="no">} Compiler;
</pre><div class="source-file"><em>compiler.c</em><br/>
add after struct <em>Compiler</em></div>
<pre class="insert" translate="no">

<span class="k">typedef</span> <span class="k">struct</span> <span class="t">ClassCompiler</span> {
  <span class="k">struct</span> <span class="t">ClassCompiler</span>* <span class="i">enclosing</span>;
} <span class="t">ClassCompiler</span>;
</pre><pre class="insert-after" translate="no">

Parser parser;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after struct <em>Compiler</em></div>
<p>Right now we store only a pointer to the ClassCompiler for the enclosing class,
if any. Nesting a class declaration inside a method in some other class is an
uncommon thing to do, but Lox supports it. Just like the Compiler struct, this
means ClassCompiler forms a linked list from the current innermost class being
compiled out through all of the enclosing classes.</p>
<p>If we aren’t inside any class declaration at all, the module variable
<code translate="no">currentClass</code> is <code translate="no">NULL</code>. When the compiler begins compiling a class, it pushes
a new ClassCompiler onto that implicit linked stack.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  defineVariable(nameConstant);

</pre><div class="source-file"><em>compiler.c</em><br/>
in <em>classDeclaration</em>()</div>
<pre class="insert" translate="no">  <span class="t">ClassCompiler</span> <span class="i">classCompiler</span>;
  <span class="i">classCompiler</span>.<span class="i">enclosing</span> = <span class="i">currentClass</span>;
  <span class="i">currentClass</span> = &amp;<span class="i">classCompiler</span>;

</pre><pre class="insert-after" translate="no">  namedVariable(className, false);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>classDeclaration</em>()</div>
<p>The memory for the ClassCompiler struct lives right on the C stack, a handy
capability we get by writing our compiler using recursive descent. At the end of
the class body, we pop that compiler off the stack and restore the enclosing
one.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  emitByte(OP_POP);
</pre><div class="source-file"><em>compiler.c</em><br/>
in <em>classDeclaration</em>()</div>
<pre class="insert" translate="no">

  <span class="i">currentClass</span> = <span class="i">currentClass</span>-&gt;<span class="i">enclosing</span>;
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>classDeclaration</em>()</div>
<p>When an outermost class body ends, <code translate="no">enclosing</code> will be <code translate="no">NULL</code>, so this resets
<code translate="no">currentClass</code> to <code translate="no">NULL</code>. Thus, to see if we are inside a class<span class="em">—</span>and therefore
inside a method<span class="em">—</span>we simply check that module variable.</p>
<div class="codehilite"><pre class="insert-before" translate="no">static void this_(bool canAssign) {
</pre><div class="source-file"><em>compiler.c</em><br/>
in <em>this_</em>()</div>
<pre class="insert" translate="no">  <span class="k">if</span> (<span class="i">currentClass</span> == <span class="a">NULL</span>) {
    <span class="i">error</span>(<span class="s">"Can't use 'this' outside of a class."</span>);
    <span class="k">return</span>;
  }

</pre><pre class="insert-after" translate="no">  variable(false);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>this_</em>()</div>
<p>With that, <code translate="no">this</code> outside of a class is correctly forbidden. Now our methods
really feel like <em>methods</em> in the object-oriented sense. Accessing the receiver
lets them affect the instance you called the method on. We’re getting there!</p>
<h2><a href="#instance-initializers" id="instance-initializers"><small>28 . 4</small>Instance Initializers</a></h2>
<p>The reason object-oriented languages tie state and behavior together<span class="em">—</span>one of
the core tenets of the paradigm<span class="em">—</span>is to ensure that objects are always in a
valid, meaningful state. When the only way to touch an object’s state is <span name="through">through</span> its methods, the methods can make sure nothing
goes awry. But that presumes the object is <em>already</em> in a proper state. What
about when it’s first created?</p>
<aside name="through">
<p>Of course, Lox does let outside code directly access and modify an instance’s
fields without going through its methods. This is unlike Ruby and Smalltalk,
which completely encapsulate state inside objects. Our toy scripting language,
alas, isn’t so principled.</p>
</aside>
<p>Object-oriented languages ensure that brand new objects are properly set up
through constructors, which both produce a new instance and initialize its
state. In Lox, the runtime allocates new raw instances, and a class may declare
an initializer to set up any fields. Initializers work mostly like normal
methods, with a few tweaks:</p>
<ol>
<li>
<p>The runtime automatically invokes the initializer method whenever an
instance of a class is created.</p>
</li>
<li>
<p>The caller that constructs an instance always gets the instance <span name="return">back</span> after the initializer finishes, regardless of what
the initializer function itself returns. The initializer method doesn’t need
to explicitly return <code translate="no">this</code>.</p>
</li>
<li>
<p>In fact, an initializer is <em>prohibited</em> from returning any value at all
since the value would never be seen anyway.</p>
</li>
</ol>
<aside name="return">
<p>It’s as if the initializer is implicitly wrapped in a bundle of code like this:</p>
<div class="codehilite"><pre translate="no"><span class="k">fun</span> <span class="i">create</span>(<span class="i">klass</span>) {
  <span class="k">var</span> <span class="i">obj</span> = <span class="i">newInstance</span>(<span class="i">klass</span>);
  <span class="i">obj</span>.<span class="i">init</span>();
  <span class="k">return</span> <span class="i">obj</span>;
}
</pre></div>
<p>Note how the value returned by <code translate="no">init()</code> is discarded.</p>
</aside>
<p>Now that we support methods, to add initializers, we merely need to implement
those three special rules. We’ll go in order.</p>
<h3><a href="#invoking-initializers" id="invoking-initializers"><small>28 . 4 . 1</small>Invoking initializers</a></h3>
<p>First, automatically calling <code translate="no">init()</code> on new instances:</p>
<div class="codehilite"><pre class="insert-before" translate="no">        vm.stackTop[-argCount - 1] = OBJ_VAL(newInstance(klass));
</pre><div class="source-file"><em>vm.c</em><br/>
in <em>callValue</em>()</div>
<pre class="insert" translate="no">        <span class="t">Value</span> <span class="i">initializer</span>;
        <span class="k">if</span> (<span class="i">tableGet</span>(&amp;<span class="i">klass</span>-&gt;<span class="i">methods</span>, <span class="i">vm</span>.<span class="i">initString</span>,
                     &amp;<span class="i">initializer</span>)) {
          <span class="k">return</span> <span class="i">call</span>(<span class="a">AS_CLOSURE</span>(<span class="i">initializer</span>), <span class="i">argCount</span>);
        }
</pre><pre class="insert-after" translate="no">        return true;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>callValue</em>()</div>
<p>After the runtime allocates the new instance, we look for an <code translate="no">init()</code> method on
the class. If we find one, we initiate a call to it. This pushes a new CallFrame
for the initializer’s closure. Say we run this program:</p>
<div class="codehilite"><pre translate="no"><span class="k">class</span> <span class="t">Brunch</span> {
  <span class="i">init</span>(<span class="i">food</span>, <span class="i">drink</span>) {}
}

<span class="t">Brunch</span>(<span class="s">"eggs"</span>, <span class="s">"coffee"</span>);
</pre></div>
<p>When the VM executes the call to <code translate="no">Brunch()</code>, it goes like this:</p><img alt="The aligned stack windows for the Brunch() call and the corresponding init() method it forwards to." src="image/methods-and-initializers/init-call-frame.png"/>
<p>Any arguments passed to the class when we called it are still sitting on the
stack above the instance. The new CallFrame for the <code translate="no">init()</code> method shares that
stack window, so those arguments implicitly get forwarded to the initializer.</p>
<p>Lox doesn’t require a class to define an initializer. If omitted, the runtime
simply returns the new uninitialized instance. However, if there is no <code translate="no">init()</code>
method, then it doesn’t make any sense to pass arguments to the class when
creating the instance. We make that an error.</p>
<div class="codehilite"><pre class="insert-before" translate="no">          return call(AS_CLOSURE(initializer), argCount);
</pre><div class="source-file"><em>vm.c</em><br/>
in <em>callValue</em>()</div>
<pre class="insert" translate="no">        } <span class="k">else</span> <span class="k">if</span> (<span class="i">argCount</span> != <span class="n">0</span>) {
          <span class="i">runtimeError</span>(<span class="s">"Expected 0 arguments but got %d."</span>,
                       <span class="i">argCount</span>);
          <span class="k">return</span> <span class="k">false</span>;
</pre><pre class="insert-after" translate="no">        }
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>callValue</em>()</div>
<p>When the class <em>does</em> provide an initializer, we also need to ensure that the
number of arguments passed matches the initializer’s arity. Fortunately, the
<code translate="no">call()</code> helper does that for us already.</p>
<p>To call the initializer, the runtime looks up the <code translate="no">init()</code> method by name. We
want that to be fast since it happens every time an instance is constructed.
That means it would be good to take advantage of the string interning we’ve
already implemented. To do that, the VM creates an ObjString for “init” and
reuses it. The string lives right in the VM struct.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  Table strings;
</pre><div class="source-file"><em>vm.h</em><br/>
in struct <em>VM</em></div>
<pre class="insert" translate="no">  <span class="t">ObjString</span>* <span class="i">initString</span>;
</pre><pre class="insert-after" translate="no">  ObjUpvalue* openUpvalues;
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, in struct <em>VM</em></div>
<p>We create and intern the string when the VM boots up.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  initTable(&amp;vm.strings);
</pre><div class="source-file"><em>vm.c</em><br/>
in <em>initVM</em>()</div>
<pre class="insert" translate="no">

  <span class="i">vm</span>.<span class="i">initString</span> = <span class="i">copyString</span>(<span class="s">"init"</span>, <span class="n">4</span>);
</pre><pre class="insert-after" translate="no">

  defineNative("clock", clockNative);
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>initVM</em>()</div>
<p>We want it to stick around, so the GC considers it a root.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  markCompilerRoots();
</pre><div class="source-file"><em>memory.c</em><br/>
in <em>markRoots</em>()</div>
<pre class="insert" translate="no">  <span class="i">markObject</span>((<span class="t">Obj</span>*)<span class="i">vm</span>.<span class="i">initString</span>);
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>markRoots</em>()</div>
<p>Look carefully. See any bug waiting to happen? No? It’s a subtle one. The
garbage collector now reads <code translate="no">vm.initString</code>. That field is initialized from the
result of calling <code translate="no">copyString()</code>. But copying a string allocates memory, which
can trigger a GC. If the collector ran at just the wrong time, it would read
<code translate="no">vm.initString</code> before it had been initialized. So, first we zero the field out.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  initTable(&amp;vm.strings);

</pre><div class="source-file"><em>vm.c</em><br/>
in <em>initVM</em>()</div>
<pre class="insert" translate="no">  <span class="i">vm</span>.<span class="i">initString</span> = <span class="a">NULL</span>;
</pre><pre class="insert-after" translate="no">  vm.initString = copyString("init", 4);

</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>initVM</em>()</div>
<p>We clear the pointer when the VM shuts down since the next line will free it.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  freeTable(&amp;vm.strings);
</pre><div class="source-file"><em>vm.c</em><br/>
in <em>freeVM</em>()</div>
<pre class="insert" translate="no">  <span class="i">vm</span>.<span class="i">initString</span> = <span class="a">NULL</span>;
</pre><pre class="insert-after" translate="no">  freeObjects();
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>freeVM</em>()</div>
<p>OK, that lets us call initializers.</p>
<h3><a href="#initializer-return-values" id="initializer-return-values"><small>28 . 4 . 2</small>Initializer return values</a></h3>
<p>The next step is ensuring that constructing an instance of a class with an
initializer always returns the new instance, and not <code translate="no">nil</code> or whatever the body
of the initializer returns. Right now, if a class defines an initializer, then
when an instance is constructed, the VM pushes a call to that initializer onto
the CallFrame stack. Then it just keeps on trucking.</p>
<p>The user’s invocation on the class to create the instance will complete whenever
that initializer method returns, and will leave on the stack whatever value the
initializer puts there. That means that unless the user takes care to put
<code translate="no">return this;</code> at the end of the initializer, no instance will come out. Not
very helpful.</p>
<p>To fix this, whenever the front end compiles an initializer method, it will emit
different bytecode at the end of the body to return <code translate="no">this</code> from the method
instead of the usual implicit <code translate="no">nil</code> most functions return. In order to do
<em>that</em>, the compiler needs to actually know when it is compiling an initializer.
We detect that by checking to see if the name of the method we’re compiling is
“init”.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  FunctionType type = TYPE_METHOD;
</pre><div class="source-file"><em>compiler.c</em><br/>
in <em>method</em>()</div>
<pre class="insert" translate="no">  <span class="k">if</span> (<span class="i">parser</span>.<span class="i">previous</span>.<span class="i">length</span> == <span class="n">4</span> &amp;&amp;
      <span class="i">memcmp</span>(<span class="i">parser</span>.<span class="i">previous</span>.<span class="i">start</span>, <span class="s">"init"</span>, <span class="n">4</span>) == <span class="n">0</span>) {
    <span class="i">type</span> = <span class="a">TYPE_INITIALIZER</span>;
  }

</pre><pre class="insert-after" translate="no">  function(type);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>method</em>()</div>
<p>We define a new function type to distinguish initializers from other methods.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  TYPE_FUNCTION,
</pre><div class="source-file"><em>compiler.c</em><br/>
in enum <em>FunctionType</em></div>
<pre class="insert" translate="no">  <span class="a">TYPE_INITIALIZER</span>,
</pre><pre class="insert-after" translate="no">  TYPE_METHOD,
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in enum <em>FunctionType</em></div>
<p>Whenever the compiler emits the implicit return at the end of a body, we check
the type to decide whether to insert the initializer-specific behavior.</p>
<div class="codehilite"><pre class="insert-before" translate="no">static void emitReturn() {
</pre><div class="source-file"><em>compiler.c</em><br/>
in <em>emitReturn</em>()<br/>
replace 1 line</div>
<pre class="insert" translate="no">  <span class="k">if</span> (<span class="i">current</span>-&gt;<span class="i">type</span> == <span class="a">TYPE_INITIALIZER</span>) {
    <span class="i">emitBytes</span>(<span class="a">OP_GET_LOCAL</span>, <span class="n">0</span>);
  } <span class="k">else</span> {
    <span class="i">emitByte</span>(<span class="a">OP_NIL</span>);
  }

</pre><pre class="insert-after" translate="no">  emitByte(OP_RETURN);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>emitReturn</em>(), replace 1 line</div>
<p>In an initializer, instead of pushing <code translate="no">nil</code> onto the stack before returning,
we load slot zero, which contains the instance. This <code translate="no">emitReturn()</code> function is
also called when compiling a <code translate="no">return</code> statement without a value, so this also
correctly handles cases where the user does an early return inside the
initializer.</p>
<h3><a href="#incorrect-returns-in-initializers" id="incorrect-returns-in-initializers"><small>28 . 4 . 3</small>Incorrect returns in initializers</a></h3>
<p>The last step, the last item in our list of special features of initializers, is
making it an error to try to return anything <em>else</em> from an initializer. Now
that the compiler tracks the method type, this is straightforward.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  if (match(TOKEN_SEMICOLON)) {
    emitReturn();
  } else {
</pre><div class="source-file"><em>compiler.c</em><br/>
in <em>returnStatement</em>()</div>
<pre class="insert" translate="no">    <span class="k">if</span> (<span class="i">current</span>-&gt;<span class="i">type</span> == <span class="a">TYPE_INITIALIZER</span>) {
      <span class="i">error</span>(<span class="s">"Can't return a value from an initializer."</span>);
    }

</pre><pre class="insert-after" translate="no">    expression();
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>returnStatement</em>()</div>
<p>We report an error if a <code translate="no">return</code> statement in an initializer has a value. We
still go ahead and compile the value afterwards so that the compiler doesn’t get
confused by the trailing expression and report a bunch of cascaded errors.</p>
<p>Aside from inheritance, which we’ll get to <a href="superclasses.html">soon</a>, we now have a
fairly full-featured class system working in clox.</p>
<div class="codehilite"><pre translate="no"><span class="k">class</span> <span class="t">CoffeeMaker</span> {
  <span class="i">init</span>(<span class="i">coffee</span>) {
    <span class="k">this</span>.<span class="i">coffee</span> = <span class="i">coffee</span>;
  }

  <span class="i">brew</span>() {
    <span class="k">print</span> <span class="s">"Enjoy your cup of "</span> + <span class="k">this</span>.<span class="i">coffee</span>;

    <span class="c">// No reusing the grounds!</span>
    <span class="k">this</span>.<span class="i">coffee</span> = <span class="k">nil</span>;
  }
}

<span class="k">var</span> <span class="i">maker</span> = <span class="t">CoffeeMaker</span>(<span class="s">"coffee and chicory"</span>);
<span class="i">maker</span>.<span class="i">brew</span>();
</pre></div>
<p>Pretty fancy for a C program that would fit on an old <span name="floppy">floppy</span> disk.</p>
<aside name="floppy">
<p>I acknowledge that “floppy disk” may no longer be a useful size reference for
current generations of programmers. Maybe I should have said “a few tweets” or
something.</p>
</aside>
<h2><a href="#optimized-invocations" id="optimized-invocations"><small>28 . 5</small>Optimized Invocations</a></h2>
<p>Our VM correctly implements the language’s semantics for method calls and
initializers. We could stop here. But the main reason we are building an entire
second implementation of Lox from scratch is to execute faster than our old Java
interpreter. Right now, method calls even in clox are slow.</p>
<p>Lox’s semantics define a method invocation as two operations<span class="em">—</span>accessing the
method and then calling the result. Our VM must support those as separate
operations because the user <em>can</em> separate them. You can access a method without
calling it and then invoke the bound method later. Nothing we’ve implemented so
far is unnecessary.</p>
<p>But <em>always</em> executing those as separate operations has a significant cost.
Every single time a Lox program accesses and invokes a method, the runtime
heap allocates a new ObjBoundMethod, initializes its fields, then pulls them
right back out. Later, the GC has to spend time freeing all of those ephemeral
bound methods.</p>
<p>Most of the time, a Lox program accesses a method and then immediately calls it.
The bound method is created by one bytecode instruction and then consumed by the
very next one. In fact, it’s so immediate that the compiler can even textually
<em>see</em> that it’s happening<span class="em">—</span>a dotted property access followed by an opening
parenthesis is most likely a method call.</p>
<p>Since we can recognize this pair of operations at compile time, we have the
opportunity to emit a <span name="super">new, special</span> instruction that
performs an optimized method call.</p>
<p>We start in the function that compiles dotted property expressions.</p>
<aside class="bottom" name="super">
<p>If you spend enough time watching your bytecode VM run, you’ll notice it often
executes the same series of bytecode instructions one after the other. A classic
optimization technique is to define a new single instruction called a
<strong>superinstruction</strong> that fuses those into a single instruction with the same
behavior as the entire sequence.</p>
<p>One of the largest performance drains in a bytecode interpreter is the overhead
of decoding and dispatching each instruction. Fusing several instructions into
one eliminates some of that.</p>
<p>The challenge is determining <em>which</em> instruction sequences are common enough to
benefit from this optimization. Every new superinstruction claims an opcode for
its own use and there are only so many of those to go around. Add too many, and
you’ll need a larger encoding for opcodes, which then increases code size and
makes decoding <em>all</em> instructions slower.</p>
</aside>
<div class="codehilite"><pre class="insert-before" translate="no">  if (canAssign &amp;&amp; match(TOKEN_EQUAL)) {
    expression();
    emitBytes(OP_SET_PROPERTY, name);
</pre><div class="source-file"><em>compiler.c</em><br/>
in <em>dot</em>()</div>
<pre class="insert" translate="no">  } <span class="k">else</span> <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_LEFT_PAREN</span>)) {
    <span class="t">uint8_t</span> <span class="i">argCount</span> = <span class="i">argumentList</span>();
    <span class="i">emitBytes</span>(<span class="a">OP_INVOKE</span>, <span class="i">name</span>);
    <span class="i">emitByte</span>(<span class="i">argCount</span>);
</pre><pre class="insert-after" translate="no">  } else {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>dot</em>()</div>
<p>After the compiler has parsed the property name, we look for a left parenthesis.
If we match one, we switch to a new code path. There, we compile the argument
list exactly like we do when compiling a call expression. Then we emit a single
new <code translate="no">OP_INVOKE</code> instruction. It takes two operands:</p>
<ol>
<li>
<p>The index of the property name in the constant table.</p>
</li>
<li>
<p>The number of arguments passed to the method.</p>
</li>
</ol>
<p>In other words, this single instruction combines the operands of the
<code translate="no">OP_GET_PROPERTY</code> and <code translate="no">OP_CALL</code> instructions it replaces, in that order. It
really is a fusion of those two instructions. Let’s define it.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  OP_CALL,
</pre><div class="source-file"><em>chunk.h</em><br/>
in enum <em>OpCode</em></div>
<pre class="insert" translate="no">  <span class="a">OP_INVOKE</span>,
</pre><pre class="insert-after" translate="no">  OP_CLOSURE,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>
<p>And add it to the disassembler:</p>
<div class="codehilite"><pre class="insert-before" translate="no">    case OP_CALL:
      return byteInstruction("OP_CALL", chunk, offset);
</pre><div class="source-file"><em>debug.c</em><br/>
in <em>disassembleInstruction</em>()</div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="a">OP_INVOKE</span>:
      <span class="k">return</span> <span class="i">invokeInstruction</span>(<span class="s">"OP_INVOKE"</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
</pre><pre class="insert-after" translate="no">    case OP_CLOSURE: {
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>
<p>This is a new, special instruction format, so it needs a little custom
disassembly logic.</p>
<div class="codehilite"><div class="source-file"><em>debug.c</em><br/>
add after <em>constantInstruction</em>()</div>
<pre translate="no"><span class="k">static</span> <span class="t">int</span> <span class="i">invokeInstruction</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">name</span>, <span class="t">Chunk</span>* <span class="i">chunk</span>,
                                <span class="t">int</span> <span class="i">offset</span>) {
  <span class="t">uint8_t</span> <span class="i">constant</span> = <span class="i">chunk</span>-&gt;<span class="i">code</span>[<span class="i">offset</span> + <span class="n">1</span>];
  <span class="t">uint8_t</span> <span class="i">argCount</span> = <span class="i">chunk</span>-&gt;<span class="i">code</span>[<span class="i">offset</span> + <span class="n">2</span>];
  <span class="i">printf</span>(<span class="s">"%-16s (%d args) %4d '"</span>, <span class="i">name</span>, <span class="i">argCount</span>, <span class="i">constant</span>);
  <span class="i">printValue</span>(<span class="i">chunk</span>-&gt;<span class="i">constants</span>.<span class="i">values</span>[<span class="i">constant</span>]);
  <span class="i">printf</span>(<span class="s">"'</span><span class="e">\n</span><span class="s">"</span>);
  <span class="k">return</span> <span class="i">offset</span> + <span class="n">3</span>;
}
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, add after <em>constantInstruction</em>()</div>
<p>We read the two operands and then print out both the method name and the
argument count. Over in the interpreter’s bytecode dispatch loop is where the
real action begins.</p>
<div class="codehilite"><pre class="insert-before" translate="no">      }
</pre><div class="source-file"><em>vm.c</em><br/>
in <em>run</em>()</div>
<pre class="insert" translate="no">      <span class="k">case</span> <span class="a">OP_INVOKE</span>: {
        <span class="t">ObjString</span>* <span class="i">method</span> = <span class="a">READ_STRING</span>();
        <span class="t">int</span> <span class="i">argCount</span> = <span class="a">READ_BYTE</span>();
        <span class="k">if</span> (!<span class="i">invoke</span>(<span class="i">method</span>, <span class="i">argCount</span>)) {
          <span class="k">return</span> <span class="a">INTERPRET_RUNTIME_ERROR</span>;
        }
        <span class="i">frame</span> = &amp;<span class="i">vm</span>.<span class="i">frames</span>[<span class="i">vm</span>.<span class="i">frameCount</span> - <span class="n">1</span>];
        <span class="k">break</span>;
      }
</pre><pre class="insert-after" translate="no">      case OP_CLOSURE: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p>Most of the work happens in <code translate="no">invoke()</code>, which we’ll get to. Here, we look up the
method name from the first operand and then read the argument count operand.
Then we hand off to <code translate="no">invoke()</code> to do the heavy lifting. That function returns
<code translate="no">true</code> if the invocation succeeds. As usual, a <code translate="no">false</code> return means a runtime
error occurred. We check for that here and abort the interpreter if disaster has
struck.</p>
<p>Finally, assuming the invocation succeeded, then there is a new CallFrame on the
stack, so we refresh our cached copy of the current frame in <code translate="no">frame</code>.</p>
<p>The interesting work happens here:</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br/>
add after <em>callValue</em>()</div>
<pre translate="no"><span class="k">static</span> <span class="t">bool</span> <span class="i">invoke</span>(<span class="t">ObjString</span>* <span class="i">name</span>, <span class="t">int</span> <span class="i">argCount</span>) {
  <span class="t">Value</span> <span class="i">receiver</span> = <span class="i">peek</span>(<span class="i">argCount</span>);
  <span class="t">ObjInstance</span>* <span class="i">instance</span> = <span class="a">AS_INSTANCE</span>(<span class="i">receiver</span>);
  <span class="k">return</span> <span class="i">invokeFromClass</span>(<span class="i">instance</span>-&gt;<span class="i">klass</span>, <span class="i">name</span>, <span class="i">argCount</span>);
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>callValue</em>()</div>
<p>First we grab the receiver off the stack. The arguments passed to the method are
above it on the stack, so we peek that many slots down. Then it’s a simple
matter to cast the object to an instance and invoke the method on it.</p>
<p>That does assume the object <em>is</em> an instance. As with <code translate="no">OP_GET_PROPERTY</code>
instructions, we also need to handle the case where a user incorrectly tries to
call a method on a value of the wrong type.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  Value receiver = peek(argCount);
</pre><div class="source-file"><em>vm.c</em><br/>
in <em>invoke</em>()</div>
<pre class="insert" translate="no">

  <span class="k">if</span> (!<span class="a">IS_INSTANCE</span>(<span class="i">receiver</span>)) {
    <span class="i">runtimeError</span>(<span class="s">"Only instances have methods."</span>);
    <span class="k">return</span> <span class="k">false</span>;
  }

</pre><pre class="insert-after" translate="no">  ObjInstance* instance = AS_INSTANCE(receiver);
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>invoke</em>()</div>
<p><span name="helper">That’s</span> a runtime error, so we report that and bail
out. Otherwise, we get the instance’s class and jump over to this other new
utility function:</p>
<aside name="helper">
<p>As you can guess by now, we split this code into a separate function because
we’re going to reuse it later<span class="em">—</span>in this case for <code translate="no">super</code> calls.</p>
</aside>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br/>
add after <em>callValue</em>()</div>
<pre translate="no"><span class="k">static</span> <span class="t">bool</span> <span class="i">invokeFromClass</span>(<span class="t">ObjClass</span>* <span class="i">klass</span>, <span class="t">ObjString</span>* <span class="i">name</span>,
                            <span class="t">int</span> <span class="i">argCount</span>) {
  <span class="t">Value</span> <span class="i">method</span>;
  <span class="k">if</span> (!<span class="i">tableGet</span>(&amp;<span class="i">klass</span>-&gt;<span class="i">methods</span>, <span class="i">name</span>, &amp;<span class="i">method</span>)) {
    <span class="i">runtimeError</span>(<span class="s">"Undefined property '%s'."</span>, <span class="i">name</span>-&gt;<span class="i">chars</span>);
    <span class="k">return</span> <span class="k">false</span>;
  }
  <span class="k">return</span> <span class="i">call</span>(<span class="a">AS_CLOSURE</span>(<span class="i">method</span>), <span class="i">argCount</span>);
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>callValue</em>()</div>
<p>This function combines the logic of how the VM implements <code translate="no">OP_GET_PROPERTY</code> and
<code translate="no">OP_CALL</code> instructions, in that order. First we look up the method by name in
the class’s method table. If we don’t find one, we report that runtime error and
exit.</p>
<p>Otherwise, we take the method’s closure and push a call to it onto the CallFrame
stack. We don’t need to heap allocate and initialize an ObjBoundMethod. In fact,
we don’t even need to <span name="juggle">juggle</span> anything on the stack.
The receiver and method arguments are already right where they need to be.</p>
<aside name="juggle">
<p>This is a key reason <em>why</em> we use stack slot zero to store the receiver<span class="em">—</span>it’s
how the caller already organizes the stack for a method call. An efficient
calling convention is an important part of a bytecode VM’s performance story.</p>
</aside>
<p>If you fire up the VM and run a little program that calls methods now, you
should see the exact same behavior as before. But, if we did our job right, the
<em>performance</em> should be much improved. I wrote a little microbenchmark that
does a batch of 10,000 method calls. Then it tests how many of these batches it
can execute in 10 seconds. On my computer, without the new <code translate="no">OP_INVOKE</code>
instruction, it got through 1,089 batches. With this new optimization, it
finished 8,324 batches in the same time. That’s <em>7.6 times faster</em>, which is a
huge improvement when it comes to programming language optimization.</p>
<p><span name="pat"></span></p>
<aside name="pat">
<p>We shouldn’t pat ourselves on the back <em>too</em> firmly. This performance
improvement is relative to our own unoptimized method call implementation which
was quite slow. Doing a heap allocation for every single method call isn’t going
to win any races.</p>
</aside><img alt="Bar chart comparing the two benchmark results." src="image/methods-and-initializers/benchmark.png"/>
<h3><a href="#invoking-fields" id="invoking-fields"><small>28 . 5 . 1</small>Invoking fields</a></h3>
<p>The fundamental creed of optimization is: “Thou shalt not break correctness.”
<span name="monte">Users</span> like it when a language implementation gives
them an answer faster, but only if it’s the <em>right</em> answer. Alas, our
implementation of faster method invocations fails to uphold that principle:</p>
<div class="codehilite"><pre translate="no"><span class="k">class</span> <span class="t">Oops</span> {
  <span class="i">init</span>() {
    <span class="k">fun</span> <span class="i">f</span>() {
      <span class="k">print</span> <span class="s">"not a method"</span>;
    }

    <span class="k">this</span>.<span class="i">field</span> = <span class="i">f</span>;
  }
}

<span class="k">var</span> <span class="i">oops</span> = <span class="t">Oops</span>();
<span class="i">oops</span>.<span class="i">field</span>();
</pre></div>
<p>The last line looks like a method call. The compiler thinks that it is and
dutifully emits an <code translate="no">OP_INVOKE</code> instruction for it. However, it’s not. What is
actually happening is a <em>field</em> access that returns a function which then gets
called. Right now, instead of executing that correctly, our VM reports a runtime
error when it can’t find a method named “field”.</p>
<aside name="monte">
<p>There are cases where users may be satisfied when a program sometimes returns
the wrong answer in return for running significantly faster or with a better
bound on the performance. These are the field of <a href="https://en.wikipedia.org/wiki/Monte_Carlo_algorithm"><strong>Monte Carlo
algorithms</strong></a>. For some use cases, this is a good trade-off.</p>
<p>The important part, though, is that the user is <em>choosing</em> to apply one of these
algorithms. We language implementers can’t unilaterally decide to sacrifice
their program’s correctness.</p>
</aside>
<p>Earlier, when we implemented <code translate="no">OP_GET_PROPERTY</code>, we handled both field and method
accesses. To squash this new bug, we need to do the same thing for <code translate="no">OP_INVOKE</code>.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  ObjInstance* instance = AS_INSTANCE(receiver);
</pre><div class="source-file"><em>vm.c</em><br/>
in <em>invoke</em>()</div>
<pre class="insert" translate="no">

  <span class="t">Value</span> <span class="i">value</span>;
  <span class="k">if</span> (<span class="i">tableGet</span>(&amp;<span class="i">instance</span>-&gt;<span class="i">fields</span>, <span class="i">name</span>, &amp;<span class="i">value</span>)) {
    <span class="i">vm</span>.<span class="i">stackTop</span>[-<span class="i">argCount</span> - <span class="n">1</span>] = <span class="i">value</span>;
    <span class="k">return</span> <span class="i">callValue</span>(<span class="i">value</span>, <span class="i">argCount</span>);
  }

</pre><pre class="insert-after" translate="no">  return invokeFromClass(instance-&gt;klass, name, argCount);
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>invoke</em>()</div>
<p>Pretty simple fix. Before looking up a method on the instance’s class, we look
for a field with the same name. If we find a field, then we store it on the
stack in place of the receiver, <em>under</em> the argument list. This is how
<code translate="no">OP_GET_PROPERTY</code> behaves since the latter instruction executes before a
subsequent parenthesized list of arguments has been evaluated.</p>
<p>Then we try to call that field’s value like the callable that it hopefully is.
The <code translate="no">callValue()</code> helper will check the value’s type and call it as appropriate
or report a runtime error if the field’s value isn’t a callable type like a
closure.</p>
<p>That’s all it takes to make our optimization fully safe. We do sacrifice a
little performance, unfortunately. But that’s the price you have to pay
sometimes. You occasionally get frustrated by optimizations you <em>could</em> do if
only the language wouldn’t allow some annoying corner case. But, as language
<span name="designer">implementers</span>, we have to play the game we’re given.</p>
<aside name="designer">
<p>As language <em>designers</em>, our role is very different. If we do control the
language itself, we may sometimes choose to restrict or change the language in
ways that enable optimizations. Users want expressive languages, but they also
want fast implementations. Sometimes it is good language design to sacrifice a
little power if you can give them perf in return.</p>
</aside>
<p>The code we wrote here follows a typical pattern in optimization:</p>
<ol>
<li>
<p>Recognize a common operation or sequence of operations that is performance
critical. In this case, it is a method access followed by a call.</p>
</li>
<li>
<p>Add an optimized implementation of that pattern. That’s our <code translate="no">OP_INVOKE</code>
instruction.</p>
</li>
<li>
<p>Guard the optimized code with some conditional logic that validates that the
pattern actually applies. If it does, stay on the fast path. Otherwise, fall
back to a slower but more robust unoptimized behavior. Here, that means
checking that we are actually calling a method and not accessing a field.</p>
</li>
</ol>
<p>As your language work moves from getting the implementation working <em>at all</em> to
getting it to work <em>faster</em>, you will find yourself spending more and more
time looking for patterns like this and adding guarded optimizations for them.
Full-time VM engineers spend much of their careers in this loop.</p>
<p>But we can stop here for now. With this, clox now supports most of the features
of an object-oriented programming language, and with respectable performance.</p>
<div class="challenges">
<h2><a href="#challenges" id="challenges">Challenges</a></h2>
<ol>
<li>
<p>The hash table lookup to find a class’s <code translate="no">init()</code> method is constant time,
but still fairly slow. Implement something faster. Write a benchmark and
measure the performance difference.</p>
</li>
<li>
<p>In a dynamically typed language like Lox, a single callsite may invoke a
variety of methods on a number of classes throughout a program’s execution.
Even so, in practice, most of the time a callsite ends up calling the exact
same method on the exact same class for the duration of the run. Most calls
are actually not polymorphic even if the language says they can be.</p>
<p>How do advanced language implementations optimize based on that observation?</p>
</li>
<li>
<p>When interpreting an <code translate="no">OP_INVOKE</code> instruction, the VM has to do two hash
table lookups. First, it looks for a field that could shadow a method, and
only if that fails does it look for a method. The former check is rarely
useful<span class="em">—</span>most fields do not contain functions. But it is <em>necessary</em>
because the language says fields and methods are accessed using the same
syntax, and fields shadow methods.</p>
<p>That is a language <em>choice</em> that affects the performance of our
implementation. Was it the right choice? If Lox were your language, what
would you do?</p>
</li>
</ol>
</div>
<div class="design-note">
<h2><a href="#design-note" id="design-note">Design Note: Novelty Budget</a></h2>
<p>I still remember the first time I wrote a tiny BASIC program on a TRS-80 and
made a computer do something it hadn’t done before. It felt like a superpower.
The first time I cobbled together just enough of a parser and interpreter to let
me write a tiny program in <em>my own language</em> that made a computer do a thing was
like some sort of higher-order meta-superpower. It was and remains a wonderful
feeling.</p>
<p>I realized I could design a language that looked and behaved however I chose. It
was like I’d been going to a private school that required uniforms my whole life
and then one day transferred to a public school where I could wear whatever I
wanted. I don’t need to use curly braces for blocks? I can use something other
than an equals sign for assignment? I can do objects without classes? Multiple
inheritance <em>and</em> multimethods? A dynamic language that overloads statically, by
arity?</p>
<p>Naturally, I took that freedom and ran with it. I made the weirdest, most
arbitrary language design decisions. Apostrophes for generics. No commas between
arguments. Overload resolution that can fail at runtime. I did things
differently just for difference’s sake.</p>
<p>This is a very fun experience that I highly recommend. We need more weird,
avant-garde programming languages. I want to see more art languages. I still
make oddball toy languages for fun sometimes.</p>
<p><em>However</em>, if your goal is success where “success” is defined as a large number
of users, then your priorities must be different. In that case, your primary
goal is to have your language loaded into the brains of as many people as
possible. That’s <em>really hard</em>. It takes a lot of human effort to move a
language’s syntax and semantics from a computer into trillions of neurons.</p>
<p>Programmers are naturally conservative with their time and cautious about what
languages are worth uploading into their wetware. They don’t want to waste their
time on a language that ends up not being useful to them. As a language
designer, your goal is thus to give them as much language power as you can with
as little required learning as possible.</p>
<p>One natural approach is <em>simplicity</em>. The fewer concepts and features your
language has, the less total volume of stuff there is to learn. This is one of
the reasons minimal <span name="dynamic">scripting</span> languages often find
success even though they aren’t as powerful as the big industrial languages<span class="em">—</span>they are easier to get started with, and once they are in someone’s brain, the
user wants to keep using them.</p>
<aside name="dynamic">
<p>In particular, this is a big advantage of dynamically typed languages. A static
language requires you to learn <em>two</em> languages<span class="em">—</span>the runtime semantics and the
static type system<span class="em">—</span>before you can get to the point where you are making the
computer do stuff. Dynamic languages require you to learn only the former.</p>
<p>Eventually, programs get big enough that the value of static analysis pays for
the effort to learn that second static language, but the value proposition isn’t
as obvious at the outset.</p>
</aside>
<p>The problem with simplicity is that simply cutting features often sacrifices
power and expressiveness. There is an art to finding features that punch above
their weight, but often minimal languages simply do less.</p>
<p>There is another path that avoids much of that problem. The trick is to realize
that a user doesn’t have to load your entire language into their head, <em>just the
part they don’t already have in there</em>. As I mentioned in an <a href="parsing-expressions.html#design-note">earlier design
note</a>, learning is about transferring the <em>delta</em> between what they
already know and what they need to know.</p>
<p>Many potential users of your language already know some other programming
language. Any features your language shares with that language are essentially
“free” when it comes to learning. It’s already in their head, they just have to
recognize that your language does the same thing.</p>
<p>In other words, <em>familiarity</em> is another key tool to lower the adoption cost of
your language. Of course, if you fully maximize that attribute, the end result
is a language that is completely identical to some existing one. That’s not a
recipe for success, because at that point there’s no incentive for users to
switch to your language at all.</p>
<p>So you do need to provide some compelling differences. Some things your language
can do that other languages can’t, or at least can’t do as well. I believe this
is one of the fundamental balancing acts of language design: similarity to other
languages lowers learning cost, while divergence raises the compelling
advantages.</p>
<p>I think of this balancing act in terms of a <span name="idiosyncracy"><strong>novelty
budget</strong></span>, or as Steve Klabnik calls it, a “<a href="https://words.steveklabnik.com/the-language-strangeness-budget">strangeness budget</a>”. Users
have a low threshold for the total amount of new stuff they are willing to
accept to learn a new language. Exceed that, and they won’t show up.</p>
<aside name="idiosyncracy">
<p>A related concept in psychology is <a href="https://en.wikipedia.org/wiki/Idiosyncrasy_credit"><strong>idiosyncrasy credit</strong></a>, the
idea that other people in society grant you a finite amount of deviations from
social norms. You earn credit by fitting in and doing in-group things, which you
can then spend on oddball activities that might otherwise raise eyebrows. In
other words, demonstrating that you are “one of the good ones” gives you license
to raise your freak flag, but only so far.</p>
</aside>
<p>Anytime you add something new to your language that other languages don’t have,
or anytime your language does something other languages do in a different way,
you spend some of that budget. That’s OK<span class="em">—</span>you <em>need</em> to spend it to make your
language compelling. But your goal is to spend it <em>wisely</em>. For each feature or
difference, ask yourself how much compelling power it adds to your language and
then evaluate critically whether it pays its way. Is the change so valuable that
it is worth blowing some of your novelty budget?</p>
<p>In practice, I find this means that you end up being pretty conservative with
syntax and more adventurous with semantics. As fun as it is to put on a new
change of clothes, swapping out curly braces with some other block delimiter is
very unlikely to add much real power to the language, but it does spend some
novelty. It’s hard for syntax differences to carry their weight.</p>
<p>On the other hand, new semantics can significantly increase the power of the
language. Multimethods, mixins, traits, reflection, dependent types, runtime
metaprogramming, etc. can radically level up what a user can do with the
language.</p>
<p>Alas, being conservative like this is not as fun as just changing everything.
But it’s up to you to decide whether you want to chase mainstream success or not
in the first place. We don’t all need to be radio-friendly pop bands. If you
want your language to be like free jazz or drone metal and are happy with the
proportionally smaller (but likely more devoted) audience size, go for it.</p>
</div>
<footer>
<a class="next" href="superclasses.html">
  Next Chapter: “Superclasses” →
</a>
Handcrafted by Robert Nystrom — <a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">© 2015 – 2021</a>
</footer>
</img></img></article>
</div>
</body>
</html>
