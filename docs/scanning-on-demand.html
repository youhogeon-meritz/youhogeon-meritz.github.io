<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link rel="stylesheet" type="text/css" href="cid:css-0be6a3e0-259d-4bdb-b49e-b380e8ed0186@mhtml.blink" />

<title>Scanning on Demand · Crafting Interpreters</title>
<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta content="width=device-width, initial-scale=1" name="viewport">
<link href="https://youhogeon-meritz.github.io/style.css" rel="stylesheet" type="text/css">
<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600" rel="stylesheet" type="text/css">
<link href="https://youhogeon-meritz.github.io/image/favicon.png" rel="icon" type="image/png">


<!-- Google analytics -->

</head>
<body id="top">
<!-- <div class="scrim"></div> -->
<nav class="wide">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<div class="contents">
<h3><a href="https://youhogeon-meritz.github.io/scanning-on-demand.html#top"><font papago-translate="splitted"><font papago-translate="translated">온디맨드 스캔</font></font><small>16</small></a></h3>
<ul>
<li><a href="https://youhogeon-meritz.github.io/scanning-on-demand.html#spinning-up-the-interpreter"><small>16.1</small><font papago-translate="splitted"><font papago-translate="translated"> 통역사 스피닝 업</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/scanning-on-demand.html#a-token-at-a-time"><small>16.2</small><font papago-translate="splitted"><font papago-translate="translated"> 토큰 한 번에</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/scanning-on-demand.html#a-lexical-grammar-for-lox"><small>16.3</small><font papago-translate="splitted"><font papago-translate="translated"> Lox를 위한 어휘 문법</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/scanning-on-demand.html#identifiers-and-keywords"><small>16.4</small><font papago-translate="splitted"><font papago-translate="translated"> 식별자 및 키워드</font></font></a></li>
<li class="divider"></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/scanning-on-demand.html#challenges"><font papago-translate="translated">과제들</font></a></li>
</ul>
<div class="prev-next">
<a class="left" href="https://youhogeon-meritz.github.io/a-virtual-machine.html" title="가상 머신" papago-attr-id="1"><font papago-translate="translated">← 이전</font></a>
<a href="https://youhogeon-meritz.github.io/a-bytecode-virtual-machine.html" title="바이트코드 가상 머신" papago-attr-id="2"><font papago-translate="translated">↑ 위로</font></a>
<a class="right" href="https://youhogeon-meritz.github.io/compiling-expressions.html" title="표현식 컴파일하기" papago-attr-id="3"><font papago-translate="translated">다음 →</font></a>
</div> </div>
</nav>
<nav class="narrow">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<a class="prev" href="https://youhogeon-meritz.github.io/a-virtual-machine.html" title="A Virtual Machine">←</a>
<a class="next" href="https://youhogeon-meritz.github.io/compiling-expressions.html" title="Compiling Expressions">→</a>
</nav>
<div class="page">
<div class="nav-wrapper">
<nav class="floating pinned">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<div class="expandable">
<h3><a href="https://youhogeon-meritz.github.io/scanning-on-demand.html#top"><font papago-translate="splitted"><font papago-translate="translated">온디맨드 스캔</font></font><small>16</small></a></h3>
<ul>
<li><a href="https://youhogeon-meritz.github.io/scanning-on-demand.html#spinning-up-the-interpreter"><small>16.1</small><font papago-translate="splitted"><font papago-translate="translated"> 통역사 스피닝 업</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/scanning-on-demand.html#a-token-at-a-time"><small>16.2</small><font papago-translate="splitted"><font papago-translate="translated"> 토큰 한 번에</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/scanning-on-demand.html#a-lexical-grammar-for-lox"><small>16.3</small><font papago-translate="splitted"><font papago-translate="translated"> Lox를 위한 어휘 문법</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/scanning-on-demand.html#identifiers-and-keywords"><small>16.4</small><font papago-translate="splitted"><font papago-translate="translated"> 식별자 및 키워드</font></font></a></li>
<li class="divider"></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/scanning-on-demand.html#challenges">Challenges</a></li>
</ul>
<div class="prev-next">
<a class="left" href="https://youhogeon-meritz.github.io/a-virtual-machine.html" title="A Virtual Machine">←&nbsp;Previous</a>
<a href="https://youhogeon-meritz.github.io/a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">↑&nbsp;Up</a>
<a class="right" href="https://youhogeon-meritz.github.io/compiling-expressions.html" title="Compiling Expressions">Next&nbsp;→</a>
</div> </div>
<a id="expand-nav">≡</a>
</nav>
</div>
<article class="chapter">
<div class="number">16</div>
<h1><font papago-translate="translated">온디맨드 스캔</font></h1>
<blockquote>
<p><font papago-translate="translated">문학은 26개의 음성 기호, 10개의 아랍어 숫자, 약 8개의 구두점만으로 이루어진 독특한 배열입니다.</font></p>
<p><cite>Kurt Vonnegut, <em>Like Shaking Hands With God: A Conversation about Writing</em></cite></p>
</blockquote>
<p><font papago-translate="translated">두 번째 인터프리터인 clox는 스캐너, 컴파일러, 가상<span class="em"></span> 머신의 세 가지 단계로 구성되어 있습니다.</font><font papago-translate="translated"> 데이터 구조는 각 단계 쌍을 연결합니다.</font><font papago-translate="translated"> 토큰은 스캐너에서 컴파일러로, 바이트코드 덩어리는 컴파일러에서 VM으로 흐릅니다.</font><font papago-translate="translated"> <a href="https://youhogeon-meritz.github.io/chunks-of-bytecode.html">우리</a>는<a href="https://youhogeon-meritz.github.io/chunks-of-bytecode.html"> 거의</a> 마지막에<a href="https://youhogeon-meritz.github.io/chunks-of-bytecode.html"> 청크</a><a href="https://youhogeon-meritz.github.io/a-virtual-machine.html"></a>와 VM으로 구현을 시작했습니다.</font><font papago-translate="translated"> 이제 처음으로 돌아가서 토큰을 만드는 스캐너를 만들겠습니다.</font><font papago-translate="translated"> <a href="https://youhogeon-meritz.github.io/compiling-expressions.html">다음 장</a>에서는 바이트코드 컴파일러와 함께 두 끝을 연결하겠습니다.</font></p><img alt="Source code → scanner → tokens → compiler → bytecode chunk → VM." src="https://youhogeon-meritz.github.io/image/scanning-on-demand/pipeline.png">
<p><font papago-translate="translated">인정하건대, 이것은 책에서 가장 흥미로운 장이 아닙니다.</font><font papago-translate="translated"> 같은 언어를 두 번 구현하면 중복성이 생길 수밖에 없습니다.</font><font papago-translate="translated"> 저는 Jlox의 스캐너와 비교했을 때 몇 가지 흥미로운 차이점을 살짝 발견했습니다.</font><font papago-translate="translated"> 그것들이 무엇인지 계속 읽어보세요.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/scanning-on-demand.html#spinning-up-the-interpreter" id="spinning-up-the-interpreter"><small><font papago-translate="translated">16 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">통역사 스피닝 업</font></font></a></h2>
<p><font papago-translate="splitted"><font papago-translate="translated">이제 프론트엔드를 구축하고 있으니 실제 통역사처럼 클록스를 실행할 수 있습니다.</font><font papago-translate="translated"> 더 이상 수작업으로 작성한 바이트코드 조각이 없습니다.</font><font papago-translate="translated"> 이제 REPL과 스크립트 로딩 시간입니다.</font><font papago-translate="translated"> 대부분의 코드를 삭제합니다 </font></font><code translate="no">main()</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고 그것을 대체합니다:</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">int main(int argc, const char* argv[]) {
  initVM();

</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">주요.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>메인</em> ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 26줄 교체</font></font></div>
<pre class="insert" translate="no">  <span class="k">if</span> (<span class="i">argc</span> == <span class="n">1</span>) {
    <span class="i">repl</span>();
  } <span class="k">else</span> <span class="k">if</span> (<span class="i">argc</span> == <span class="n">2</span>) {
    <span class="i">runFile</span>(<span class="i">argv</span>[<span class="n">1</span>]);
  } <span class="k">else</span> {
    <span class="i">fprintf</span>(<span class="i">stderr</span>, <span class="s">"Usage: clox [path]</span><span class="e">\n</span><span class="s">"</span>);
    <span class="i">exit</span>(<span class="n">64</span>);
  }

  <span class="i">freeVM</span>();
</pre><pre class="insert-after" translate="no">  return 0;
}
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>main</em>(), replace 26 lines</div>
<p><font papago-translate="translated">실행 파일에<span name="args"> 인수</span>를 전달<span name="args">하지 않으면</span> REPL에 삭제됩니다.</font><font papago-translate="translated"> 단일 명령줄 인수는 실행할 스크립트의 경로로 이해됩니다.</font></p>
<aside name="args" style="top: 1498px;">
<p><font papago-translate="splitted"><font papago-translate="translated">코드는 첫 번째 인수가 0과 1이 아닌 1과 2 인수에 대해 테스트합니다 </font></font><code translate="no">argv</code><font papago-translate="splitted"><font papago-translate="translated"> 는 항상 실행 중인 실행 파일의 이름입니다.</font></font></p>
</aside>
<p><font papago-translate="translated">시스템 헤더가 몇 개 필요하니 모두 정리해 보겠습니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">주요.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 파일 위에 추가</font></font></div>
<pre class="insert" translate="no"><span class="a">#include &lt;stdio.h&gt;</span>
<span class="a">#include &lt;stdlib.h&gt;</span>
<span class="a">#include &lt;string.h&gt;</span>

</pre><pre class="insert-after" translate="no">#include "common.h"
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, add to top of file</div>
<p><font papago-translate="translated">다음으로, 우리는 REPL을 올리고 REPL-ing합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#include "vm.h"
</pre><div class="source-file"><em><font papago-translate="translated">주요.c</font></em></div>
<pre class="insert" translate="no">
<span class="k">static</span> <span class="t">void</span> <span class="i">repl</span>() {
  <span class="t">char</span> <span class="i">line</span>[<span class="n">1024</span>];
  <span class="k">for</span> (;;) {
    <span class="i">printf</span>(<span class="s">"&gt; "</span>);

    <span class="k">if</span> (!<span class="i">fgets</span>(<span class="i">line</span>, <span class="k">sizeof</span>(<span class="i">line</span>), <span class="i">stdin</span>)) {
      <span class="i">printf</span>(<span class="s">"</span><span class="e">\n</span><span class="s">"</span>);
      <span class="k">break</span>;
    }

    <span class="i">interpret</span>(<span class="i">line</span>);
  }
}
</pre></div>
<div class="source-file-narrow"><em>main.c</em></div>
<p><font papago-translate="translated">품질 좋은 REPL은 여러 줄에 걸쳐 있는 입력을 우아하게 처리하며, 하드코딩된 줄 길이 제한이 없습니다.</font><font papago-translate="translated"> 여기 있는 이 REPL은 조금 더, 아흠, 엄격하지만 우리의 목적에는 괜찮습니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">실제 작업은 다음에서 이루어집니다 </font></font><code translate="no">interpret()</code><font papago-translate="splitted"><font papago-translate="translated">. 곧 설명하겠지만, 먼저 스크립트를 로드하는 작업을 처리하겠습니다.</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">주요.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>repl</em> () 후 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">runFile</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">path</span>) {
  <span class="t">char</span>* <span class="i">source</span> = <span class="i">readFile</span>(<span class="i">path</span>);
  <span class="t">InterpretResult</span> <span class="i">result</span> = <span class="i">interpret</span>(<span class="i">source</span>);
  <span class="i">free</span>(<span class="i">source</span>);<span name="owner"> </span>

  <span class="k">if</span> (<span class="i">result</span> == <span class="a">INTERPRET_COMPILE_ERROR</span>) <span class="i">exit</span>(<span class="n">65</span>);
  <span class="k">if</span> (<span class="i">result</span> == <span class="a">INTERPRET_RUNTIME_ERROR</span>) <span class="i">exit</span>(<span class="n">70</span>);
}
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, add after <em>repl</em>()</div>
<p><font papago-translate="translated">파일을 읽고 결과적으로 생성된 Lox 소스 코드 문자열을 실행합니다.</font><font papago-translate="translated"> 그런 다음 그 결과를 바탕으로 신중한 도구 제작자이기 때문에 출구 코드를 적절하게 설정하고 작은 세부 사항에도 신경을 씁니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">소스 코드 문자열을 해제해야 하는 이유는 다음과 같습니다 </font></font><code translate="no">readFile()</code><font papago-translate="splitted"><font papago-translate="translated"> 동적으로 할당하고 발신자에게 소유권을 넘깁니다.</font><font papago-translate="translated"> 그 함수는 다음과 같습니다:</font></font></p>
<aside name="owner" style="top: 2341px;">
<p><font papago-translate="translated">C는 우리에게 기억을 명시적으로 관리하는 것뿐만 아니라<em> 정신적으로도</em> 관리해 달라고 요청합니다.</font><font papago-translate="translated"> 프로그래머들은 소유권 규칙을 기억하고 프로그램 전반에 걸쳐 이를 수작업으로 구현해야 합니다.</font><font papago-translate="translated"> 자바는 우리를 위해 그것을 해줍니다.</font><font papago-translate="translated"> C++는 컴파일러가 이를 검증할 수 있도록 정책을 직접 인코딩할 수 있는 도구를 제공합니다.</font></p>
<p><font papago-translate="translated">저는 C의 단순함을 좋아하지만, 우리는 그것에 대해 진정한 대가를 치릅니다. 그 언어는 우리가 더<span class="em"></span> 성실해야 한다는 것을 요구합니다.</font></p>
</aside>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">주요.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>repl</em> () 후 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">char</span>* <span class="i">readFile</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">path</span>) {
  <span class="a">FILE</span>* <span class="i">file</span> = <span class="i">fopen</span>(<span class="i">path</span>, <span class="s">"rb"</span>);

  <span class="i">fseek</span>(<span class="i">file</span>, <span class="n">0L</span>, <span class="a">SEEK_END</span>);
  <span class="t">size_t</span> <span class="i">fileSize</span> = <span class="i">ftell</span>(<span class="i">file</span>);
  <span class="i">rewind</span>(<span class="i">file</span>);

  <span class="t">char</span>* <span class="i">buffer</span> = (<span class="t">char</span>*)<span class="i">malloc</span>(<span class="i">fileSize</span> + <span class="n">1</span>);
  <span class="t">size_t</span> <span class="i">bytesRead</span> = <span class="i">fread</span>(<span class="i">buffer</span>, <span class="k">sizeof</span>(<span class="t">char</span>), <span class="i">fileSize</span>, <span class="i">file</span>);
  <span class="i">buffer</span>[<span class="i">bytesRead</span>] = <span class="s">'\0'</span>;

  <span class="i">fclose</span>(<span class="i">file</span>);
  <span class="k">return</span> <span class="i">buffer</span>;
}
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, add after <em>repl</em>()</div>
<p><font papago-translate="translated">많은 C 코드와 마찬가지로, 특히 운영 체제를 위해 특별히 설계된 언어의 경우 생각보다 더 많은 노력이 필요합니다.</font><font papago-translate="translated"> 어려운 점은 전체 파일을 읽을 수 있을 만큼 큰 문자열을 할당하고 싶지만, 파일이 얼마나 큰지는 읽기 전까지는 알 수 없다는 것입니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">여기 있는 코드가 그것을 해결하는 고전적인 요령입니다.</font><font papago-translate="translated"> 파일을 열기 전에 다음과 같은 방법으로 파일을 끝까지 읽습니다 </font></font><code translate="no">fseek()</code><font papago-translate="splitted"><font papago-translate="translated">. 그러면 우리는 전화합니다 </font></font><code translate="no">ftell()</code><font papago-translate="splitted"><font papago-translate="translated"> 파일 시작 시점부터 우리가 얼마나 많은 바이트를 가지고 있는지를 알려줍니다.</font><font papago-translate="translated"> 우리가 끝까지 추구(?)했으니, 그것이 바로 그 크기입니다.</font><font papago-translate="translated"> 우리는 처음으로 돌아가서 그<span name="one"> 크기</span>의 문자열을 할당하고 전체 파일을 한 번에 읽습니다.</font></font></p>
<aside name="one" style="top: 3154px;">
<p><font papago-translate="translated">음, 그 크기<em>에 하나를 더하면</em> 됩니다.</font><font papago-translate="translated"> 항상 널 바이트를 위한 공간을 마련해야 한다는 것을 기억해야 합니다.</font></p>
</aside>
<p><font papago-translate="translated">이제 끝났죠?</font><font papago-translate="translated"> 별로 그렇지 않아요.</font><font papago-translate="translated"> 이러한 함수 호출은 C 표준 라이브러리의 대부분의 호출과 마찬가지로 실패할 수 있습니다.</font><font papago-translate="translated"> 만약 이것이 Java라면, 실패는 예외로 간주되어 자동으로 스택을 해제하여 우리가<em></em> 실제로 처리할 필요가 없게 될 것입니다.</font><font papago-translate="translated"> C에서는 우리가 그들을 확인하지 않으면, 그들은 조용히 무시당합니다.</font></p>
<p><font papago-translate="translated">이것은 좋은 C 프로그래밍 연습에 관한 책은 아니지만, 나쁜 스타일을 권장하는 것은 싫으니 오류를 처리해 보겠습니다.</font><font papago-translate="translated"> 채소를 먹거나 치실질을 하는 것과 같이 우리에게 좋습니다.</font></p>
<p><font papago-translate="translated">다행히도 장애가 발생하면 특별히 영리한 조치를 취할 필요는 없습니다.</font><font papago-translate="translated"> 사용자의 스크립트를 제대로 읽을 수 없다면, 우리가 실제로 할 수 있는 일은 사용자에게 말하고 우아하게 인터프리터를 떠나는 것뿐입니다.</font><font papago-translate="translated"> 우선, 파일을 열지 못할 수도 있습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  FILE* file = fopen(path, "rb");
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">주요.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>readFile</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="k">if</span> (<span class="i">file</span> == <span class="a">NULL</span>) {
    <span class="i">fprintf</span>(<span class="i">stderr</span>, <span class="s">"Could not open file </span><span class="e">\"</span><span class="s">%s</span><span class="e">\"</span><span class="s">.</span><span class="e">\n</span><span class="s">"</span>, <span class="i">path</span>);
    <span class="i">exit</span>(<span class="n">74</span>);
  }
</pre><pre class="insert-after" translate="no">
  fseek(file, 0L, SEEK_END);
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>readFile</em>()</div>
<p><font papago-translate="translated">파일이 존재하지 않거나 사용자가 파일에 접근할 수 없는 경우 이런 일이 발생할 수 있습니다.</font><font papago-translate="translated"> 사람들이<span class="em"></span> 항상 경로를 잘못 입력하는 것은 꽤 흔한 일입니다.</font></p>
<p><font papago-translate="translated">이 실패는 훨씬 드뭅니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  char* buffer = (char*)malloc(fileSize + 1);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">주요.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>readFile</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="k">if</span> (<span class="i">buffer</span> == <span class="a">NULL</span>) {
    <span class="i">fprintf</span>(<span class="i">stderr</span>, <span class="s">"Not enough memory to read </span><span class="e">\"</span><span class="s">%s</span><span class="e">\"</span><span class="s">.</span><span class="e">\n</span><span class="s">"</span>, <span class="i">path</span>);
    <span class="i">exit</span>(<span class="n">74</span>);
  }

</pre><pre class="insert-after" translate="no">  size_t bytesRead = fread(buffer, sizeof(char), fileSize, file);
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>readFile</em>()</div>
<p><font papago-translate="translated">Lox 스크립트를 읽을 만큼 충분한 메모리를 할당할 수 없다면 사용자가 걱정해야 할 더 큰 문제가 있을 수 있지만, 최소한 그들에게 알릴 수 있도록 최선을 다해야 합니다.</font></p>
<p><font papago-translate="translated">마지막으로, 읽기 자체가 실패할 수 있습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  size_t bytesRead = fread(buffer, sizeof(char), fileSize, file);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">주요.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>readFile</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="k">if</span> (<span class="i">bytesRead</span> &lt; <span class="i">fileSize</span>) {
    <span class="i">fprintf</span>(<span class="i">stderr</span>, <span class="s">"Could not read file </span><span class="e">\"</span><span class="s">%s</span><span class="e">\"</span><span class="s">.</span><span class="e">\n</span><span class="s">"</span>, <span class="i">path</span>);
    <span class="i">exit</span>(<span class="n">74</span>);
  }

</pre><pre class="insert-after" translate="no">  buffer[bytesRead] = '\0';
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>readFile</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">이것도 가능성이 낮습니다.</font><font papago-translate="translated"> 사실, 다음과 같은<span name="printf"> 요청들</span> </font></font><code translate="no">fseek()</code><font papago-translate="splitted"><font papago-translate="translated">, </font></font><code translate="no">ftell()</code><font papago-translate="splitted"><font papago-translate="translated">,그리고. </font></font><code translate="no">rewind()</code><font papago-translate="splitted"><font papago-translate="translated"> 이론적으로는 실패할 수도 있지만, 너무 멀리 가지 말자, 그렇지 않나요?</font></font></p>
<aside name="printf" style="top: 4270px;">
<p><font papago-translate="splitted"><font papago-translate="translated">옛날에도 </font></font><code translate="no">printf()</code><font papago-translate="splitted"><font papago-translate="translated"> 실패할 수 있습니다.</font><font papago-translate="translated"> 네.<em> 그</em> 오류를 몇 번이나 처리하셨나요?</font></font></p>
</aside>
<h3><a href="https://youhogeon-meritz.github.io/scanning-on-demand.html#opening-the-compilation-pipeline" id="opening-the-compilation-pipeline"><small><font papago-translate="translated">16 . 1 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">컴파일 파이프라인 열기</font></font></a></h3>
<p><font papago-translate="splitted"><font papago-translate="translated">우리는 Lox 소스 코드 문자열을 가지고 있어서 이제 이를 스캔하고 컴파일하며 실행할 파이프라인을 설정할 준비가 되었습니다.</font><font papago-translate="translated"> 다음에 의해 구동됩니다 </font></font><code translate="no">interpret()</code><font papago-translate="splitted"><font papago-translate="translated">. 현재 이 함수는 이전 하드코딩된 테스트 청크를 실행합니다.</font><font papago-translate="translated"> 마지막 화신에 더 가까운 것으로 바꿔 보겠습니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">void freeVM();
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">VM.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 함수<em> 해석</em> ()</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no"><span class="t">InterpretResult</span> <span class="i">interpret</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">source</span>);
</pre><pre class="insert-after" translate="no">void push(Value value);
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, function <em>interpret</em>(), replace 1 line</div>
<p><font papago-translate="translated">청크를 통과하기 전에는 이제 소스 코드 문자열을 통과합니다.</font><font papago-translate="translated"> 새로운 구현은 다음과 같습니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 함수<em> 해석</em> ()</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 4줄 교체</font></font></div>
<pre class="insert" translate="no"><span class="t">InterpretResult</span> <span class="i">interpret</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">source</span>) {
  <span class="i">compile</span>(<span class="i">source</span>);
  <span class="k">return</span> <span class="a">INTERPRET_OK</span>;
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, function <em>interpret</em>(), replace 4 lines</div>
<p><font papago-translate="translated">이 장에서는 아직 실제<em> 컴파일러</em>를 만들지는 않겠지만, 그 구조를 정리하기 시작할 수 있습니다.</font><font papago-translate="translated"> 새 모듈에 저장됩니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#include "common.h"
</pre><div class="source-file"><em>vm.c</em></div>
<pre class="insert" translate="no"><span class="a">#include "compiler.h"</span>
</pre><pre class="insert-after" translate="no">#include "debug.h"
</pre></div>
<div class="source-file-narrow"><em>vm.c</em></div>
<p><font papago-translate="translated">현재로서는 그 안에 있는 유일한 기능이 다음과 같이 선언되어 있습니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 새 파일 만들기</font></font></div>
<pre translate="no"><span class="a">#ifndef clox_compiler_h</span>
<span class="a">#define clox_compiler_h</span>

<span class="t">void</span> <span class="i">compile</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">source</span>);

<span class="a">#endif</span>
</pre></div>
<div class="source-file-narrow"><em>compiler.h</em>, create new file</div>
<p><font papago-translate="translated">그 서명은 바뀔 것이지만, 우리를 움직이게 합니다.</font></p>
<p><font papago-translate="translated">컴파일의 첫 번째 단계는 스캔입니다. 이 장에서 우리가 하고 있는 일은 지금 컴파일러가<span class="em"></span><span class="em"></span> 그것을 설정하는 것뿐입니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 새 파일 만들기</font></font></div>
<pre translate="no"><span class="a">#include &lt;stdio.h&gt;</span>

<span class="a">#include "common.h"</span>
<span class="a">#include "compiler.h"</span>
<span class="a">#include "scanner.h"</span>

<span class="t">void</span> <span class="i">compile</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">source</span>) {
  <span class="i">initScanner</span>(<span class="i">source</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, create new file</div>
<p><font papago-translate="translated">이것은 나중 장에서도 자연스럽게 성장할 것입니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/scanning-on-demand.html#the-scanner-scans" id="the-scanner-scans"><small><font papago-translate="translated">16 . 1 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">스캐너 스캔</font></font></a></h3>
<p><font papago-translate="translated">유용한 코드를 작성하기 전에 아직 발판이 몇 피트 더 남아 있습니다.</font><font papago-translate="translated"> 먼저, 새로운 헤더입니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">스캐너.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 새 파일 만들기</font></font></div>
<pre translate="no"><span class="a">#ifndef clox_scanner_h</span>
<span class="a">#define clox_scanner_h</span>

<span class="t">void</span> <span class="i">initScanner</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">source</span>);

<span class="a">#endif</span>
</pre></div>
<div class="source-file-narrow"><em>scanner.h</em>, create new file</div>
<p><font papago-translate="translated">그리고 그에 상응하는 구현:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">스캐너.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 새 파일 만들기</font></font></div>
<pre translate="no"><span class="a">#include &lt;stdio.h&gt;</span>
<span class="a">#include &lt;string.h&gt;</span>

<span class="a">#include "common.h"</span>
<span class="a">#include "scanner.h"</span>

<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="k">const</span> <span class="t">char</span>* <span class="i">start</span>;
  <span class="k">const</span> <span class="t">char</span>* <span class="i">current</span>;
  <span class="t">int</span> <span class="i">line</span>;
} <span class="t">Scanner</span>;

<span class="t">Scanner</span> <span class="i">scanner</span>;
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, create new file</div>
<p><font papago-translate="translated">스캐너가 사용자의 소스 코드를 훑어보면서 얼마나 멀리 갔는지 추적합니다.</font><font papago-translate="translated"> 우리가 VM에서 했던 것처럼, 우리는 그 상태를 구조로 감싸고, 그런 다음 그 유형의 단일 최상위 모듈 변수를 생성하여 모든 다양한 함수들에 전달할 필요가 없습니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">의외로 필드가 적습니다.</font><font papago-translate="translated"> 그 </font></font><code translate="no">start</code><font papago-translate="splitted"><font papago-translate="translated"> 포인터는 현재 스캔 중인 어휘의 시작을 나타냅니다 </font></font><code translate="no">current</code><font papago-translate="splitted"><font papago-translate="translated"> 현재 보고 있는 캐릭터를 가리킵니다.</font></font></p>
<p><span name="fields"></span></p><img alt="The start and current fields pointing at 'print bacon;'. Start points at 'b' and current points at 'o'." src="https://youhogeon-meritz.github.io/image/scanning-on-demand/fields.png">
<aside name="fields" style="top: 6396px;">
<p><font papago-translate="splitted"><font papago-translate="translated">여기서 우리는 식별자를 스캔하는 중입니다 </font></font><code translate="no">bacon</code><font papago-translate="splitted"><font papago-translate="translated">. 현재 캐릭터는 </font></font><code translate="no">o</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고 우리가 가장 최근에 소비한 캐릭터는 </font></font><code translate="no">c</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">우리는 </font></font><code translate="no">line</code><font papago-translate="splitted"><font papago-translate="translated"> 오류 보고를 위해 현재 어휘소가 어느 선에 있는지 추적하는 필드입니다.</font><font papago-translate="translated"> 다 됐다! 더 이상 어쩔 수 없다!</font><font papago-translate="translated"> 소스 코드 문자열의 시작 부분에 포인터를 두지도 않습니다.</font><font papago-translate="translated"> 스캐너는 코드를 한 번 통과한 후에 완료됩니다.</font></font></p>
<p><font papago-translate="translated">상태가 어느 정도 있으므로 초기화해야 합니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">스캐너.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 변수<em> 스캐너</em> 후에 추가</font></font></div>
<pre translate="no"><span class="t">void</span> <span class="i">initScanner</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">source</span>) {
  <span class="i">scanner</span>.<span class="i">start</span> = <span class="i">source</span>;
  <span class="i">scanner</span>.<span class="i">current</span> = <span class="i">source</span>;
  <span class="i">scanner</span>.<span class="i">line</span> = <span class="n">1</span>;
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after variable <em>scanner</em></div>
<p><font papago-translate="translated">우리는 첫 번째 줄의 첫 번째 문자에서 시작합니다. 마치 주자가 출발선에 웅크리고 있는 것처럼 말이죠.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/scanning-on-demand.html#a-token-at-a-time" id="a-token-at-a-time"><small><font papago-translate="translated">16 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">토큰 한 번에</font></font></a></h2>
<p><font papago-translate="translated">Jlox에서 시작 총성이 울리자 스캐너는 앞으로 달려가 전체 프로그램을 열심히 스캔하고 토큰 목록을 반환했습니다.</font><font papago-translate="translated"> 이것은 클록스에서 도전이 될 것입니다.</font><font papago-translate="translated"> 토큰을 저장하려면 어떤 종류의 성장 가능한 배열이나 목록이 필요합니다.</font><font papago-translate="translated"> 토큰의 할당과 해제, 그리고 컬렉션 자체를 관리해야 합니다.</font><font papago-translate="translated"> 그것은 많은 코드와 많은 메모리 이탈입니다.</font></p>
<p><font papago-translate="translated">컴파일러는 언제든지 한두 개의 토큰만 있으면 됩니다. 우리 문법은 한 번의 미리 보기 토큰만 있으면 된다는 점을 기억하세요. 따라서<em></em><span class="em"></span><span class="em"></span> 모든 토큰을 동시에 유지할 필요는 없습니다.</font><font papago-translate="translated"> 대신, 가장 간단한 해결책은 컴파일러가 토큰을 필요로 할 때까지 토큰을 스캔하지 않는 것입니다.</font><font papago-translate="translated"> 스캐너가 토큰을 제공하면 토큰을 값별로 반환합니다.</font><font papago-translate="translated"> 동적으로 할당할 필요 없이 토큰을 C<span class="em"></span> 스택에 전달하기만 하면 됩니다.</font></p>
<p><font papago-translate="translated">안타깝게도 아직 스캐너에 토큰을 요청할 수 있는 컴파일러가 없어서 스캐너는 아무것도 하지 않고 그냥 앉아 있을 것입니다.</font><font papago-translate="translated"> 실행에 옮기기 위해 임시 코드를 작성하여 실행하겠습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  initScanner(source);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>컴파일</em> ()에서</font></font></div>
<pre class="insert" translate="no">  <span class="t">int</span> <span class="i">line</span> = -<span class="n">1</span>;
  <span class="k">for</span> (;;) {
    <span class="t">Token</span> <span class="i">token</span> = <span class="i">scanToken</span>();
    <span class="k">if</span> (<span class="i">token</span>.<span class="i">line</span> != <span class="i">line</span>) {
      <span class="i">printf</span>(<span class="s">"%4d "</span>, <span class="i">token</span>.<span class="i">line</span>);
      <span class="i">line</span> = <span class="i">token</span>.<span class="i">line</span>;
    } <span class="k">else</span> {
      <span class="i">printf</span>(<span class="s">"   | "</span>);
    }
    <span class="i">printf</span>(<span class="s">"%2d '%.*s'</span><span class="e">\n</span><span class="s">"</span>, <span class="i">token</span>.<span class="i">type</span>, <span class="i">token</span>.<span class="i">length</span>, <span class="i">token</span>.<span class="i">start</span>);<span name="format"> </span>

    <span class="k">if</span> (<span class="i">token</span>.<span class="i">type</span> == <span class="a">TOKEN_EOF</span>) <span class="k">break</span>;
  }
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>compile</em>()</div>
<aside name="format" style="top: 7566px;">
<p><font papago-translate="splitted"><font papago-translate="translated">그거 </font></font><code translate="no">%.*s</code><font papago-translate="splitted"><font papago-translate="translated"> 형식 문자열은 깔끔한 기능입니다.</font><font papago-translate="translated"> 일반적으로 형식<span class="em"></span><span class="em"></span> 문자열 안에 숫자를 넣어 출력 정밀도(표시할 문자 수)를 설정합니다.</font><font papago-translate="translated"> 사용. </font></font><code translate="no">*</code><font papago-translate="splitted"><font papago-translate="translated"> 대신 정확도를 인수로 전달할 수 있습니다.</font><font papago-translate="translated"> 하도록 </font></font><code translate="no">printf()</code><font papago-translate="splitted"><font papago-translate="translated"> 콜 프린트 첫 번째 </font></font><code translate="no">token.length</code><font papago-translate="splitted"><font papago-translate="translated"> 문자열의 문자 위치 </font></font><code translate="no">token.start</code><font papago-translate="splitted"><font papago-translate="translated">. 어휘가 원래 소스 문자열을 가리키고 끝에 종결자가 없기 때문에 길이를 그렇게 제한해야 합니다.</font></font></p>
</aside>
<p><font papago-translate="translated">이것은 무한히 반복됩니다.</font><font papago-translate="translated"> 루프를 통과할 때마다 하나의 토큰을 스캔하여 인쇄합니다.</font><font papago-translate="translated"> 특별한 "파일 종료" 토큰이나 오류에 도달하면 중지됩니다.</font><font papago-translate="translated"> 예를 들어, 이 프로그램에서 인터프리터를 실행하면:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">print</span> <span class="n">1</span> + <span class="n">2</span>;
</pre></div>
<p><font papago-translate="translated">출력됩니다:</font></p>
<div class="codehilite"><pre translate="no">   1 31 'print'
   | 21 '1'
   |  7 '+'
   | 21 '2'
   |  8 ';'
   2 39 ''
</pre></div>
<p><font papago-translate="translated">첫 번째 열은 줄 번호이고, 두 번째 열은 토큰<span name="token"> 유형</span>의 숫자 값이며, 마지막으로 어휘소입니다.</font><font papago-translate="translated"> 2호선의 마지막 빈 어휘는 EOF 토큰입니다.</font></p>
<aside name="token" style="top: 8047px;">
<p><font papago-translate="translated">네, 토큰 유형의 원시 인덱스는 정확히 사람이 읽을 수 있는 것은 아니지만, C가 제공하는 모든 것입니다.</font></p>
</aside>
<p><font papago-translate="translated">나머지 장의 목표는 이 핵심 기능을 구현하여 코드 덩어리를 작동시키는 것입니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">void initScanner(const char* source);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">스캐너.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>init</em>Sc<em>anner</em>() 뒤에 추가</font></font></div>
<pre class="insert" translate="no"><span class="t">Token</span> <span class="i">scanToken</span>();
</pre><pre class="insert-after" translate="no">
#endif
</pre></div>
<div class="source-file-narrow"><em>scanner.h</em>, add after <em>initScanner</em>()</div>
<p><font papago-translate="translated">각 호출은 소스 코드의 다음 토큰을 스캔하여 반환합니다.</font><font papago-translate="translated"> 토큰은 다음과 같습니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#define clox_scanner_h
</pre><div class="source-file"><em><font papago-translate="translated">스캐너.h</font></em></div>
<pre class="insert" translate="no">
<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">TokenType</span> <span class="i">type</span>;
  <span class="k">const</span> <span class="t">char</span>* <span class="i">start</span>;
  <span class="t">int</span> <span class="i">length</span>;
  <span class="t">int</span> <span class="i">line</span>;
} <span class="t">Token</span>;
</pre><pre class="insert-after" translate="no">
void initScanner(const char* source);
</pre></div>
<div class="source-file-narrow"><em>scanner.h</em></div>
<p><font papago-translate="splitted"><font papago-translate="translated">Jlox의 토큰 클래스와 매우 비슷합니다.</font><font papago-translate="translated"> 어떤 유형의 토큰인지 식별할 수 있는 열거형이 있습니다—번호,<span class="em"></span> 식별자, </font></font><code translate="no">+</code><font papago-translate="splitted"><font papago-translate="translated"> 운영자 등.</font><font papago-translate="translated"> 열거된 항목은 jlox에 있는 항목과 거의 동일하므로 전체 항목을 정리해 보겠습니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#ifndef clox_scanner_h
#define clox_scanner_h
</pre><div class="source-file"><em><font papago-translate="translated">스캐너.h</font></em></div>
<pre class="insert" translate="no">
<span class="k">typedef</span> <span class="k">enum</span> {
  <span class="c">// Single-character tokens.</span>
  <span class="a">TOKEN_LEFT_PAREN</span>, <span class="a">TOKEN_RIGHT_PAREN</span>,
  <span class="a">TOKEN_LEFT_BRACE</span>, <span class="a">TOKEN_RIGHT_BRACE</span>,
  <span class="a">TOKEN_COMMA</span>, <span class="a">TOKEN_DOT</span>, <span class="a">TOKEN_MINUS</span>, <span class="a">TOKEN_PLUS</span>,
  <span class="a">TOKEN_SEMICOLON</span>, <span class="a">TOKEN_SLASH</span>, <span class="a">TOKEN_STAR</span>,
  <span class="c">// One or two character tokens.</span>
  <span class="a">TOKEN_BANG</span>, <span class="a">TOKEN_BANG_EQUAL</span>,
  <span class="a">TOKEN_EQUAL</span>, <span class="a">TOKEN_EQUAL_EQUAL</span>,
  <span class="a">TOKEN_GREATER</span>, <span class="a">TOKEN_GREATER_EQUAL</span>,
  <span class="a">TOKEN_LESS</span>, <span class="a">TOKEN_LESS_EQUAL</span>,
  <span class="c">// Literals.</span>
  <span class="a">TOKEN_IDENTIFIER</span>, <span class="a">TOKEN_STRING</span>, <span class="a">TOKEN_NUMBER</span>,
  <span class="c">// Keywords.</span>
  <span class="a">TOKEN_AND</span>, <span class="a">TOKEN_CLASS</span>, <span class="a">TOKEN_ELSE</span>, <span class="a">TOKEN_FALSE</span>,
  <span class="a">TOKEN_FOR</span>, <span class="a">TOKEN_FUN</span>, <span class="a">TOKEN_IF</span>, <span class="a">TOKEN_NIL</span>, <span class="a">TOKEN_OR</span>,
  <span class="a">TOKEN_PRINT</span>, <span class="a">TOKEN_RETURN</span>, <span class="a">TOKEN_SUPER</span>, <span class="a">TOKEN_THIS</span>,
  <span class="a">TOKEN_TRUE</span>, <span class="a">TOKEN_VAR</span>, <span class="a">TOKEN_WHILE</span>,

  <span class="a">TOKEN_ERROR</span>, <span class="a">TOKEN_EOF</span>
} <span class="t">TokenType</span>;
</pre><pre class="insert-after" translate="no">
typedef struct {
</pre></div>
<div class="source-file-narrow"><em>scanner.h</em></div>
<p><font papago-translate="splitted"><font papago-translate="translated">모든 이름 앞에 접두사를 붙이는 것 외에도 </font></font><code translate="no">TOKEN_</code><font papago-translate="splitted"><font papago-translate="translated"> (C가 최상위 네임스페이스에 열거형 이름을 던지기 때문에) 유일한 차이점은 추가적인 </font></font><code translate="no">TOKEN_ERROR</code><font papago-translate="splitted"><font papago-translate="translated"> 타입. 그게 뭐예요?</font></font></p>
<p><font papago-translate="translated">스캔 중에 감지되는 오류는 종료되지 않은 문자열과 인식되지 않는 문자 몇 가지뿐입니다.</font><font papago-translate="translated"> Jlox에서는 스캐너가 직접 보고합니다.</font><font papago-translate="translated"> clox에서 스캐너는 해당 오류에 대한 합성 "오류" 토큰을 생성하여 컴파일러에게 전달합니다.</font><font papago-translate="translated"> 이렇게 하면 컴파일러가 오류가 발생했음을 알고 오류 복구를 시작한 후 보고할 수 있습니다.</font></p>
<p><font papago-translate="translated">clox의 토큰 유형에서 새로운 부분은 어휘를 나타내는 방식입니다.</font><font papago-translate="translated"> jlox에서는 각 토큰이 어휘소를 고유한 작은 자바 문자열로 저장했습니다.</font><font papago-translate="translated"> clox에 대해 그렇게 했다면, 그 문자열의 메모리를 관리하는 방법을 알아내야 했을 것입니다.</font><font papago-translate="translated"> 토큰을 가치별로 전달하기 때문에 특히 어렵습니다. 여러 토큰이 동일한 어휘<span class="em"></span> 문자열을 가리킬 수 있기 때문입니다.</font><font papago-translate="translated"> 소유권이 이상해집니다.</font></p>
<p><font papago-translate="translated">대신 원본 소스 문자열을 캐릭터 저장소로 사용합니다.</font><font papago-translate="translated"> 우리는 어휘소를 첫 번째 문자와 그 안에 포함된 문자의 수를 가리키는 포인터로 표현합니다.</font><font papago-translate="translated"> 즉, 어휘소의 메모리 관리에 대해 전혀 걱정할 필요가 없으며 토큰을 자유롭게 복사할 수 있습니다.</font><font papago-translate="translated"> 메인 소스 코드 문자열이 모든 토큰<span name="outlive">보다 오래 지속되는</span> 한 모든 것이 정상적으로 작동합니다.</font></p>
<aside name="outlive" style="top: 9711px;">
<p><font papago-translate="splitted"><font papago-translate="translated">경솔하게 들릴 의도는 없습니다.</font><font papago-translate="translated"> 우리는 정말로 "메인" 모듈에서 멀리 떨어진 곳에서 생성되는 소스 문자열이 충분히 긴 수명을 가질 수 있도록 생각하고 보장할 필요가 있습니다.</font><font papago-translate="translated"> 그래서 </font></font><code translate="no">runFile()</code><font papago-translate="splitted"><font papago-translate="translated"> 다음이 될 때까지 문자열을 해제하지 않습니다 </font></font><code translate="no">interpret()</code><font papago-translate="splitted"><font papago-translate="translated"> 코드 실행을 완료하고 반환합니다.</font></font></p>
</aside>
<h3><a href="https://youhogeon-meritz.github.io/scanning-on-demand.html#scanning-tokens" id="scanning-tokens"><small><font papago-translate="translated">16 . 2 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">토큰 스캔</font></font></a></h3>
<p><font papago-translate="translated">토큰을 스캔할 준비가 되었습니다.</font><font papago-translate="translated"> 우리는 이것부터 시작하여 완전한 구현까지 최선을 다할 것입니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">스캐너.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>init</em>Sc<em>anner</em>() 뒤에 추가</font></font></div>
<pre translate="no"><span class="t">Token</span> <span class="i">scanToken</span>() {
  <span class="i">scanner</span>.<span class="i">start</span> = <span class="i">scanner</span>.<span class="i">current</span>;

  <span class="k">if</span> (<span class="i">isAtEnd</span>()) <span class="k">return</span> <span class="i">makeToken</span>(<span class="a">TOKEN_EOF</span>);

  <span class="k">return</span> <span class="i">errorToken</span>(<span class="s">"Unexpected character."</span>);
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>initScanner</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">이 함수에 대한 각 호출이 전체 토큰을 스캔하기 때문에 함수에 들어갈 때 새로운 토큰의 시작점에 있다는 것을 알 수 있습니다.</font><font papago-translate="translated"> 따라서 다음과 같이 설정합니다 </font></font><code translate="no">scanner.start</code><font papago-translate="splitted"><font papago-translate="translated"> 현재 문자를 가리키면 우리가 스캔하려는 어휘가 어디서 시작되는지 기억할 수 있습니다.</font></font></p>
<p><font papago-translate="translated">그런 다음 소스 코드의 끝에 도달했는지 확인합니다.</font><font papago-translate="translated"> 그렇다면 EOF 토큰을 반환하고 중지합니다.</font><font papago-translate="translated"> 이것은 컴파일러에게 더 이상 토큰을 요청하지 말라는 신호를 보내는 센티널 값입니다.</font></p>
<p><font papago-translate="translated">끝에 도달하지 못하면 다음 토큰을 스캔하기 위해<span class="ellipse"> 몇</span> 가지 작업을 수행합니다<span class="ellipse">.</span></font><font papago-translate="translated"> 하지만 우리는 아직 그 코드를 작성하지 않았습니다.</font><font papago-translate="translated"> 곧 그것에 도달할 것입니다.</font><font papago-translate="translated"> 해당 코드가 토큰을 스캔하여 반환하지 않으면 함수의 끝에 도달합니다.</font><font papago-translate="translated"> 즉, 스캐너가 인식할 수 없는 문자에 도달했음을 의미하므로 이에 대한 오류 토큰을 반환합니다.</font></p>
<p><font papago-translate="translated">이 기능은 대부분 jlox에서 익숙한 몇 명의 도우미에 의존합니다.</font><font papago-translate="translated"> 우선:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">스캐너.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>init</em>Sc<em>anner</em>() 뒤에 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">bool</span> <span class="i">isAtEnd</span>() {
  <span class="k">return</span> *<span class="i">scanner</span>.<span class="i">current</span> == <span class="s">'\0'</span>;
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>initScanner</em>()</div>
<p><font papago-translate="translated">소스 문자열은 좋은 null-terminated C 문자열이어야 합니다.</font><font papago-translate="translated"> 현재 문자가 널 바이트라면, 우리는 끝에 도달한 것입니다.</font></p>
<p><font papago-translate="translated">토큰을 만들려면 다음과 같은 생성자 유사 함수가 있습니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">스캐너.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>isAtEnd</em>() 뒤에 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">Token</span> <span class="i">makeToken</span>(<span class="t">TokenType</span> <span class="i">type</span>) {
  <span class="t">Token</span> <span class="i">token</span>;
  <span class="i">token</span>.<span class="i">type</span> = <span class="i">type</span>;
  <span class="i">token</span>.<span class="i">start</span> = <span class="i">scanner</span>.<span class="i">start</span>;
  <span class="i">token</span>.<span class="i">length</span> = (<span class="t">int</span>)(<span class="i">scanner</span>.<span class="i">current</span> - <span class="i">scanner</span>.<span class="i">start</span>);
  <span class="i">token</span>.<span class="i">line</span> = <span class="i">scanner</span>.<span class="i">line</span>;
  <span class="k">return</span> <span class="i">token</span>;
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>isAtEnd</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">스캐너를 사용합니다 </font></font><code translate="no">start</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">current</code><font papago-translate="splitted"><font papago-translate="translated"> 토큰의 어휘를 캡처하는 포인터.</font><font papago-translate="translated"> 다른 몇 가지 명백한 필드를 설정한 다음 토큰을 반환합니다.</font><font papago-translate="translated"> 오류 토큰을 반환하는 자매 기능이 있습니다.</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">스캐너.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>만든</em> 후에 추가</font><font papago-translate="translated"><em>토큰</em>()</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">Token</span> <span class="i">errorToken</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">message</span>) {
  <span class="t">Token</span> <span class="i">token</span>;
  <span class="i">token</span>.<span class="i">type</span> = <span class="a">TOKEN_ERROR</span>;
  <span class="i">token</span>.<span class="i">start</span> = <span class="i">message</span>;
  <span class="i">token</span>.<span class="i">length</span> = (<span class="t">int</span>)<span class="i">strlen</span>(<span class="i">message</span>);
  <span class="i">token</span>.<span class="i">line</span> = <span class="i">scanner</span>.<span class="i">line</span>;
  <span class="k">return</span> <span class="i">token</span>;
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>makeToken</em>()</div>
<p><span name="axolotl"></span></p>
<aside name="axolotl" style="top: 11189px;">
<p><font papago-translate="translated">이 장의 이 부분은 꽤 건조해서 여기 축삭의 그림이 있습니다.</font></p><img alt="A drawing of an axolotl." src="https://youhogeon-meritz.github.io/image/scanning-on-demand/axolotl.png">
</aside>
<p><font papago-translate="translated">유일한 차이점은 "lexeme"가 사용자의 소스 코드를 가리키는 대신 오류 메시지 문자열을 가리킨다는 것입니다.</font><font papago-translate="translated"> 다시 말하지만, 컴파일러가 읽을 수 있을 만큼 오류 메시지가 오래 지속되도록 해야 합니다.</font><font papago-translate="translated"> 실제로 우리는 이 함수를 C 문자열 리터럴로만 부릅니다.</font><font papago-translate="translated"> 그것들은 일정하고 영원하기 때문에 우리는 괜찮습니다.</font></p>
<p><font papago-translate="translated">현재 우리가 가지고 있는 것은 기본적으로 빈 어휘 문법을 가진 언어를 위한 작동 스캐너입니다.</font><font papago-translate="translated"> 문법에 생성물이 없기 때문에 모든 문자는 오류입니다.</font><font papago-translate="translated"> 그것은 프로그래밍하기에 재미있는 언어가 아니므로 규칙을 작성해 보겠습니다.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/scanning-on-demand.html#a-lexical-grammar-for-lox" id="a-lexical-grammar-for-lox"><small><font papago-translate="translated">16 . 3</font></small><font papago-translate="splitted"><font papago-translate="translated">Lox를 위한 어휘 문법</font></font></a></h2>
<p><font papago-translate="translated">가장 간단한 토큰은 단일 문자로만 구성됩니다.</font><font papago-translate="translated"> 우리는 그것들을 그렇게 인식합니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  if (isAtEnd()) return makeToken(TOKEN_EOF);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">스캐너.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>스캔</em> 중에</font><font papago-translate="translated"><em>토큰</em>()</font></font></div>
<pre class="insert" translate="no">
  <span class="t">char</span> <span class="i">c</span> = <span class="i">advance</span>();

  <span class="k">switch</span> (<span class="i">c</span>) {
    <span class="k">case</span> <span class="s">'('</span>: <span class="k">return</span> <span class="i">makeToken</span>(<span class="a">TOKEN_LEFT_PAREN</span>);
    <span class="k">case</span> <span class="s">')'</span>: <span class="k">return</span> <span class="i">makeToken</span>(<span class="a">TOKEN_RIGHT_PAREN</span>);
    <span class="k">case</span> <span class="s">'{'</span>: <span class="k">return</span> <span class="i">makeToken</span>(<span class="a">TOKEN_LEFT_BRACE</span>);
    <span class="k">case</span> <span class="s">'}'</span>: <span class="k">return</span> <span class="i">makeToken</span>(<span class="a">TOKEN_RIGHT_BRACE</span>);
    <span class="k">case</span> <span class="s">';'</span>: <span class="k">return</span> <span class="i">makeToken</span>(<span class="a">TOKEN_SEMICOLON</span>);
    <span class="k">case</span> <span class="s">','</span>: <span class="k">return</span> <span class="i">makeToken</span>(<span class="a">TOKEN_COMMA</span>);
    <span class="k">case</span> <span class="s">'.'</span>: <span class="k">return</span> <span class="i">makeToken</span>(<span class="a">TOKEN_DOT</span>);
    <span class="k">case</span> <span class="s">'-'</span>: <span class="k">return</span> <span class="i">makeToken</span>(<span class="a">TOKEN_MINUS</span>);
    <span class="k">case</span> <span class="s">'+'</span>: <span class="k">return</span> <span class="i">makeToken</span>(<span class="a">TOKEN_PLUS</span>);
    <span class="k">case</span> <span class="s">'/'</span>: <span class="k">return</span> <span class="i">makeToken</span>(<span class="a">TOKEN_SLASH</span>);
    <span class="k">case</span> <span class="s">'*'</span>: <span class="k">return</span> <span class="i">makeToken</span>(<span class="a">TOKEN_STAR</span>);
  }
</pre><pre class="insert-after" translate="no">
  return errorToken("Unexpected character.");
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, in <em>scanToken</em>()</div>
<p><font papago-translate="translated">소스 코드에서 다음 문자를 읽은 다음, Lox의 한 문자 어휘와 일치하는지 확인하기 위해 간단한 전환을 합니다.</font><font papago-translate="translated"> 다음 캐릭터를 읽으려면 현재 캐릭터를 소비하고 반환하는 새로운 도우미를 사용합니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">스캐너.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>isAtEnd</em>() 뒤에 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">char</span> <span class="i">advance</span>() {
  <span class="i">scanner</span>.<span class="i">current</span>++;
  <span class="k">return</span> <span class="i">scanner</span>.<span class="i">current</span>[-<span class="n">1</span>];
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>isAtEnd</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">다음은 다음과 같은 두 문자 구두점 토큰입니다 </font></font><code translate="no">!=</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">&gt;=</code><font papago-translate="splitted"><font papago-translate="translated">. 이들 각각은 또한 해당하는 단일 문자 토큰을 가지고 있습니다.</font><font papago-translate="translated"> 즉, 다음과 같은 캐릭터를 볼 때 </font></font><code translate="no">!</code><font papago-translate="splitted"><font papago-translate="translated">, 우리가 여기에 있는지 모르겠습니다 </font></font><code translate="no">!</code><font papago-translate="splitted"><font papago-translate="translated"> 토큰 또는 </font></font><code translate="no">!=</code><font papago-translate="splitted"><font papago-translate="translated"> 다음 캐릭터도 살펴볼 때까지.</font><font papago-translate="translated"> 우리는 그것들을 이렇게 처리합니다:</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    case '*': return makeToken(TOKEN_STAR);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">스캐너.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>스캔</em> 중에</font><font papago-translate="translated"><em>토큰</em>()</font></font></div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="s">'!'</span>:
      <span class="k">return</span> <span class="i">makeToken</span>(
          <span class="i">match</span>(<span class="s">'='</span>) ? <span class="a">TOKEN_BANG_EQUAL</span> : <span class="a">TOKEN_BANG</span>);
    <span class="k">case</span> <span class="s">'='</span>:
      <span class="k">return</span> <span class="i">makeToken</span>(
          <span class="i">match</span>(<span class="s">'='</span>) ? <span class="a">TOKEN_EQUAL_EQUAL</span> : <span class="a">TOKEN_EQUAL</span>);
    <span class="k">case</span> <span class="s">'&lt;'</span>:
      <span class="k">return</span> <span class="i">makeToken</span>(
          <span class="i">match</span>(<span class="s">'='</span>) ? <span class="a">TOKEN_LESS_EQUAL</span> : <span class="a">TOKEN_LESS</span>);
    <span class="k">case</span> <span class="s">'&gt;'</span>:
      <span class="k">return</span> <span class="i">makeToken</span>(
          <span class="i">match</span>(<span class="s">'='</span>) ? <span class="a">TOKEN_GREATER_EQUAL</span> : <span class="a">TOKEN_GREATER</span>);
</pre><pre class="insert-after" translate="no">  }
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, in <em>scanToken</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">첫 번째 캐릭터를 섭취한 후, 우리는 </font></font><code translate="no">=</code><font papago-translate="splitted"><font papago-translate="translated">. 발견되면, 우리는 그것을 소비하고 해당 두 문자 토큰을 반환합니다.</font><font papago-translate="translated"> 그렇지 않으면 현재 문자를 그대로 두고(다음 토큰의 일부가 될 수 있도록) 적절한 한 문자<em></em> 토큰을 반환합니다.</font></font></p>
<p><font papago-translate="translated">두 번째 캐릭터를 조건부로 소비하는 논리는 여기에 있습니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">스캐너.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>사전</em> () 후 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">bool</span> <span class="i">match</span>(<span class="t">char</span> <span class="i">expected</span>) {
  <span class="k">if</span> (<span class="i">isAtEnd</span>()) <span class="k">return</span> <span class="k">false</span>;
  <span class="k">if</span> (*<span class="i">scanner</span>.<span class="i">current</span> != <span class="i">expected</span>) <span class="k">return</span> <span class="k">false</span>;
  <span class="i">scanner</span>.<span class="i">current</span>++;
  <span class="k">return</span> <span class="k">true</span>;
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>advance</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">현재 캐릭터가 원하는 캐릭터인 경우, 진행하여 반환합니다 </font></font><code translate="no">true</code><font papago-translate="splitted"><font papago-translate="translated">. 그렇지 않으면, 우리는 돌아갑니다 </font></font><code translate="no">false</code><font papago-translate="splitted"><font papago-translate="translated"> 일치하지 않았음을 나타냅니다.</font></font></p>
<p><font papago-translate="translated">이제 우리 스캐너는 모든 구두점과 같은 토큰을 지원합니다.</font><font papago-translate="translated"> 더 긴 것들로 넘어가기 전에, 토큰에 전혀 포함되지 않은 캐릭터들을 다루기 위해 간단한 부업을 해보겠습니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/scanning-on-demand.html#whitespace" id="whitespace"><small><font papago-translate="translated">16 . 3 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">화이트스페이스</font></font></a></h3>
<p><font papago-translate="splitted"><font papago-translate="translated">우리 스캐너는 공백, 탭, 그리고 새로운 줄을 처리해야 하지만, 그 문자들은 어떤 토큰의 어휘소에도 포함되지 않습니다.</font><font papago-translate="translated"> 우리는 주인공 스위치 내부에 있는 것들을 확인할 수 있습니다 </font></font><code translate="no">scanToken()</code><font papago-translate="splitted"><font papago-translate="translated"> 하지만 함수를 호출할 때 빈칸<em> 뒤에 있는</em> 다음 토큰을 올바르게 찾는 것이 조금 까다로워집니다.</font><font papago-translate="translated"> 함수의 전체를 루프 같은 형태로 감싸야 합니다.</font></font></p>
<p><font papago-translate="translated">대신 토큰을 시작하기 전에 별도의 함수로 전환합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">Token scanToken() {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">스캐너.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>스캔</em> 중에</font><font papago-translate="translated"><em>토큰</em>()</font></font></div>
<pre class="insert" translate="no">  <span class="i">skipWhitespace</span>();
</pre><pre class="insert-after" translate="no">  scanner.start = scanner.current;
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, in <em>scanToken</em>()</div>
<p><font papago-translate="translated">이렇게 하면 스캐너가 모든 주요 공백을 지나갑니다.</font><font papago-translate="translated"> 이 통화가 돌아온 후, 우리는 다음 문자가 의미 있는 문자라는 것을 알게 됩니다 (또는 소스 코드의 끝에 있습니다).</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">스캐너.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>오류</em> 후 추가</font><font papago-translate="translated"><em>토큰</em>()</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">skipWhitespace</span>() {
  <span class="k">for</span> (;;) {
    <span class="t">char</span> <span class="i">c</span> = <span class="i">peek</span>();
    <span class="k">switch</span> (<span class="i">c</span>) {
      <span class="k">case</span> <span class="s">' '</span>:
      <span class="k">case</span> <span class="s">'\r'</span>:
      <span class="k">case</span> <span class="s">'\t'</span>:
        <span class="i">advance</span>();
        <span class="k">break</span>;
      <span class="k">default</span>:
        <span class="k">return</span>;
    }
  }
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>errorToken</em>()</div>
<p><font papago-translate="translated">일종의 별도의 미니 스캐너입니다.</font><font papago-translate="translated"> 그것은 반복되며, 만나는 모든 공백 문자를 소비합니다.</font><font papago-translate="translated"> 화이트스페이스<em></em>가<em> 아닌</em> 문자를 사용하지 않도록 주의해야 합니다.</font><font papago-translate="translated"> 이를 지원하기 위해 다음을 사용합니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">스캐너.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>사전</em> () 후 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">char</span> <span class="i">peek</span>() {
  <span class="k">return</span> *<span class="i">scanner</span>.<span class="i">current</span>;
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>advance</em>()</div>
<p><font papago-translate="translated">이것은 단순히 현재 캐릭터를 반환할 뿐, 그것을 소비하지는 않습니다.</font><font papago-translate="translated"> 이전 코드는 새 줄을 제외한 모든 공백 문자를 처리합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">        break;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">스캐너.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>건너뛰</em>고</font><font papago-translate="translated"><em>공백(</em>)</font></font></div>
<pre class="insert" translate="no">      <span class="k">case</span> <span class="s">'\n'</span>:
        <span class="i">scanner</span>.<span class="i">line</span>++;
        <span class="i">advance</span>();
        <span class="k">break</span>;
</pre><pre class="insert-after" translate="no">      default:
        return;
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, in <em>skipWhitespace</em>()</div>
<p><font papago-translate="translated">우리가 그것들 중 하나를 소비할 때, 현재의 회선 번호도 부딪히게 됩니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/scanning-on-demand.html#comments" id="comments"><small><font papago-translate="translated">16 . 3 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">평.</font></font></a></h3>
<p><font papago-translate="translated">용어를 정확하게 설명하고 싶다면 댓글은 엄밀히 말하면 '화이트스페이스'가 아니지만, Lox에 관해서는 그럴 수 있으므로 댓글도 생략합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">        break;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">스캐너.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>건너뛰</em>고</font><font papago-translate="translated"><em>공백(</em>)</font></font></div>
<pre class="insert" translate="no">      <span class="k">case</span> <span class="s">'/'</span>:
        <span class="k">if</span> (<span class="i">peekNext</span>() == <span class="s">'/'</span>) {
          <span class="c">// A comment goes until the end of the line.</span>
          <span class="k">while</span> (<span class="i">peek</span>() != <span class="s">'\n'</span> &amp;&amp; !<span class="i">isAtEnd</span>()) <span class="i">advance</span>();
        } <span class="k">else</span> {
          <span class="k">return</span>;
        }
        <span class="k">break</span>;
</pre><pre class="insert-after" translate="no">      default:
        return;
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, in <em>skipWhitespace</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">댓글은 다음과 같이 시작합니다 </font></font><code translate="no">//</code><font papago-translate="splitted"><font papago-translate="translated"> 록스에서, 예를 들어 </font></font><code translate="no">!=</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고 친구들, 우리는 앞을 내다보는 두 번째 인격이 필요합니다.</font><font papago-translate="translated"> 그러나 </font></font><code translate="no">!=</code><font papago-translate="splitted"><font papago-translate="translated">, 우리는 여전히 소비하고 싶었습니다 </font></font><code translate="no">!</code><font papago-translate="splitted"><font papago-translate="translated"> 비록 </font></font><code translate="no">=</code><font papago-translate="splitted"><font papago-translate="translated"> 찾을 수 없습니다.</font><font papago-translate="translated"> 댓글이 다릅니다.</font><font papago-translate="translated"> 잠시도 찾지 못하면 </font></font><code translate="no">/</code><font papago-translate="splitted"><font papago-translate="translated">,그리고나서 </font></font><code translate="no">skipWhitespace()</code><font papago-translate="splitted"><font papago-translate="translated"> <em>첫</em> 번째 슬래시도 소비할 필요가 없습니다.</font></font></p>
<p><font papago-translate="translated">이를 처리하기 위해 다음과 같이 추가합니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">스캐너.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>엿보기</em> () 후 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">char</span> <span class="i">peekNext</span>() {
  <span class="k">if</span> (<span class="i">isAtEnd</span>()) <span class="k">return</span> <span class="s">'\0'</span>;
  <span class="k">return</span> <span class="i">scanner</span>.<span class="i">current</span>[<span class="n">1</span>];
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>peek</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">이것은 마치 </font></font><code translate="no">peek()</code><font papago-translate="splitted"><font papago-translate="translated"> 하지만 현재 캐릭터를 넘어서 한 캐릭터에 대해서는.</font><font papago-translate="translated"> 현재 캐릭터와 다음 캐릭터가 모두 다음과 같은 경우 </font></font><code translate="no">/</code><font papago-translate="splitted"><font papago-translate="translated">, 우리는 그것들을 소비하고 다음 새로운 줄이나 소스 코드의 끝까지 다른 문자들을 소비합니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">우리는 </font></font><code translate="no">peek()</code><font papago-translate="splitted"><font papago-translate="translated"> 새 라인을 확인하지만 소비하지는 않습니다.</font><font papago-translate="translated"> 이렇게 하면 새 선이 외부 루프의 다음 턴에 있는 현재 문자가 됩니다 </font></font><code translate="no">skipWhitespace()</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고 우리는 그것을 인식하고 증가시킬 것입니다 </font></font><code translate="no">scanner.line</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p>
<h3><a href="https://youhogeon-meritz.github.io/scanning-on-demand.html#literal-tokens" id="literal-tokens"><small><font papago-translate="translated">16 . 3 . 3</font></small><font papago-translate="splitted"><font papago-translate="translated">리터럴 토큰</font></font></a></h3>
<p><font papago-translate="translated">숫자와 문자열 토큰은 실행 시간 값이 연관되어 있기 때문에 특별합니다.</font><font papago-translate="translated"> 문자열은 인식하기 쉽기 때문에 항상 두<span class="em"></span> 개의 따옴표로 시작합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">          match('=') ? TOKEN_GREATER_EQUAL : TOKEN_GREATER);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">스캐너.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>스캔</em> 중에</font><font papago-translate="translated"><em>토큰</em>()</font></font></div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="s">'"'</span>: <span class="k">return</span> <span class="i">string</span>();
</pre><pre class="insert-after" translate="no">  }
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, in <em>scanToken</em>()</div>
<p><font papago-translate="translated">이를 새로운 기능이라고 합니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">스캐너.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>건너뛰기</em> 후 추가</font><font papago-translate="translated"><em>공백(</em>)</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">Token</span> <span class="i">string</span>() {
  <span class="k">while</span> (<span class="i">peek</span>() != <span class="s">'"'</span> &amp;&amp; !<span class="i">isAtEnd</span>()) {
    <span class="k">if</span> (<span class="i">peek</span>() == <span class="s">'\n'</span>) <span class="i">scanner</span>.<span class="i">line</span>++;
    <span class="i">advance</span>();
  }

  <span class="k">if</span> (<span class="i">isAtEnd</span>()) <span class="k">return</span> <span class="i">errorToken</span>(<span class="s">"Unterminated string."</span>);

  <span class="c">// The closing quote.</span>
  <span class="i">advance</span>();
  <span class="k">return</span> <span class="i">makeToken</span>(<span class="a">TOKEN_STRING</span>);
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>skipWhitespace</em>()</div>
<p><font papago-translate="translated">Jlox와 마찬가지로, 우리는 마지막 인용문에 도달할 때까지 문자를 소비합니다.</font><font papago-translate="translated"> 문자열 리터럴 내부의 새로운 줄도 추적합니다. (Lox는 다중 줄 문자열을 지원합니다.)</font><font papago-translate="translated"> 그리고 언제나 그렇듯이, 최종 견적을 찾기 전에 소스 코드의 부족을 우아하게 처리합니다.</font></p>
<p><font papago-translate="translated">여기서 클록스의 주요 변화는 존재<em>하지</em> 않는 것입니다.</font><font papago-translate="translated"> 다시 말하지만, 그것은 메모리 관리와 관련이 있습니다.</font><font papago-translate="translated"> jlox에서 토큰 클래스는 리터럴 토큰의 어휘소에서 변환된 런타임 값을 저장하기 위해 객체 유형 필드를 가지고 있었습니다.</font></p>
<p><font papago-translate="translated">C에서 이를 구현하려면 많은 작업이 필요합니다.</font><font papago-translate="translated"> 토큰에 문자열이 포함되어 있는지 또는 이중 값이 포함되어 있는지 확인하려면 일종의 조합 및 유형 태그가 필요합니다.</font><font papago-translate="translated"> 문자열이라면 문자열의 문자 배열에 대한 메모리를 어떻게든 관리해야 합니다.</font></p>
<p><font papago-translate="translated">스캐너에 이러한 복잡성을 추가하는 대신, 우리는 문자 그대로의 어휘를 런타임 값으로<span name="convert"> 변환</span>하는 것을 나중으로 연기합니다.</font><font papago-translate="translated"> clox에서 토큰은 사용자의 소스<span class="em"></span> 코드에 표시된 문자 시퀀스인 어휘만 저장합니다.</font><font papago-translate="translated"> 컴파일러 후반부에서는 해당 어휘를 청크의 상수 테이블에 저장할 준비가 되면 런타임 값으로 변환할 것입니다.</font></p>
<aside name="convert" style="top: 16143px;">
<p><font papago-translate="translated">컴파일러에서 어휘-값 변환을 수행하면 중복성이 발생합니다.</font><font papago-translate="translated"> 숫자 리터럴을 스캔하는 작업은 일련의 숫자 문자를 숫자 값으로 변환하는 데 필요한 작업과 매우 유사합니다.</font><font papago-translate="translated"> 하지만 중복성이<em> 그다지</em> 크지 않고 성능이 중요하지 않으며 스캐너를 더 간단하게 유지합니다.</font></p>
</aside>
<p><font papago-translate="translated">다음으로 숫자입니다.</font><font papago-translate="translated"> 숫자를 시작할 수 있는 열 자리 숫자 각각에 스위치 케이스를 추가하는 대신, 여기서 이를 처리합니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  char c = advance();
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">스캐너.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>스캔</em> 중에</font><font papago-translate="translated"><em>토큰</em>()</font></font></div>
<pre class="insert" translate="no">  <span class="k">if</span> (<span class="i">isDigit</span>(<span class="i">c</span>)) <span class="k">return</span> <span class="i">number</span>();
</pre><pre class="insert-after" translate="no">
  switch (c) {
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, in <em>scanToken</em>()</div>
<p><font papago-translate="translated">이는 명백한 유틸리티 함수를 사용합니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">스캐너.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>init</em>Sc<em>anner</em>() 뒤에 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">bool</span> <span class="i">isDigit</span>(<span class="t">char</span> <span class="i">c</span>) {
  <span class="k">return</span> <span class="i">c</span> &gt;= <span class="s">'0'</span> &amp;&amp; <span class="i">c</span> &lt;= <span class="s">'9'</span>;
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>initScanner</em>()</div>
<p><font papago-translate="translated">이것을 사용하여 숫자 스캔을 마칩니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">스캐너.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>건너뛰기</em> 후 추가</font><font papago-translate="translated"><em>공백(</em>)</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">Token</span> <span class="i">number</span>() {
  <span class="k">while</span> (<span class="i">isDigit</span>(<span class="i">peek</span>())) <span class="i">advance</span>();

  <span class="c">// Look for a fractional part.</span>
  <span class="k">if</span> (<span class="i">peek</span>() == <span class="s">'.'</span> &amp;&amp; <span class="i">isDigit</span>(<span class="i">peekNext</span>())) {
    <span class="c">// Consume the ".".</span>
    <span class="i">advance</span>();

    <span class="k">while</span> (<span class="i">isDigit</span>(<span class="i">peek</span>())) <span class="i">advance</span>();
  }

  <span class="k">return</span> <span class="i">makeToken</span>(<span class="a">TOKEN_NUMBER</span>);
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>skipWhitespace</em>()</div>
<p><font papago-translate="translated">Jlox의 버전과 거의 동일하지만, 아직 어휘를 두 배로 변환하지는 않습니다.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/scanning-on-demand.html#identifiers-and-keywords" id="identifiers-and-keywords"><small><font papago-translate="translated">16 . 4</font></small><font papago-translate="splitted"><font papago-translate="translated">식별자 및 키워드</font></font></a></h2>
<p><font papago-translate="translated">마지막 토큰 배치는 사용자 정의 및 예약된 식별자입니다.</font><font papago-translate="translated"> 이 섹션은 재미있을 것입니다. 우리가 clox에서 키워드를 인식하는 방식은 jlox에서 인식하는 방식과 상당히 다르며, 몇 가지 중요한 데이터<span class="em"></span> 구조에 대해 다룹니다.</font></p>
<p><font papago-translate="translated">하지만 먼저 어휘를 스캔해야 합니다.</font><font papago-translate="translated"> 이름은 글자나 밑줄로 시작합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  char c = advance();
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">스캐너.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>스캔</em> 중에</font><font papago-translate="translated"><em>토큰</em>()</font></font></div>
<pre class="insert" translate="no">  <span class="k">if</span> (<span class="i">isAlpha</span>(<span class="i">c</span>)) <span class="k">return</span> <span class="i">identifier</span>();
</pre><pre class="insert-after" translate="no">  if (isDigit(c)) return number();
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, in <em>scanToken</em>()</div>
<p><font papago-translate="translated">우리는 이것을 사용하는 사람들을 인식합니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">스캐너.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>init</em>Sc<em>anner</em>() 뒤에 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">bool</span> <span class="i">isAlpha</span>(<span class="t">char</span> <span class="i">c</span>) {
  <span class="k">return</span> (<span class="i">c</span> &gt;= <span class="s">'a'</span> &amp;&amp; <span class="i">c</span> &lt;= <span class="s">'z'</span>) ||
         (<span class="i">c</span> &gt;= <span class="s">'A'</span> &amp;&amp; <span class="i">c</span> &lt;= <span class="s">'Z'</span>) ||
          <span class="i">c</span> == <span class="s">'_'</span>;
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>initScanner</em>()</div>
<p><font papago-translate="translated">식별자를 찾으면 나머지는 여기에서 스캔합니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">스캐너.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>건너뛰기</em> 후 추가</font><font papago-translate="translated"><em>공백(</em>)</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">Token</span> <span class="i">identifier</span>() {
  <span class="k">while</span> (<span class="i">isAlpha</span>(<span class="i">peek</span>()) || <span class="i">isDigit</span>(<span class="i">peek</span>())) <span class="i">advance</span>();
  <span class="k">return</span> <span class="i">makeToken</span>(<span class="i">identifierType</span>());
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>skipWhitespace</em>()</div>
<p><font papago-translate="translated">첫 글자 뒤에는 숫자도 허용하고, 알파벳이 다 떨어질 때까지 계속해서 알파벳을 소비합니다.</font><font papago-translate="translated"> 그런 다음 적절한 유형의 토큰을 생성합니다.</font><font papago-translate="translated"> "적절한" 유형을 결정하는 것은 이 장의 고유한 부분입니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">스캐너.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>건너뛰기</em> 후 추가</font><font papago-translate="translated"><em>공백(</em>)</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">TokenType</span> <span class="i">identifierType</span>() {
  <span class="k">return</span> <span class="a">TOKEN_IDENTIFIER</span>;
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>skipWhitespace</em>()</div>
<p><font papago-translate="translated">알겠어요, 아직 그다지 흥미롭지 않은 것 같아요.</font><font papago-translate="translated"> 예약된 단어가 전혀 없다면 그렇게 보일 것입니다.</font><font papago-translate="translated"> 키워드를 어떻게 인식해야 할까요?</font><font papago-translate="translated"> Jlox에서는 모든 것을 자바 맵에 채우고 이름을 찾아봤습니다.</font><font papago-translate="translated"> 적어도 아직 클록스에는 해시 테이블 구조가 없습니다.</font></p>
<p><font papago-translate="translated">해시 테이블은 어차피 과하게 만들 것입니다.</font><font papago-translate="translated"> 해시<span name="hash"> 테이블</span>에서 문자열을 찾으려면 문자열을 걸어 해시 코드를 계산하고, 해시 테이블에서 해당 버킷을 찾은 다음, 해당 문자열에 대해 문자별 등식 비교를 수행해야 합니다.</font></p>
<aside name="hash" style="top: 17971px;">
<p><font papago-translate="translated">낯설어도 걱정하지 마세요.</font><font papago-translate="translated"> <a href="https://youhogeon-meritz.github.io/hash-tables.html">우리가 처음부터 우리만의 해시 테이블을 구축</a>하게 되면, 우리는 그것에 대해 아주 자세하게 배울 것입니다.</font></p>
</aside>
<p><font papago-translate="translated">"고르곤졸라"라는 식별자를 스캔했다고 가정해 보겠습니다.</font><font papago-translate="translated"> 예약된 단어인지 확인하려면 얼마나 많은 작업을 해야<em> 하나</em>요?</font><font papago-translate="translated"> "g"로 시작하는 Lox 키워드는 없으므로 첫 번째 문자를 보면 확실히 아니오라고 대답하기에 충분합니다.</font><font papago-translate="translated"> 해시 테이블 조회보다 훨씬 간단합니다.</font></p>
<p><font papago-translate="translated">"카디건"은 어때요?</font><font papago-translate="translated"> Lox에는 "c"로 시작하는 키워드가 있습니다: "class".</font><font papago-translate="translated"> 하지만 '카디건'의 두 번째 캐릭터인 'a'는 이를 배제합니다.</font><font papago-translate="translated"> "숲"은 어떨까요?</font><font papago-translate="translated"> "for"가 키워드이기 때문에 예약된 단어가 없다는 것을 확인하려면 문자열에서 더 멀리 나아가야 합니다.</font><font papago-translate="translated"> 하지만 대부분의 경우 사용자가 정의한 이름이 있다는 것을 알기 위해서는 한두 글자만으로도 충분합니다.</font><font papago-translate="translated"> 우리는 그것을 인식하고 빠르게 실패할 수 있어야 합니다.</font></p>
<p><font papago-translate="translated">다음은 분기 문자 검사 논리의 시각적 표현입니다:</font></p>
<p><span name="down"></span></p><img alt="A trie that contains all of Lox's keywords." src="https://youhogeon-meritz.github.io/image/scanning-on-demand/keywords.png">
<aside name="down" style="top: 18425px;">
<p><font papago-translate="translated">각 노드 체인을 읽어보면 Lox의 키워드가 나타나는 것을 볼 수 있습니다.</font></p>
</aside>
<p><font papago-translate="translated">우리는 루트 노드에서 시작합니다.</font><font papago-translate="translated"> 어휘소의 첫 번째 문자와 일치하는 문자를 가진 자식 노드가 있는 경우 해당 노드로 이동합니다.</font><font papago-translate="translated"> 그런 다음 어휘의 다음 글자 등을 반복합니다.</font><font papago-translate="translated"> 어휘의 다음 글자가 자식 노드와 일치하지 않는 경우 식별자가 키워드가 되어서는 안 되며 중지합니다.</font><font papago-translate="translated"> 이중 줄 상자에 도달하여 어휘의 마지막 문자에 도달하면 키워드를 찾을 수 있습니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/scanning-on-demand.html#tries-and-state-machines" id="tries-and-state-machines"><small><font papago-translate="translated">16 . 4 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">시도 및 상태 기계</font></font></a></h3>
<p><font papago-translate="translated">이 트리 다이어그램은<span name="trie"><a href="https://en.wikipedia.org/wiki/Trie"><strong> 트리</strong></a></span>라고 불리는 것의 예입니다.</font><font papago-translate="translated"> 트라이는 문자열 세트를 저장합니다.</font><font papago-translate="translated"> 문자열을 저장하기 위한 대부분의 다른 데이터 구조는 원시 문자 배열을 포함하고 있으며, 이를 더 빠르게 검색할 수 있도록 도와주는 더 큰 구조로 감싸줍니다.</font><font papago-translate="translated"> 트라이는 다릅니다.</font><font papago-translate="translated"> 트라이 어디에서도 전체 문자열을 찾을 수 없습니다.</font></p>
<aside name="trie" style="top: 19144px;">
<p><font papago-translate="translated">"Trie"는 CS에서 가장 혼란스러운 이름 중 하나입니다.</font><font papago-translate="translated"> 에드워드 프레드킨은 "리트리벌"이라는 단어의 중간에서 그것을 빼냈는데, 이는 "나무"처럼 발음해야 한다는 것을 의미합니다.</font><font papago-translate="translated"> 하지만 이미 "나무"라는 꽤 중요한 데이터 구조가 있는데<em>, 이를 시도하는 것은 특별한 경우</em>입니다. 그래서 이런 것들에 대해 큰 소리로 말하지 않으면 아무도 당신이 어떤 것을 말하고 있는지 알 수 없습니다.</font><font papago-translate="translated"> 따라서 요즘 사람들은 두통을 피하기 위해 종종 "시도해 보세요"라고 발음합니다.</font></p>
</aside>
<p><font papago-translate="translated">대신, 트리에 "포함"된 각 문자열은 위의 탐색에서와 같이 문자 노드 트리를 통과<em>하는 경로</em>로 표현됩니다.</font><font papago-translate="translated"> 문자열의 마지막 문자와 일치하는 노드에는 특별한 마커가 있는데,<span class="em"></span> 이는 그림의 이중 줄 상자입니다.</font><font papago-translate="translated"> 그렇게 하면, 만약 당신의 트라이에 "banquet"과 "ban"이 포함되어 있다면, "banquet<span class="em">"</span>이<em> 포함되어 있지</em> 않다는 것을 알 수 있습니다. "e" 노드는 그 마커를 가지지 않을 것이고, "n"과 "t" 노드는 그렇지 않을 것입니다.</font></p>
<p><font papago-translate="translated">시도는 훨씬 더 근본적인 데이터 구조인<a href="https://en.wikipedia.org/wiki/Deterministic_finite_automaton"><strong> 결정론적 유한 오토마톤</strong></a>(D<strong>FA</strong>)의 특별한 경우입니다.</font><font papago-translate="translated"> <strong>다른</strong> 이름으로도 알 수 있습니다<strong>: 유한 상태 기계</strong> 또는 단순<strong> 상태 기계.</strong></font><font papago-translate="translated"> 상태 기계는 rad입니다.</font><font papago-translate="translated"> <a href="http://gameprogrammingpatterns.com/state.html">그</a>들은<a href="http://gameprogrammingpatterns.com/state.html"> 결국 게임 프로그래밍</a>부터 네트워킹 프로토콜 구현까지 모든 면에서 유용하게 사용됩니다.</font></p>
<p><font papago-translate="translated">DFA에서는 이들 사이<em>에 전이가</em> 있는<em> 상태</em> 집합이 그래프를 형성합니다.</font><font papago-translate="translated"> 어느 시점에서든 기계는 정확히 하나의 상태에 있습니다.</font><font papago-translate="translated"> 전환을 따라 다른 상태로 이동합니다.</font><font papago-translate="translated"> 어휘 분석을 위해 DFA를 사용할 때, 각 전이는 문자열에서 일치하는 문자입니다.</font><font papago-translate="translated"> 각 상태는 허용된 문자 집합을 나타냅니다.</font></p>
<p><font papago-translate="translated">우리의 키워드 트리는 정확히 Lox 키워드를 인식하는 DFA입니다.</font><font papago-translate="translated"> 하지만 DFA는 임의<em>의 그래프</em>일 수 있기 때문에 단순한 트리보다 더 강력합니다.</font><font papago-translate="translated"> 전환은 상태 간의 순환을 형성할 수 있습니다.</font><font papago-translate="translated"> 이를 통해 임의로 긴 문자열을 인식할 수 있습니다.</font><font papago-translate="translated"> 예를 들어, 숫자 리터럴을 인식하는 DFA가 있습니다:</font></p>
<p><span name="railroad"></span></p><img alt="A syntax diagram that recognizes integer and floating point literals." src="https://youhogeon-meritz.github.io/image/scanning-on-demand/numbers.png">
<aside name="railroad" style="top: 19838px;">
<p><font papago-translate="translated">이 스타일의 다이어그램은<a href="https://en.wikipedia.org/wiki/Syntax_diagram"><strong> 구문 다이어그램</strong></a> 또는 더 매력적<strong>인 철도 다이어그램</strong>이라고 불립니다.</font><font papago-translate="translated"> 후자의 이름은 기차의 전환 야드처럼 보이기 때문입니다.</font></p>
<p><font papago-translate="translated">Backus-Naur Form이 존재하기 전에는 이것이 언어의 문법을 문서화하는 주된 방법 중 하나였습니다.</font><font papago-translate="translated"> 요즘 우리는 주로 텍스트를 사용하지만<em>, 이미지</em>에 의존하는<em> 텍스트 언어</em>의 공식 사양에는 기쁜 점이 있습니다.</font></p>
</aside>
<p><font papago-translate="translated">10자리 숫자의 노드를 더 읽기 쉽게 만들기 위해 함께 접었지만 기본 프로세스는 동일하게 작동합니다. 즉, 해당 문자를 어휘<span class="em"></span>소에서 사용할 때마다 경로를 통해 노드를 입력하는 방식입니다.</font><font papago-translate="translated"> 우리가 그렇게 기울었다면<em></em>, 필요한 모든 토큰을 인식하고 분사하는 단일 상태 기계인 Lox의 모든 어휘 분석을 수행하는 하나의 거대한 DFA를 만들 수 있을 것입니다.</font></p>
<p><font papago-translate="translated">그러나 그 메가 DFA를<span name="regex"> 수작업</span>으로 만드는 것은 어려울 것입니다.</font><font papago-translate="translated"> 그래서 <a href="https://en.wikipedia.org/wiki/Lex_(software)">렉스</a>가 만들어졌습니다.</font><font papago-translate="translated"> 어휘 문법에 대한 간단한 텍스트 설명, 즉 여러 개의 정규 표현식을 제공하면 자동으로 DFA를 생성하고<span class="em"></span><span class="em"></span> 이를 구현하는 C 코드 더미를 생성합니다.</font></p>
<aside name="regex" style="top: 20174px;">
<p><font papago-translate="translated">이것이 프로그래밍 언어와 텍스트 편집기의 대부분의 정규 표현 엔진이 작동하는 방식이기도 합니다.</font><font papago-translate="translated"> 그들은 당신의 정규 표현 문자열을 가져와서 DFA로 변환한 후, 문자열을 맞추는 데 사용합니다.</font></p>
<p><font papago-translate="translated">정규 표현식을 DFA로 변환하는 알고리즘을 배우고 싶다면<a href="https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools">, 드래곤북</a>에서 다룰 수 있습니다.</font></p>
</aside>
<p><font papago-translate="translated">우리는 그 길을 가지 않을 것입니다.</font><font papago-translate="translated"> 저희는 이미 완벽하게 서비스 가능한 핸드 롤 스캐너를 보유하고 있습니다.</font><font papago-translate="translated"> 키워드를 인식하는 데는 작은 시도만 있으면 됩니다.</font><font papago-translate="translated"> 그것을 코드에 어떻게 매핑해야 하나요?</font></p>
<p><font papago-translate="translated">가장 간단한<span name="v8"> 해결책</span>은 각 노드에 대해 각 분기마다 사례가 있는 스위치 문을 사용하는 것입니다.</font><font papago-translate="translated"> 루트 노드부터 시작하여 쉬운 키워드를 다룰 것입니다.</font></p>
<aside name="v8" style="top: 20390px;">
<p><font papago-translate="translated">단순하다는 것은 멍청하다는 뜻이 아닙니다.</font><font papago-translate="translated"> 동일한 접근 방식은<a href="https://github.com/v8/v8/blob/e77eebfe3b747fb315bd3baad09bec0953e53e68/src/parsing/scanner.cc#L1643"> 본질적으로</a> V<a href="https://github.com/v8/v8/blob/e77eebfe3b747fb315bd3baad09bec0953e53e68/src/parsing/scanner.cc#L1643">8이 하는 일</a>이며, 현재 세계에서 가장 정교하고 빠른 언어 구현 중 하나입니다.</font></p>
</aside>
<div class="codehilite"><pre class="insert-before" translate="no">static TokenType identifierType() {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">스캐너.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>식별자Type</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="k">switch</span> (<span class="i">scanner</span>.<span class="i">start</span>[<span class="n">0</span>]) {
    <span class="k">case</span> <span class="s">'a'</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">1</span>, <span class="n">2</span>, <span class="s">"nd"</span>, <span class="a">TOKEN_AND</span>);
    <span class="k">case</span> <span class="s">'c'</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">1</span>, <span class="n">4</span>, <span class="s">"lass"</span>, <span class="a">TOKEN_CLASS</span>);
    <span class="k">case</span> <span class="s">'e'</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">1</span>, <span class="n">3</span>, <span class="s">"lse"</span>, <span class="a">TOKEN_ELSE</span>);
    <span class="k">case</span> <span class="s">'i'</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">1</span>, <span class="n">1</span>, <span class="s">"f"</span>, <span class="a">TOKEN_IF</span>);
    <span class="k">case</span> <span class="s">'n'</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">1</span>, <span class="n">2</span>, <span class="s">"il"</span>, <span class="a">TOKEN_NIL</span>);
    <span class="k">case</span> <span class="s">'o'</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">1</span>, <span class="n">1</span>, <span class="s">"r"</span>, <span class="a">TOKEN_OR</span>);
    <span class="k">case</span> <span class="s">'p'</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">1</span>, <span class="n">4</span>, <span class="s">"rint"</span>, <span class="a">TOKEN_PRINT</span>);
    <span class="k">case</span> <span class="s">'r'</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">1</span>, <span class="n">5</span>, <span class="s">"eturn"</span>, <span class="a">TOKEN_RETURN</span>);
    <span class="k">case</span> <span class="s">'s'</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">1</span>, <span class="n">4</span>, <span class="s">"uper"</span>, <span class="a">TOKEN_SUPER</span>);
    <span class="k">case</span> <span class="s">'v'</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">1</span>, <span class="n">2</span>, <span class="s">"ar"</span>, <span class="a">TOKEN_VAR</span>);
    <span class="k">case</span> <span class="s">'w'</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">1</span>, <span class="n">4</span>, <span class="s">"hile"</span>, <span class="a">TOKEN_WHILE</span>);
  }

</pre><pre class="insert-after" translate="no">  return TOKEN_IDENTIFIER;
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, in <em>identifierType</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">이것들은 하나의 키워드에 해당하는 초기 글자들입니다.</font><font papago-translate="translated"> "s"가 보이면 식별자가 될 수 있는 유일한 키워드는 다음과 같습니다 </font></font><code translate="no">super</code><font papago-translate="splitted"><font papago-translate="translated">. 그렇지 않을 수도 있으니 나머지 글자들도 확인해야 합니다.</font><font papago-translate="translated"> 트리 다이어그램에서 이것은 기본적으로 "s"에 매달려 있는 직선 경로입니다.</font></font></p>
<p><font papago-translate="translated">각 노드에 대해 스위치를 굴리지 않습니다.</font><font papago-translate="translated"> 대신 잠재 키워드의 나머지 어휘를 테스트하는 유틸리티 함수가 있습니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">스캐너.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>건너뛰기</em> 후 추가</font><font papago-translate="translated"><em>공백(</em>)</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">TokenType</span> <span class="i">checkKeyword</span>(<span class="t">int</span> <span class="i">start</span>, <span class="t">int</span> <span class="i">length</span>,
    <span class="k">const</span> <span class="t">char</span>* <span class="i">rest</span>, <span class="t">TokenType</span> <span class="i">type</span>) {
  <span class="k">if</span> (<span class="i">scanner</span>.<span class="i">current</span> - <span class="i">scanner</span>.<span class="i">start</span> == <span class="i">start</span> + <span class="i">length</span> &amp;&amp;
      <span class="i">memcmp</span>(<span class="i">scanner</span>.<span class="i">start</span> + <span class="i">start</span>, <span class="i">rest</span>, <span class="i">length</span>) == <span class="n">0</span>) {
    <span class="k">return</span> <span class="i">type</span>;
  }

  <span class="k">return</span> <span class="a">TOKEN_IDENTIFIER</span>;
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>skipWhitespace</em>()</div>
<p><font papago-translate="translated">우리는 이것을 트리의 모든 가지치기 해제 경로에 사용합니다.</font><font papago-translate="translated"> 하나의 가능한 예약된 단어일 수 있는 접두사를 찾은 후, 두 가지를 확인해야 합니다.</font><font papago-translate="translated"> 어휘는 키워드만큼 정확히 길어야 합니다.</font><font papago-translate="translated"> 첫 글자가 "s"라면, 어휘는 여전히 "sup" 또는 "superb"일 수 있습니다.</font><font papago-translate="translated"> 그리고 나머지 문자들은 정확히 일치해야 합니다—"supar"만으로는<span class="em"></span> 충분하지 않습니다.</font></p>
<p><font papago-translate="translated">적절한 수의 문자가 있고 원하는 문자가 있다면, 그것은 키워드이며 관련된 토큰 유형을 반환합니다.</font><font papago-translate="translated"> 그렇지 않으면 일반 식별자여야 합니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">첫 글자 뒤에 나무가 다시 가지를 치는 몇 가지 키워드가 있습니다.</font><font papago-translate="translated"> 어휘가 "f"로 시작하면 다음과 같을 수 있습니다 </font></font><code translate="no">false</code><font papago-translate="splitted"><font papago-translate="translated">, </font></font><code translate="no">for</code><font papago-translate="splitted"><font papago-translate="translated">, 또는 </font></font><code translate="no">fun</code><font papago-translate="splitted"><font papago-translate="translated">. 그래서 우리는 "f" 노드에서 나오는 가지들을 위한 또 다른 스위치를 추가합니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    case 'e': return checkKeyword(1, 3, "lse", TOKEN_ELSE);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">스캐너.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>식별자Type</em>()에서</font></font></div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="s">'f'</span>:
      <span class="k">if</span> (<span class="i">scanner</span>.<span class="i">current</span> - <span class="i">scanner</span>.<span class="i">start</span> &gt; <span class="n">1</span>) {
        <span class="k">switch</span> (<span class="i">scanner</span>.<span class="i">start</span>[<span class="n">1</span>]) {
          <span class="k">case</span> <span class="s">'a'</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">2</span>, <span class="n">3</span>, <span class="s">"lse"</span>, <span class="a">TOKEN_FALSE</span>);
          <span class="k">case</span> <span class="s">'o'</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">2</span>, <span class="n">1</span>, <span class="s">"r"</span>, <span class="a">TOKEN_FOR</span>);
          <span class="k">case</span> <span class="s">'u'</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">2</span>, <span class="n">1</span>, <span class="s">"n"</span>, <span class="a">TOKEN_FUN</span>);
        }
      }
      <span class="k">break</span>;
</pre><pre class="insert-after" translate="no">    case 'i': return checkKeyword(1, 1, "f", TOKEN_IF);
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, in <em>identifierType</em>()</div>
<p><font papago-translate="translated">전환하기 전에 두 번째<em></em> 글자가 있는지 확인해야 합니다.</font><font papago-translate="translated"> 결국 "f" 자체도 유효한 식별자입니다.</font><font papago-translate="translated"> 분기되는 다른 문자는 "t"입니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    case 's': return checkKeyword(1, 4, "uper", TOKEN_SUPER);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">스캐너.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>식별자Type</em>()에서</font></font></div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="s">'t'</span>:
      <span class="k">if</span> (<span class="i">scanner</span>.<span class="i">current</span> - <span class="i">scanner</span>.<span class="i">start</span> &gt; <span class="n">1</span>) {
        <span class="k">switch</span> (<span class="i">scanner</span>.<span class="i">start</span>[<span class="n">1</span>]) {
          <span class="k">case</span> <span class="s">'h'</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">2</span>, <span class="n">2</span>, <span class="s">"is"</span>, <span class="a">TOKEN_THIS</span>);
          <span class="k">case</span> <span class="s">'r'</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">2</span>, <span class="n">2</span>, <span class="s">"ue"</span>, <span class="a">TOKEN_TRUE</span>);
        }
      }
      <span class="k">break</span>;
</pre><pre class="insert-after" translate="no">    case 'v': return checkKeyword(1, 2, "ar", TOKEN_VAR);
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, in <em>identifierType</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">그게 다입니다.</font><font papago-translate="translated"> 중첩된 몇 가지 </font></font><code translate="no">switch</code><font papago-translate="splitted"><font papago-translate="translated"> 진술들.</font><font papago-translate="translated"> 이 코드는<span name="short"> 짧</span>을 뿐만 아니라 매우, 매우 빠릅니다.</font><font papago-translate="translated"> 키워드를 감지하는 데 필요한 최소한의 작업을 수행하며, 식별자가 예약된 것이 아님을 알 수 있는 즉시 실행됩니다.</font></font></p>
<p><font papago-translate="translated">이로써 스캐너는 완성되었습니다.</font></p>
<aside name="short" style="top: 22102px;">
<p><font papago-translate="translated">우리는 때때로 성능이 복잡한 데이터 구조, 계층적 캐싱 및 기타 화려한 최적화에서 비롯된다고 생각하는 함정에 빠지기도 합니다.</font><font papago-translate="translated"> 하지만 많은 경우에 필요한 것은 일을 덜 하는 것뿐이며, 제가 할 수 있는 가장 간단한 코드를 작성하는 것만으로도 충분하다는 것을 자주 알게 됩니다.</font></p>
</aside>
<div class="challenges">
<h2><a href="https://youhogeon-meritz.github.io/scanning-on-demand.html#challenges" id="challenges"><font papago-translate="translated">과제들</font></a></h2>
<ol>
<li>
<p><font papago-translate="splitted"><font papago-translate="translated">많은 최신 언어들이<a href="https://en.wikipedia.org/wiki/String_interpolation"><strong> 문자열 보간</strong></a>을 지원합니다.</font><font papago-translate="translated"> 문자열 리터럴 안에는 특별한 구분 기호가 있습니다—가장<span class="em"></span> 일반적으로 그렇습니다 </font></font><code translate="no">${</code><font papago-translate="splitted"><font papago-translate="translated"> 처음에 그리고 </font></font><code translate="no">}</code><font papago-translate="splitted"><font papago-translate="translated"> 마지막에.</font><font papago-translate="translated"> 그 구분 기호들 사이에는 어떤 표현이든 나타날 수 있습니다.</font><font papago-translate="translated"> 문자열 리터럴이 실행되면 내부 표현식이 평가되어 문자열로 변환된 다음 주변 문자열 리터럴과 병합됩니다.</font></font></p>
<p><font papago-translate="translated">예를 들어, Lox가 문자열 보간을 지원한다면, 이것<span class="ellipse">은 . . .</span></font></p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="i">drink</span> = <span class="s">"Tea"</span>;
<span class="k">var</span> <span class="i">steep</span> = <span class="n">4</span>;
<span class="k">var</span> <span class="i">cool</span> = <span class="n">2</span>;
<span class="k">print</span> <span class="s">"${drink} will be ready in ${steep + cool} minutes."</span>;
</pre></div>
<p><font papago-translate="translated"><span class="ellipse"> . </span>. . 인쇄할 것입니다<span class="ellipse">:</span></font></p>
<div class="codehilite"><pre translate="no">Tea will be ready in 6 minutes.
</pre></div>
<p><font papago-translate="translated">문자열 보간을 위한 스캐너를 구현하기 위해 어떤 토큰 유형을 정의하시겠습니까?</font><font papago-translate="translated"> 위의 문자열 리터럴에 대해 어떤 토큰 시퀀스를 방출하시겠습니까?</font></p>
<p><font papago-translate="translated">어떤 토큰을 발행하시겠습니까:</font></p>
<div class="codehilite"><pre translate="no">"Nested ${"interpolation?! Are you ${"mad?!"}"}"
</pre></div>
<p><font papago-translate="translated">보간을 지원하는 다른 언어 구현을 살펴보고 이를 어떻게 처리하는지 살펴보세요.</font></p>
</li>
<li>
<p><font papago-translate="splitted"><font papago-translate="translated">여러 언어에서 일반적인 언어로 각 괄호를 사용하며 </font></font><code translate="no">&gt;&gt;</code><font papago-translate="splitted"><font papago-translate="translated"> 우회전 연산자.</font><font papago-translate="translated"> 이로 인해 초기 버전의 C++에서는 고전적인 문제가 발생했습니다:</font></font></p>
<div class="codehilite"><pre translate="no"><span class="t">vector</span>&lt;<span class="t">vector</span>&lt;<span class="t">string</span>&gt;&gt; <span class="i">nestedVectors</span>;
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">이로 인해 컴파일 오류가 발생할 수 있습니다 </font></font><code translate="no">&gt;&gt;</code><font papago-translate="splitted"><font papago-translate="translated"> 두 개가 아닌 단일 오른쪽 시프트 토큰으로 렉시되었습니다 </font></font><code translate="no">&gt;</code><font papago-translate="splitted"><font papago-translate="translated"> 토큰.</font><font papago-translate="translated"> 사용자들은 닫힘 각도 괄호 사이에 공백을 두어 이를 피할 수밖에 없었습니다.</font></font></p>
<p><font papago-translate="translated">이후 버전의 C++는 더 스마트하며 위의 코드를 처리할 수 있습니다.</font><font papago-translate="translated"> Java와 C#에는 문제가 없었습니다.</font><font papago-translate="translated"> 그 언어들은 이것을 어떻게 명시하고 구현하나요?</font></p>
</li>
<li>
<p><font papago-translate="translated" class="">많은 언어들, 특히 진화의 후반부에서 "맥락 키워드"를 정의합니다.</font><font papago-translate="translated" class=""> 이 식별자들은 어떤 맥락에서는 예약된 단어처럼 작동하지만, 다른 맥락에서는 일반적인 사용자 정의 식별자일 수 있습니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">예를들면, </font></font><code translate="no">await</code><font papago-translate="splitted"><font papago-translate="translated"> 는 내부의 키워드입니다 </font></font><code translate="no">async</code><font papago-translate="splitted"><font papago-translate="translated"> C#의 메서드이지만 다른 메서드에서는 다음과 같은 방법을 사용할 수 있습니다 </font></font><code translate="no">await</code><font papago-translate="splitted"><font papago-translate="translated"> 자신의 식별자로.</font></font></p>
<p><font papago-translate="translated">다른 언어에서 온 몇 가지 문맥 키워드와 그것들이 의미 있는 문맥을 말해보세요.</font><font papago-translate="translated"> 문맥 키워드를 사용하는 것의 장단점은 무엇입니까?</font><font papago-translate="translated" class=""> 필요하다면 언어의 프론트엔드에서 어떻게 구현하시겠습니까?</font></p>
</li>
</ol>
</div>
<footer>
<a class="next" href="https://youhogeon-meritz.github.io/compiling-expressions.html"><font papago-translate="translated" class=""> 다음 장: "표현식 모음" → </font></a><font papago-translate="splitted"><font papago-translate="translated"> 로버트 니스트롬이 수작업으로 제작한 -<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE"> © 2015 ~ 2021</a></font></font>
</footer>
</article>
</div>


<div id="papagoTooltip" margin="5" style="display: none;">
        <h1 id="tooltipTitle">원문</h1>
        <p id="tooltipText"></p>
      </div>
      </body></html>