<!DOCTYPE html>

<html>
<head>
<meta content="text/html;charset=utf-8" http-equiv="Content-type"/>
<title>Scanning on Demand · Crafting Interpreters</title>
<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<link href="style.css" rel="stylesheet" type="text/css"/>
<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600" rel="stylesheet" type="text/css"/>
<link href="image/favicon.png" rel="icon" type="image/png">
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>
<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>
</link></head>
<body id="top">
<!-- <div class="scrim"></div> -->
<nav class="wide">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"/></a>
<div class="contents">
<h3><a href="#top">Scanning on Demand<small>16</small></a></h3>
<ul>
<li><a href="#spinning-up-the-interpreter"><small>16.1</small> Spinning Up the Interpreter</a></li>
<li><a href="#a-token-at-a-time"><small>16.2</small> A Token at a Time</a></li>
<li><a href="#a-lexical-grammar-for-lox"><small>16.3</small> A Lexical Grammar for Lox</a></li>
<li><a href="#identifiers-and-keywords"><small>16.4</small> Identifiers and Keywords</a></li>
<li class="divider"></li>
<li class="end-part"><a href="#challenges">Challenges</a></li>
</ul>
<div class="prev-next">
<a class="left" href="a-virtual-machine.html" title="A Virtual Machine">← Previous</a>
<a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">↑ Up</a>
<a class="right" href="compiling-expressions.html" title="Compiling Expressions">Next →</a>
</div> </div>
</nav>
<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"/></a>
<a class="prev" href="a-virtual-machine.html" title="A Virtual Machine">←</a>
<a class="next" href="compiling-expressions.html" title="Compiling Expressions">→</a>
</nav>
<div class="page">
<div class="nav-wrapper">
<nav class="floating">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"/></a>
<div class="expandable">
<h3><a href="#top">Scanning on Demand<small>16</small></a></h3>
<ul>
<li><a href="#spinning-up-the-interpreter"><small>16.1</small> Spinning Up the Interpreter</a></li>
<li><a href="#a-token-at-a-time"><small>16.2</small> A Token at a Time</a></li>
<li><a href="#a-lexical-grammar-for-lox"><small>16.3</small> A Lexical Grammar for Lox</a></li>
<li><a href="#identifiers-and-keywords"><small>16.4</small> Identifiers and Keywords</a></li>
<li class="divider"></li>
<li class="end-part"><a href="#challenges">Challenges</a></li>
</ul>
<div class="prev-next">
<a class="left" href="a-virtual-machine.html" title="A Virtual Machine">← Previous</a>
<a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">↑ Up</a>
<a class="right" href="compiling-expressions.html" title="Compiling Expressions">Next →</a>
</div> </div>
<a id="expand-nav">≡</a>
</nav>
</div>
<article class="chapter">
<div class="number">16</div>
<h1>Scanning on Demand</h1>
<blockquote>
<p>Literature is idiosyncratic arrangements in horizontal lines in only
twenty-six phonetic symbols, ten Arabic numbers, and about eight punctuation
marks.</p>
<p><cite>Kurt Vonnegut, <em>Like Shaking Hands With God: A Conversation about Writing</em></cite></p>
</blockquote>
<p>Our second interpreter, clox, has three phases<span class="em">—</span>scanner, compiler, and virtual
machine. A data structure joins each pair of phases. Tokens flow from scanner to
compiler, and chunks of bytecode from compiler to VM. We began our
implementation near the end with <a href="chunks-of-bytecode.html">chunks</a> and the <a href="a-virtual-machine.html">VM</a>. Now, we’re going to
hop back to the beginning and build a scanner that makes tokens. In the
<a href="compiling-expressions.html">next chapter</a>, we’ll tie the two ends together with our bytecode compiler.</p><img alt="Source code → scanner → tokens → compiler → bytecode chunk → VM." src="image/scanning-on-demand/pipeline.png">
<p>I’ll admit, this is not the most exciting chapter in the book. With two
implementations of the same language, there’s bound to be some redundancy. I did
sneak in a few interesting differences compared to jlox’s scanner. Read on to
see what they are.</p>
<h2><a href="#spinning-up-the-interpreter" id="spinning-up-the-interpreter"><small>16 . 1</small>Spinning Up the Interpreter</a></h2>
<p>Now that we’re building the front end, we can get clox running like a real
interpreter. No more hand-authored chunks of bytecode. It’s time for a REPL and
script loading. Tear out most of the code in <code translate="no">main()</code> and replace it with:</p>
<div class="codehilite"><pre class="insert-before" translate="no">int main(int argc, const char* argv[]) {
  initVM();

</pre><div class="source-file"><em>main.c</em><br/>
in <em>main</em>()<br/>
replace 26 lines</div>
<pre class="insert" translate="no">  <span class="k">if</span> (<span class="i">argc</span> == <span class="n">1</span>) {
    <span class="i">repl</span>();
  } <span class="k">else</span> <span class="k">if</span> (<span class="i">argc</span> == <span class="n">2</span>) {
    <span class="i">runFile</span>(<span class="i">argv</span>[<span class="n">1</span>]);
  } <span class="k">else</span> {
    <span class="i">fprintf</span>(<span class="i">stderr</span>, <span class="s">"Usage: clox [path]</span><span class="e">\n</span><span class="s">"</span>);
    <span class="i">exit</span>(<span class="n">64</span>);
  }

  <span class="i">freeVM</span>();
</pre><pre class="insert-after" translate="no">  return 0;
}
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>main</em>(), replace 26 lines</div>
<p>If you pass <span name="args">no arguments</span> to the executable, you are
dropped into the REPL. A single command line argument is understood to be the
path to a script to run.</p>
<aside name="args">
<p>The code tests for one and two arguments, not zero and one, because the first
argument in <code translate="no">argv</code> is always the name of the executable being run.</p>
</aside>
<p>We’ll need a few system headers, so let’s get them all out of the way.</p>
<div class="codehilite"><div class="source-file"><em>main.c</em><br/>
add to top of file</div>
<pre class="insert" translate="no"><span class="a">#include &lt;stdio.h&gt;</span>
<span class="a">#include &lt;stdlib.h&gt;</span>
<span class="a">#include &lt;string.h&gt;</span>

</pre><pre class="insert-after" translate="no">#include "common.h"
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, add to top of file</div>
<p>Next, we get the REPL up and REPL-ing.</p>
<div class="codehilite"><pre class="insert-before" translate="no">#include "vm.h"
</pre><div class="source-file"><em>main.c</em></div>
<pre class="insert" translate="no">

<span class="k">static</span> <span class="t">void</span> <span class="i">repl</span>() {
  <span class="t">char</span> <span class="i">line</span>[<span class="n">1024</span>];
  <span class="k">for</span> (;;) {
    <span class="i">printf</span>(<span class="s">"&gt; "</span>);

    <span class="k">if</span> (!<span class="i">fgets</span>(<span class="i">line</span>, <span class="k">sizeof</span>(<span class="i">line</span>), <span class="i">stdin</span>)) {
      <span class="i">printf</span>(<span class="s">"</span><span class="e">\n</span><span class="s">"</span>);
      <span class="k">break</span>;
    }

    <span class="i">interpret</span>(<span class="i">line</span>);
  }
}
</pre></div>
<div class="source-file-narrow"><em>main.c</em></div>
<p>A quality REPL handles input that spans multiple lines gracefully and doesn’t
have a hardcoded line length limit. This REPL here is a little more, ahem,
austere, but it’s fine for our purposes.</p>
<p>The real work happens in <code translate="no">interpret()</code>. We’ll get to that soon, but first let’s
take care of loading scripts.</p>
<div class="codehilite"><div class="source-file"><em>main.c</em><br/>
add after <em>repl</em>()</div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">runFile</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">path</span>) {
  <span class="t">char</span>* <span class="i">source</span> = <span class="i">readFile</span>(<span class="i">path</span>);
  <span class="t">InterpretResult</span> <span class="i">result</span> = <span class="i">interpret</span>(<span class="i">source</span>);
  <span class="i">free</span>(<span class="i">source</span>);<span name="owner"> </span>

  <span class="k">if</span> (<span class="i">result</span> == <span class="a">INTERPRET_COMPILE_ERROR</span>) <span class="i">exit</span>(<span class="n">65</span>);
  <span class="k">if</span> (<span class="i">result</span> == <span class="a">INTERPRET_RUNTIME_ERROR</span>) <span class="i">exit</span>(<span class="n">70</span>);
}
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, add after <em>repl</em>()</div>
<p>We read the file and execute the resulting string of Lox source code. Then,
based on the result of that, we set the exit code appropriately because we’re
scrupulous tool builders and care about little details like that.</p>
<p>We also need to free the source code string because <code translate="no">readFile()</code> dynamically
allocates it and passes ownership to its caller. That function looks like this:</p>
<aside name="owner">
<p>C asks us not just to manage memory explicitly, but <em>mentally</em>. We programmers
have to remember the ownership rules and hand-implement them throughout the
program. Java just does it for us. C++ gives us tools to encode the policy
directly so that the compiler validates it for us.</p>
<p>I like C’s simplicity, but we pay a real price for it<span class="em">—</span>the language requires
us to be more conscientious.</p>
</aside>
<div class="codehilite"><div class="source-file"><em>main.c</em><br/>
add after <em>repl</em>()</div>
<pre translate="no"><span class="k">static</span> <span class="t">char</span>* <span class="i">readFile</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">path</span>) {
  <span class="a">FILE</span>* <span class="i">file</span> = <span class="i">fopen</span>(<span class="i">path</span>, <span class="s">"rb"</span>);

  <span class="i">fseek</span>(<span class="i">file</span>, <span class="n">0L</span>, <span class="a">SEEK_END</span>);
  <span class="t">size_t</span> <span class="i">fileSize</span> = <span class="i">ftell</span>(<span class="i">file</span>);
  <span class="i">rewind</span>(<span class="i">file</span>);

  <span class="t">char</span>* <span class="i">buffer</span> = (<span class="t">char</span>*)<span class="i">malloc</span>(<span class="i">fileSize</span> + <span class="n">1</span>);
  <span class="t">size_t</span> <span class="i">bytesRead</span> = <span class="i">fread</span>(<span class="i">buffer</span>, <span class="k">sizeof</span>(<span class="t">char</span>), <span class="i">fileSize</span>, <span class="i">file</span>);
  <span class="i">buffer</span>[<span class="i">bytesRead</span>] = <span class="s">'\0'</span>;

  <span class="i">fclose</span>(<span class="i">file</span>);
  <span class="k">return</span> <span class="i">buffer</span>;
}
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, add after <em>repl</em>()</div>
<p>Like a lot of C code, it takes more effort than it seems like it should,
especially for a language expressly designed for operating systems. The
difficult part is that we want to allocate a big enough string to read the whole
file, but we don’t know how big the file is until we’ve read it.</p>
<p>The code here is the classic trick to solve that. We open the file, but before
reading it, we seek to the very end using <code translate="no">fseek()</code>. Then we call <code translate="no">ftell()</code>
which tells us how many bytes we are from the start of the file. Since we seeked
(sought?) to the end, that’s the size. We rewind back to the beginning, allocate
a string of that <span name="one">size</span>, and read the whole file in a
single batch.</p>
<aside name="one">
<p>Well, that size <em>plus one</em>. Always gotta remember to make room for the null
byte.</p>
</aside>
<p>So we’re done, right? Not quite. These function calls, like most calls in the C
standard library, can fail. If this were Java, the failures would be thrown as
exceptions and automatically unwind the stack so we wouldn’t <em>really</em> need to
handle them. In C, if we don’t check for them, they silently get ignored.</p>
<p>This isn’t really a book on good C programming practice, but I hate to encourage
bad style, so let’s go ahead and handle the errors. It’s good for us, like
eating our vegetables or flossing.</p>
<p>Fortunately, we don’t need to do anything particularly clever if a failure
occurs. If we can’t correctly read the user’s script, all we can really do is
tell the user and exit the interpreter gracefully. First of all, we might fail
to open the file.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  FILE* file = fopen(path, "rb");
</pre><div class="source-file"><em>main.c</em><br/>
in <em>readFile</em>()</div>
<pre class="insert" translate="no">  <span class="k">if</span> (<span class="i">file</span> == <span class="a">NULL</span>) {
    <span class="i">fprintf</span>(<span class="i">stderr</span>, <span class="s">"Could not open file </span><span class="e">\"</span><span class="s">%s</span><span class="e">\"</span><span class="s">.</span><span class="e">\n</span><span class="s">"</span>, <span class="i">path</span>);
    <span class="i">exit</span>(<span class="n">74</span>);
  }
</pre><pre class="insert-after" translate="no">

  fseek(file, 0L, SEEK_END);
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>readFile</em>()</div>
<p>This can happen if the file doesn’t exist or the user doesn’t have access to it.
It’s pretty common<span class="em">—</span>people mistype paths all the time.</p>
<p>This failure is much rarer:</p>
<div class="codehilite"><pre class="insert-before" translate="no">  char* buffer = (char*)malloc(fileSize + 1);
</pre><div class="source-file"><em>main.c</em><br/>
in <em>readFile</em>()</div>
<pre class="insert" translate="no">  <span class="k">if</span> (<span class="i">buffer</span> == <span class="a">NULL</span>) {
    <span class="i">fprintf</span>(<span class="i">stderr</span>, <span class="s">"Not enough memory to read </span><span class="e">\"</span><span class="s">%s</span><span class="e">\"</span><span class="s">.</span><span class="e">\n</span><span class="s">"</span>, <span class="i">path</span>);
    <span class="i">exit</span>(<span class="n">74</span>);
  }

</pre><pre class="insert-after" translate="no">  size_t bytesRead = fread(buffer, sizeof(char), fileSize, file);
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>readFile</em>()</div>
<p>If we can’t even allocate enough memory to read the Lox script, the user’s
probably got bigger problems to worry about, but we should do our best to at
least let them know.</p>
<p>Finally, the read itself may fail.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  size_t bytesRead = fread(buffer, sizeof(char), fileSize, file);
</pre><div class="source-file"><em>main.c</em><br/>
in <em>readFile</em>()</div>
<pre class="insert" translate="no">  <span class="k">if</span> (<span class="i">bytesRead</span> &lt; <span class="i">fileSize</span>) {
    <span class="i">fprintf</span>(<span class="i">stderr</span>, <span class="s">"Could not read file </span><span class="e">\"</span><span class="s">%s</span><span class="e">\"</span><span class="s">.</span><span class="e">\n</span><span class="s">"</span>, <span class="i">path</span>);
    <span class="i">exit</span>(<span class="n">74</span>);
  }

</pre><pre class="insert-after" translate="no">  buffer[bytesRead] = '\0';
</pre></div>
<div class="source-file-narrow"><em>main.c</em>, in <em>readFile</em>()</div>
<p>This is also unlikely. Actually, the <span name="printf"> calls</span> to
<code translate="no">fseek()</code>, <code translate="no">ftell()</code>, and <code translate="no">rewind()</code> could theoretically fail too, but let’s not
go too far off in the weeds, shall we?</p>
<aside name="printf">
<p>Even good old <code translate="no">printf()</code> can fail. Yup. How many times have you handled <em>that</em>
error?</p>
</aside>
<h3><a href="#opening-the-compilation-pipeline" id="opening-the-compilation-pipeline"><small>16 . 1 . 1</small>Opening the compilation pipeline</a></h3>
<p>We’ve got ourselves a string of Lox source code, so now we’re ready to set up a
pipeline to scan, compile, and execute it. It’s driven by <code translate="no">interpret()</code>. Right
now, that function runs our old hardcoded test chunk. Let’s change it to
something closer to its final incarnation.</p>
<div class="codehilite"><pre class="insert-before" translate="no">void freeVM();
</pre><div class="source-file"><em>vm.h</em><br/>
function <em>interpret</em>()<br/>
replace 1 line</div>
<pre class="insert" translate="no"><span class="t">InterpretResult</span> <span class="i">interpret</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">source</span>);
</pre><pre class="insert-after" translate="no">void push(Value value);
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, function <em>interpret</em>(), replace 1 line</div>
<p>Where before we passed in a Chunk, now we pass in the string of source code.
Here’s the new implementation:</p>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br/>
function <em>interpret</em>()<br/>
replace 4 lines</div>
<pre class="insert" translate="no"><span class="t">InterpretResult</span> <span class="i">interpret</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">source</span>) {
  <span class="i">compile</span>(<span class="i">source</span>);
  <span class="k">return</span> <span class="a">INTERPRET_OK</span>;
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, function <em>interpret</em>(), replace 4 lines</div>
<p>We won’t build the actual <em>compiler</em> yet in this chapter, but we can start
laying out its structure. It lives in a new module.</p>
<div class="codehilite"><pre class="insert-before" translate="no">#include "common.h"
</pre><div class="source-file"><em>vm.c</em></div>
<pre class="insert" translate="no"><span class="a">#include "compiler.h"</span>
</pre><pre class="insert-after" translate="no">#include "debug.h"
</pre></div>
<div class="source-file-narrow"><em>vm.c</em></div>
<p>For now, the one function in it is declared like so:</p>
<div class="codehilite"><div class="source-file"><em>compiler.h</em><br/>
create new file</div>
<pre translate="no"><span class="a">#ifndef clox_compiler_h</span>
<span class="a">#define clox_compiler_h</span>

<span class="t">void</span> <span class="i">compile</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">source</span>);

<span class="a">#endif</span>
</pre></div>
<div class="source-file-narrow"><em>compiler.h</em>, create new file</div>
<p>That signature will change, but it gets us going.</p>
<p>The first phase of compilation is scanning<span class="em">—</span>the thing we’re doing in this
chapter<span class="em">—</span>so right now all the compiler does is set that up.</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br/>
create new file</div>
<pre translate="no"><span class="a">#include &lt;stdio.h&gt;</span>

<span class="a">#include "common.h"</span>
<span class="a">#include "compiler.h"</span>
<span class="a">#include "scanner.h"</span>

<span class="t">void</span> <span class="i">compile</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">source</span>) {
  <span class="i">initScanner</span>(<span class="i">source</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, create new file</div>
<p>This will also grow in later chapters, naturally.</p>
<h3><a href="#the-scanner-scans" id="the-scanner-scans"><small>16 . 1 . 2</small>The scanner scans</a></h3>
<p>There are still a few more feet of scaffolding to stand up before we can start
writing useful code. First, a new header:</p>
<div class="codehilite"><div class="source-file"><em>scanner.h</em><br/>
create new file</div>
<pre translate="no"><span class="a">#ifndef clox_scanner_h</span>
<span class="a">#define clox_scanner_h</span>

<span class="t">void</span> <span class="i">initScanner</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">source</span>);

<span class="a">#endif</span>
</pre></div>
<div class="source-file-narrow"><em>scanner.h</em>, create new file</div>
<p>And its corresponding implementation:</p>
<div class="codehilite"><div class="source-file"><em>scanner.c</em><br/>
create new file</div>
<pre translate="no"><span class="a">#include &lt;stdio.h&gt;</span>
<span class="a">#include &lt;string.h&gt;</span>

<span class="a">#include "common.h"</span>
<span class="a">#include "scanner.h"</span>

<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="k">const</span> <span class="t">char</span>* <span class="i">start</span>;
  <span class="k">const</span> <span class="t">char</span>* <span class="i">current</span>;
  <span class="t">int</span> <span class="i">line</span>;
} <span class="t">Scanner</span>;

<span class="t">Scanner</span> <span class="i">scanner</span>;
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, create new file</div>
<p>As our scanner chews through the user’s source code, it tracks how far it’s
gone. Like we did with the VM, we wrap that state in a struct and then create a
single top-level module variable of that type so we don’t have to pass it around
all of the various functions.</p>
<p>There are surprisingly few fields. The <code translate="no">start</code> pointer marks the beginning of
the current lexeme being scanned, and <code translate="no">current</code> points to the current character
being looked at.</p>
<p><span name="fields"></span></p><img alt="The start and current fields pointing at 'print bacon;'. Start points at 'b' and current points at 'o'." src="image/scanning-on-demand/fields.png">
<aside name="fields">
<p>Here, we are in the middle of scanning the identifier <code translate="no">bacon</code>. The current
character is <code translate="no">o</code> and the character we most recently consumed is <code translate="no">c</code>.</p>
</aside>
<p>We have a <code translate="no">line</code> field to track what line the current lexeme is on for error
reporting. That’s it! We don’t even keep a pointer to the beginning of the
source code string. The scanner works its way through the code once and is done
after that.</p>
<p>Since we have some state, we should initialize it.</p>
<div class="codehilite"><div class="source-file"><em>scanner.c</em><br/>
add after variable <em>scanner</em></div>
<pre translate="no"><span class="t">void</span> <span class="i">initScanner</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">source</span>) {
  <span class="i">scanner</span>.<span class="i">start</span> = <span class="i">source</span>;
  <span class="i">scanner</span>.<span class="i">current</span> = <span class="i">source</span>;
  <span class="i">scanner</span>.<span class="i">line</span> = <span class="n">1</span>;
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after variable <em>scanner</em></div>
<p>We start at the very first character on the very first line, like a runner
crouched at the starting line.</p>
<h2><a href="#a-token-at-a-time" id="a-token-at-a-time"><small>16 . 2</small>A Token at a Time</a></h2>
<p>In jlox, when the starting gun went off, the scanner raced ahead and eagerly
scanned the whole program, returning a list of tokens. This would be a challenge
in clox. We’d need some sort of growable array or list to store the tokens in.
We’d need to manage allocating and freeing the tokens, and the collection
itself. That’s a lot of code, and a lot of memory churn.</p>
<p>At any point in time, the compiler needs only one or two tokens<span class="em">—</span>remember our
grammar requires only a single token of lookahead<span class="em">—</span>so we don’t need to keep
them <em>all</em> around at the same time. Instead, the simplest solution is to not
scan a token until the compiler needs one. When the scanner provides one, it
returns the token by value. It doesn’t need to dynamically allocate anything<span class="em">—</span>it can just pass tokens around on the C stack.</p>
<p>Unfortunately, we don’t have a compiler yet that can ask the scanner for tokens,
so the scanner will just sit there doing nothing. To kick it into action, we’ll
write some temporary code to drive it.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  initScanner(source);
</pre><div class="source-file"><em>compiler.c</em><br/>
in <em>compile</em>()</div>
<pre class="insert" translate="no">  <span class="t">int</span> <span class="i">line</span> = -<span class="n">1</span>;
  <span class="k">for</span> (;;) {
    <span class="t">Token</span> <span class="i">token</span> = <span class="i">scanToken</span>();
    <span class="k">if</span> (<span class="i">token</span>.<span class="i">line</span> != <span class="i">line</span>) {
      <span class="i">printf</span>(<span class="s">"%4d "</span>, <span class="i">token</span>.<span class="i">line</span>);
      <span class="i">line</span> = <span class="i">token</span>.<span class="i">line</span>;
    } <span class="k">else</span> {
      <span class="i">printf</span>(<span class="s">"   | "</span>);
    }
    <span class="i">printf</span>(<span class="s">"%2d '%.*s'</span><span class="e">\n</span><span class="s">"</span>, <span class="i">token</span>.<span class="i">type</span>, <span class="i">token</span>.<span class="i">length</span>, <span class="i">token</span>.<span class="i">start</span>);<span name="format"> </span>

    <span class="k">if</span> (<span class="i">token</span>.<span class="i">type</span> == <span class="a">TOKEN_EOF</span>) <span class="k">break</span>;
  }
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>compile</em>()</div>
<aside name="format">
<p>That <code translate="no">%.*s</code> in the format string is a neat feature. Usually, you set the output
precision<span class="em">—</span>the number of characters to show<span class="em">—</span>by placing a number inside the
format string. Using <code translate="no">*</code> instead lets you pass the precision as an argument. So
that <code translate="no">printf()</code> call prints the first <code translate="no">token.length</code> characters of the string at
<code translate="no">token.start</code>. We need to limit the length like that because the lexeme points
into the original source string and doesn’t have a terminator at the end.</p>
</aside>
<p>This loops indefinitely. Each turn through the loop, it scans one token and
prints it. When it reaches a special “end of file” token or an error, it stops.
For example, if we run the interpreter on this program:</p>
<div class="codehilite"><pre translate="no"><span class="k">print</span> <span class="n">1</span> + <span class="n">2</span>;
</pre></div>
<p>It prints out:</p>
<div class="codehilite"><pre translate="no">   1 31 'print'
   | 21 '1'
   |  7 '+'
   | 21 '2'
   |  8 ';'
   2 39 ''
</pre></div>
<p>The first column is the line number, the second is the numeric value of the
token <span name="token">type</span>, and then finally the lexeme. That last
empty lexeme on line 2 is the EOF token.</p>
<aside name="token">
<p>Yeah, the raw index of the token type isn’t exactly human readable, but it’s all
C gives us.</p>
</aside>
<p>The goal for the rest of the chapter is to make that blob of code work by
implementing this key function:</p>
<div class="codehilite"><pre class="insert-before" translate="no">void initScanner(const char* source);
</pre><div class="source-file"><em>scanner.h</em><br/>
add after <em>initScanner</em>()</div>
<pre class="insert" translate="no"><span class="t">Token</span> <span class="i">scanToken</span>();
</pre><pre class="insert-after" translate="no">

#endif
</pre></div>
<div class="source-file-narrow"><em>scanner.h</em>, add after <em>initScanner</em>()</div>
<p>Each call scans and returns the next token in the source code. A token looks
like this:</p>
<div class="codehilite"><pre class="insert-before" translate="no">#define clox_scanner_h
</pre><div class="source-file"><em>scanner.h</em></div>
<pre class="insert" translate="no">

<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">TokenType</span> <span class="i">type</span>;
  <span class="k">const</span> <span class="t">char</span>* <span class="i">start</span>;
  <span class="t">int</span> <span class="i">length</span>;
  <span class="t">int</span> <span class="i">line</span>;
} <span class="t">Token</span>;
</pre><pre class="insert-after" translate="no">

void initScanner(const char* source);
</pre></div>
<div class="source-file-narrow"><em>scanner.h</em></div>
<p>It’s pretty similar to jlox’s Token class. We have an enum identifying what type
of token it is<span class="em">—</span>number, identifier, <code translate="no">+</code> operator, etc. The enum is virtually
identical to the one in jlox, so let’s just hammer out the whole thing.</p>
<div class="codehilite"><pre class="insert-before" translate="no">#ifndef clox_scanner_h
#define clox_scanner_h
</pre><div class="source-file"><em>scanner.h</em></div>
<pre class="insert" translate="no">

<span class="k">typedef</span> <span class="k">enum</span> {
  <span class="c">// Single-character tokens.</span>
  <span class="a">TOKEN_LEFT_PAREN</span>, <span class="a">TOKEN_RIGHT_PAREN</span>,
  <span class="a">TOKEN_LEFT_BRACE</span>, <span class="a">TOKEN_RIGHT_BRACE</span>,
  <span class="a">TOKEN_COMMA</span>, <span class="a">TOKEN_DOT</span>, <span class="a">TOKEN_MINUS</span>, <span class="a">TOKEN_PLUS</span>,
  <span class="a">TOKEN_SEMICOLON</span>, <span class="a">TOKEN_SLASH</span>, <span class="a">TOKEN_STAR</span>,
  <span class="c">// One or two character tokens.</span>
  <span class="a">TOKEN_BANG</span>, <span class="a">TOKEN_BANG_EQUAL</span>,
  <span class="a">TOKEN_EQUAL</span>, <span class="a">TOKEN_EQUAL_EQUAL</span>,
  <span class="a">TOKEN_GREATER</span>, <span class="a">TOKEN_GREATER_EQUAL</span>,
  <span class="a">TOKEN_LESS</span>, <span class="a">TOKEN_LESS_EQUAL</span>,
  <span class="c">// Literals.</span>
  <span class="a">TOKEN_IDENTIFIER</span>, <span class="a">TOKEN_STRING</span>, <span class="a">TOKEN_NUMBER</span>,
  <span class="c">// Keywords.</span>
  <span class="a">TOKEN_AND</span>, <span class="a">TOKEN_CLASS</span>, <span class="a">TOKEN_ELSE</span>, <span class="a">TOKEN_FALSE</span>,
  <span class="a">TOKEN_FOR</span>, <span class="a">TOKEN_FUN</span>, <span class="a">TOKEN_IF</span>, <span class="a">TOKEN_NIL</span>, <span class="a">TOKEN_OR</span>,
  <span class="a">TOKEN_PRINT</span>, <span class="a">TOKEN_RETURN</span>, <span class="a">TOKEN_SUPER</span>, <span class="a">TOKEN_THIS</span>,
  <span class="a">TOKEN_TRUE</span>, <span class="a">TOKEN_VAR</span>, <span class="a">TOKEN_WHILE</span>,

  <span class="a">TOKEN_ERROR</span>, <span class="a">TOKEN_EOF</span>
} <span class="t">TokenType</span>;
</pre><pre class="insert-after" translate="no">

typedef struct {
</pre></div>
<div class="source-file-narrow"><em>scanner.h</em></div>
<p>Aside from prefixing all the names with <code translate="no">TOKEN_</code> (since C tosses enum names in
the top-level namespace) the only difference is that extra <code translate="no">TOKEN_ERROR</code> type.
What’s that about?</p>
<p>There are only a couple of errors that get detected during scanning:
unterminated strings and unrecognized characters. In jlox, the scanner reports
those itself. In clox, the scanner produces a synthetic “error” token for that
error and passes it over to the compiler. This way, the compiler knows an error
occurred and can kick off error recovery before reporting it.</p>
<p>The novel part in clox’s Token type is how it represents the lexeme. In jlox,
each Token stored the lexeme as its own separate little Java string. If we did
that for clox, we’d have to figure out how to manage the memory for those
strings. That’s especially hard since we pass tokens by value<span class="em">—</span>multiple tokens could point to the same lexeme string. Ownership gets weird.</p>
<p>Instead, we use the original source string as our character store. We represent
a lexeme by a pointer to its first character and the number of characters it
contains. This means we don’t need to worry about managing memory for lexemes at
all and we can freely copy tokens around. As long as the main source code string
<span name="outlive">outlives</span> all of the tokens, everything works fine.</p>
<aside name="outlive">
<p>I don’t mean to sound flippant. We really do need to think about and ensure that
the source string, which is created far away over in the “main” module, has a
long enough lifetime. That’s why <code translate="no">runFile()</code> doesn’t free the string until
<code translate="no">interpret()</code> finishes executing the code and returns.</p>
</aside>
<h3><a href="#scanning-tokens" id="scanning-tokens"><small>16 . 2 . 1</small>Scanning tokens</a></h3>
<p>We’re ready to scan some tokens. We’ll work our way up to the complete
implementation, starting with this:</p>
<div class="codehilite"><div class="source-file"><em>scanner.c</em><br/>
add after <em>initScanner</em>()</div>
<pre translate="no"><span class="t">Token</span> <span class="i">scanToken</span>() {
  <span class="i">scanner</span>.<span class="i">start</span> = <span class="i">scanner</span>.<span class="i">current</span>;

  <span class="k">if</span> (<span class="i">isAtEnd</span>()) <span class="k">return</span> <span class="i">makeToken</span>(<span class="a">TOKEN_EOF</span>);

  <span class="k">return</span> <span class="i">errorToken</span>(<span class="s">"Unexpected character."</span>);
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>initScanner</em>()</div>
<p>Since each call to this function scans a complete token, we know we are at the
beginning of a new token when we enter the function. Thus, we set
<code translate="no">scanner.start</code> to point to the current character so we remember where the
lexeme we’re about to scan starts.</p>
<p>Then we check to see if we’ve reached the end of the source code. If so, we
return an EOF token and stop. This is a sentinel value that signals to the
compiler to stop asking for more tokens.</p>
<p>If we aren’t at the end, we do some<span class="ellipse"> . . . </span>stuff<span class="ellipse"> . . . </span>to scan the next token. But we
haven’t written that code yet. We’ll get to that soon. If that code doesn’t
successfully scan and return a token, then we reach the end of the function.
That must mean we’re at a character that the scanner can’t recognize, so we
return an error token for that.</p>
<p>This function relies on a couple of helpers, most of which are familiar from
jlox. First up:</p>
<div class="codehilite"><div class="source-file"><em>scanner.c</em><br/>
add after <em>initScanner</em>()</div>
<pre translate="no"><span class="k">static</span> <span class="t">bool</span> <span class="i">isAtEnd</span>() {
  <span class="k">return</span> *<span class="i">scanner</span>.<span class="i">current</span> == <span class="s">'\0'</span>;
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>initScanner</em>()</div>
<p>We require the source string to be a good null-terminated C string. If the
current character is the null byte, then we’ve reached the end.</p>
<p>To create a token, we have this constructor-like function:</p>
<div class="codehilite"><div class="source-file"><em>scanner.c</em><br/>
add after <em>isAtEnd</em>()</div>
<pre translate="no"><span class="k">static</span> <span class="t">Token</span> <span class="i">makeToken</span>(<span class="t">TokenType</span> <span class="i">type</span>) {
  <span class="t">Token</span> <span class="i">token</span>;
  <span class="i">token</span>.<span class="i">type</span> = <span class="i">type</span>;
  <span class="i">token</span>.<span class="i">start</span> = <span class="i">scanner</span>.<span class="i">start</span>;
  <span class="i">token</span>.<span class="i">length</span> = (<span class="t">int</span>)(<span class="i">scanner</span>.<span class="i">current</span> - <span class="i">scanner</span>.<span class="i">start</span>);
  <span class="i">token</span>.<span class="i">line</span> = <span class="i">scanner</span>.<span class="i">line</span>;
  <span class="k">return</span> <span class="i">token</span>;
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>isAtEnd</em>()</div>
<p>It uses the scanner’s <code translate="no">start</code> and <code translate="no">current</code> pointers to capture the token’s
lexeme. It sets a couple of other obvious fields then returns the token. It has
a sister function for returning error tokens.</p>
<div class="codehilite"><div class="source-file"><em>scanner.c</em><br/>
add after <em>makeToken</em>()</div>
<pre translate="no"><span class="k">static</span> <span class="t">Token</span> <span class="i">errorToken</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">message</span>) {
  <span class="t">Token</span> <span class="i">token</span>;
  <span class="i">token</span>.<span class="i">type</span> = <span class="a">TOKEN_ERROR</span>;
  <span class="i">token</span>.<span class="i">start</span> = <span class="i">message</span>;
  <span class="i">token</span>.<span class="i">length</span> = (<span class="t">int</span>)<span class="i">strlen</span>(<span class="i">message</span>);
  <span class="i">token</span>.<span class="i">line</span> = <span class="i">scanner</span>.<span class="i">line</span>;
  <span class="k">return</span> <span class="i">token</span>;
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>makeToken</em>()</div>
<p><span name="axolotl"></span></p>
<aside name="axolotl">
<p>This part of the chapter is pretty dry, so here’s a picture of an axolotl.</p><img alt="A drawing of an axolotl." src="image/scanning-on-demand/axolotl.png">
</img></aside>
<p>The only difference is that the “lexeme” points to the error message string
instead of pointing into the user’s source code. Again, we need to ensure that
the error message sticks around long enough for the compiler to read it. In
practice, we only ever call this function with C string literals. Those are
constant and eternal, so we’re fine.</p>
<p>What we have now is basically a working scanner for a language with an empty
lexical grammar. Since the grammar has no productions, every character is an
error. That’s not exactly a fun language to program in, so let’s fill in the
rules.</p>
<h2><a href="#a-lexical-grammar-for-lox" id="a-lexical-grammar-for-lox"><small>16 . 3</small>A Lexical Grammar for Lox</a></h2>
<p>The simplest tokens are only a single character. We recognize those like so:</p>
<div class="codehilite"><pre class="insert-before" translate="no">  if (isAtEnd()) return makeToken(TOKEN_EOF);
</pre><div class="source-file"><em>scanner.c</em><br/>
in <em>scanToken</em>()</div>
<pre class="insert" translate="no">

  <span class="t">char</span> <span class="i">c</span> = <span class="i">advance</span>();

  <span class="k">switch</span> (<span class="i">c</span>) {
    <span class="k">case</span> <span class="s">'('</span>: <span class="k">return</span> <span class="i">makeToken</span>(<span class="a">TOKEN_LEFT_PAREN</span>);
    <span class="k">case</span> <span class="s">')'</span>: <span class="k">return</span> <span class="i">makeToken</span>(<span class="a">TOKEN_RIGHT_PAREN</span>);
    <span class="k">case</span> <span class="s">'{'</span>: <span class="k">return</span> <span class="i">makeToken</span>(<span class="a">TOKEN_LEFT_BRACE</span>);
    <span class="k">case</span> <span class="s">'}'</span>: <span class="k">return</span> <span class="i">makeToken</span>(<span class="a">TOKEN_RIGHT_BRACE</span>);
    <span class="k">case</span> <span class="s">';'</span>: <span class="k">return</span> <span class="i">makeToken</span>(<span class="a">TOKEN_SEMICOLON</span>);
    <span class="k">case</span> <span class="s">','</span>: <span class="k">return</span> <span class="i">makeToken</span>(<span class="a">TOKEN_COMMA</span>);
    <span class="k">case</span> <span class="s">'.'</span>: <span class="k">return</span> <span class="i">makeToken</span>(<span class="a">TOKEN_DOT</span>);
    <span class="k">case</span> <span class="s">'-'</span>: <span class="k">return</span> <span class="i">makeToken</span>(<span class="a">TOKEN_MINUS</span>);
    <span class="k">case</span> <span class="s">'+'</span>: <span class="k">return</span> <span class="i">makeToken</span>(<span class="a">TOKEN_PLUS</span>);
    <span class="k">case</span> <span class="s">'/'</span>: <span class="k">return</span> <span class="i">makeToken</span>(<span class="a">TOKEN_SLASH</span>);
    <span class="k">case</span> <span class="s">'*'</span>: <span class="k">return</span> <span class="i">makeToken</span>(<span class="a">TOKEN_STAR</span>);
  }
</pre><pre class="insert-after" translate="no">

  return errorToken("Unexpected character.");
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, in <em>scanToken</em>()</div>
<p>We read the next character from the source code, and then do a straightforward
switch to see if it matches any of Lox’s one-character lexemes. To read the next
character, we use a new helper which consumes the current character and returns
it.</p>
<div class="codehilite"><div class="source-file"><em>scanner.c</em><br/>
add after <em>isAtEnd</em>()</div>
<pre translate="no"><span class="k">static</span> <span class="t">char</span> <span class="i">advance</span>() {
  <span class="i">scanner</span>.<span class="i">current</span>++;
  <span class="k">return</span> <span class="i">scanner</span>.<span class="i">current</span>[-<span class="n">1</span>];
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>isAtEnd</em>()</div>
<p>Next up are the two-character punctuation tokens like <code translate="no">!=</code> and <code translate="no">&gt;=</code>. Each of
these also has a corresponding single-character token. That means that when we
see a character like <code translate="no">!</code>, we don’t know if we’re in a <code translate="no">!</code> token or a <code translate="no">!=</code> until
we look at the next character too. We handle those like so:</p>
<div class="codehilite"><pre class="insert-before" translate="no">    case '*': return makeToken(TOKEN_STAR);
</pre><div class="source-file"><em>scanner.c</em><br/>
in <em>scanToken</em>()</div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="s">'!'</span>:
      <span class="k">return</span> <span class="i">makeToken</span>(
          <span class="i">match</span>(<span class="s">'='</span>) ? <span class="a">TOKEN_BANG_EQUAL</span> : <span class="a">TOKEN_BANG</span>);
    <span class="k">case</span> <span class="s">'='</span>:
      <span class="k">return</span> <span class="i">makeToken</span>(
          <span class="i">match</span>(<span class="s">'='</span>) ? <span class="a">TOKEN_EQUAL_EQUAL</span> : <span class="a">TOKEN_EQUAL</span>);
    <span class="k">case</span> <span class="s">'&lt;'</span>:
      <span class="k">return</span> <span class="i">makeToken</span>(
          <span class="i">match</span>(<span class="s">'='</span>) ? <span class="a">TOKEN_LESS_EQUAL</span> : <span class="a">TOKEN_LESS</span>);
    <span class="k">case</span> <span class="s">'&gt;'</span>:
      <span class="k">return</span> <span class="i">makeToken</span>(
          <span class="i">match</span>(<span class="s">'='</span>) ? <span class="a">TOKEN_GREATER_EQUAL</span> : <span class="a">TOKEN_GREATER</span>);
</pre><pre class="insert-after" translate="no">  }
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, in <em>scanToken</em>()</div>
<p>After consuming the first character, we look for an <code translate="no">=</code>. If found, we consume it
and return the corresponding two-character token. Otherwise, we leave the
current character alone (so it can be part of the <em>next</em> token) and return the
appropriate one-character token.</p>
<p>That logic for conditionally consuming the second character lives here:</p>
<div class="codehilite"><div class="source-file"><em>scanner.c</em><br/>
add after <em>advance</em>()</div>
<pre translate="no"><span class="k">static</span> <span class="t">bool</span> <span class="i">match</span>(<span class="t">char</span> <span class="i">expected</span>) {
  <span class="k">if</span> (<span class="i">isAtEnd</span>()) <span class="k">return</span> <span class="k">false</span>;
  <span class="k">if</span> (*<span class="i">scanner</span>.<span class="i">current</span> != <span class="i">expected</span>) <span class="k">return</span> <span class="k">false</span>;
  <span class="i">scanner</span>.<span class="i">current</span>++;
  <span class="k">return</span> <span class="k">true</span>;
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>advance</em>()</div>
<p>If the current character is the desired one, we advance and return <code translate="no">true</code>.
Otherwise, we return <code translate="no">false</code> to indicate it wasn’t matched.</p>
<p>Now our scanner supports all of the punctuation-like tokens. Before we get to
the longer ones, let’s take a little side trip to handle characters that aren’t
part of a token at all.</p>
<h3><a href="#whitespace" id="whitespace"><small>16 . 3 . 1</small>Whitespace</a></h3>
<p>Our scanner needs to handle spaces, tabs, and newlines, but those characters
don’t become part of any token’s lexeme. We could check for those inside the
main character switch in <code translate="no">scanToken()</code> but it gets a little tricky to ensure
that the function still correctly finds the next token <em>after</em> the whitespace
when you call it. We’d have to wrap the whole body of the function in a loop or
something.</p>
<p>Instead, before starting the token, we shunt off to a separate function.</p>
<div class="codehilite"><pre class="insert-before" translate="no">Token scanToken() {
</pre><div class="source-file"><em>scanner.c</em><br/>
in <em>scanToken</em>()</div>
<pre class="insert" translate="no">  <span class="i">skipWhitespace</span>();
</pre><pre class="insert-after" translate="no">  scanner.start = scanner.current;
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, in <em>scanToken</em>()</div>
<p>This advances the scanner past any leading whitespace. After this call returns,
we know the very next character is a meaningful one (or we’re at the end of the
source code).</p>
<div class="codehilite"><div class="source-file"><em>scanner.c</em><br/>
add after <em>errorToken</em>()</div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">skipWhitespace</span>() {
  <span class="k">for</span> (;;) {
    <span class="t">char</span> <span class="i">c</span> = <span class="i">peek</span>();
    <span class="k">switch</span> (<span class="i">c</span>) {
      <span class="k">case</span> <span class="s">' '</span>:
      <span class="k">case</span> <span class="s">'\r'</span>:
      <span class="k">case</span> <span class="s">'\t'</span>:
        <span class="i">advance</span>();
        <span class="k">break</span>;
      <span class="k">default</span>:
        <span class="k">return</span>;
    }
  }
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>errorToken</em>()</div>
<p>It’s sort of a separate mini-scanner. It loops, consuming every whitespace
character it encounters. We need to be careful that it does <em>not</em> consume any
<em>non</em>-whitespace characters. To support that, we use this:</p>
<div class="codehilite"><div class="source-file"><em>scanner.c</em><br/>
add after <em>advance</em>()</div>
<pre translate="no"><span class="k">static</span> <span class="t">char</span> <span class="i">peek</span>() {
  <span class="k">return</span> *<span class="i">scanner</span>.<span class="i">current</span>;
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>advance</em>()</div>
<p>This simply returns the current character, but doesn’t consume it. The previous
code handles all the whitespace characters except for newlines.</p>
<div class="codehilite"><pre class="insert-before" translate="no">        break;
</pre><div class="source-file"><em>scanner.c</em><br/>
in <em>skipWhitespace</em>()</div>
<pre class="insert" translate="no">      <span class="k">case</span> <span class="s">'\n'</span>:
        <span class="i">scanner</span>.<span class="i">line</span>++;
        <span class="i">advance</span>();
        <span class="k">break</span>;
</pre><pre class="insert-after" translate="no">      default:
        return;
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, in <em>skipWhitespace</em>()</div>
<p>When we consume one of those, we also bump the current line number.</p>
<h3><a href="#comments" id="comments"><small>16 . 3 . 2</small>Comments</a></h3>
<p>Comments aren’t technically “whitespace”, if you want to get all precise with
your terminology, but as far as Lox is concerned, they may as well be, so we
skip those too.</p>
<div class="codehilite"><pre class="insert-before" translate="no">        break;
</pre><div class="source-file"><em>scanner.c</em><br/>
in <em>skipWhitespace</em>()</div>
<pre class="insert" translate="no">      <span class="k">case</span> <span class="s">'/'</span>:
        <span class="k">if</span> (<span class="i">peekNext</span>() == <span class="s">'/'</span>) {
          <span class="c">// A comment goes until the end of the line.</span>
          <span class="k">while</span> (<span class="i">peek</span>() != <span class="s">'\n'</span> &amp;&amp; !<span class="i">isAtEnd</span>()) <span class="i">advance</span>();
        } <span class="k">else</span> {
          <span class="k">return</span>;
        }
        <span class="k">break</span>;
</pre><pre class="insert-after" translate="no">      default:
        return;
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, in <em>skipWhitespace</em>()</div>
<p>Comments start with <code translate="no">//</code> in Lox, so as with <code translate="no">!=</code> and friends, we need a second
character of lookahead. However, with <code translate="no">!=</code>, we still wanted to consume the <code translate="no">!</code>
even if the <code translate="no">=</code> wasn’t found. Comments are different. If we don’t find a second
<code translate="no">/</code>, then <code translate="no">skipWhitespace()</code> needs to not consume the <em>first</em> slash either.</p>
<p>To handle that, we add:</p>
<div class="codehilite"><div class="source-file"><em>scanner.c</em><br/>
add after <em>peek</em>()</div>
<pre translate="no"><span class="k">static</span> <span class="t">char</span> <span class="i">peekNext</span>() {
  <span class="k">if</span> (<span class="i">isAtEnd</span>()) <span class="k">return</span> <span class="s">'\0'</span>;
  <span class="k">return</span> <span class="i">scanner</span>.<span class="i">current</span>[<span class="n">1</span>];
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>peek</em>()</div>
<p>This is like <code translate="no">peek()</code> but for one character past the current one. If the current
character and the next one are both <code translate="no">/</code>, we consume them and then any other
characters until the next newline or the end of the source code.</p>
<p>We use <code translate="no">peek()</code> to check for the newline but not consume it. That way, the
newline will be the current character on the next turn of the outer loop in
<code translate="no">skipWhitespace()</code> and we’ll recognize it and increment <code translate="no">scanner.line</code>.</p>
<h3><a href="#literal-tokens" id="literal-tokens"><small>16 . 3 . 3</small>Literal tokens</a></h3>
<p>Number and string tokens are special because they have a runtime value
associated with them. We’ll start with strings because they are easy to
recognize<span class="em">—</span>they always begin with a double quote.</p>
<div class="codehilite"><pre class="insert-before" translate="no">          match('=') ? TOKEN_GREATER_EQUAL : TOKEN_GREATER);
</pre><div class="source-file"><em>scanner.c</em><br/>
in <em>scanToken</em>()</div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="s">'"'</span>: <span class="k">return</span> <span class="i">string</span>();
</pre><pre class="insert-after" translate="no">  }
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, in <em>scanToken</em>()</div>
<p>That calls a new function.</p>
<div class="codehilite"><div class="source-file"><em>scanner.c</em><br/>
add after <em>skipWhitespace</em>()</div>
<pre translate="no"><span class="k">static</span> <span class="t">Token</span> <span class="i">string</span>() {
  <span class="k">while</span> (<span class="i">peek</span>() != <span class="s">'"'</span> &amp;&amp; !<span class="i">isAtEnd</span>()) {
    <span class="k">if</span> (<span class="i">peek</span>() == <span class="s">'\n'</span>) <span class="i">scanner</span>.<span class="i">line</span>++;
    <span class="i">advance</span>();
  }

  <span class="k">if</span> (<span class="i">isAtEnd</span>()) <span class="k">return</span> <span class="i">errorToken</span>(<span class="s">"Unterminated string."</span>);

  <span class="c">// The closing quote.</span>
  <span class="i">advance</span>();
  <span class="k">return</span> <span class="i">makeToken</span>(<span class="a">TOKEN_STRING</span>);
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>skipWhitespace</em>()</div>
<p>Similar to jlox, we consume characters until we reach the closing quote. We also
track newlines inside the string literal. (Lox supports multi-line strings.)
And, as ever, we gracefully handle running out of source code before we find the
end quote.</p>
<p>The main change here in clox is something that’s <em>not</em> present. Again, it
relates to memory management. In jlox, the Token class had a field of type
Object to store the runtime value converted from the literal token’s lexeme.</p>
<p>Implementing that in C would require a lot of work. We’d need some sort of union
and type tag to tell whether the token contains a string or double value. If
it’s a string, we’d need to manage the memory for the string’s character array
somehow.</p>
<p>Instead of adding that complexity to the scanner, we defer <span name="convert">converting</span> the literal lexeme to a runtime value until
later. In clox, tokens only store the lexeme<span class="em">—</span>the character sequence exactly
as it appears in the user’s source code. Later in the compiler, we’ll convert
that lexeme to a runtime value right when we are ready to store it in the
chunk’s constant table.</p>
<aside name="convert">
<p>Doing the lexeme-to-value conversion in the compiler does introduce some
redundancy. The work to scan a number literal is awfully similar to the work
required to convert a sequence of digit characters to a number value. But there
isn’t <em>that</em> much redundancy, it isn’t in anything performance critical, and it
keeps our scanner simpler.</p>
</aside>
<p>Next up, numbers. Instead of adding a switch case for each of the ten digits
that can start a number, we handle them here:</p>
<div class="codehilite"><pre class="insert-before" translate="no">  char c = advance();
</pre><div class="source-file"><em>scanner.c</em><br/>
in <em>scanToken</em>()</div>
<pre class="insert" translate="no">  <span class="k">if</span> (<span class="i">isDigit</span>(<span class="i">c</span>)) <span class="k">return</span> <span class="i">number</span>();
</pre><pre class="insert-after" translate="no">

  switch (c) {
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, in <em>scanToken</em>()</div>
<p>That uses this obvious utility function:</p>
<div class="codehilite"><div class="source-file"><em>scanner.c</em><br/>
add after <em>initScanner</em>()</div>
<pre translate="no"><span class="k">static</span> <span class="t">bool</span> <span class="i">isDigit</span>(<span class="t">char</span> <span class="i">c</span>) {
  <span class="k">return</span> <span class="i">c</span> &gt;= <span class="s">'0'</span> &amp;&amp; <span class="i">c</span> &lt;= <span class="s">'9'</span>;
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>initScanner</em>()</div>
<p>We finish scanning the number using this:</p>
<div class="codehilite"><div class="source-file"><em>scanner.c</em><br/>
add after <em>skipWhitespace</em>()</div>
<pre translate="no"><span class="k">static</span> <span class="t">Token</span> <span class="i">number</span>() {
  <span class="k">while</span> (<span class="i">isDigit</span>(<span class="i">peek</span>())) <span class="i">advance</span>();

  <span class="c">// Look for a fractional part.</span>
  <span class="k">if</span> (<span class="i">peek</span>() == <span class="s">'.'</span> &amp;&amp; <span class="i">isDigit</span>(<span class="i">peekNext</span>())) {
    <span class="c">// Consume the ".".</span>
    <span class="i">advance</span>();

    <span class="k">while</span> (<span class="i">isDigit</span>(<span class="i">peek</span>())) <span class="i">advance</span>();
  }

  <span class="k">return</span> <span class="i">makeToken</span>(<span class="a">TOKEN_NUMBER</span>);
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>skipWhitespace</em>()</div>
<p>It’s virtually identical to jlox’s version except, again, we don’t convert the
lexeme to a double yet.</p>
<h2><a href="#identifiers-and-keywords" id="identifiers-and-keywords"><small>16 . 4</small>Identifiers and Keywords</a></h2>
<p>The last batch of tokens are identifiers, both user-defined and reserved. This
section should be fun<span class="em">—</span>the way we recognize keywords in clox is quite
different from how we did it in jlox, and touches on some important data
structures.</p>
<p>First, though, we have to scan the lexeme. Names start with a letter or
underscore.</p>
<div class="codehilite"><pre class="insert-before" translate="no">  char c = advance();
</pre><div class="source-file"><em>scanner.c</em><br/>
in <em>scanToken</em>()</div>
<pre class="insert" translate="no">  <span class="k">if</span> (<span class="i">isAlpha</span>(<span class="i">c</span>)) <span class="k">return</span> <span class="i">identifier</span>();
</pre><pre class="insert-after" translate="no">  if (isDigit(c)) return number();
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, in <em>scanToken</em>()</div>
<p>We recognize those using this:</p>
<div class="codehilite"><div class="source-file"><em>scanner.c</em><br/>
add after <em>initScanner</em>()</div>
<pre translate="no"><span class="k">static</span> <span class="t">bool</span> <span class="i">isAlpha</span>(<span class="t">char</span> <span class="i">c</span>) {
  <span class="k">return</span> (<span class="i">c</span> &gt;= <span class="s">'a'</span> &amp;&amp; <span class="i">c</span> &lt;= <span class="s">'z'</span>) ||
         (<span class="i">c</span> &gt;= <span class="s">'A'</span> &amp;&amp; <span class="i">c</span> &lt;= <span class="s">'Z'</span>) ||
          <span class="i">c</span> == <span class="s">'_'</span>;
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>initScanner</em>()</div>
<p>Once we’ve found an identifier, we scan the rest of it here:</p>
<div class="codehilite"><div class="source-file"><em>scanner.c</em><br/>
add after <em>skipWhitespace</em>()</div>
<pre translate="no"><span class="k">static</span> <span class="t">Token</span> <span class="i">identifier</span>() {
  <span class="k">while</span> (<span class="i">isAlpha</span>(<span class="i">peek</span>()) || <span class="i">isDigit</span>(<span class="i">peek</span>())) <span class="i">advance</span>();
  <span class="k">return</span> <span class="i">makeToken</span>(<span class="i">identifierType</span>());
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>skipWhitespace</em>()</div>
<p>After the first letter, we allow digits too, and we keep consuming alphanumerics
until we run out of them. Then we produce a token with the proper type.
Determining that “proper” type is the unique part of this chapter.</p>
<div class="codehilite"><div class="source-file"><em>scanner.c</em><br/>
add after <em>skipWhitespace</em>()</div>
<pre translate="no"><span class="k">static</span> <span class="t">TokenType</span> <span class="i">identifierType</span>() {
  <span class="k">return</span> <span class="a">TOKEN_IDENTIFIER</span>;
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>skipWhitespace</em>()</div>
<p>Okay, I guess that’s not very exciting yet. That’s what it looks like if we
have no reserved words at all. How should we go about recognizing keywords? In
jlox, we stuffed them all in a Java Map and looked them up by name. We don’t
have any sort of hash table structure in clox, at least not yet.</p>
<p>A hash table would be overkill anyway. To look up a string in a hash <span name="hash">table</span>, we need to walk the string to calculate its hash code,
find the corresponding bucket in the hash table, and then do a
character-by-character equality comparison on any string it happens to find
there.</p>
<aside name="hash">
<p>Don’t worry if this is unfamiliar to you. When we get to <a href="hash-tables.html">building our own hash
table from scratch</a>, we’ll learn all about it in exquisite detail.</p>
</aside>
<p>Let’s say we’ve scanned the identifier “gorgonzola”. How much work <em>should</em> we
need to do to tell if that’s a reserved word? Well, no Lox keyword starts with
“g”, so looking at the first character is enough to definitively answer no.
That’s a lot simpler than a hash table lookup.</p>
<p>What about “cardigan”? We do have a keyword in Lox that starts with “c”:
“class”. But the second character in “cardigan”, “a”, rules that out. What about
“forest”? Since “for” is a keyword, we have to go farther in the string before
we can establish that we don’t have a reserved word. But, in most cases, only a
character or two is enough to tell we’ve got a user-defined name on our hands.
We should be able to recognize that and fail fast.</p>
<p>Here’s a visual representation of that branching character-inspection logic:</p>
<p><span name="down"></span></p><img alt="A trie that contains all of Lox's keywords." src="image/scanning-on-demand/keywords.png"/>
<aside name="down">
<p>Read down each chain of nodes and you’ll see Lox’s keywords emerge.</p>
</aside>
<p>We start at the root node. If there is a child node whose letter matches the
first character in the lexeme, we move to that node. Then repeat for the next
letter in the lexeme and so on. If at any point the next letter in the lexeme
doesn’t match a child node, then the identifier must not be a keyword and we
stop. If we reach a double-lined box, and we’re at the last character of the
lexeme, then we found a keyword.</p>
<h3><a href="#tries-and-state-machines" id="tries-and-state-machines"><small>16 . 4 . 1</small>Tries and state machines</a></h3>
<p>This tree diagram is an example of a thing called a <span name="trie"><a href="https://en.wikipedia.org/wiki/Trie"><strong>trie</strong></a></span>. A trie stores a set of strings. Most other
data structures for storing strings contain the raw character arrays and then
wrap them inside some larger construct that helps you search faster. A trie is
different. Nowhere in the trie will you find a whole string.</p>
<aside name="trie">
<p>“Trie” is one of the most confusing names in CS. Edward Fredkin yanked it out of
the middle of the word “retrieval”, which means it should be pronounced like
“tree”. But, uh, there is already a pretty important data structure pronounced
“tree” <em>which tries are a special case of</em>, so unless you never speak of these
things out loud, no one can tell which one you’re talking about. Thus, people
these days often pronounce it like “try” to avoid the headache.</p>
</aside>
<p>Instead, each string the trie “contains” is represented as a <em>path</em> through the
tree of character nodes, as in our traversal above. Nodes that match the last
character in a string have a special marker<span class="em">—</span>the double lined boxes in the
illustration. That way, if your trie contains, say, “banquet” and “ban”, you are
able to tell that it does <em>not</em> contain “banque”<span class="em">—</span>the “e” node won’t have that
marker, while the “n” and “t” nodes will.</p>
<p>Tries are a special case of an even more fundamental data structure: a
<a href="https://en.wikipedia.org/wiki/Deterministic_finite_automaton"><strong>deterministic finite automaton</strong></a> (<strong>DFA</strong>). You might also know these
by other names: <strong>finite state machine</strong>, or just <strong>state machine</strong>. State
machines are rad. They end up useful in everything from <a href="http://gameprogrammingpatterns.com/state.html">game
programming</a> to implementing networking protocols.</p>
<p>In a DFA, you have a set of <em>states</em> with <em>transitions</em> between them, forming a
graph. At any point in time, the machine is “in” exactly one state. It gets to
other states by following transitions. When you use a DFA for lexical analysis,
each transition is a character that gets matched from the string. Each state
represents a set of allowed characters.</p>
<p>Our keyword tree is exactly a DFA that recognizes Lox keywords. But DFAs are
more powerful than simple trees because they can be arbitrary <em>graphs</em>.
Transitions can form cycles between states. That lets you recognize arbitrarily
long strings. For example, here’s a DFA that recognizes number literals:</p>
<p><span name="railroad"></span></p><img alt="A syntax diagram that recognizes integer and floating point literals." src="image/scanning-on-demand/numbers.png"/>
<aside name="railroad">
<p>This style of diagram is called a <a href="https://en.wikipedia.org/wiki/Syntax_diagram"><strong>syntax diagram</strong></a> or the
more charming <strong>railroad diagram</strong>. The latter name is because it looks
something like a switching yard for trains.</p>
<p>Back before Backus-Naur Form was a thing, this was one of the predominant ways
of documenting a language’s grammar. These days, we mostly use text, but there’s
something delightful about the official specification for a <em>textual language</em>
relying on an <em>image</em>.</p>
</aside>
<p>I’ve collapsed the nodes for the ten digits together to keep it more readable,
but the basic process works the same<span class="em">—</span>you work through the path, entering
nodes whenever you consume a corresponding character in the lexeme. If we were
so inclined, we could construct one big giant DFA that does <em>all</em> of the lexical
analysis for Lox, a single state machine that recognizes and spits out all of
the tokens we need.</p>
<p>However, crafting that mega-DFA by <span name="regex">hand</span> would be
challenging. That’s why <a href="https://en.wikipedia.org/wiki/Lex_(software)">Lex</a> was created. You give it a simple textual
description of your lexical grammar<span class="em">—</span>a bunch of regular expressions<span class="em">—</span>and it
automatically generates a DFA for you and produces a pile of C code that
implements it.</p>
<aside name="regex">
<p>This is also how most regular expression engines in programming languages and
text editors work under the hood. They take your regex string and convert it to
a DFA, which they then use to match strings.</p>
<p>If you want to learn the algorithm to convert a regular expression into a DFA,
<a href="https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools">the dragon book</a> has you covered.</p>
</aside>
<p>We won’t go down that road. We already have a perfectly serviceable hand-rolled
scanner. We just need a tiny trie for recognizing keywords. How should we map
that to code?</p>
<p>The absolute simplest <span name="v8">solution</span> is to use a switch
statement for each node with cases for each branch. We’ll start with the root
node and handle the easy keywords.</p>
<aside name="v8">
<p>Simple doesn’t mean dumb. The same approach is <a href="https://github.com/v8/v8/blob/e77eebfe3b747fb315bd3baad09bec0953e53e68/src/parsing/scanner.cc#L1643">essentially what V8 does</a>,
and that’s currently one of the world’s most sophisticated, fastest language
implementations.</p>
</aside>
<div class="codehilite"><pre class="insert-before" translate="no">static TokenType identifierType() {
</pre><div class="source-file"><em>scanner.c</em><br/>
in <em>identifierType</em>()</div>
<pre class="insert" translate="no">  <span class="k">switch</span> (<span class="i">scanner</span>.<span class="i">start</span>[<span class="n">0</span>]) {
    <span class="k">case</span> <span class="s">'a'</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">1</span>, <span class="n">2</span>, <span class="s">"nd"</span>, <span class="a">TOKEN_AND</span>);
    <span class="k">case</span> <span class="s">'c'</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">1</span>, <span class="n">4</span>, <span class="s">"lass"</span>, <span class="a">TOKEN_CLASS</span>);
    <span class="k">case</span> <span class="s">'e'</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">1</span>, <span class="n">3</span>, <span class="s">"lse"</span>, <span class="a">TOKEN_ELSE</span>);
    <span class="k">case</span> <span class="s">'i'</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">1</span>, <span class="n">1</span>, <span class="s">"f"</span>, <span class="a">TOKEN_IF</span>);
    <span class="k">case</span> <span class="s">'n'</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">1</span>, <span class="n">2</span>, <span class="s">"il"</span>, <span class="a">TOKEN_NIL</span>);
    <span class="k">case</span> <span class="s">'o'</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">1</span>, <span class="n">1</span>, <span class="s">"r"</span>, <span class="a">TOKEN_OR</span>);
    <span class="k">case</span> <span class="s">'p'</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">1</span>, <span class="n">4</span>, <span class="s">"rint"</span>, <span class="a">TOKEN_PRINT</span>);
    <span class="k">case</span> <span class="s">'r'</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">1</span>, <span class="n">5</span>, <span class="s">"eturn"</span>, <span class="a">TOKEN_RETURN</span>);
    <span class="k">case</span> <span class="s">'s'</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">1</span>, <span class="n">4</span>, <span class="s">"uper"</span>, <span class="a">TOKEN_SUPER</span>);
    <span class="k">case</span> <span class="s">'v'</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">1</span>, <span class="n">2</span>, <span class="s">"ar"</span>, <span class="a">TOKEN_VAR</span>);
    <span class="k">case</span> <span class="s">'w'</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">1</span>, <span class="n">4</span>, <span class="s">"hile"</span>, <span class="a">TOKEN_WHILE</span>);
  }

</pre><pre class="insert-after" translate="no">  return TOKEN_IDENTIFIER;
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, in <em>identifierType</em>()</div>
<p>These are the initial letters that correspond to a single keyword. If we see an
“s”, the only keyword the identifier could possibly be is <code translate="no">super</code>. It might not
be, though, so we still need to check the rest of the letters too. In the tree
diagram, this is basically that straight path hanging off the “s”.</p>
<p>We won’t roll a switch for each of those nodes. Instead, we have a utility
function that tests the rest of a potential keyword’s lexeme.</p>
<div class="codehilite"><div class="source-file"><em>scanner.c</em><br/>
add after <em>skipWhitespace</em>()</div>
<pre translate="no"><span class="k">static</span> <span class="t">TokenType</span> <span class="i">checkKeyword</span>(<span class="t">int</span> <span class="i">start</span>, <span class="t">int</span> <span class="i">length</span>,
    <span class="k">const</span> <span class="t">char</span>* <span class="i">rest</span>, <span class="t">TokenType</span> <span class="i">type</span>) {
  <span class="k">if</span> (<span class="i">scanner</span>.<span class="i">current</span> - <span class="i">scanner</span>.<span class="i">start</span> == <span class="i">start</span> + <span class="i">length</span> &amp;&amp;
      <span class="i">memcmp</span>(<span class="i">scanner</span>.<span class="i">start</span> + <span class="i">start</span>, <span class="i">rest</span>, <span class="i">length</span>) == <span class="n">0</span>) {
    <span class="k">return</span> <span class="i">type</span>;
  }

  <span class="k">return</span> <span class="a">TOKEN_IDENTIFIER</span>;
}
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, add after <em>skipWhitespace</em>()</div>
<p>We use this for all of the unbranching paths in the tree. Once we’ve found a
prefix that could only be one possible reserved word, we need to verify two
things. The lexeme must be exactly as long as the keyword. If the first letter
is “s”, the lexeme could still be “sup” or “superb”. And the remaining
characters must match exactly<span class="em">—</span>“supar” isn’t good enough.</p>
<p>If we do have the right number of characters, and they’re the ones we want, then
it’s a keyword, and we return the associated token type. Otherwise, it must be a
normal identifier.</p>
<p>We have a couple of keywords where the tree branches again after the first
letter. If the lexeme starts with “f”, it could be <code translate="no">false</code>, <code translate="no">for</code>, or <code translate="no">fun</code>. So
we add another switch for the branches coming off the “f” node.</p>
<div class="codehilite"><pre class="insert-before" translate="no">    case 'e': return checkKeyword(1, 3, "lse", TOKEN_ELSE);
</pre><div class="source-file"><em>scanner.c</em><br/>
in <em>identifierType</em>()</div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="s">'f'</span>:
      <span class="k">if</span> (<span class="i">scanner</span>.<span class="i">current</span> - <span class="i">scanner</span>.<span class="i">start</span> &gt; <span class="n">1</span>) {
        <span class="k">switch</span> (<span class="i">scanner</span>.<span class="i">start</span>[<span class="n">1</span>]) {
          <span class="k">case</span> <span class="s">'a'</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">2</span>, <span class="n">3</span>, <span class="s">"lse"</span>, <span class="a">TOKEN_FALSE</span>);
          <span class="k">case</span> <span class="s">'o'</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">2</span>, <span class="n">1</span>, <span class="s">"r"</span>, <span class="a">TOKEN_FOR</span>);
          <span class="k">case</span> <span class="s">'u'</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">2</span>, <span class="n">1</span>, <span class="s">"n"</span>, <span class="a">TOKEN_FUN</span>);
        }
      }
      <span class="k">break</span>;
</pre><pre class="insert-after" translate="no">    case 'i': return checkKeyword(1, 1, "f", TOKEN_IF);
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, in <em>identifierType</em>()</div>
<p>Before we switch, we need to check that there even <em>is</em> a second letter. “f” by
itself is a valid identifier too, after all. The other letter that branches is
“t”.</p>
<div class="codehilite"><pre class="insert-before" translate="no">    case 's': return checkKeyword(1, 4, "uper", TOKEN_SUPER);
</pre><div class="source-file"><em>scanner.c</em><br/>
in <em>identifierType</em>()</div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="s">'t'</span>:
      <span class="k">if</span> (<span class="i">scanner</span>.<span class="i">current</span> - <span class="i">scanner</span>.<span class="i">start</span> &gt; <span class="n">1</span>) {
        <span class="k">switch</span> (<span class="i">scanner</span>.<span class="i">start</span>[<span class="n">1</span>]) {
          <span class="k">case</span> <span class="s">'h'</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">2</span>, <span class="n">2</span>, <span class="s">"is"</span>, <span class="a">TOKEN_THIS</span>);
          <span class="k">case</span> <span class="s">'r'</span>: <span class="k">return</span> <span class="i">checkKeyword</span>(<span class="n">2</span>, <span class="n">2</span>, <span class="s">"ue"</span>, <span class="a">TOKEN_TRUE</span>);
        }
      }
      <span class="k">break</span>;
</pre><pre class="insert-after" translate="no">    case 'v': return checkKeyword(1, 2, "ar", TOKEN_VAR);
</pre></div>
<div class="source-file-narrow"><em>scanner.c</em>, in <em>identifierType</em>()</div>
<p>That’s it. A couple of nested <code translate="no">switch</code> statements. Not only is this code <span name="short">short</span>, but it’s very, very fast. It does the minimum amount
of work required to detect a keyword, and bails out as soon as it can tell the
identifier will not be a reserved one.</p>
<p>And with that, our scanner is complete.</p>
<aside name="short">
<p>We sometimes fall into the trap of thinking that performance comes from
complicated data structures, layers of caching, and other fancy optimizations.
But, many times, all that’s required is to do less work, and I often find that
writing the simplest code I can is sufficient to accomplish that.</p>
</aside>
<div class="challenges">
<h2><a href="#challenges" id="challenges">Challenges</a></h2>
<ol>
<li>
<p>Many newer languages support <a href="https://en.wikipedia.org/wiki/String_interpolation"><strong>string interpolation</strong></a>. Inside a
string literal, you have some sort of special delimiters<span class="em">—</span>most commonly
<code translate="no">${</code> at the beginning and <code translate="no">}</code> at the end. Between those delimiters, any
expression can appear. When the string literal is executed, the inner
expression is evaluated, converted to a string, and then merged with the
surrounding string literal.</p>
<p>For example, if Lox supported string interpolation, then this<span class="ellipse"> . . . </span></p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="i">drink</span> = <span class="s">"Tea"</span>;
<span class="k">var</span> <span class="i">steep</span> = <span class="n">4</span>;
<span class="k">var</span> <span class="i">cool</span> = <span class="n">2</span>;
<span class="k">print</span> <span class="s">"${drink} will be ready in ${steep + cool} minutes."</span>;
</pre></div>
<p><span class="ellipse"> . . . </span>would print:</p>
<div class="codehilite"><pre translate="no">Tea will be ready in 6 minutes.
</pre></div>
<p>What token types would you define to implement a scanner for string
interpolation? What sequence of tokens would you emit for the above string
literal?</p>
<p>What tokens would you emit for:</p>
<div class="codehilite"><pre translate="no">"Nested ${"interpolation?! Are you ${"mad?!"}"}"
</pre></div>
<p>Consider looking at other language implementations that support
interpolation to see how they handle it.</p>
</li>
<li>
<p>Several languages use angle brackets for generics and also have a <code translate="no">&gt;&gt;</code> right
shift operator. This led to a classic problem in early versions of C++:</p>
<div class="codehilite"><pre translate="no"><span class="t">vector</span>&lt;<span class="t">vector</span>&lt;<span class="t">string</span>&gt;&gt; <span class="i">nestedVectors</span>;
</pre></div>
<p>This would produce a compile error because the <code translate="no">&gt;&gt;</code> was lexed to a single
right shift token, not two <code translate="no">&gt;</code> tokens. Users were forced to avoid this by
putting a space between the closing angle brackets.</p>
<p>Later versions of C++ are smarter and can handle the above code. Java and C#
never had the problem. How do those languages specify and implement this?</p>
</li>
<li>
<p>Many languages, especially later in their evolution, define “contextual
keywords”. These are identifiers that act like reserved words in some
contexts but can be normal user-defined identifiers in others.</p>
<p>For example, <code translate="no">await</code> is a keyword inside an <code translate="no">async</code> method in C#, but
in other methods, you can use <code translate="no">await</code> as your own identifier.</p>
<p>Name a few contextual keywords from other languages, and the context where
they are meaningful. What are the pros and cons of having contextual
keywords? How would you implement them in your language’s front end if you
needed to?</p>
</li>
</ol>
</div>
<footer>
<a class="next" href="compiling-expressions.html">
  Next Chapter: “Compiling Expressions” →
</a>
Handcrafted by Robert Nystrom — <a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">© 2015 – 2021</a>
</footer>
</img></img></article>
</div>
</body>
</html>
