<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link rel="stylesheet" type="text/css" href="cid:css-87de7bb3-e57d-41d5-85cc-1c816ddcedab@mhtml.blink" />

<title>A Map of the Territory · Crafting Interpreters</title>
<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta content="width=device-width, initial-scale=1" name="viewport">
<link href="https://youhogeon-meritz.github.io/style.css" rel="stylesheet" type="text/css">
<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600" rel="stylesheet" type="text/css">
<link href="https://youhogeon-meritz.github.io/image/favicon.png" rel="icon" type="image/png">


<!-- Google analytics -->

</head>
<body id="top">
<!-- <div class="scrim"></div> -->
<nav class="wide">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<div class="contents">
<h3><a href="https://youhogeon-meritz.github.io/a-map-of-the-territory.html#top"><font papago-translate="splitted"><font papago-translate="translated">영토 지도</font></font><small>2</small></a></h3>
<ul>
<li><a href="https://youhogeon-meritz.github.io/a-map-of-the-territory.html#the-parts-of-a-language"><small>2.1</small><font papago-translate="splitted"><font papago-translate="translated"> 언어의 일부</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/a-map-of-the-territory.html#shortcuts-and-alternate-routes"><small>2.2</small><font papago-translate="splitted"><font papago-translate="translated"> 지름길 및 대체 경로</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/a-map-of-the-territory.html#compilers-and-interpreters"><small>2.3</small><font papago-translate="splitted"><font papago-translate="translated"> 컴파일러 및 인터프리터</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/a-map-of-the-territory.html#our-journey"><small>2.4</small><font papago-translate="splitted"><font papago-translate="translated"> 우리의 여정</font></font></a></li>
<li class="divider"></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/a-map-of-the-territory.html#challenges"><font papago-translate="translated">과제들</font></a></li>
</ul>
<div class="prev-next">
<a class="left" href="https://youhogeon-meritz.github.io/introduction.html" title="소개" papago-attr-id="1"><font papago-translate="translated">← 이전</font></a>
<a href="https://youhogeon-meritz.github.io/welcome.html" title="환영해" papago-attr-id="2"><font papago-translate="translated">↑ 위로</font></a>
<a class="right" href="https://youhogeon-meritz.github.io/the-lox-language.html" title="록스 언어" papago-attr-id="3"><font papago-translate="translated">다음 →</font></a>
</div> </div>
</nav>
<nav class="narrow">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<a class="prev" href="https://youhogeon-meritz.github.io/introduction.html" title="Introduction">←</a>
<a class="next" href="https://youhogeon-meritz.github.io/the-lox-language.html" title="The Lox Language">→</a>
</nav>
<div class="page">
<div class="nav-wrapper">
<nav class="floating pinned">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<div class="expandable">
<h3><a href="https://youhogeon-meritz.github.io/a-map-of-the-territory.html#top"><font papago-translate="splitted"><font papago-translate="translated">영토 지도</font></font><small>2</small></a></h3>
<ul>
<li><a href="https://youhogeon-meritz.github.io/a-map-of-the-territory.html#the-parts-of-a-language"><small>2.1</small><font papago-translate="splitted"><font papago-translate="translated"> 언어의 일부</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/a-map-of-the-territory.html#shortcuts-and-alternate-routes"><small>2.2</small><font papago-translate="splitted"><font papago-translate="translated"> 지름길 및 대체 경로</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/a-map-of-the-territory.html#compilers-and-interpreters"><small>2.3</small><font papago-translate="splitted"><font papago-translate="translated"> 컴파일러 및 인터프리터</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/a-map-of-the-territory.html#our-journey"><small>2.4</small><font papago-translate="splitted"><font papago-translate="translated"> 우리의 여정</font></font></a></li>
<li class="divider"></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/a-map-of-the-territory.html#challenges">Challenges</a></li>
</ul>
<div class="prev-next">
<a class="left" href="https://youhogeon-meritz.github.io/introduction.html" title="Introduction">←&nbsp;Previous</a>
<a href="https://youhogeon-meritz.github.io/welcome.html" title="Welcome">↑&nbsp;Up</a>
<a class="right" href="https://youhogeon-meritz.github.io/the-lox-language.html" title="The Lox Language">Next&nbsp;→</a>
</div> </div>
<a id="expand-nav">≡</a>
</nav>
</div>
<article class="chapter">
<div class="number">2</div>
<h1><font papago-translate="translated">영토 지도</font></h1>
<blockquote>
<p><font papago-translate="translated">아무리 거칠어도 지도가 있어야 합니다.</font><font papago-translate="translated"> 그렇지 않으면 여기저기 돌아다니게 됩니다.</font><font papago-translate="translated"> 반지<em>의 제왕</em>에서 나는 주어진 날에 그보다 더 멀리 갈 수 있는 사람을 한 번도 보내지 않았습니다.</font></p>
<p><cite>J. R. R. Tolkien</cite></p>
</blockquote>
<p><font papago-translate="translated">여기저기 돌아다니고 싶지 않으니 출발하기 전에 이전 언어 구현자들이 차트에 표시한 영역을 스캔해 보겠습니다.</font><font papago-translate="translated"> 우리가 어디로 가고 있는지와 다른 사람들이 선택한 대체 경로를 이해하는 데 도움이 될 것입니다.</font></p>
<p><font papago-translate="translated">먼저, 속기를 확립하겠습니다.</font><font papago-translate="translated"> 이 책의 대부분은 언어<em>의</em><em> 구현</em>에 관한 것으로, 일종의 플라톤 이상적인 형태로<em> 언어 자체</em>와는 구별됩니다.</font><font papago-translate="translated"> "스택", "바이트코드", "재귀 하강"과 같은 것들은 특정 구현에서 사용할 수 있는 너트와 볼트입니다.</font><font papago-translate="translated"> 사용자의 관점에서 보면, 결과적인 장치가 언어의 사양을 충실히 따르는 한, 그것은 모두 구현 세부 사항입니다.</font></p>
<p><font papago-translate="translated">우리는 그 세부 사항들에 많은 시간을 할애할 것이기 때문에, 매번 언급할 때마다 "언어<em> 구현"</em>을 써야 한다면, 저는 망설일 것입니다.</font><font papago-translate="translated"> 대신, 구분이 중요하지 않은 한 "언어"를 사용하여 언어 또는 그 구현체 또는 둘 다를 가리킬 것입니다.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/a-map-of-the-territory.html#the-parts-of-a-language" id="the-parts-of-a-language"><small><font papago-translate="translated">2 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">언어의 일부</font></font></a></h2>
<p><font papago-translate="translated">엔지니어들은 컴퓨팅의 암흑기부터 프로그래밍 언어를 구축해 왔습니다.</font><font papago-translate="translated"> 컴퓨터와 대화를 나누자마자 너무 어렵다는 것을 깨닫고 도움을 요청했습니다.</font><font papago-translate="translated"> 오늘날의 기계는 문자 그대로 백만 배 더 빠르고 저장 공간이 훨씬 더 많지만, 프로그래밍 언어를 구축하는 방식은 거의 변하지 않는다는 점이 흥미롭습니다.</font></p>
<p><font papago-translate="translated">언어 디자이너들이 탐험한 지역은 넓지만, 그들이 개척한 흔적<span name="dead">은 거의</span> 없습니다.</font><font papago-translate="translated"> 모든 언어가 정확히 같은 경로를 따르는 것은 아닙니다. 일부 언어는 지름길을 한두 번 선택하기도 하지만, 그렇지 않으면 그레이스 호퍼 제독의 첫 번째 COBOL 컴파일러부터 새로운 트랜파일-JavaScript 언어까지, "문서"는<span class="em"></span><span class="em"></span> Git 저장소 어딘가에 있는 제대로 편집되지 않은 단일 README로 구성된 뜨겁고 새로운 트랜파일-JavaScript 언어에 이르기까지 안심할 수 있을 정도로 유사합니다.</font></p>
<aside name="dead" style="top: 964px;">
<p><font papago-translate="translated">CS 논문에는 인용이 전혀 없는 막다른 골목, 슬픈 작은 cul-de-sacs가 있으며, 이제는 잊혀진 최적화는 메모리가 개별 바이트 단위로 측정될 때만 이해가 됩니다.</font></p>
</aside>
<p><font papago-translate="translated">저는 구현이 산을 오를 때 선택할 수 있는 경로 네트워크를 시각화합니다.</font><font papago-translate="translated"> 프로그램은 원래 원본 텍스트로 시작하며, 문자 그대로 문자열일 뿐입니다.</font><font papago-translate="translated"> 각 단계는 프로그램을 분석하고 이를 더 높은 수준의 표현으로 변환합니다. 여기서 저자가 컴퓨터가 무엇을 하기를 원하는지에 대한 의미가 더<span class="em"></span><span class="em"></span> 명확해집니다.</font></p>
<p><font papago-translate="translated">결국 우리는 정점에 도달합니다.</font><font papago-translate="translated"> 사용자의 프로그램을 한눈에 볼 수 있으며 코드<em>의 의미</em>를 확인할 수 있습니다.</font><font papago-translate="translated"> 우리는 산 너머로 내려가기 시작합니다.</font><font papago-translate="translated"> 우리는 CPU를 실제로 실행하는 방법을 알고 있는 것에 점점 더 가까워지기 위해 이 최고 수준 표현을 연속적으로 낮은 수준의 형태로 변환합니다.</font></p><img alt="The branching paths a language may take over the mountain." class="wide" src="https://youhogeon-meritz.github.io/image/a-map-of-the-territory/mountain.png">
<p><font papago-translate="translated">각 트레일과 관심 지점을 추적해 보겠습니다.</font><font papago-translate="translated"> 우리의 여정은 왼쪽에서 사용자 소스 코드의 맨 텍스트로 시작됩니다:</font></p><img alt="var average = (min + max) / 2;" src="https://youhogeon-meritz.github.io/image/a-map-of-the-territory/string.png">
<h3><a href="https://youhogeon-meritz.github.io/a-map-of-the-territory.html#scanning" id="scanning"><small><font papago-translate="translated">2 . 1 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">스캔</font></font></a></h3>
<p><font papago-translate="translated">첫 번째 단계는<strong> 어휘</strong><strong></strong><strong> 분석</strong><strong>이라고</strong>도 하는<strong> 스캔입니다</strong>.</font><font papago-translate="translated"> 모두 거의 같은 의미입니다.</font><font papago-translate="translated"> 저는 "렉싱"이 사악한 슈퍼 악당이 할 수 있는 일처럼 들리기 때문에 좋아하지만, "스캐닝"이 조금 더 흔할 것 같아서 사용할 것입니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated"><strong>스캐너</strong>(또는<strong> 렉서</strong>)는 문자의 선형 스트림을 가져와<span name="word"> "단어</span>"와 더 유사한 일련의 단어로 통합합니다.</font><font papago-translate="translated"> 프로그래밍 언어에서는 이 단어들을<strong> 각각 토큰</strong>이라고 부릅니다.</font><font papago-translate="translated"> 일부 토큰은 다음과 같은 단일 문자입니다 </font></font><code translate="no">(</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">,</code><font papago-translate="splitted"><font papago-translate="translated">. 다른 문자들은 숫자처럼 여러 문자 길이일 수 있습니다 (</font></font><code translate="no">123</code><font papago-translate="splitted"><font papago-translate="translated">문자열 리터럴 ()</font></font><code translate="no">"hi!"</code><font papago-translate="splitted"><font papago-translate="translated">) 및 식별자 (</font></font><code translate="no">min</code><font papago-translate="splitted"><font papago-translate="translated">).</font></font></p>
<aside name="word" style="top: 2142.5px;">
<p><font papago-translate="translated">"lexical"은 그리스어 어근 "lex"에서 유래했으며, 이는 "단어"를 의미합니다.</font></p>
</aside>
<p><font papago-translate="translated">소스 파일의 일부 문자는 실제로 아무런 의미가 없습니다.</font><font papago-translate="translated"> 공백은 종종 중요하지 않으며, 정의상 댓글은 언어에 의해 무시됩니다.</font><font papago-translate="translated"> 스캐너는 보통 이것들을 버리고 의미 있는 토큰의 깨끗한 시퀀스를 남깁니다.</font></p><img alt="[var] [average] [=] [(] [min] [+] [max] [)] [/] [2] [;]" src="https://youhogeon-meritz.github.io/image/a-map-of-the-territory/tokens.png">
<h3><a href="https://youhogeon-meritz.github.io/a-map-of-the-territory.html#parsing" id="parsing"><small><font papago-translate="translated">2 . 1 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">구문 분석</font></font></a></h3>
<p><font papago-translate="translated">다음 단계는<strong> 구문 분석</strong>입니다.</font><font papago-translate="translated"> 여기서 우리의 구문은<strong> 문법</strong>, 즉 작은<span class="em"></span> 부분에서 더 큰 표현과 문장을 구성할 수 있는 능력을 얻게 됩니다.</font><font papago-translate="translated"> 영어 수업에서 문장을 도표로 작성해 본 적이 있습니까?</font><font papago-translate="translated"> 그렇다면 영어에는 수천 개의 "키워드"와 넘쳐나는 모호성의 코누코피아가 있다는 점을 제외하고는 파서가 하는 일을 해낸 셈입니다.</font><font papago-translate="translated"> 프로그래밍 언어는 훨씬 더 간단합니다.</font></p>
<p><font papago-translate="translated"><strong>파서</strong>는 평평한 토큰 시퀀스를 가져와 문법의 중첩된 특성을 반영하는 트리 구조를 구축합니다.</font><font papago-translate="translated"> 이 트리들은 소스<span class="em"></span><span class="em"></span> 언어의 기본 구문 구조에 얼마나 가까운지에 따라<strong> 몇</strong> 가지 다른 이름<strong>, 즉 구문 트리</strong> 또는<strong> 추상 구문 트리</strong>를 가지고 있습니다.</font><font papago-translate="translated"> 실제로 언어 해커들은 보통<strong> 구문 트리</strong><strong>,</strong> A<strong>ST</strong> 또는 종종 단순히<strong> 트리</strong>라고 부릅니다.</font></p><img alt="An abstract syntax tree." src="https://youhogeon-meritz.github.io/image/a-map-of-the-territory/ast.png">
<p><font papago-translate="translated">파싱은 인공지능 커뮤니티와 밀접하게 연관된 컴퓨터 과학 분야에서 오랜 역사를 가지고 있습니다.</font><font papago-translate="translated"> 오늘날 프로그래밍 언어를 구문 분석하는 데 사용되는 많은 기술들은 원래 컴퓨터가 우리와 대화하도록 하려는 AI 연구자들에 의해<em> 인간</em> 언어를 구문 분석하기 위해 고안되었습니다.</font></p>
<p><font papago-translate="translated">알고 보니 인간 언어는 파서가 다룰 수 있는 딱딱한 문법에는 너무 지저분했지만, 프로그래밍 언어의 단순한 인공 문법에는 완벽하게 어울렸습니다.</font><font papago-translate="translated"> 안타깝게도 우리는 여전히 결함이 있는 사람들이 간단한 문법을 잘못 사용하고 있기 때문에 구문<strong> 오류</strong>를 보고하여 언제 사용할지 알려주는 것도 파서의 역할입니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/a-map-of-the-territory.html#static-analysis" id="static-analysis"><small><font papago-translate="translated">2 . 1 . 3</font></small><font papago-translate="splitted"><font papago-translate="translated">정적 분석</font></font></a></h3>
<p><font papago-translate="translated">처음 두 단계는 모든 구현에서 매우 유사합니다.</font><font papago-translate="translated"> 이제 각 언어의 개별적인 특성이 작용하기 시작합니다.</font><font papago-translate="translated"> 이 시점에서 우리는 코드의 구문 구조(예: 어떤 표현이 중첩되어 있는지)를 알고 있지만<span class="em"></span><span class="em"></span>, 그 이상은 잘 모릅니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">다음과 같은 표현으로 </font></font><code translate="no">a + b</code><font papago-translate="splitted"><font papago-translate="translated">, 우리는 우리가 추가하고 있다는 것을 알고 있습니다 </font></font><code translate="no">a</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">b</code><font papago-translate="splitted"><font papago-translate="translated">, 하지만 우리는 그 이름들이 무엇을 의미하는지 모릅니다.</font><font papago-translate="translated"> 그것들은 지역 변수인가요?</font><font papago-translate="translated"> 글로벌?</font><font papago-translate="translated"> 그들은 어디에서 정의되나요?</font></font></p>
<p><font papago-translate="translated">대부분의 언어에서 가장 먼저 수행하는 분석은<strong> 바인딩</strong> 또는<strong> 해상도</strong>라고 합니다.</font><font papago-translate="translated"> 각<strong> 식별자</strong>에 대해 해당 이름이 정의된 위치를 찾아 두 이름을 연결합니다.</font><font papago-translate="translated"> <strong>여기서 범위가</strong> 적용됩니다. 특정 이름을 사용하여 특정<span class="em"></span> 선언을 지칭할 수 있는 소스 코드의 영역입니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">언어<span name="type">가 정적으로 입력</span>되면, 이때 체크를 입력합니다.</font><font papago-translate="translated"> 어디에 있는지 알게 되면 </font></font><code translate="no">a</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">b</code><font papago-translate="splitted"><font papago-translate="translated"> 선언된 경우 유형도 파악할 수 있습니다.</font><font papago-translate="translated"> 그런 다음 이러한 유형이 서로 추가되는 것을 지원하지 않으면<strong> 유형 오류</strong>를 보고합니다.</font></font></p>
<aside name="type" style="top: 3636px;">
<p><font papago-translate="translated">이 책에서 구축할 언어는 동적으로 타이핑되므로 나중에 런타임에 타입 검사를 수행합니다.</font></p>
</aside>
<p><font papago-translate="translated">숨을 깊게 들이마시세요.</font><font papago-translate="translated"> 우리는 산 정상에 도달하고 사용자 프로그램의 전반적인 시야를 확보했습니다.</font><font papago-translate="translated"> 분석을 통해 우리에게 보이는 모든 의미론적 통찰은 어딘가에 저장되어야 합니다.</font><font papago-translate="translated"> 우리가 그것을 처리할 수 있는 몇 군데가 있습니다:</font></p>
<ul>
<li>
<p><font papago-translate="translated">구문 트리 자체에<strong> 속성</strong>으로 바로 저장되는 경우가 많습니다. 구문 분석 중에 초기화되지는 않았지만<span class="em"></span> 나중에 채워지는 노드의 추가 필드입니다.</font></p>
</li>
<li>
<p><font papago-translate="translated">다른 경우에는 데이터를 옆으로 치우친 조회 테이블에 저장할 수 있습니다.</font><font papago-translate="translated"> 일반적으로 이 테이블의 키는 변수와<span class="em"></span> 선언의 이름인 식별자입니다.</font><font papago-translate="translated"> 이 경우<strong>, 우리</strong>는<strong> 그것</strong>을<strong> 기호 테이블</strong>이라고 부르며 각 키와 연관된 값들이 그 식별자가 무엇을 의미하는지 알려줍니다.</font></p>
</li>
<li>
<p><font papago-translate="translated">가장 강력한 부기 도구는 트리를 완전히 새로운 데이터 구조로 변환하여 코드의 의미를 보다 직접적으로 표현하는 것입니다.</font><font papago-translate="translated"> 다음 섹션입니다.</font></p>
</li>
</ul>
<p><font papago-translate="translated">지금까지의 모든 것이 실행<strong>의 최전선으로</strong> 간주됩니다.</font><font papago-translate="translated"> 이 후에는 모든 것이<strong> 백엔드</strong>라고 추측할 수 있지만, 그렇지 않습니다.</font><font papago-translate="translated"> 예전에 "프론트 엔드"와 "백엔드"가 만들어졌을 때, 컴파일러는 훨씬 더 간단했습니다.</font><font papago-translate="translated"> 이후 연구자들은 두 반쪽 사이에 새로운 단계를 발명했습니다.</font><font papago-translate="translated"> 윌리엄 울프와 회사는 기존 용어를 버리는 대신, 그 새로운 단계들을 매력적이지만 공간적으로 역설적인 이름<strong>인 중간 단계</strong>로 통합했습니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/a-map-of-the-territory.html#intermediate-representations" id="intermediate-representations"><small><font papago-translate="translated">2 . 1 . 4</font></small><font papago-translate="splitted"><font papago-translate="translated">중간 표현</font></font></a></h3>
<p><font papago-translate="translated">컴파일러는 각 단계의 작업이 사용자의 코드를 나타내는 데이터를 다음 단계로 더 쉽게 구현할 수 있도록 구성하는 파이프라인이라고 생각할 수 있습니다.</font><font papago-translate="translated"> 파이프라인의 앞쪽 끝은 프로그램이 작성된 소스 언어에 특화되어 있습니다.</font><font papago-translate="translated"> 백엔드는 프로그램이 실행될 최종 아키텍처와 관련이 있습니다.</font></p>
<p><font papago-translate="translated">중간에 코드는 소스나 목적지 형식에 밀접하게 연결되지 않은 중간<span name="ir"><strong> 표현</strong></span>(<strong>IR</strong>)에 저장될 수 있습니다(따라서 "중간").</font><font papago-translate="translated"> 대신 IR은 이 두 언어 사이의 인터페이스 역할을 합니다.</font></p>
<aside name="ir" style="top: 4476px;">
<p><font papago-translate="translated">몇 가지 잘 정립된 IR 스타일이 있습니다.</font><font papago-translate="translated"> 원하는 검색 엔진을 눌러 "제어 흐름 그래프", "정적 단일 할당", "연속 전달 스타일", 그리고 "세 주소 코드"를 찾아보세요.</font></p>
</aside>
<p><font papago-translate="translated">이를 통해 더 적은 노력으로 여러 소스 언어와 타겟 플랫폼을 지원할 수 있습니다.</font><font papago-translate="translated"> 파스칼, C, 포트란 컴파일러를 구현하고 x86, ARM, 그리고 SPARC를 타겟팅하고 싶다고 가정해 보겠습니다.</font><font papago-translate="translated"> 일반적으로 이는<em> 9개</em>의 전체 컴파일러를 작성하기 위해 가입한다는 것을 의미합니다: Pascal→x86, C→ARM 및 기타 모든 조합.</font></p>
<p><font papago-translate="translated"><span name="gcc">공유</span>된 중간 표현은 그것을 극적으로 줄여줍니다.</font><font papago-translate="translated"> IR을 생성하는 각 소스 언어에 대해 하나<em>의</em> 프론트엔드를 작성합니다.</font><font papago-translate="translated"> 그런 다음 각 대상 아키텍처에<em> 대해 하나의</em> 백엔드<em>를 제공</em>합니다.</font><font papago-translate="translated"> 이제 그것들을 섞고 조합하여 모든 조합을 얻을 수 있습니다.</font></p>
<aside name="gcc" style="top: 4692px;">
<p><font papago-translate="translated">G<a href="https://en.wikipedia.org/wiki/GNU_Compiler_Collection">CC</a>가 Motorola 68k의 Modula-3와 같은 수많은 미친 언어와 아키텍처를 어떻게 지원하는지 궁금해 본 적이 있다면 이제 알게 되실 겁니다.</font><font papago-translate="translated"> 언어 프론트엔드는 주로 G<a href="https://gcc.gnu.org/onlinedocs/gccint/GIMPLE.html">IMPLE</a>과<a href="https://gcc.gnu.org/onlinedocs/gccint/RTL.html"> RT</a>L과 같은 소수의 IR 중 하나를 대상으로 합니다.</font><font papago-translate="translated"> 목표 백엔드는 68,000에 해당하는 백엔드와 마찬가지로, 그런 다음 IR을 가져와서 네이티브 코드를 생성합니다.</font></p>
</aside>
<p><font papago-translate="translated">우리가 코드를 의미론을 더 명확하게 만드는 형태로 변환하고자 하는 또 다른 큰 이유<span class="ellipse">가</span> 있습니다<span class="ellipse">. . .</span></font></p>
<h3><a href="https://youhogeon-meritz.github.io/a-map-of-the-territory.html#optimization" id="optimization"><small><font papago-translate="translated">2 . 1 . 5</font></small><font papago-translate="splitted"><font papago-translate="translated">최적화</font></font></a></h3>
<p><font papago-translate="translated">사용자의 프로그램이 무엇을 의미하는지 이해한 후<em>에는 동일한 의미를</em> 가지지만 더 효율적으로 구현하는 다른 프로그램으로 자유롭게 교체할 수 있습니다.<span class="em"></span><strong> 최적화</strong>할 수 있습니다.</font></p>
<p><font papago-translate="translated"><strong>간단한</strong> 예로는<strong> 상수 접기</strong>가 있습니다: 어떤 식이 항상 정확히 같은 값으로 평가된다면, 컴파일 시 평가를 수행하고 그 식의 코드를 결과로 대체할 수 있습니다.</font><font papago-translate="translated"> 사용자가 이것을 입력한 경우:</font></p>
<div class="codehilite"><pre translate="no"><span class="i">pennyArea</span> = <span class="n">3.14159</span> * (<span class="n">0.75</span> / <span class="n">2</span>) * (<span class="n">0.75</span> / <span class="n">2</span>);
</pre></div>
<p><font papago-translate="translated">컴파일러에서 모든 산술 연산을 수행하고 코드를 다음과 같이 변경할 수 있습니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="i">pennyArea</span> = <span class="n">0.4417860938</span>;
</pre></div>
<p><font papago-translate="translated">최적화는 프로그래밍 언어 비즈니스에서 큰 부분을 차지합니다.</font><font papago-translate="translated"> 많은 언어 해커들이 이곳에서 경력 전체를 보내며, 컴파일러에서 가능한 모든 성능을 압축하여 벤치마크를 몇 퍼센트 더 빠르게 확보합니다.</font><font papago-translate="translated"> 일종의 집착이 될 수 있습니다.</font></p>
<p><font papago-translate="translated">우리는 이 책에서 주로<span name="rathole"> 그 라솔레를 뛰어넘</span>을 것입니다.</font><font papago-translate="translated"> 많은 성공적인 언어들은 놀랍게도 컴파일 시간 최적화가 거의 없습니다.</font><font papago-translate="translated"> 예를 들어, Lua와 CPython은 상대적으로 최적화되지 않은 코드를 생성하며, 대부분의 성능 노력을 런타임에 집중합니다.</font></p>
<aside name="rathole" style="top: 5380px;">
<p><font papago-translate="translated">그 구멍에 발을 찔러 넣는 것을 참을 수 없다면, 시작하기 위한 몇 가지 키워드는 "상수 전파", "공통 부분 표현 제거", "루프 불변 코드 동작", "글로벌 값 번호 매기기", "강도 감소", "골재의 스칼라 교체", "데드 코드 제거", 그리고 "루프 언롤링"입니다.</font></p>
</aside>
<h3><a href="https://youhogeon-meritz.github.io/a-map-of-the-territory.html#code-generation" id="code-generation"><small><font papago-translate="translated">2 . 1 . 6</font></small><font papago-translate="splitted"><font papago-translate="translated">코드 생성</font></font></a></h3>
<p><font papago-translate="translated">우리가 생각할 수 있는 모든 최적화를 사용자 프로그램에 적용했습니다.</font><font papago-translate="translated"> 마지막 단계는 기계가 실제로 실행할 수 있는 형태로 변환하는 것입니다.</font><font papago-translate="translated"> 즉,<strong> 코드</strong><strong> 생성</strong><strong> 코드</strong>(또는<strong> 코드 젠)</strong><strong>는</strong> 일반적으로 CPU가 실행하는 원시 어셈블리와 같은 명령어를 의미하며, 사람이 읽고 싶어 할 수 있는 "소스 코드"의 종류가 아닙니다.</font></p>
<p><font papago-translate="translated">마침내, 우리는<strong> 산</strong>의 반대편을 내려가는 뒷<strong>편에</strong> 있습니다.</font><font papago-translate="translated"> 여기서부터 우리의 코드 표현은 진화가 역으로 진행되는 것처럼 점점 더 원시적으로 변하게 됩니다. 우리가 단순한 기계가 이해할 수 있는 무언가에 가까워질수록 말이죠.</font></p>
<p><font papago-translate="translated">결정을 내려야 합니다.</font><font papago-translate="translated"> 실제 CPU에 대한 명령어를 생성하나요, 아니면 가상 CPU에 대한 명령어를 생성하나요?</font><font papago-translate="translated"> 실제 기계 코드를 생성하면 OS가 칩에 직접 로드할 수 있는 실행 파일을 얻을 수 있습니다.</font><font papago-translate="translated"> 네이티브 코드는 매우 빠르지만 생성하는 데 많은 노력이 필요합니다.</font><font papago-translate="translated"> 오늘날의 건축물들은 747의 짐칸을 채울 만큼 많은 지침서, 복잡한 파이프라인,<span name="aad"> 그리고 충분한 역사적 짐을</span> 가지고 있습니다.</font></p>
<p><font papago-translate="translated">칩의 언어를 사용한다는 것은 컴파일러가 특정 아키텍처에 연결되어 있다는 것을 의미하기도 합니다.</font><font papago-translate="translated"> 컴파일러가<a href="https://en.wikipedia.org/wiki/X86"> x86</a> 머신 코드를 타겟팅하면 A<a href="https://en.wikipedia.org/wiki/ARM_architecture">RM</a> 장치에서 실행되지 않습니다.</font><font papago-translate="translated"> 60년대, 캄브리아기 컴퓨터 아키텍처의 폭발적인 성장기 동안 휴대성 부족은 정말 큰 장애물이었습니다.</font></p>
<aside name="aad" style="top: 5908px;">
<p><font papago-translate="translated">예를 들어, AA<a href="http://www.felixcloutier.com/x86/AAD.html">D</a>("ASCII 분할 전 AX 조정") 명령어를 사용하면 분할을 수행할 수 있는데, 이는 유용하게 들립니다.</font><font papago-translate="translated"> 그 명령어는 피연산자로서 두 개의 이진 코드 십진수를 하나의 16비트 레지스터에 포함시킵니다.</font><font papago-translate="translated"> 16비트<em></em> 컴퓨터에서 마지막으로 BCD가 필요했던 때가 언제였나요?</font></p>
</aside>
<p><font papago-translate="translated">이를 해결하기 위해 BCPL과 파스칼의 유명한 마틴 리처즈와 니클라우스 워스 같은 해커들은 각각 컴파일러가<em> 가상</em> 머신 코드를 생성하도록 만들었습니다.</font><font papago-translate="translated"> 실제 칩에 대한 지침 대신, 그들은 가상의 이상화된 기계를 위한 코드를 생성했습니다.</font><font papago-translate="translated" class=""> Wirth는<em> 이</em>를<em> 휴대용</em><strong> p-코드</strong>라고 불렀지만, 오늘날에는 각 명령어가 종종 단일 바이트 길이이기 때문에<strong> 일반</strong>적으로<strong> 바이트코드</strong>라고 부릅니다.</font></p>
<p><font papago-translate="translated">이 합성 명령어들은 언어의 의미론에 조금 더 가깝게 매핑되도록 설계되었으며, 특정 컴퓨터 아키텍처와 그 축적된 역사적 흐름의 특수성에 얽매이지 않도록 설계되었습니다.</font><font papago-translate="translated" class=""> 언어의 저수준 연산을 밀집된 이진 인코딩으로 생각할 수 있습니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/a-map-of-the-territory.html#virtual-machine" id="virtual-machine"><small><font papago-translate="translated">2 . 1 . 7</font></small><font papago-translate="splitted"><font papago-translate="translated">가상 머신</font></font></a></h3>
<p><font papago-translate="translated">컴파일러가 바이트코드를 생성하면 작업이 완료된 후에도 작업이 끝나지 않습니다.</font><font papago-translate="translated"> 바이트코드를 사용하는 칩이 없기 때문에 번역하는 것이 여러분의 몫입니다.</font><font papago-translate="translated" class=""> 다시 말하지만, 두 가지 옵션이 있습니다.</font><font papago-translate="translated"> 각 대상 아키텍처에 대해 바이트코드를 해당 머신의 네이티브 코드로 변환하는 작은 미니 컴파일러를 작성할 수 있습니다.</font><font papago-translate="translated" class=""> 지원하는 각 칩에 대해 여전히 작업을 수행해야 하지만, 이 마지막 단계는 매우 간단하며<span name="shared"></span> 지원하는 모든 기계에서 나머지 컴파일러 파이프라인을 재사용할 수 있습니다.</font><font papago-translate="translated"> 당신은 기본적으로 바이트코드를 중간 표현으로 사용하고 있습니다.</font></p>
<aside class="bottom" name="shared" style="top: 6353px;">
<p><font papago-translate="translated">여기서 기본 원칙은 아키텍처별 작업을 더 멀리 밀어낼수록 아키텍처 전반에 걸쳐 더 많은 초기 단계를 공유할 수 있다는 것입니다.</font></p>
<p><font papago-translate="translated">하지만 긴장감이 있습니다.</font><font papago-translate="translated"> 레지스터 할당 및 명령어 선택과 같은 많은 최적화는 특정 칩의 강점과 기능을 알 때 가장 잘 작동합니다.</font><font papago-translate="translated"> 컴파일러의 어떤 부분을 공유할 수 있는지, 그리고 어떤 부분을 대상별로 공유해야 하는지 알아내는 것은 예술입니다.</font></p>
</aside>
<p><font papago-translate="translated" class="">또는 런타임에 가상 아키텍처를 지원하는 가상 칩을 에뮬레이트하는 프로그램인<span name="vm"><strong> 가상 머신</strong></span>(<strong>VM</strong>)을 작성할 수도 있습니다.</font><font papago-translate="translated"> VM에서 바이트코드를 실행하는 것은 실행될 때마다 모든 명령어를 런타임에 시뮬레이션해야 하기 때문에 미리 네이티브 코드로 변환하는 것보다 느립니다.</font><font papago-translate="translated"> 그 대가로, 당신은 단순함과 휴대성을 얻게 됩니다.</font><font papago-translate="translated"> 예를 들어 C에 VM을 구현하면 C 컴파일러가 있는 모든 플랫폼에서 언어를 실행할 수 있습니다.</font><font papago-translate="translated"> 이 책에서 우리가 만든 두 번째 통역사는 이렇게 작동합니다.</font></p>
<aside name="vm" style="top: 6628px;">
<p><font papago-translate="translated">"가상 머신"이라는 용어는 또한 다른 종류의 추상화를 의미합니다.</font><font papago-translate="translated"> <strong>시스템 가상 머신은</strong> 소프트웨어에서 전체 하드웨어 플랫폼과 운영 체제를 에뮬레이트합니다.</font><font papago-translate="translated"> 이렇게 하면 Linux 컴퓨터에서 Windows 게임을 플레이할 수 있으며, 클라우드 제공업체가 각 사용자에게 별도의 컴퓨터를 물리적으로 할당하지 않고도 자신의 "서버"를 제어할 수 있는 사용자 경험을 제공합니다.</font></p>
<p><font papago-translate="translated">이 책에서 다룰 VM의 종류는<strong> 언어 가상 머신</strong> 또는<strong> 프로세스 가상 머신</strong>입니다.</font></p>
</aside>
<h3><a href="https://youhogeon-meritz.github.io/a-map-of-the-territory.html#runtime" id="runtime"><small><font papago-translate="translated">2 . 1 . 8</font></small><font papago-translate="splitted"><font papago-translate="translated">런타임</font></font></a></h3>
<p><font papago-translate="translated">마침내 사용자 프로그램을 실행할 수 있는 형태로 만들었습니다.</font><font papago-translate="translated"> 마지막 단계는 실행하는 것입니다.</font><font papago-translate="translated"> 우리가 그것을 기계 코드로 컴파일하면, 단순히 운영 체제에 실행 파일을 로드하라고 지시하고 실행 파일을 꺼버립니다.</font><font papago-translate="translated"> 바이트코드로 컴파일하면 VM을 시작하고 프로그램을 로드해야 합니다.</font></p>
<p><font papago-translate="translated">두 경우 모두, 가장 기본적인 저수준 언어를 제외한 모든 언어에 대해, 우리는 보통 프로그램이 실행되는 동안 우리 언어가 제공하는 몇 가지 서비스가 필요합니다.</font><font papago-translate="translated"> 예를 들어, 언어가 메모리를 자동으로 관리하는 경우, 사용되지 않은 비트를 회수하기 위해 가비지 컬렉터가 필요합니다.</font><font papago-translate="translated"> 우리 언어가 "인스턴스 오브" 테스트를 지원하여 어떤 종류의 객체를 가지고 있는지 확인할 수 있다면, 실행 중에 각 객체의 유형을 추적하기 위해 표현이 필요합니다.</font></p>
<p><font papago-translate="translated">이 모든 것이 런타임에 진행되므로 적절하게<strong> 런타임</strong>이라고 합니다.</font><font papago-translate="translated"> 완전히 컴파일된 언어에서는 런타임을 구현하는 코드가 결과 실행 파일에 직접 삽입됩니다.</font><font papago-translate="translated"> 예를 들어, Go에서는 각 컴파일된 애플리케이션마다 Go의 런타임 복사본이 직접<a href="https://golang.org/"></a> 내장되어 있습니다.</font><font papago-translate="translated"> 언어가 인터프리터나 VM 내에서 실행되면 런타임이 거기에 저장됩니다.</font><font papago-translate="translated"> Java, Python, JavaScript와 같은 대부분의 언어 구현은 이렇게 작동합니다.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/a-map-of-the-territory.html#shortcuts-and-alternate-routes" id="shortcuts-and-alternate-routes"><small><font papago-translate="translated">2 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">지름길 및 대체 경로</font></font></a></h2>
<p><font papago-translate="translated">그것이 당신이 구현할 수 있는 모든 가능한 단계를 포괄하는 긴 경로입니다.</font><font papago-translate="translated"> 많은 언어들이 전체 경로를 걸어 다니지만, 몇 가지 지름길과 대체 경로가 있습니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/a-map-of-the-territory.html#single-pass-compilers" id="single-pass-compilers"><small><font papago-translate="translated">2 . 2 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">단일 패스 컴파일러</font></font></a></h3>
<p><font papago-translate="translated">일부 단순 컴파일러는 구문 트리나 기타 IR을 할당하지 않고 파싱, 분석 및 코드 생성을 인터리브하여 파싱기에서 직접 출력 코드를 생성합니다.</font><font papago-translate="translated"> 이<span name="sdt"><strong> 단일 패스 컴파일러</strong></span>들은 언어 설계를 제한합니다.</font><font papago-translate="translated"> 프로그램에 대한 전역 정보를 저장할 중간 데이터 구조가 없으며, 이전에 분석된 코드의 어떤 부분도 다시 검토하지 않습니다.</font><font papago-translate="translated"> 즉, 어떤 표현을 보자마자 올바르게 컴파일할 수 있을 만큼 충분히 알아야 한다는 뜻입니다.</font></p>
<aside name="sdt" style="top: 7588px;">
<p><font papago-translate="translated"><a href="https://en.wikipedia.org/wiki/Syntax-directed_translation"><strong>구문 지향 번역</strong></a>은 이러한 컴파일러를 한꺼번에 구축하기 위한 구조화된 기법입니다<a href="https://en.wikipedia.org/wiki/Syntax-directed_translation"><strong>.</strong></a></font><font papago-translate="translated"> <em>동작을</em> 문법의 각 부분, 보통 출력 코드를 생성하는 동작과 연관시킵니다.</font><font papago-translate="translated"> 그런 다음 구문 분석기가 구문의 청크와 일치할 때마다 작업을 실행하여 대상 코드를 하나씩 빌드합니다.</font></p>
</aside>
<p><font papago-translate="translated">파스칼과 C는 이 한계를 중심으로 설계되었습니다.</font><font papago-translate="translated"> 당시에는 메모리가 너무 소중해서 컴파일러가<em> 전체 소스 파일</em>, 즉 전체 프로그램을 메모리에 저장할 수 없을 수도 있었습니다.</font><font papago-translate="translated"> 이것이 바로 파스칼의 문법이 타입 선언이 블록에 먼저 나타나도록 요구하는 이유입니다.</font><font papago-translate="translated"> 그렇기 때문에 C에서는 컴파일러가 나중 함수 호출을 위해 코드를 생성하기 위해 알아야 할 사항을 명시적으로 전달하는 선언이 없으면 코드 위의 함수를 호출할 수 없습니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/a-map-of-the-territory.html#tree-walk-interpreters" id="tree-walk-interpreters"><small><font papago-translate="translated">2 . 2 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">트리워크 통역사</font></font></a></h3>
<p><font papago-translate="translated">일부 프로그래밍 언어는 코드를 AST에 구문 분석한 후 바로 실행하기 시작합니다(아마도 약간의 정적 분석이 적용될 수 있습니다).</font><font papago-translate="translated"> 프로그램을 실행하기 위해 인터프리터는 구문 트리를 한 번에 하나씩 분기하고 리프하면서 각 노드를 평가합니다.</font></p>
<p><font papago-translate="translated">이 구현 방식은 학생 프로젝트와 작은 언어에서는 흔히 사용되지만, 일반<span name="ruby"> 목적</span> 언어에서는 느리기 때문에 널리 사용되지 않습니다.</font><font papago-translate="translated"> 어떤 사람들은 이러한 종류의 구현만을 의미하기 위해 "interpreter"를 사용하지만, 다른 사람들은 그 단어를 더 일반적으로 정의하기 때문에, 저는 이를 참조하기 위해 명백한<strong> 트리 워크 인터프리터</strong>를 사용할 것입니다.</font><font papago-translate="translated"> 우리의 첫 번째 통역사가 이렇게 굴립니다.</font></p>
<aside name="ruby" style="top: 8092px;">
<p><font papago-translate="translated">주목할 만한 예외 중 하나는 트리워커였던 초기 버전의 루비입니다.</font><font papago-translate="translated"> 1.9에서 Ruby의 정식 구현은 원래 MRI(Matz의 Ruby Interpreter)에서 Koichi Sasada의 YARV(Yet Another Ruby VM)로 전환되었습니다. YARV는 바이트코드 가상 머신입니다.</font></p>
</aside>
<h3><a href="https://youhogeon-meritz.github.io/a-map-of-the-territory.html#transpilers" id="transpilers"><small><font papago-translate="translated">2 . 2 . 3</font></small><font papago-translate="splitted"><font papago-translate="translated">트랜스필러</font></font></a></h3>
<p><font papago-translate="translated">언어의 완전한 백엔드<span name="gary">를 작성하는 것</span>은 많은 작업이 될 수 있습니다<span name="gary">.</span></font><font papago-translate="translated"> 기존의 일반적인 IR을 타겟팅할 수 있다면 프론트엔드를 공략할 수 있습니다.</font><font papago-translate="translated"> 그렇지 않으면 갇혀 있는 것 같습니다.</font><font papago-translate="translated"> 하지만 다른<em> 소스 언어</em>를 중간 표현처럼 취급한다면 어떨까요?</font></p>
<p><font papago-translate="translated">당신은 당신의 언어의 앞부분을 씁니다.</font><font papago-translate="translated"> 그런 다음, 백엔드에서는 의미론<em>을</em> 원시 목표 언어로<em> 낮추기</em> 위해 모든 작업을 수행하는 대신, 다른 언어에 대해 유효한 소스 코드 문자열을 생성합니다. 이는 당신의 언어만큼이나 높은 수준입니다.</font><font papago-translate="translated"> 그런 다음 해당 언어에 대한 기존 컴파일 도구를 산을 떠나<em></em> 실행할 수 있는 경로로 사용합니다.</font></p>
<p><font papago-translate="translated">그들은 이것을<strong> 소스 간 컴파일러</strong> 또는<strong> 트랜스컴파일러</strong>라고 불렀습니다.</font><font papago-translate="translated"> 브라우저에서 실행하기 위해 JavaScript로 컴파일하는 언어들이 등장한 이후, 이 언어들은 힙스터 sobriquet<strong> transpiler</strong>에 영향을 미쳤습니다.</font></p>
<aside name="gary" style="top: 8332px;">
<p><font papago-translate="translated">최초의 트랜스컴파일러인 XLT86은 8080 어셈블리를 8086 어셈블리로 번역했습니다.</font><font papago-translate="translated"> 간단해 보일 수 있지만 8080은 8비트 칩, 8086은 각 레지스터를 8비트 칩으로 사용할 수 있는 16비트 칩이라는 점을 명심하세요. XLT86은 소스 프로그램에서 레지스터 사용량을 추적한 다음 8086의 레지스터 세트에 효율적으로 매핑하기 위해 데이터 흐름 분석을 수행했습니다.</font></p>
<p><font papago-translate="translated">그것은 컴퓨터 과학의 비극적인 영웅인 게리 킬달에 의해 쓰여졌습니다.</font><font papago-translate="translated"> 마이크로컴퓨터의 가능성을 처음으로 인식한 사람 중 한 명인 그는 그들을 위한 최초의 고급 언어이자 운영 체제인 PL/M과 CP/M을 만들었습니다.</font></p>
<p><font papago-translate="translated">그는 선장, 사업주, 면허 조종사, 그리고 오토바이 운전자였습니다.</font><font papago-translate="translated"> 크리스 크리스토퍼슨 스타일의 TV 진행자는 80년대에 늠름한 수염을 기른 남자들과 함께 스포츠를 즐겼습니다.</font><font papago-translate="translated"> 그는 빌 게이츠와 맞서 싸웠고, 많은 사람들처럼 길을 잃었지만, 미스터리한 상황 속에서 바이커 바에서 최후를 맞이했습니다.</font><font papago-translate="translated"> 그는 너무 일찍 죽었지만, 분명히 그 이전에는 지옥처럼 살았습니다.</font></p>
</aside>
<p><font papago-translate="translated">최초의 트랜스컴파일러는 한 어셈블리 언어를 다른 어셈블리 언어로 번역했지만, 오늘날 대부분의 트랜스필러는 상위 언어에서 작업합니다.</font><font papago-translate="translated"> UNIX가 다양하고 다양한 기계에 바이러스로 확산된 후, C를 출력 언어로 사용하는 컴파일러의 오랜 전통이 시작되었습니다.</font><font papago-translate="translated"> C 컴파일러는 UNIX가 있는 모든 곳에서 사용할 수 있었고 효율적인 코드를 생성했기 때문에 C를 타겟팅하는 것이 많은 아키텍처에서 언어를 실행하는 데 좋은 방법이었습니다.</font></p>
<p><font papago-translate="translated">웹 브라우저는 오늘날 "기계"이며, 그들의 "기계 코드"는 JavaScript입니다. 그래서 요즘<a href="https://github.com/jashkenas/coffeescript/wiki/list-of-languages-that-compile-to-js">은 거의 모든 언어에</a> JS를 타겟으로 하는 컴파일러가 있는 것 같습니다. 이는 JS를 타겟으로 하는 컴파일러가 브라우저에서 코드를 실행하는<span name="js"> 주된</span> 방법이기 때문입니다.</font></p>
<aside name="js" style="top: 8932px;">
<p><font papago-translate="translated">JS는 브라우저에서 코드를 실행하는<em> 유일</em>한 방법이었습니다.</font><font papago-translate="translated"> Web<a href="https://github.com/webassembly/">Assembly</a> 덕분에 컴파일러는 이제 웹에서 실행되는 두 번째 하위 언어를 타겟팅할 수 있게 되었습니다.</font></p>
</aside>
<p><font papago-translate="translated">트랜스필러의 프런트엔드(스캐너와 파서)는 다른 컴파일<span class="em"></span><span class="em"></span>러와 비슷하게 생겼습니다.</font><font papago-translate="translated"> 그런 다음 원본 언어가 대상 언어에 대한 단순한 구문 스킨에 불과하다면 분석을 완전히 건너뛰고 대상 언어에서 유사한 구문을 출력하는 것으로 바로 이동할 수 있습니다.</font></p>
<p><font papago-translate="translated">두 언어가 의미적으로 더 다르다면, 전체 컴파일러의 일반적인 단계 중 분석과 최적화를 포함한 더 많은 단계를 보게 될 것입니다.</font><font papago-translate="translated"> 그런 다음 코드 생성에 관해서는 기계 코드와 같은 이진 언어를 출력하는 대신 대상 언어에서 문법적으로 올바른 소스(음, 목적지) 코드 문자열을 생성합니다.</font></p>
<p><font papago-translate="translated">어느 쪽이든 출력 언어의 기존 컴파일 파이프라인을 통해 결과 코드를 실행하면 됩니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/a-map-of-the-territory.html#just-in-time-compilation" id="just-in-time-compilation"><small><font papago-translate="translated">2 . 2 . 4</font></small><font papago-translate="splitted"><font papago-translate="translated">적시 컴파일</font></font></a></h3>
<p><font papago-translate="translated">이 마지막 것은 지름길이라기보다는 전문가들에게 가장 적합한 위험한 알파인 스크램블입니다.</font><font papago-translate="translated"> 코드를 실행하는 가장 빠른 방법은 기계 코드로 컴파일하는 것이지만, 최종 사용자의 기계가 어떤 아키텍처를 지원하는지 모를 수도 있습니다.</font><font papago-translate="translated"> 무엇을 해야 하나?</font></p>
<p><font papago-translate="translated">핫스팟 자바 가상 머신(JVM), 마이크로소프트의 공통 언어 런타임(CLR) 및 대부분의 자바스크립트 인터프리터와 동일한 작업을 수행할 수 있습니다.</font><font papago-translate="translated"> 최종 사용자의 컴퓨터에서 JS의 경우 소스에서 프로그램이 로드되거나 JVM과 C<span class="em">LR</span>의 플랫폼 독립 바이트코드에서 컴퓨터<span class="em"></span>가 지원하는 아키텍처의 네이티브 코드로 컴파일됩니다.</font><font papago-translate="translated"> 당연히 이를<strong> 적시 컴파일이라고</strong> 합니다.</font><font papago-translate="translated"> 대부분의 해커들은 "적합"과 운율이 맞는 것처럼 발음되는 "JIT"라고 말합니다.</font></p>
<p><font papago-translate="translated">가장 정교한 J</font><font papago-translate="translated">IT는 생성된 코드에 프로파일링 훅을 삽입하여 어떤 영역이 성능에 가장 중요한지, 어떤 종류의 데이터가 이를 통해 흐르고 있는지 확인합니다.</font><font papago-translate="translated"> 그런 다음 시간이 지남에 따라<span name="hot"> 더</span> 고급 최적화를 통해<span name="hot"> 핫스팟을</span> 자동으로 재컴파일합니다.</font></p>
<aside name="hot" style="top: 9796px;">
<p><font papago-translate="translated">물론 여기가 바로 핫스팟 JVM의 이름이 붙여진 곳입니다.</font></p>
</aside>
<h2><a href="https://youhogeon-meritz.github.io/a-map-of-the-territory.html#compilers-and-interpreters" id="compilers-and-interpreters"><small><font papago-translate="translated">2 . 3</font></small><font papago-translate="splitted"><font papago-translate="translated">컴파일러 및 인터프리터</font></font></a></h2>
<p><font papago-translate="translated">이제 여러분의 머릿속에 사전의 프로그래밍 언어 전문 용어를 채워 넣었으니, 우리는 마침내 고대부터 코더들을 괴롭혀온 질문을 해결할 수 있게 되었습니다:</font><font papago-translate="translated"> 컴파일러와 인터프리터의 차이점은 무엇인가요?</font></p>
<p><font papago-translate="translated">알고 보니 이것은 과일과 채소의 차이를 묻는 것과 같습니다.</font><font papago-translate="translated"> 그것은 이분법적인 선택처럼 보이지만, 사실 "과일"은<em> 식물</em>학적 용어이고 "채소"는<em> 요리적</em>인 용어입니다.</font><font papago-translate="translated"> 하나는 다른 하나의 부정을 엄밀히 암시하지 않습니다.</font><font papago-translate="translated"> 채소(사과)가 아닌 과일(사과)과 과일(당근)이 아닌 식용 식물(토마토처럼 과일<em>과</em> 채소)도 있습니다.</font></p>
<p><span name="veg"></span></p><img alt="A Venn diagram of edible plants" src="https://youhogeon-meritz.github.io/image/a-map-of-the-territory/plants.png">
<aside name="veg" style="top: 10178px;">
<p><font papago-translate="translated">땅콩(땅콩도 아니고)과 밀 같은 시리얼은 사실 과일인데, 제가 이 그림을 잘못 봤어요.</font><font papago-translate="translated"> 뭐라고 말할 수 있을까요? 저는 식물학자가 아니라 소프트웨어 엔지니어입니다.</font><font papago-translate="translated"> 작은 땅콩 남자를 지워야 할 것 같은데 너무 귀여워서 참을 수가 없어요.</font></p>
<p><font papago-translate="translated"><em>반면에 잣은</em> 과일도 채소도 아닌 식물성 식품입니다.</font><font papago-translate="translated"> 적어도 제가 아는 한.</font></p>
</aside>
<p><font papago-translate="translated">다시 언어로 돌아가 보겠습니다:</font></p>
<ul>
<li>
<p><font papago-translate="translated"><strong>컴파일링</strong>은 소스 언어를 다른<span class="em"></span><span class="em"></span> 형태(보통 하위 수준)로 번역하는 구현<em> 기법</em>입니다<strong>.</strong></font><font papago-translate="translated"> 바이트코드나 머신 코드를 생성할 때는 컴파일을 하는 것입니다.</font><font papago-translate="translated"> 다른 고급 언어로 변환할 때, 당신도 컴파일하는 것입니다.</font></p>
</li>
<li>
<p><font papago-translate="translated">우리가 언어 구현체를 "<strong>컴파일러</strong>"라고 말할 때, 소스 코드를 다른 형태로 번역하지만 실행하지 않는다는 의미입니다.</font><font papago-translate="translated"> 사용자는 결과물을 가져와서 직접 실행해야 합니다.</font></p>
</li>
<li>
<p><font papago-translate="translated">반대로, 구현이 "<strong>인터프리터</strong>"라고 말할 때는 소스 코드를 가져와서 즉시 실행하는 것을 의미합니다.</font><font papago-translate="translated"> "소스에서" 프로그램을 실행합니다.</font></p>
</li>
</ul>
<p><font papago-translate="translated">사과나 오렌지와 마찬가지로, 일부 구현은 분명히 컴파일러이며 인터프리터<em>가 아닙니다</em>.</font><font papago-translate="translated"> GCC와 Clang은 당신의 C 코드를 가져와서 기계 코드로 컴파일합니다.</font><font papago-translate="translated"> 최종 사용자는 해당 실행 파일을 직접 실행하며 어떤 도구를 사용하여 컴파일했는지조차 알 수 없습니다.</font><font papago-translate="translated"> 그래서 저것들은 C용<em> 컴파일러</em>입니다.</font></p>
<p><font papago-translate="translated">이전 버전의 Matz의 표준 루비 구현에서는 사용자가 소스에서 루비를 실행했습니다.</font><font papago-translate="translated"> 구현은 구문 트리를 탐색하여 직접 실행했습니다.</font><font papago-translate="translated"> 내부적으로 또는 사용자가 볼 수 있는 형태로 다른 번역은 발생하지 않았습니다.</font><font papago-translate="translated"> 그래서 이것은 확실히 루비를 위한<em> 통역</em>사였습니다.</font></p>
<p><font papago-translate="translated">하지만 CPython은 어떨까요?</font><font papago-translate="translated"> 이를 사용하여 파이썬 프로그램을 실행하면 코드가 구문 분석되어 내부 바이트코드 형식으로 변환된 후 VM 내부에서 실행됩니다.</font><font papago-translate="translated"> 사용자의 관점에서 보면, 이것은 분명히 통역사입니다.<span class="em"></span> 그들은 소스에서 프로그램을 실행합니다.</font><font papago-translate="translated"> 하지만 CPython의 비늘 같은 피부 아래를 보면 분명히 어떤 편집 작업이 진행되고 있다는 것을 알 수 있습니다.</font></p>
<p><font papago-translate="translated">답은<span name="go"> 둘 다</span>라는 것입니다.</font><font papago-translate="translated"> CPython<em>은</em> 인터프리터<em>이며</em> 컴파일러<em>가 있습니다</em>.</font><font papago-translate="translated"> 실제로 대부분의 스크립팅 언어는 보시다시피 이렇게 작동합니다:</font></p>
<aside name="go" style="top: 11302.5px;">
<p><font papago-translate="splitted"><font papago-translate="translated">바둑<a href="https://golang.org/"> 도구는</a> 더욱 원예에 대한 호기심입니다.</font><font papago-translate="translated"> 달리면 </font></font><code translate="no">go build</code><font papago-translate="splitted"><font papago-translate="translated">, Go 소스 코드를 기계 코드에 컴파일하고 중지합니다.</font><font papago-translate="translated"> 입력하면 </font></font><code translate="no">go run</code><font papago-translate="splitted"><font papago-translate="translated">, 그렇게 한 다음 생성된 실행 파일을 즉시 실행합니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">그렇게 </font></font><code translate="no">go</code> <font papago-translate="splitted"><font papago-translate="translated" class="">는 컴파일<em></em><em></em>러(코드를 실행하지 않고 컴파일 도구로 사용할 수 있음)이며, 인터프리터(소스에서 프로그램을 즉시 실행하기 위해 호출할 수 있음)이며, 컴파일러<em>도 있습니다</em>(인터프리터로 사용할 때는 여전히 내부적으로 컴파일 중입니다).</font></font></p>
</aside><img alt="A Venn diagram of compilers and interpreters" src="https://youhogeon-meritz.github.io/image/a-map-of-the-territory/venn.png">
<p><font papago-translate="translated">중앙에 겹치는 영역은 내부적으로 바이트코드를 컴파일하기 때문에 두 번째 통역사가 거주하는 곳이기도 합니다.</font><font papago-translate="translated"> 따라서 이 책은 명목상으로는 통역사에 관한 책이지만, 일부 편집본도 다룰 예정입니다.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/a-map-of-the-territory.html#our-journey" id="our-journey"><small><font papago-translate="translated">2 . 4</font></small><font papago-translate="splitted"><font papago-translate="translated">우리의 여정</font></font></a></h2>
<p><font papago-translate="translated">한 번에 많은 양을 섭취할 수 있습니다.</font><font papago-translate="translated"> 걱정하지 마세요.</font><font papago-translate="translated"> 이 모든 부분과 부분<em>을 이해</em>해야 하는 장은 아닙니다.</font><font papago-translate="translated"> 그들이 밖에 있고 대략적으로 어떻게 어울리는지 알아주셨으면 합니다.</font></p>
<p><font papago-translate="translated">이 지도는 이 책에서 안내하는 경로를 넘어 영토를 탐험할 때 유용할 것입니다.</font><font papago-translate="translated"> 혼자서 파업을 하고 그 산 전체를 돌아다니고 싶어하는 당신을 떠나고 싶습니다.</font></p>
<p><font papago-translate="translated">하지만 지금은 우리만의 여정을 시작할 때입니다.</font><font papago-translate="translated"> 부츠 끈을 조이고, 짐을 단단히 묶고, 함께 오세요.</font><font papago-translate="translated"> <span name="here">이제</span>부터 당신이 집중해야 할 것은 눈앞의 길뿐입니다.</font></p>
<aside name="here" style="top: 12137px;">
<p><font papago-translate="translated">앞으로는 산의 은유적인 요소를 전체적으로 완화할 것을 약속드립니다.</font></p>
</aside>
<div class="challenges">
<h2><a href="https://youhogeon-meritz.github.io/a-map-of-the-territory.html#challenges" id="challenges"><font papago-translate="translated">과제들</font></a></h2>
<ol>
<li>
<p><font papago-translate="splitted"><font papago-translate="translated">원하는 언어의 오픈 소스 구현을 선택합니다.</font><font papago-translate="translated"> 소스 코드를 다운로드하고 그 안을 들여다보세요.</font><font papago-translate="translated"> 스캐너와 파서를 구현하는 코드를 찾아보세요.</font><font papago-translate="translated"> 그것들은 손글씨로 작성된 것인가요, 아니면 Lex와 Yacc 같은 도구를 사용하여 생성된 것인가요? (</font></font><code translate="no">.l</code><font papago-translate="splitted"><font papago-translate="translated"> 또는 </font></font><code translate="no">.y</code><font papago-translate="splitted"><font papago-translate="translated"> 파일은 일반적으로 후자를 의미합니다.)</font></font></p>
</li>
<li>
<p><font papago-translate="translated">적시 컴파일은 동적으로 입력된 언어를 구현하는 가장 빠른 방법인 경향이 있지만, 모든 언어가 이를 사용하는 것은 아닙니다.</font><font papago-translate="translated"> JIT<em>를 하지 않는</em> 이유가 무엇입니까?</font></p>
</li>
<li>
<p><font papago-translate="translated">C로 컴파일하는 대부분의 리스프 구현에는 리스프 코드를 즉석에서 실행할 수 있는 인터프리터도 포함되어 있습니다. 왜 그럴까요?</font></p>
</li>
</ol>
</div>
<footer>
<a class="next" href="https://youhogeon-meritz.github.io/the-lox-language.html"><font papago-translate="translated"> 다음 장: "록스 언어" → </font></a><font papago-translate="splitted"><font papago-translate="translated"> 로버트 니스트롬이 수작업으로 제작한 -<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE"> © 2015 ~ 2021</a></font></font>
</footer>
</article>
</div>


<div id="papagoTooltip" margin="5" style="display: none;">
        <h1 id="tooltipTitle">원문</h1>
        <p id="tooltipText"></p>
      </div>
      </body></html>