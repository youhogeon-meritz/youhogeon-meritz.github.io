<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>Calls and Functions · Crafting Interpreters</title>
<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta content="width=device-width, initial-scale=1" name="viewport">
<link href="https://youhogeon-meritz.github.io/style.css" rel="stylesheet" type="text/css">
<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600" rel="stylesheet" type="text/css">
<link href="https://youhogeon-meritz.github.io/image/favicon.png" rel="icon" type="image/png">


<!-- Google analytics -->

</head>
<body id="top">
<!-- <div class="scrim"></div> -->
<nav class="wide">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<div class="contents">
<h3><a href="https://youhogeon-meritz.github.io/calls-and-functions.html#top"><font papago-translate="splitted"><font papago-translate="translated">호출 및 기능</font></font><small>24</small></a></h3>
<ul>
<li><a href="https://youhogeon-meritz.github.io/calls-and-functions.html#function-objects"><small>24.1</small><font papago-translate="splitted"><font papago-translate="translated"> 함수 객체</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/calls-and-functions.html#compiling-to-function-objects"><small>24.2</small><font papago-translate="splitted"><font papago-translate="translated"> 함수 객체로 컴파일하기</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/calls-and-functions.html#call-frames"><small>24.3</small><font papago-translate="splitted"><font papago-translate="translated"> 통화 프레임</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/calls-and-functions.html#function-declarations"><small>24.4</small><font papago-translate="splitted"><font papago-translate="translated"> 함수 선언</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/calls-and-functions.html#function-calls"><small>24.5</small><font papago-translate="splitted"><font papago-translate="translated"> 함수 호출</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/calls-and-functions.html#return-statements"><small>24.6</small><font papago-translate="splitted"><font papago-translate="translated"> 반품 명세서</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/calls-and-functions.html#native-functions"><small>24.7</small><font papago-translate="splitted"><font papago-translate="translated"> 네이티브 함수</font></font></a></li>
<li class="divider"></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/calls-and-functions.html#challenges"><font papago-translate="translated">과제들</font></a></li>
</ul>
<div class="prev-next">
<a class="left" href="https://youhogeon-meritz.github.io/jumping-back-and-forth.html" title="앞뒤로 뛰기" papago-attr-id="1"><font papago-translate="translated">← 이전</font></a>
<a href="https://youhogeon-meritz.github.io/a-bytecode-virtual-machine.html" title="바이트코드 가상 머신" papago-attr-id="2"><font papago-translate="translated">↑ 위로</font></a>
<a class="right" href="https://youhogeon-meritz.github.io/closures.html" title="폐쇄" papago-attr-id="3"><font papago-translate="translated">다음 →</font></a>
</div> </div>
</nav>
<nav class="narrow">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<a class="prev" href="https://youhogeon-meritz.github.io/jumping-back-and-forth.html" title="Jumping Back and Forth">←</a>
<a class="next" href="https://youhogeon-meritz.github.io/closures.html" title="Closures">→</a>
</nav>
<div class="page">
<div class="nav-wrapper">
<nav class="floating pinned">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<div class="expandable">
<h3><a href="https://youhogeon-meritz.github.io/calls-and-functions.html#top"><font papago-translate="splitted"><font papago-translate="translated">호출 및 기능</font></font><small>24</small></a></h3>
<ul>
<li><a href="https://youhogeon-meritz.github.io/calls-and-functions.html#function-objects"><small>24.1</small><font papago-translate="splitted"><font papago-translate="translated"> 함수 객체</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/calls-and-functions.html#compiling-to-function-objects"><small>24.2</small><font papago-translate="splitted"><font papago-translate="translated"> 함수 객체로 컴파일하기</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/calls-and-functions.html#call-frames"><small>24.3</small><font papago-translate="splitted"><font papago-translate="translated"> 통화 프레임</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/calls-and-functions.html#function-declarations"><small>24.4</small><font papago-translate="splitted"><font papago-translate="translated"> 함수 선언</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/calls-and-functions.html#function-calls"><small>24.5</small><font papago-translate="splitted"><font papago-translate="translated"> 함수 호출</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/calls-and-functions.html#return-statements"><small>24.6</small><font papago-translate="splitted"><font papago-translate="translated"> 반품 명세서</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/calls-and-functions.html#native-functions"><small>24.7</small><font papago-translate="splitted"><font papago-translate="translated"> 네이티브 함수</font></font></a></li>
<li class="divider"></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/calls-and-functions.html#challenges">Challenges</a></li>
</ul>
<div class="prev-next">
<a class="left" href="https://youhogeon-meritz.github.io/jumping-back-and-forth.html" title="Jumping Back and Forth">←&nbsp;Previous</a>
<a href="https://youhogeon-meritz.github.io/a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">↑&nbsp;Up</a>
<a class="right" href="https://youhogeon-meritz.github.io/closures.html" title="Closures">Next&nbsp;→</a>
</div> </div>
<a id="expand-nav">≡</a>
</nav>
</div>
<article class="chapter">
<div class="number">24</div>
<h1><font papago-translate="translated">호출 및 기능</font></h1>
<blockquote>
<p><font papago-translate="translated">컴퓨터 과학의 모든 문제는 또 다른 차원의 간접적인 방법으로 해결할 수 있습니다.</font><font papago-translate="translated"> 너무 많은 층위의 간접 문제를 제외하고는.</font></p>
<p><cite>David Wheeler</cite></p>
</blockquote>
<p><font papago-translate="translated">이 장은 짐승입니다.</font><font papago-translate="translated"> 저는 특징을 한 입 크기로 쪼개려고 노력하지만, 가끔<span name="eat">은 한 끼</span>를 통째로 삼켜야 할 때도 있습니다.</font><font papago-translate="translated"> 다음 과제는 함수입니다.</font><font papago-translate="translated"> 함수 선언으로만 시작할 수 있지만, 호출할 수 없을 때는 그다지 유용하지 않습니다.</font><font papago-translate="translated"> 우리는 전화를 할 수 있지만, 전화할 것이 없습니다.</font><font papago-translate="translated"> 그리고 VM에서 두 가지를 모두 지원하는 데 필요한 모든 런타임 지원은 눈에 보이는 것과 연결되지 않으면 큰 보람이 없습니다.</font><font papago-translate="translated"> 그래서 우리는 모든 것을 할 것입니다.</font><font papago-translate="translated"> 많지만 끝나면 기분이 좋아질 것입니다.</font></p>
<aside name="eat" style="top: 400px;">
<p><font papago-translate="translated">먹는 것, 즉 소비는 창의<span class="em"></span><span class="em"></span>적인 행위에 대한 이상한 비유입니다.</font><font papago-translate="translated"> 하지만 "산출"을 생성하는 대부분의 생물학적 과정은 조금 덜 화려하고 장식적입니다.</font></p>
</aside>
<h2><a href="https://youhogeon-meritz.github.io/calls-and-functions.html#function-objects" id="function-objects"><small><font papago-translate="translated">24 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">함수 객체</font></font></a></h2>
<p><font papago-translate="translated">VM에서 가장 흥미로운 구조적 변화는 스택 주변에 있습니다.</font><font papago-translate="translated"> 우리는 이미 지역 변수와 임시 변수들을 위한 스택을<em> 가지고</em> 있어서, 이제 막 그곳에 도착했습니다.</font><font papago-translate="translated"> <em>하지만 우리는 콜</em> 스택에 대한 개념이 없습니다.</font><font papago-translate="translated"> 큰 진전을 이루기 전에, 우리는 그것을 고쳐야 할 것입니다.</font><font papago-translate="translated"> 하지만 먼저 코드를 작성해 보겠습니다.</font><font papago-translate="translated"> 움직이기 시작하면 항상 기분이 좋아집니다.</font><font papago-translate="translated"> 함수에 대한 표현 없이는 많은 것을 할 수 없으므로 여기서부터 시작하겠습니다.</font><font papago-translate="translated"> VM의 관점에서 기능이란 무엇인가요?</font></p>
<p><font papago-translate="translated">함수에는 실행할 수 있는 본체가 있으므로 바이트코드가 있습니다.</font><font papago-translate="translated"> 전체 프로그램과 모든 함수 선언을 하나의 큰 단일 청크로 컴파일할 수 있습니다.</font><font papago-translate="translated"> 각 함수는 청크 내부에서 코드의 첫 번째 명령어에 대한 포인터를 가질 것입니다.</font></p>
<p><font papago-translate="translated">네이티브 코드에 대한 컴파일은 대략 이렇게 작동하며, 결국 하나의 견고한 기계 코드 덩어리를 얻게 됩니다.</font><font papago-translate="translated"> 하지만 바이트코드 VM의 경우 조금 더 높은 수준의 작업을 수행할 수 있습니다.</font><font papago-translate="translated"> 더 깨끗한 모델은 각 함수에 고유한 청크를 부여하는 것이라고 생각합니다.</font><font papago-translate="translated"> 다른 메타데이터도 필요하니 이제 모든 것을 구조로 정리해 보겠습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  struct Obj* next;
};
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em></em>구조 Obj 뒤에 추가</font></font></div>
<pre class="insert" translate="no">
<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">Obj</span> <span class="i">obj</span>;
  <span class="t">int</span> <span class="i">arity</span>;
  <span class="t">Chunk</span> <span class="i">chunk</span>;
  <span class="t">ObjString</span>* <span class="i">name</span>;
} <span class="t">ObjFunction</span>;
</pre><pre class="insert-after" translate="no">
struct ObjString {
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after struct <em>Obj</em></div>
<p><font papago-translate="splitted"><font papago-translate="translated">함수는 Lox에서 1등급이므로 실제 Lox 객체여야 합니다.</font><font papago-translate="translated"> 따라서 ObjFunction은 모든 객체 유형이 공유하는 동일한 Obj 헤더를 가지고 있습니다.</font><font papago-translate="translated"> 그 </font></font><code translate="no">arity</code><font papago-translate="splitted"><font papago-translate="translated"> 필드는 함수가 기대하는 매개변수의 수를 저장합니다.</font><font papago-translate="translated"> 그런 다음 청크 외에도 함수<span name="name">의 이름</span>을 저장합니다.</font><font papago-translate="translated"> 읽기 쉬운 런타임 오류를 보고하는 데 유용할 것입니다.</font></font></p>
<aside name="name" style="top: 1388px;">
<p><font papago-translate="translated">인간은 크래시 덤프에서 숫자 바이트코드 오프셋이 특별히 밝다고 생각하지 않는 것 같습니다.</font></p>
</aside>
<p><font papago-translate="translated">"객체" 모듈이 청크를 참조해야 하는 것은 이번이 처음이므로 포함 항목을 얻게 됩니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#include "common.h"
</pre><div class="source-file"><em><font papago-translate="translated">객체.h</font></em></div>
<pre class="insert" translate="no"><span class="a">#include "chunk.h"</span>
</pre><pre class="insert-after" translate="no">#include "value.h"
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>
<p><font papago-translate="translated">문자열에서와 마찬가지로, 우리는 C에서 Lox 함수를 더 쉽게 사용할 수 있도록 몇 가지 액세서리를 정의합니다.</font><font papago-translate="translated"> 일종의 가난한 사람의 사물 지향.</font><font papago-translate="translated"> 먼저, 새로운 Lox 함수를 만들기 위해 C 함수를 선언하겠습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  uint32_t hash;
};

</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 구조 Ob<em>jString</em> 뒤에 추가</font></font></div>
<pre class="insert" translate="no"><span class="t">ObjFunction</span>* <span class="i">newFunction</span>();
</pre><pre class="insert-after" translate="no">ObjString* takeString(char* chars, int length);
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after struct <em>ObjString</em></div>
<p><font papago-translate="translated">구현은 여기에 있습니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>할당</em> 후 추가O<em>bject</em>()</font></font></div>
<pre translate="no"><span class="t">ObjFunction</span>* <span class="i">newFunction</span>() {
  <span class="t">ObjFunction</span>* <span class="i">function</span> = <span class="a">ALLOCATE_OBJ</span>(<span class="t">ObjFunction</span>, <span class="a">OBJ_FUNCTION</span>);
  <span class="i">function</span>-&gt;<span class="i">arity</span> = <span class="n">0</span>;
  <span class="i">function</span>-&gt;<span class="i">name</span> = <span class="a">NULL</span>;
  <span class="i">initChunk</span>(&amp;<span class="i">function</span>-&gt;<span class="i">chunk</span>);
  <span class="k">return</span> <span class="i">function</span>;
}
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, add after <em>allocateObject</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">우리는 친구를 사용합니다 </font></font><code translate="no">ALLOCATE_OBJ()</code><font papago-translate="splitted"><font papago-translate="translated"> VM이 어떤 유형의 객체인지 알 수 있도록 메모리를 할당하고 객체의 헤더를 초기화합니다.</font><font papago-translate="translated"> ObjString처럼 함수를 초기화하기 위해 인수를 전달하는 대신, 함수를 영점, 이름 없음,<span class="em"></span> 코드 없음 등 일종의 빈 상태로 설정했습니다.</font><font papago-translate="translated"> 그것은 함수가 생성된 후 나중에 채워질 것입니다.</font></font></p>
<p><font papago-translate="translated">새로운 종류의 객체가 있으므로 열거형에서 새로운 객체 유형이 필요합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">typedef enum {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> enum Ob<em>jType</em>에서</font></font></div>
<pre class="insert" translate="no">  <span class="a">OBJ_FUNCTION</span>,
</pre><pre class="insert-after" translate="no">  OBJ_STRING,
} ObjType;
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, in enum <em>ObjType</em></div>
<p><font papago-translate="translated">함수 객체가 끝나면, 그 객체가 빌린 비트를 다시 운영 체제로 반환해야 합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  switch (object-&gt;type) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>free</em>O<em>bject</em>()에서</font></font></div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="a">OBJ_FUNCTION</span>: {
      <span class="t">ObjFunction</span>* <span class="i">function</span> = (<span class="t">ObjFunction</span>*)<span class="i">object</span>;
      <span class="i">freeChunk</span>(&amp;<span class="i">function</span>-&gt;<span class="i">chunk</span>);
      <span class="a">FREE</span>(<span class="t">ObjFunction</span>, <span class="i">object</span>);
      <span class="k">break</span>;
    }
</pre><pre class="insert-after" translate="no">    case OBJ_STRING: {
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>freeObject</em>()</div>
<p><font papago-translate="translated">이 스위치 케이스는 ObjFunction 자체뿐만 아니라<span name="free-name"></span> 소유하고 있는 다른 메모리도 해방시키는 역할을 합니다.</font><font papago-translate="translated"> 함수는 자신의 청크를 소유하므로 청크의 파괴자와 같은 함수라고 부릅니다.</font></p>
<aside name="free-name" style="top: 2576px;">
<p><font papago-translate="translated">ObjString이기 때문에 함수의 이름을 명시적으로 해제할 필요는 없습니다.</font><font papago-translate="translated"> 즉, 쓰레기 수거업체가 수명을 관리할 수 있도록 할 수 있습니다.</font><font papago-translate="translated"> 적어도<a href="https://youhogeon-meritz.github.io/garbage-collection.html"> 쓰레기 수거기를 도입</a>하면 가능할 것입니다.</font></p>
</aside>
<p><font papago-translate="translated">Lox는 모든 객체를 인쇄할 수 있게 해주며, 함수는 일류 객체이므로 이를 처리해야 합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  switch (OBJ_TYPE(value)) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>print</em>O<em>bject</em>()에서</font></font></div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="a">OBJ_FUNCTION</span>:
      <span class="i">printFunction</span>(<span class="a">AS_FUNCTION</span>(<span class="i">value</span>));
      <span class="k">break</span>;
</pre><pre class="insert-after" translate="no">    case OBJ_STRING:
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>printObject</em>()</div>
<p><font papago-translate="translated">이것은 다음과 같습니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>copy</em>St<em>ring</em>() 다음에 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">printFunction</span>(<span class="t">ObjFunction</span>* <span class="i">function</span>) {
  <span class="i">printf</span>(<span class="s">"&lt;fn %s&gt;"</span>, <span class="i">function</span>-&gt;<span class="i">name</span>-&gt;<span class="i">chars</span>);
}
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, add after <em>copyString</em>()</div>
<p><font papago-translate="translated">함수는 자신의 이름을 알고 있으므로 말할 수도 있습니다.</font></p>
<p><font papago-translate="translated">마지막으로, 값을 함수로 변환하기 위한 몇 가지 매크로가 있습니다.</font><font papago-translate="translated"> 먼저, 당신의 가치가 실제로 함수<em>인지</em> 확인하세요.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#define OBJ_TYPE(value)        (AS_OBJ(value)-&gt;type)

</pre><div class="source-file"><em><font papago-translate="translated">객체.h</font></em></div>
<pre class="insert" translate="no"><span class="a">#define IS_FUNCTION(value)     isObjType(value, OBJ_FUNCTION)</span>
</pre><pre class="insert-after" translate="no">#define IS_STRING(value)       isObjType(value, OBJ_STRING)
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>
<p><font papago-translate="translated">그것이 사실로 평가된다고 가정하면, 이를 사용하여 값을 ObjFunction 포인터에 안전하게 캐스팅할 수 있습니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#define IS_STRING(value)       isObjType(value, OBJ_STRING)

</pre><div class="source-file"><em><font papago-translate="translated">객체.h</font></em></div>
<pre class="insert" translate="no"><span class="a">#define AS_FUNCTION(value)     ((ObjFunction*)AS_OBJ(value))</span>
</pre><pre class="insert-after" translate="no">#define AS_STRING(value)       ((ObjString*)AS_OBJ(value))
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>
<p><font papago-translate="translated">이를 통해 객체 모델은 함수를 표현하는 방법을 알고 있습니다.</font><font papago-translate="translated"> 이제 몸이 풀린 것 같아요.</font><font papago-translate="translated"> 조금 더 어려운 일을 할 준비가 되셨나요?</font></p>
<h2><a href="https://youhogeon-meritz.github.io/calls-and-functions.html#compiling-to-function-objects" id="compiling-to-function-objects"><small><font papago-translate="translated">24 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">함수 객체로 컴파일하기</font></font></a></h2>
<p><font papago-translate="translated">현재 저희 컴파일러는 항상 하나의 청크로 컴파일된다고 가정하고 있습니다.</font><font papago-translate="translated"> 각 함수의 코드가 개별적인 덩어리로 저장되면, 그것은 더욱 복잡해집니다.</font><font papago-translate="translated"> 컴파일러가 함수 선언에 도달하면, 함수의 본문을 컴파일할 때 함수의 청크에 코드를 보내야 합니다.</font><font papago-translate="translated"> 함수 본문이 끝나면 컴파일러는 이전에 작업하던 청크로 돌아가야 합니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">함수체 내부의 코드는 괜찮지만 그렇지 않은 코드는 어떨까요?</font><font papago-translate="translated"> Lox 프로그램의 "상위 레벨"도 필수 코드이며, 이를 컴파일하려면 청크가 필요합니다.</font><font papago-translate="translated"> 컴파일러와 VM도 자동으로 정의된 함수 안에 최상위 코드를 배치하여 단순화할 수 있습니다.</font><font papago-translate="translated"> 그렇게 하면 컴파일러는 항상 어떤 종류의 함수 본문 내에 있으며, VM은 항상 함수를 호출하여 코드를 실행합니다.</font><font papago-translate="translated"> 마치 프로그램 전체<span name="wrap">가</span> 암묵적으로<span name="wrap"> 감싸</span>져 있는 것과 같습니다 </font></font><code translate="no">main()</code><font papago-translate="splitted"><font papago-translate="translated"> 기능.</font></font></p>
<aside name="wrap" style="top: 3808px;">
<p><font papago-translate="translated">그 비유가 무너지는 의미론적인 한 구석은 전역 변수입니다.</font><font papago-translate="translated"> 그들은 지역 변수와는 다른 특별한 범위 규칙을 가지고 있기 때문에, 그런 식으로 스크립트의 최상위 단계는 함수체와 같지 않습니다.</font></p>
</aside>
<p><font papago-translate="translated">사용자 정의 함수에 도달하기 전에, 그 암묵적인 최상위 함수를 지원하기 위해 재구성을 해보겠습니다.</font><font papago-translate="translated"> 컴파일러 구조로 시작합니다.</font><font papago-translate="translated"> 컴파일러가 쓰는 청크를 직접 가리키는 대신, 빌드 중인 함수 객체에 대한 참조가 있습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">typedef struct {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 구조<em> 컴파일</em>러에서</font></font></div>
<pre class="insert" translate="no">  <span class="t">ObjFunction</span>* <span class="i">function</span>;
  <span class="t">FunctionType</span> <span class="i">type</span>;

</pre><pre class="insert-after" translate="no">  Local locals[UINT8_COUNT];
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in struct <em>Compiler</em></div>
<p><font papago-translate="translated">저희는 또한 작은 기능도 있습니다</font><font papago-translate="translated">enum을 입력합니다.</font><font papago-translate="translated"> 이를 통해 컴파일러는 최상위 코드를 컴파일할 때와 함수의 본문을 구분할 수 있습니다.</font><font papago-translate="translated"> 대부분의 컴파일러는 이것에 대해 신경 쓰지 않습니다. 그래서 유용한 추상화입니다. 하지만 한두 군데에서는 그 구분이<span class="em"></span><span class="em"></span> 의미가 있습니다.</font><font papago-translate="translated"> 나중에 하나에 도착할 것입니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em></em>구조 후 로컬 추가</font></font></div>
<pre translate="no"><span class="k">typedef</span> <span class="k">enum</span> {
  <span class="a">TYPE_FUNCTION</span>,
  <span class="a">TYPE_SCRIPT</span>
} <span class="t">FunctionType</span>;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after struct <em>Local</em></div>
<p><font papago-translate="splitted"><font papago-translate="translated">컴파일러에서 청크에 글을 쓰던 모든 곳이 이제 그 과정을 거쳐야 합니다 </font></font><code translate="no">function</code><font papago-translate="splitted"><font papago-translate="translated"> 포인터.</font><font papago-translate="translated"> 다행히도, 여러<span name="current"> 장</span> 전에 우리는 다음과 같은 장소에서 청크에 대한 접근을 캡슐화했습니다 </font></font><code translate="no">currentChunk()</code><font papago-translate="splitted"><font papago-translate="translated"> 기능.</font><font papago-translate="translated"> 우리는 그것을 고치기만 하면 나머지 컴파일러들은 행복합니다.</font></font></p>
<aside name="current" style="top: 4372px;">
<p><font papago-translate="translated">마치 미래를 내다볼 수 있는 수정 구슬을 가지고 있다가 나중에 코드를 바꿔야 한다는 것을 알게 된 것과 같습니다.</font><font papago-translate="translated"> 하지만 정말로, 그것은 제가 책의 모든 코드를 텍스트 이전에 작성했기 때문입니다.</font></p>
</aside>
<div class="codehilite"><pre class="insert-before" translate="no">Compiler* current = NULL;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 가변<em> 전류</em> 후에 추가</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 5줄 교체</font></font></div>
<pre class="insert" translate="no">
<span class="k">static</span> <span class="t">Chunk</span>* <span class="i">currentChunk</span>() {
  <span class="k">return</span> &amp;<span class="i">current</span>-&gt;<span class="i">function</span>-&gt;<span class="i">chunk</span>;
}
</pre><pre class="insert-after" translate="no">
static void errorAt(Token* token, const char* message) {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after variable <em>current</em>, replace 5 lines</div>
<p><font papago-translate="translated">현재 청크는 항상 컴파일 중인 함수가 소유한 청크입니다.</font><font papago-translate="translated"> 다음으로, 우리는 실제로 그 기능을 만들어야 합니다.</font><font papago-translate="translated"> 이전에 VM은 코드로 채워진 청크를 컴파일러에 전달했습니다.</font><font papago-translate="translated"> 대신, 컴파일러는 사용자<span class="em"></span><span class="em"></span> 프로그램의 컴파일된 최상위 코드를 포함하는 함수를 생성하고 반환할 것입니다. 이 함수는 현재 우리가 지원하는 모든 것입니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/calls-and-functions.html#creating-functions-at-compile-time" id="creating-functions-at-compile-time"><small><font papago-translate="translated">24 . 2 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">컴파일 시 함수 생성</font></font></a></h3>
<p><font papago-translate="splitted"><font papago-translate="translated">우리는 이것을 꿰뚫기 시작합니다 </font></font><code translate="no">compile()</code><font papago-translate="splitted"><font papago-translate="translated">, 컴파일러의 주요 진입점입니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  Compiler compiler;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>컴파일</em> ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 두 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">  <span class="i">initCompiler</span>(&amp;<span class="i">compiler</span>, <span class="a">TYPE_SCRIPT</span>);
</pre><pre class="insert-after" translate="no">
  parser.hadError = false;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>compile</em>(), replace 2 lines</div>
<p><font papago-translate="translated">컴파일러가 초기화되는 방식에는 많은 변화가 있습니다.</font><font papago-translate="translated"> 먼저, 새로운 컴파일러 필드를 초기화합니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 함수<em> initCompiler</em>()</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">initCompiler</span>(<span class="t">Compiler</span>* <span class="i">compiler</span>, <span class="t">FunctionType</span> <span class="i">type</span>) {
  <span class="i">compiler</span>-&gt;<span class="i">function</span> = <span class="a">NULL</span>;
  <span class="i">compiler</span>-&gt;<span class="i">type</span> = <span class="i">type</span>;
</pre><pre class="insert-after" translate="no">  compiler-&gt;localCount = 0;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, function <em>initCompiler</em>(), replace 1 line</div>
<p><font papago-translate="translated">그런 다음 컴파일할 새 함수 객체를 할당합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  compiler-&gt;scopeDepth = 0;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>initCompiler</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="i">compiler</span>-&gt;<span class="i">function</span> = <span class="i">newFunction</span>();
</pre><pre class="insert-after" translate="no">  current = compiler;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>initCompiler</em>()</div>
<p><span name="null"></span></p>
<aside name="null" style="top: 5330px;">
<p><font papago-translate="splitted"><font papago-translate="translated">알아요, 무효화하는 것이 어리석게 보입니다 </font></font><code translate="no">function</code><font papago-translate="splitted"><font papago-translate="translated"> 필드는 몇 줄 후에 즉시 값을 할당합니다.</font><font papago-translate="translated"> 더 많은 쓰레기 수거 관련 편집증.</font></font></p>
</aside>
<p><font papago-translate="translated">컴파일러에서 ObjFunction을 만드는 것은 조금 이상하게 보일 수 있습니다.</font><font papago-translate="translated"> 함수 객체는 함수<em>의 런타임</em> 표현이지만, 여기서는 컴파일 시에 함수를 생성합니다.</font><font papago-translate="translated"> 그것을 생각하는 방법은 함수가 문자열이나 숫자 리터럴과 유사하다는 것입니다.</font><font papago-translate="translated"> 컴파일 시간과 런타임 세계를 연결하는 다리를 형성합니다.</font><font papago-translate="translated"> 함수<em> 선언에</em> 도달하면, 그것들은 실제로 리터럴<em> 형식</em>의<span class="em"></span> 값을 생성하는 표기법입니다.</font><font papago-translate="translated"> <span name="closure">그래서 컴파일</span>러는 컴파일 중에 함수 객체를 생성합니다.</font><font papago-translate="translated"> 그런 다음 런타임에 간단히 호출됩니다.</font></p>
<aside name="closure" style="top: 5452px;">
<p><font papago-translate="translated">컴파일 시 사용 가능한 데이터만 포함되어 있기 때문에 컴파일 시 함수를 만들 수 있습니다.</font><font papago-translate="translated"> 함수의 코드, 이름, 그리고 순열은 모두 고정되어 있습니다.</font><font papago-translate="translated"> 다음<a href="https://youhogeon-meritz.github.io/closures.html"> 장</a>에 변수를 런타임에 캡처하는 클로저를 추가하면 이야기가 더 복잡해집니다.</font></p>
</aside>
<p><font papago-translate="translated">여기 또 다른 이상한 코드 조각이 있습니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  current = compiler;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>initCompiler</em>()에서</font></font></div>
<pre class="insert" translate="no">
  <span class="t">Local</span>* <span class="i">local</span> = &amp;<span class="i">current</span>-&gt;<span class="i">locals</span>[<span class="i">current</span>-&gt;<span class="i">localCount</span>++];
  <span class="i">local</span>-&gt;<span class="i">depth</span> = <span class="n">0</span>;
  <span class="i">local</span>-&gt;<span class="i">name</span>.<span class="i">start</span> = <span class="s">""</span>;
  <span class="i">local</span>-&gt;<span class="i">name</span>.<span class="i">length</span> = <span class="n">0</span>;
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>initCompiler</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">컴파일러의 </font></font><code translate="no">locals</code><font papago-translate="splitted"><font papago-translate="translated"> 배열은 어떤 스택 슬롯이 어떤 로컬 변수나 임시 변수와 연결되어 있는지 추적합니다.</font><font papago-translate="translated"> 이제부터 컴파일러는 VM 자체의 내부 용도로 스택 슬롯 0을 암묵적으로 주장합니다.</font><font papago-translate="translated"> 사용자가 이를 참조하는 식별자를 작성할 수 없도록 빈 이름을 부여합니다.</font><font papago-translate="translated"> 이것이 유용해지면 무엇에 관한 것인지 설명해 드리겠습니다.</font></font></p>
<p><font papago-translate="translated">이것이 초기화 측면입니다.</font><font papago-translate="translated"> 코드 컴파일을 마치면 반대편에도 몇 가지 변경 사항이 필요합니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 함수<em> endCompiler</em>()</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no"><span class="k">static</span> <span class="t">ObjFunction</span>* <span class="i">endCompiler</span>() {
</pre><pre class="insert-after" translate="no">  emitReturn();
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, function <em>endCompiler</em>(), replace 1 line</div>
<p><font papago-translate="splitted"><font papago-translate="translated">이전에, 언제 </font></font><code translate="no">interpret()</code><font papago-translate="splitted"><font papago-translate="translated"> 컴파일러에 호출되어 작성할 청크로 전달되었습니다.</font><font papago-translate="translated"> 이제 컴파일러가 함수 객체를 직접 생성하므로 해당 함수를 반환합니다.</font><font papago-translate="translated"> 현재 컴파일러에서 가져옵니다:</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  emitReturn();
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>endCompiler</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="t">ObjFunction</span>* <span class="i">function</span> = <span class="i">current</span>-&gt;<span class="i">function</span>;

</pre><pre class="insert-after" translate="no">#ifdef DEBUG_PRINT_CODE
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>endCompiler</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">그리고 그것을 반환합니다 </font></font><code translate="no">compile()</code><font papago-translate="splitted"><font papago-translate="translated"> 이렇게:</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#endif
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>endCompiler</em>()에서</font></font></div>
<pre class="insert" translate="no">
  <span class="k">return</span> <span class="i">function</span>;
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>endCompiler</em>()</div>
<p><font papago-translate="translated">지금이 이 기능을 다시 조정하기에 좋은 시기입니다.</font><font papago-translate="translated"> 이전에 우리는 VM이 분해된 바이트코드를 덤프하도록 진단 코드를 추가하여 컴파일러를 디버깅할 수 있도록 했습니다.</font><font papago-translate="translated"> 생성된 청크가 함수로 감싸져 있으므로 계속 작동하도록 수정해야 합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#ifdef DEBUG_PRINT_CODE
  if (!parser.hadError) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>endCompiler</em>()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">    <span class="i">disassembleChunk</span>(<span class="i">currentChunk</span>(), <span class="i">function</span>-&gt;<span class="i">name</span> != <span class="a">NULL</span>
        ? <span class="i">function</span>-&gt;<span class="i">name</span>-&gt;<span class="i">chars</span> : <span class="s">"&lt;script&gt;"</span>);
</pre><pre class="insert-after" translate="no">  }
#endif
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>endCompiler</em>(), replace 1 line</div>
<p><font papago-translate="splitted"><font papago-translate="translated">여기 체크 인을 확인하여 함수의 이름이 다음과 같은지 확인하세요 </font></font><code translate="no">NULL</code><font papago-translate="splitted"><font papago-translate="translated">? 사용자 정의 함수에는 이름이 있지만 최상위 코드에 대해 생성하는 암묵적 함수에는 이름이 없으며, 자체 진단 코드에서도 이를 우아하게 처리해야 합니다.</font><font papago-translate="translated"> 말이 나와서 말인데요:</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">static void printFunction(ObjFunction* function) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>인쇄 기능</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="k">if</span> (<span class="i">function</span>-&gt;<span class="i">name</span> == <span class="a">NULL</span>) {
    <span class="i">printf</span>(<span class="s">"&lt;script&gt;"</span>);
    <span class="k">return</span>;
  }
</pre><pre class="insert-after" translate="no">  printf("&lt;fn %s&gt;", function-&gt;name-&gt;chars);
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>printFunction</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated"><em>사용자가</em> 최상위 함수에 대한 참조를 받아 인쇄하려고 할 수 있는 방법은 없지만, 우리의 </font></font><code translate="no">DEBUG_TRACE_EXECUTION</code> <font papago-translate="splitted"><font papago-translate="translated">전체 스택을 인쇄할 수 있는<span name="debug"> 진단</span> 코드<span name="debug">입니다</span>.</font></font></p>
<aside name="debug" style="top: 6920px;">
<p><font papago-translate="translated">버그를 찾기 위해 사용하는 진단 코드가 VM에 결함을 일으키면 재미가 없습니다!</font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">레벨 업 투 </font></font><code translate="no">compile()</code><font papago-translate="splitted"><font papago-translate="translated">, 우리는 그것의 서명을 조정합니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#include "vm.h"

</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 함수<em> 컴파일</em> ()</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no"><span class="t">ObjFunction</span>* <span class="i">compile</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">source</span>);
</pre><pre class="insert-after" translate="no">
#endif
</pre></div>
<div class="source-file-narrow"><em>compiler.h</em>, function <em>compile</em>(), replace 1 line</div>
<p><font papago-translate="translated">청크를 가져가는 대신 이제 함수를 반환합니다.</font><font papago-translate="translated"> 구현 완료:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 함수<em> 컴파일</em> ()</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no"><span class="t">ObjFunction</span>* <span class="i">compile</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">source</span>) {
</pre><pre class="insert-after" translate="no">  initScanner(source);
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, function <em>compile</em>(), replace 1 line</div>
<p><font papago-translate="translated">마침내 실제 코드에 도달했습니다.</font><font papago-translate="translated"> 함수의 맨 끝을 다음과 같이 변경합니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  while (!match(TOKEN_EOF)) {
    declaration();
  }

</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>컴파일</em> ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 두 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">  <span class="t">ObjFunction</span>* <span class="i">function</span> = <span class="i">endCompiler</span>();
  <span class="k">return</span> <span class="i">parser</span>.<span class="i">hadError</span> ? <span class="a">NULL</span> : <span class="i">function</span>;
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>compile</em>(), replace 2 lines</div>
<p><font papago-translate="splitted"><font papago-translate="translated">컴파일러에서 함수 객체를 가져옵니다.</font><font papago-translate="translated"> 컴파일 오류가 없는 경우 반환합니다.</font><font papago-translate="translated"> 그렇지 않으면 다음과 같이 오류를 신호합니다 </font></font><code translate="no">NULL</code><font papago-translate="splitted"><font papago-translate="translated">. 이렇게 하면 VM이 잘못된 바이트코드를 포함할 수 있는 기능을 실행하려고 하지 않습니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">결국, 우리는 업데이트할 것입니다 </font></font><code translate="no">interpret()</code><font papago-translate="splitted"><font papago-translate="translated"> 새로운 선언을 처리하기 위해 </font></font><code translate="no">compile()</code><font papago-translate="splitted"><font papago-translate="translated">, 하지만 먼저 몇 가지 다른 변경 사항이 있습니다.</font></font></p>
<h2><a href="https://youhogeon-meritz.github.io/calls-and-functions.html#call-frames" id="call-frames"><small><font papago-translate="translated">24 . 3</font></small><font papago-translate="splitted"><font papago-translate="translated">통화 프레임</font></font></a></h2>
<p><font papago-translate="translated">큰 개념적 도약의 시간입니다.</font><font papago-translate="translated"> 함수 선언과 호출을 구현하기 전에 VM이 이를 처리할 준비를 해야 합니다.</font><font papago-translate="translated"> 우리가 걱정해야 할 두 가지 주요 문제가 있습니다:</font></p>
<h3><a href="https://youhogeon-meritz.github.io/calls-and-functions.html#allocating-local-variables" id="allocating-local-variables"><small><font papago-translate="translated">24 . 3 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">지역 변수 할당</font></font></a></h3>
<p><font papago-translate="translated">컴파일러는 로컬 변수에 스택 슬롯을 할당합니다.</font><font papago-translate="translated"> 프로그램의 로컬 변수 집합이 여러 함수에 걸쳐 분포되어 있을 때 어떻게 작동해야 하나요?</font></p>
<p><font papago-translate="translated">한 가지 옵션은 완전히 분리된 상태로 유지하는 것입니다.</font><font papago-translate="translated"> 각 함수는 함수가 호출되지 않더라도<span name="static"> VM</span> 스택에서<span name="static"> 영원히</span> 소유할 수 있는 전용 슬롯 세트를 얻게 됩니다.</font><font papago-translate="translated"> 전체 프로그램의 각 로컬 변수는 VM에 약간의 메모리를 가지고 있으며, 이 메모리는 자체적으로 유지됩니다.</font></p>
<aside name="static" style="top: 8112px;">
<p><font papago-translate="splitted"><font papago-translate="translated">C 프로그램의 모든 로컬 변수를 다음과 같이 선언하면 기본적으로 얻을 수 있는 결과입니다 </font></font><code translate="no">static</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p>
</aside>
<p><font papago-translate="translated">믿기 어렵겠지만, 초기 프로그래밍 언어 구현은 이렇게 작동했습니다.</font><font papago-translate="translated"> 최초의 포트란 컴파일러는 각 변수에 대해 정적으로 메모리를 할당했습니다.</font><font papago-translate="translated"> 명백한 문제는 그것이 정말 비효율적이라는 것입니다.</font><font papago-translate="translated"> 대부분의 기능은 어느 시점에서든 호출되지 않기 때문에 사용되지 않은 메모리에 앉아 있는 것은 낭비입니다.</font></p>
<p><font papago-translate="translated">하지만 더 근본적인 문제는 재귀입니다.</font><font papago-translate="translated"> 재귀를 사용하면 동일한 기능에 여러 통화를 동시에 "인"할 수 있습니다.</font><font papago-translate="translated"> 각각은 지역<span name="fortran"></span> 변수에 대한 고유한 메모리가 필요합니다.</font><font papago-translate="translated"> Jlox에서는 함수가 호출되거나 블록이 입력될 때마다 환경에 동적으로 메모리를 할당하여 이 문제를 해결했습니다.</font><font papago-translate="translated"> clox에서는 모든 함수 호출에 대해 그런 종류의 성능 비용을 원하지 않습니다.</font></p>
<aside name="fortran" style="top: 8376px;">
<p><font papago-translate="translated">포트란은 재귀를 완전히 허용하지 않음으로써 이 문제를 피할 수 있었습니다.</font><font papago-translate="translated"> 당시 재귀는 고급 난해한 특징으로 여겨졌습니다.</font></p>
</aside>
<p><font papago-translate="translated">대신, 우리의 해결책은 포트란의 정적 할당과 젝스의 동적 접근 방식 사이 어딘가에 있습니다.</font><font papago-translate="translated"> VM의 가치 스택은 로컬 변수와 임시 변수가 처음부터 끝까지 행동한다는 관찰을 기반으로 작동합니다.</font><font papago-translate="translated"> 다행히도 함수 호출을 믹스에 추가해도 여전히 사실입니다.</font><font papago-translate="translated"> 다음은 예시입니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">fun</span> <span class="i">first</span>() {
  <span class="k">var</span> <span class="i">a</span> = <span class="n">1</span>;
  <span class="i">second</span>();
  <span class="k">var</span> <span class="i">b</span> = <span class="n">2</span>;
}

<span class="k">fun</span> <span class="i">second</span>() {
  <span class="k">var</span> <span class="i">c</span> = <span class="n">3</span>;
  <span class="k">var</span> <span class="i">d</span> = <span class="n">4</span>;
}

<span class="i">first</span>();
</pre></div>
<p><font papago-translate="translated">프로그램을 단계별로 살펴보고 각 시점에서 메모리에 있는 변수를 확인합니다:</font></p><img alt="Tracing through the execution of the previous program, showing the stack of variables at each step." src="https://youhogeon-meritz.github.io/image/calls-and-functions/calls.png">
<p><font papago-translate="splitted"><font papago-translate="translated">실행이 두 호출을 통해 흐를 때, 모든 로컬 변수는 첫 번째 변수가 되기 전에 선언된 변수는 폐기된다는 원칙을 따릅니다.</font><font papago-translate="translated"> 이는 통화 중에도 마찬가지입니다.</font><font papago-translate="translated"> 우리는 끝날 것이라는 것을 알고 있습니다 </font></font><code translate="no">c</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">d</code><font papago-translate="splitted"><font papago-translate="translated"> 끝나기 전에 </font></font><code translate="no">a</code><font papago-translate="splitted"><font papago-translate="translated">. VM의 가치 스택에 로컬 변수를 할당할 수 있어야 할 것 같습니다.</font></font></p>
<p><font papago-translate="translated">이상적으로는 컴파일 시 각 변수가 스택<em>에서 어디</em>로 이동할지 여전히 결정합니다.</font><font papago-translate="translated"> 이를 통해 변수 작업을 위한 바이트코드 지침을 간단하고 빠르게 유지할 수 있습니다.</font><font papago-translate="translated"> 위의 예시에서 우리는 그렇게<span name="imagine"> 하는 것을 쉽게 상상</span>할 수 있지만, 그것이 항상 잘 되는 것은 아닙니다.</font><font papago-translate="translated"> 고려:</font></p>
<aside name="imagine" style="top: 9393.5px;">
<p><font papago-translate="translated">컴파일러가 실제로 이 문제를 해결할 수 없기 때문에 저는 "상상"이라고 말합니다.</font><font papago-translate="translated"> 함수는 Lox에서 첫 번째 클래스이기 때문에 컴파일 시 어떤 함수가 다른 함수를 호출하는지 결정할 수 없습니다.</font></p>
</aside>
<div class="codehilite"><pre translate="no"><span class="k">fun</span> <span class="i">first</span>() {
  <span class="k">var</span> <span class="i">a</span> = <span class="n">1</span>;
  <span class="i">second</span>();
  <span class="k">var</span> <span class="i">b</span> = <span class="n">2</span>;
  <span class="i">second</span>();
}

<span class="k">fun</span> <span class="i">second</span>() {
  <span class="k">var</span> <span class="i">c</span> = <span class="n">3</span>;
  <span class="k">var</span> <span class="i">d</span> = <span class="n">4</span>;
}

<span class="i">first</span>();
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">첫 번째 통화에서 </font></font><code translate="no">second()</code><font papago-translate="splitted"><font papago-translate="translated">, </font></font><code translate="no">c</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">d</code><font papago-translate="splitted"><font papago-translate="translated"> 슬롯 1과 슬롯 2에 들어갑니다.</font><font papago-translate="translated"> 하지만 두 번째 통화에서는 공간을 확보해야 합니다 </font></font><code translate="no">b</code><font papago-translate="splitted"><font papago-translate="translated">,그렇게 </font></font><code translate="no">c</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">d</code><font papago-translate="splitted"><font papago-translate="translated"> 슬롯 2와 3에 있어야 합니다.</font><font papago-translate="translated"> 따라서 컴파일러는 함수 호출에서 각 로컬 변수에 대한 정확한 슬롯을 고정할 수 없습니다.</font><font papago-translate="translated"> 그러나 주어진 함수<em> 내에서</em> 각 지역 변수<em>의 상대</em>적 위치는 고정되어 있습니다.</font><font papago-translate="translated"> 변수 </font></font><code translate="no">d</code><font papago-translate="splitted"><font papago-translate="translated"> 항상 바로 다음 슬롯에 있습니다 </font></font><code translate="no">c</code><font papago-translate="splitted"><font papago-translate="translated">. 이것이 핵심 인사이트입니다.</font></font></p>
<p><font papago-translate="translated">함수가 호출될 때, 서로 다른 맥락에서 호출될 수 있기 때문에 스택의 상단이 어디에 있을지 알 수 없습니다.</font><font papago-translate="translated"> 하지만, 그 정점이 어디에 있든, 우리는 함수의 모든 지역 변수가 그 시작점을 기준으로 어디에 있는지 알고 있습니다.</font><font papago-translate="translated"> 그래서 많은 문제들처럼, 우리는 우리의 할당 문제를 어느 정도의 간접적인 방식으로 해결합니다.</font></p>
<p><font papago-translate="translated">각 함수 호출이 시작될 때마다 VM은 해당 함수의 로컬이 시작되는 첫 번째 슬롯의 위치를 기록합니다.</font><font papago-translate="translated"> 로컬 변수를 다루는 지침은 오늘날처럼 스택의 하단에 상대적으로 접근하는 대신 슬롯 인덱스를 기준으로 접근합니다.</font><font papago-translate="translated"> 컴파일 시, 우리는 그 상대 슬롯들을 계산합니다.</font><font papago-translate="translated"> 런타임 시 함수 호출의 시작 슬롯을 추가하여 상대 슬롯을 절대 스택 인덱스로 변환합니다.</font></p>
<p><font papago-translate="translated">마치 함수가 로컬을 저장할 수 있는 더 큰 스택 내에 "창문" 또는 "프레임"을 얻는 것과 같습니다.</font><font papago-translate="translated"> <strong>호출 프레임</strong>의 위치는 런타임에 결정되지만, 해당 영역 내에서 그리고 그 영역과 관련하여 우리는 어디에서 물건을 찾을 수 있는지 알고 있습니다.</font></p><img alt="The stack at the two points when second() is called, with a window hovering over each one showing the pair of stack slots used by the function." src="https://youhogeon-meritz.github.io/image/calls-and-functions/window.png">
<p><font papago-translate="translated">함수의 로컬이 시작되는 이 기록된 위치의 역사적인 이름은<strong> 함수</strong> 호출 프레임의 시작을 가리키기 때문에<strong> 프레임 포인터</strong>입니다.</font><font papago-translate="translated"> <strong>때때로 기본 포인터</strong>가 들리는 이유는 함수의 모든 변수가 있는 기본 스택 슬롯 위를 가리키기 때문입니다.</font></p>
<p><font papago-translate="translated">그것이 우리가 추적해야 할 첫 번째 데이터입니다.</font><font papago-translate="translated"> 함수를 호출할 때마다 VM은 해당 함수의 변수가 시작되는 첫 번째 스택 슬롯을 결정합니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/calls-and-functions.html#return-addresses" id="return-addresses"><small><font papago-translate="translated">24 . 3 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">반송 주소</font></font></a></h3>
<p><font papago-translate="splitted"><font papago-translate="translated">현재 VM은 명령어 스트림을 통해 다음과 같은 작업을 수행합니다 </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated"> 들판.</font><font papago-translate="translated"> 유일하게 흥미로운 동작은 다음을 상쇄하는 제어 흐름 명령어에 관한 것입니다 </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated"> 더 많은 양으로.</font><font papago-translate="translated"> 함수<em> 호출</em>은 매우 간단합니다—<span class="em"></span>단순히 설정됩니다 </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated"> 해당 함수의 청크에 있는 첫 번째 명령을 가리키기 위해.</font><font papago-translate="translated"> 하지만 기능이 완료되면 어떻게 되나요?</font></font></p>
<p><font papago-translate="translated">VM은 함수가 호출된 청크로<span name="return"> 돌아가서</span> 호출 직후 명령어로 실행을 재개해야 합니다.</font><font papago-translate="translated"> 따라서 각 함수 호출마다 호출이 완료되면 어디로 다시 이동하는지 추적해야 합니다.</font><font papago-translate="translated"> 이것은 호출 후 VM이 반환하는 명령어의 주소이기 때문에<strong> 반환 주소</strong>라고 불립니다.</font></p>
<p><font papago-translate="translated">다시 말해서, 재귀 덕분에 단일 함수에 대해 여러 개의 반환 주소가 있을 수 있으므로, 이것은 함수 자체가 아니라 각<em> 호출</em>의 속성입니다.</font></p>
<aside name="return" style="top: 11043.5px;">
<p><font papago-translate="translated">초기 포트란 컴파일러의 저자들은 반환 주소를 구현하는 영리한 방법을 가지고 있었습니다.</font><font papago-translate="translated"> 그들은 재귀를 지원<em>하지</em> 않았기 때문에, 주어진 함수는 어느 시점에서든 하나의 반환 주소만 필요했습니다.</font><font papago-translate="translated"> 따라서 런타임에 함수가 호출되면 프로그램<em>은 함수</em>의 끝에 있는 점프 명령을 변경하여 호출자에게 다시 점프하도록<em> 자체 코드를 수정</em>합니다.</font><font papago-translate="translated"> 때때로 천재성과 광기의 경계는 머리카락이 가늘기도 합니다.</font></p>
</aside>
<h3><a href="https://youhogeon-meritz.github.io/calls-and-functions.html#the-call-stack" id="the-call-stack"><small><font papago-translate="translated">24 . 3 . 3</font></small><font papago-translate="splitted"><font papago-translate="translated">콜 스택</font></font></a></h3>
<p><font papago-translate="translated">따라서 각 실시간 함수 호출(아직 돌아오지 않은 각 호출)에 대해 해당 함수의 로컬이 스택에서 시작되는 위치와 호출자<span class="em"></span><span class="em"></span>가 다시 시작해야 하는 위치를 추적해야 합니다.</font><font papago-translate="translated"> 이것을 다른 것들과 함께 새로운 구조에 넣을 것입니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#define STACK_MAX 256
</pre><div class="source-file"><em><font papago-translate="translated">VM.h</font></em></div>
<pre class="insert" translate="no">
<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">ObjFunction</span>* <span class="i">function</span>;
  <span class="t">uint8_t</span>* <span class="i">ip</span>;
  <span class="t">Value</span>* <span class="i">slots</span>;
} <span class="t">CallFrame</span>;
</pre><pre class="insert-after" translate="no">
typedef struct {
</pre></div>
<div class="source-file-narrow"><em>vm.h</em></div>
<p><font papago-translate="splitted"><font papago-translate="translated">콜프레임은 하나의 진행 중인 함수 호출을 나타냅니다.</font><font papago-translate="translated"> 그 </font></font><code translate="no">slots</code><font papago-translate="splitted"><font papago-translate="translated"> 필드는 이 함수가 사용할 수 있는 첫 번째 슬롯에서 VM의 값 스택을 가리킵니다.</font><font papago-translate="translated"> C의 이상한 "포인터는 일종의 배열" 덕분에<span class="em"></span><span class="em"></span> 배열처럼 취급할 수 있기 때문에 복수형 이름을 붙였습니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">반품 주소의 구현 방식은 제가 위에서 설명한 것과 조금 다릅니다.</font><font papago-translate="translated"> 발신자는 발신자의 프레임에 반환 주소를 저장하는 대신 자신의 주소를 저장합니다 </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated">. 함수에서 돌아오면 VM이 다음과 같이 이동합니다 </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated"> 발신자의 콜프레임 및 거기서부터 재개합니다.</font></font></p>
<p><font papago-translate="translated">여기에 호출되는 함수에 대한 포인터도 채웠습니다.</font><font papago-translate="translated"> 그것을 사용하여 상수를 찾고 몇 가지 다른 것들을 찾아보겠습니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">함수가 호출될 때마다 우리는 이러한 구조 중 하나를 만듭니다.</font><font papago-translate="translated"> 힙에<span name="heap"> 동적</span>으로 할당할 수는 있지만 속도가 느립니다.</font><font papago-translate="translated"> 함수 호출은 핵심 작업이므로 가능한 한 빨리 해야 합니다.</font><font papago-translate="translated"> 다행히도 변수에 대해서도 동일한 관찰을 할 수 있습니다: 함수 호출에는 스택 의미가 있습니다. 만약 </font></font><code translate="no">first()</code><font papago-translate="splitted"><font papago-translate="translated"> 호출 </font></font><code translate="no">second()</code><font papago-translate="splitted"><font papago-translate="translated">, 로의 부름 </font></font><code translate="no">second()</code><font papago-translate="splitted"><font papago-translate="translated"> 이전에 완료됩니다 </font></font><code translate="no">first()</code><font papago-translate="splitted"><font papago-translate="translated"> 한다.</font></font></p>
<aside name="heap" style="top: 11967.5px;">
<p><font papago-translate="translated">많은 리스프 구현은<a href="https://en.wikipedia.org/wiki/Continuation"> 연속 구현</a>을 단순화하기 때문에 스택 프레임을 동적으로 할당합니다.</font><font papago-translate="translated"> 당신의 언어가 연속을 지원한다면, 함수 호출이 항상 스택 의미를 가지는<em> 것은 아닙니다</em>.</font></p>
</aside>
<p><font papago-translate="translated">그래서 VM에서는 이러한 CallFrame 구조의 배열을 앞쪽에 만들어 값 배열과 마찬가지로 스택으로 취급합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">typedef struct {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">VM.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em></em>구조 VM에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 두 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">  <span class="t">CallFrame</span> <span class="i">frames</span>[<span class="a">FRAMES_MAX</span>];
  <span class="t">int</span> <span class="i">frameCount</span>;

</pre><pre class="insert-after" translate="no">  Value stack[STACK_MAX];
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, in struct <em>VM</em>, replace 2 lines</div>
<p><font papago-translate="splitted"><font papago-translate="translated">이 배열은 다음을 대체합니다 </font></font><code translate="no">chunk</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated"> 우리가 VM에 직접 있던 필드들.</font><font papago-translate="translated"> 이제 각 콜프레임마다 고유한 기능이 있습니다 </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고 실행 중인 ObjFunction에 대한 자체 포인터.</font><font papago-translate="translated"> 거기서부터 함수의 청크에 도달할 수 있습니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">새로운 </font></font><code translate="no">frameCount</code><font papago-translate="splitted"><font papago-translate="translated"> VM의 필드는 CallFrame 스택의 현재 높이, 즉 진행 중인 함수<span class="em"></span> 호출의 수를 저장합니다.</font><font papago-translate="translated"> 클록스를 간단하게 유지하기 위해 배열의 용량은 고정되어 있습니다.</font><font papago-translate="translated"> 이는 많은 언어 구현에서와 마찬가지로 우리가 처리할 수 있는 최대 통화 깊이가 있다는 것을 의미합니다.</font><font papago-translate="translated"> clox의 경우, 여기서 정의됩니다:</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#include "value.h"

</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">VM.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no"><span class="a">#define FRAMES_MAX 64</span>
<span class="a">#define STACK_MAX (FRAMES_MAX * UINT8_COUNT)</span>
</pre><pre class="insert-after" translate="no">
typedef struct {
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, replace 1 line</div>
<p><font papago-translate="translated">또한 매우 깊은 호출 트리에서도 충분한 스택 슬롯을 확보할 수 있도록 가치 스택<span name="plenty">의 크기</span>를 재정의합니다.</font><font papago-translate="translated"> VM이 시작되면 CallFrame 스택이 비어 있습니다.</font></p>
<aside name="plenty" style="top: 12667.5px;">
<p><font papago-translate="translated">충분한 함수 호출이 로컬 외에도 충분한 임시 호출을 사용한다면 스택을 오버플로할 수 있습니다.</font><font papago-translate="translated"> 강력한 구현은 이를 방지할 수 있지만, 저는 일을 단순하게 하려고 노력하고 있습니다.</font></p>
</aside>
<div class="codehilite"><pre class="insert-before" translate="no">  vm.stackTop = vm.stack;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>리셋스택</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="i">vm</span>.<span class="i">frameCount</span> = <span class="n">0</span>;
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>resetStack</em>()</div>
<p><font papago-translate="translated">"vm.h" 헤더는 ObjFunction에 접근해야 하므로 포함 항목을 추가합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#define clox_vm_h

</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">VM.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no"><span class="a">#include "object.h"</span>
</pre><pre class="insert-after" translate="no">#include "table.h"
</pre></div>
<div class="source-file-narrow"><em>vm.h</em>, replace 1 line</div>
<p><font papago-translate="splitted"><font papago-translate="translated">이제 VM의 구현 파일로 이동할 준비가 되었습니다.</font><font papago-translate="translated"> 우리는 앞으로 몇 가지 힘든 일이 남아 있습니다.</font><font papago-translate="translated"> 이사했습니다 </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated"> VM 구조에서 벗어나 콜프레임으로 전환됩니다.</font><font papago-translate="translated"> VM에서 터치하는 모든 코드 라인을 수정해야 합니다 </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated"> 그것을 처리하기 위해.</font><font papago-translate="translated"> 또한 스택 슬롯별로 로컬 변수에 액세스하는 지침은 현재 CallFrame의 지침과 비교하여 업데이트해야 합니다 </font></font><code translate="no">slots</code><font papago-translate="splitted"><font papago-translate="translated"> 들판.</font></font></p>
<p><font papago-translate="translated">우리는 맨 위에서 시작해서 그것을 헤쳐 나갈 것입니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">static InterpretResult run() {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 4줄 교체</font></font></div>
<pre class="insert" translate="no">  <span class="t">CallFrame</span>* <span class="i">frame</span> = &amp;<span class="i">vm</span>.<span class="i">frames</span>[<span class="i">vm</span>.<span class="i">frameCount</span> - <span class="n">1</span>];

<span class="a">#define READ_BYTE() (*frame-&gt;ip++)</span>

<span class="a">#define READ_SHORT() \</span>
<span class="a">    (frame-&gt;ip += 2, \</span>
<span class="a">    (uint16_t)((frame-&gt;ip[-2] &lt;&lt; 8) | frame-&gt;ip[-1]))</span>

<span class="a">#define READ_CONSTANT() \</span>
<span class="a">    (frame-&gt;function-&gt;chunk.constants.values[READ_BYTE()])</span>

</pre><pre class="insert-after" translate="no">#define READ_STRING() AS_STRING(READ_CONSTANT())
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 4 lines</div>
<p><font papago-translate="splitted"><font papago-translate="translated">먼저, 현재 최상위 CallFrame을 메인 바이트코드 실행 함수 내부<span name="local">의 로컬</span> 변수에 저장합니다.</font><font papago-translate="translated"> 그런 다음 바이트코드 액세스 매크로를 액세스할 수 있는 버전으로 교체합니다 </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated"> 그 변수를 통해.</font></font></p>
<aside name="local" style="top: 13475.5px;">
<p><font papago-translate="splitted"><font papago-translate="translated">우리는 매번 CallFrame 배열을 통해 현재 프레임에 접근할 수 있었지만, 그것은 장황한 이야기입니다.</font><font papago-translate="translated"> 더 중요한 것은 프레임을 로컬 변수에 저장하는 것이 C 컴파일러가 해당 포인터를 레지스터에 유지하도록 장려한다는 점입니다.</font><font papago-translate="translated"> 프레임에 대한 액세스 속도를 높입니다 </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated">. 컴파일러가 이 작업을 수행할<em> 것이라는 보장</em>은 없지만, 그럴 가능성이 높습니다.</font></font></p>
</aside>
<p><font papago-translate="translated">이제 약간의 애정 어린 보살핌이 필요한 각 지침에 대해 말씀드리겠습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      case OP_GET_LOCAL: {
        uint8_t slot = READ_BYTE();
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">        <span class="i">push</span>(<span class="i">frame</span>-&gt;<span class="i">slots</span>[<span class="i">slot</span>]);
</pre><pre class="insert-after" translate="no">        break;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 1 line</div>
<p><font papago-translate="splitted"><font papago-translate="translated">이전에. </font></font><code translate="no">OP_GET_LOCAL</code><font papago-translate="splitted"><font papago-translate="translated"> 주어진 로컬 슬롯을 VM의 스택 배열에서 직접 읽었기 때문에 스택 하단부터 슬롯을 인덱싱했습니다.</font><font papago-translate="translated"> 이제 현재 프레임의 </font></font><code translate="no">slots</code><font papago-translate="splitted"><font papago-translate="translated"> 배열은 해당 프레임의 시작 부분을 기준으로 주어진 번호 슬롯에 접근한다는 것을 의미합니다.</font></font></p>
<p><font papago-translate="translated">로컬 변수를 설정하는 것도 같은 방식으로 작동합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      case OP_SET_LOCAL: {
        uint8_t slot = READ_BYTE();
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">        <span class="i">frame</span>-&gt;<span class="i">slots</span>[<span class="i">slot</span>] = <span class="i">peek</span>(<span class="n">0</span>);
</pre><pre class="insert-after" translate="no">        break;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 1 line</div>
<p><font papago-translate="splitted"><font papago-translate="translated">VM을 수정하는 데 사용되는 점프 지침 </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated"> 들판.</font><font papago-translate="translated"> 이제 현재 프레임의 </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      case OP_JUMP: {
        uint16_t offset = READ_SHORT();
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">        <span class="i">frame</span>-&gt;<span class="i">ip</span> += <span class="i">offset</span>;
</pre><pre class="insert-after" translate="no">        break;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 1 line</div>
<p><font papago-translate="translated">조건부 점프도 마찬가지입니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      case OP_JUMP_IF_FALSE: {
        uint16_t offset = READ_SHORT();
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">        <span class="k">if</span> (<span class="i">isFalsey</span>(<span class="i">peek</span>(<span class="n">0</span>))) <span class="i">frame</span>-&gt;<span class="i">ip</span> += <span class="i">offset</span>;
</pre><pre class="insert-after" translate="no">        break;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 1 line</div>
<p><font papago-translate="translated">그리고 우리의 후진 점프 루프 지침:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      case OP_LOOP: {
        uint16_t offset = READ_SHORT();
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">        <span class="i">frame</span>-&gt;<span class="i">ip</span> -= <span class="i">offset</span>;
</pre><pre class="insert-after" translate="no">        break;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 1 line</div>
<p><font papago-translate="translated">각 명령어가 실행될 때 출력되는 진단 코드가 있어 VM을 디버깅하는 데 도움이 됩니다.</font><font papago-translate="translated"> 그것도 새로운 구조와 함께 작동해야 합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    printf("\n");
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 두 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">    <span class="i">disassembleInstruction</span>(&amp;<span class="i">frame</span>-&gt;<span class="i">function</span>-&gt;<span class="i">chunk</span>,
        (<span class="t">int</span>)(<span class="i">frame</span>-&gt;<span class="i">ip</span> - <span class="i">frame</span>-&gt;<span class="i">function</span>-&gt;<span class="i">chunk</span>.<span class="i">code</span>));
</pre><pre class="insert-after" translate="no">#endif
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 2 lines</div>
<p><font papago-translate="splitted"><font papago-translate="translated">VM을 전달하는 대신 </font></font><code translate="no">chunk</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated"> 필드, 이제 현재 CallFrame에서 읽습니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">사실 그렇게 나쁘지 않았어요.</font><font papago-translate="translated"> 대부분의 지침은 매크로만 사용하므로 손댈 필요가 없습니다.</font><font papago-translate="translated"> 다음으로, 우리는 다음을 호출하는 코드로 한 단계 업그레이드합니다 </font></font><code translate="no">run()</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">InterpretResult interpret(const char* source) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>해석</em>상 ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 10줄 교체</font></font></div>
<pre class="insert" translate="no">  <span class="t">ObjFunction</span>* <span class="i">function</span> = <span class="i">compile</span>(<span class="i">source</span>);
  <span class="k">if</span> (<span class="i">function</span> == <span class="a">NULL</span>) <span class="k">return</span> <span class="a">INTERPRET_COMPILE_ERROR</span>;

  <span class="i">push</span>(<span class="a">OBJ_VAL</span>(<span class="i">function</span>));
  <span class="t">CallFrame</span>* <span class="i">frame</span> = &amp;<span class="i">vm</span>.<span class="i">frames</span>[<span class="i">vm</span>.<span class="i">frameCount</span>++];
  <span class="i">frame</span>-&gt;<span class="i">function</span> = <span class="i">function</span>;
  <span class="i">frame</span>-&gt;<span class="i">ip</span> = <span class="i">function</span>-&gt;<span class="i">chunk</span>.<span class="i">code</span>;
  <span class="i">frame</span>-&gt;<span class="i">slots</span> = <span class="i">vm</span>.<span class="i">stack</span>;
</pre><pre class="insert-after" translate="no">
  InterpretResult result = run();
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>interpret</em>(), replace 10 lines</div>
<p><font papago-translate="splitted"><font papago-translate="translated">마침내 우리는 방금 한 백엔드 변경 사항에 대한 이전 컴파일러 변경 사항을 연결할 수 있게 되었습니다.</font><font papago-translate="translated"> 먼저 소스 코드를 컴파일러에 전달합니다.</font><font papago-translate="translated"> 컴파일된 최상위 코드가 포함된 새로운 ObjFunction을 반환합니다.</font><font papago-translate="translated"> 만약 우리가 </font></font><code translate="no">NULL</code><font papago-translate="splitted"><font papago-translate="translated"> 다시 말해, 컴파일러가 이미 보고한 컴파일 타임 오류가 있었다는 뜻입니다.</font><font papago-translate="translated"> 그런 경우에는 아무것도 실행할 수 없기 때문에 구제금융을 받습니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">그렇지 않으면 함수를 스택에 저장하고 코드를 실행할 초기 CallFrame을 준비합니다.</font><font papago-translate="translated"> 이제 컴파일러가<span class="em"></span> 호출되는 함수를 저장하는 스택 슬롯 0을 따로 설정하는 이유를 알 수 있습니다.</font><font papago-translate="translated"> 새로운 CallFrame에서는 함수를 가리키며 초기화합니다 </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated"> 함수의 바이트코드 시작을 가리키고, VM의 값 스택 맨 아래에서 시작하도록 스택 창을 설정합니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">이렇게 하면 통역사가 코드 실행을 시작할 준비가 됩니다.</font><font papago-translate="translated"> 완료 후 VM은 하드코딩된 청크를 해제하는 데 사용되었습니다.</font><font papago-translate="translated"> 이제 ObjFunction이 해당 코드를 소유하고 있으므로 더 이상 그렇게 할 필요가 없으므로 끝입니다 </font></font><code translate="no">interpret()</code><font papago-translate="splitted"><font papago-translate="translated"> 이것은 단순히 이것입니다:</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  frame-&gt;slots = vm.stack;

</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>해석</em>상 ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 4줄 교체</font></font></div>
<pre class="insert" translate="no">  <span class="k">return</span> <span class="i">run</span>();
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>interpret</em>(), replace 4 lines</div>
<p><font papago-translate="splitted"><font papago-translate="translated">이전 VM 필드를 참조하는 마지막 코드 조각은 다음과 같습니다 </font></font><code translate="no">runtimeError()</code><font papago-translate="splitted"><font papago-translate="translated">. 그 부분은 나중에 장에서 다시 다루겠지만, 지금은 이렇게 변경해 보겠습니다:</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  fputs("\n", stderr);

</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런타임</em>에<em>Error</em>()</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 두 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">  <span class="t">CallFrame</span>* <span class="i">frame</span> = &amp;<span class="i">vm</span>.<span class="i">frames</span>[<span class="i">vm</span>.<span class="i">frameCount</span> - <span class="n">1</span>];
  <span class="t">size_t</span> <span class="i">instruction</span> = <span class="i">frame</span>-&gt;<span class="i">ip</span> - <span class="i">frame</span>-&gt;<span class="i">function</span>-&gt;<span class="i">chunk</span>.<span class="i">code</span> - <span class="n">1</span>;
  <span class="t">int</span> <span class="i">line</span> = <span class="i">frame</span>-&gt;<span class="i">function</span>-&gt;<span class="i">chunk</span>.<span class="i">lines</span>[<span class="i">instruction</span>];
</pre><pre class="insert-after" translate="no">  fprintf(stderr, "[line %d] in script\n", line);
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>runtimeError</em>(), replace 2 lines</div>
<p><font papago-translate="splitted"><font papago-translate="translated">청크를 읽는 대신에 </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated"> VM에서 직접 스택의 맨 위에 있는 CallFrame에서 가져옵니다.</font><font papago-translate="translated"> 그렇게 하면 기능이 다시 작동하여 이전처럼 작동할 것입니다.</font></font></p>
<p><font papago-translate="translated">우리가 이 모든 것을 올바르게 수행했다고 가정하면, clox는 다시 실행 가능한 상태로 돌아갑니다.</font><font papago-translate="translated"> 불을 붙이면 이전과 똑같이 작동합니다<span class="ellipse">.</span></font><font papago-translate="translated"> 아직 새로운 기능을 추가하지 않았기 때문에 다소 실망스럽습니다.</font><font papago-translate="translated"> 하지만 모든 인프라는 이제 우리를 위해 준비되어 있습니다.</font><font papago-translate="translated"> 활용해 보겠습니다.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/calls-and-functions.html#function-declarations" id="function-declarations"><small><font papago-translate="translated">24 . 4</font></small><font papago-translate="splitted"><font papago-translate="translated">함수 선언</font></font></a></h2>
<p><font papago-translate="translated">호출 표현을 하기 전에 호출할 것이 필요하므로 함수 선언을 먼저 수행합니다.</font><font papago-translate="translated"> <span name="fun">재미</span>는 키워드로 시작됩니다.</font></p>
<aside name="fun" style="top: 16103.5px;">
<p><font papago-translate="splitted"><font papago-translate="translated">네, 저는 그것에 대해 멍청한 농담을 하려고 합니다 </font></font><code translate="no">fun</code><font papago-translate="splitted"><font papago-translate="translated"> 키워드가 나올 때마다.</font></font></p>
</aside>
<div class="codehilite"><pre class="insert-before" translate="no">static void declaration() {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>선언</em>문 ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">  <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_FUN</span>)) {
    <span class="i">funDeclaration</span>();
  } <span class="k">else</span> <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_VAR</span>)) {
</pre><pre class="insert-after" translate="no">    varDeclaration();
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>declaration</em>(), replace 1 line</div>
<p><font papago-translate="translated">이는 여기까지 제어할 수 있습니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>블록</em> () 후 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">funDeclaration</span>() {
  <span class="t">uint8_t</span> <span class="i">global</span> = <span class="i">parseVariable</span>(<span class="s">"Expect function name."</span>);
  <span class="i">markInitialized</span>();
  <span class="i">function</span>(<span class="a">TYPE_FUNCTION</span>);
  <span class="i">defineVariable</span>(<span class="i">global</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>block</em>()</div>
<p><font papago-translate="translated">함수는 일급 값이며, 함수 선언은 단순히 새로 선언된 변수에 하나를 생성하고 저장합니다.</font><font papago-translate="translated"> 그래서 우리는 다른 변수 선언과 마찬가지로 이름을 구문 분석합니다.</font><font papago-translate="translated"> 최상위 수준의 함수 선언은 함수를 전역 변수에 바인딩합니다.</font><font papago-translate="translated"> 블록이나 다른 함수 내부에서 함수 선언은 로컬 변수를 생성합니다.</font></p>
<p><font papago-translate="translated">이전 장에서 변수가<a href="https://youhogeon-meritz.github.io/local-variables.html#another-scope-edge-case"> 두 단계로 정의</a>되는 방법을 설명했습니다.</font><font papago-translate="translated"> 이렇게 하면 변수 자체 초기화기 내에서 변수의 값에 접근할 수 없습니다.</font><font papago-translate="translated"> 변수에<em></em> 아직 값이 없기 때문에 좋지 않을 것입니다.</font></p>
<p><font papago-translate="translated">함수들은 이 문제를 겪지 않습니다.</font><font papago-translate="translated"> 기능이 몸 안에서 자신의 이름을 부르는 것은 안전합니다.</font><font papago-translate="translated"> 함수<em>가</em> 완전히 정의된 후에야 함수<em>를 호출</em>하고 본문을 실행할 수 있으므로 초기화되지 않은 상태에서는 변수를 볼 수 없습니다.</font><font papago-translate="translated"> 실질적으로 말하자면, 재귀적인 로컬 함수를 지원하기 위해 이를 허용하는 것이 유용합니다.</font></p>
<p><font papago-translate="translated">이를 위해 이름을 컴파일하기 전에 함수 선언의 변수를 "초기화됨"으로 표시한 후 본문을 컴파일합니다.</font><font papago-translate="translated"> 그렇게 하면 오류를 발생시키지 않고 이름을 몸 안에서 참조할 수 있습니다.</font></p>
<p><font papago-translate="translated">하지만 한 번의 점검이 필요합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">static void markInitialized() {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>표시</em>된</font><font papago-translate="translated"><em>초기화</em>됨()</font></font></div>
<pre class="insert" translate="no">  <span class="k">if</span> (<span class="i">current</span>-&gt;<span class="i">scopeDepth</span> == <span class="n">0</span>) <span class="k">return</span>;
</pre><pre class="insert-after" translate="no">  current-&gt;locals[current-&gt;localCount - 1].depth =
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>markInitialized</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">이전에 우리는 전화했습니다 </font></font><code translate="no">markInitialized()</code><font papago-translate="splitted"><font papago-translate="translated"> 우리가 이미 지역 범위 내에 있다는 것을 알았을 때만.</font><font papago-translate="translated"> 이제 최상위 함수 선언도 이 함수라고 부를 것입니다.</font><font papago-translate="translated"> 그런 경우 초기화된 것으로 표시할 로컬 변수가 없으며, 함수는 전역<span class="em"></span> 변수에 바인딩되어 있습니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">다음으로, 함수 자체인 매개변수 목록과 블록<span class="em"></span> 본문을 컴파일합니다.</font><font papago-translate="translated"> 이를 위해 별도의 도우미 기능을 사용합니다.</font><font papago-translate="translated"> 그 도우미는 결과 함수 객체를 스택 위에 남겨두는 코드를 생성합니다.</font><font papago-translate="translated"> 그 후에, 우리는 전화합니다 </font></font><code translate="no">defineVariable()</code><font papago-translate="splitted"><font papago-translate="translated"> 그 함수를 우리가 선언한 변수에 다시 저장하는 것.</font></font></p>
<p><font papago-translate="translated">나중에 클래스 내에서 메서드 선언을 구문 분석하는 데 재사용할 것이기 때문에 매개변수와 본문을 컴파일하기 위해 코드를 분리했습니다.</font><font papago-translate="translated"> 이것부터 시작하여 점진적으로 구축해 보겠습니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>블록</em> () 후 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">function</span>(<span class="t">FunctionType</span> <span class="i">type</span>) {
  <span class="t">Compiler</span> <span class="i">compiler</span>;
  <span class="i">initCompiler</span>(&amp;<span class="i">compiler</span>, <span class="i">type</span>);
  <span class="i">beginScope</span>();<span name="no-end-scope"> </span>

  <span class="i">consume</span>(<span class="a">TOKEN_LEFT_PAREN</span>, <span class="s">"Expect '(' after function name."</span>);
  <span class="i">consume</span>(<span class="a">TOKEN_RIGHT_PAREN</span>, <span class="s">"Expect ')' after parameters."</span>);
  <span class="i">consume</span>(<span class="a">TOKEN_LEFT_BRACE</span>, <span class="s">"Expect '{' before function body."</span>);
  <span class="i">block</span>();

  <span class="t">ObjFunction</span>* <span class="i">function</span> = <span class="i">endCompiler</span>();
  <span class="i">emitBytes</span>(<span class="a">OP_CONSTANT</span>, <span class="i">makeConstant</span>(<span class="a">OBJ_VAL</span>(<span class="i">function</span>)));
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>block</em>()</div>
<aside name="no-end-scope" style="top: 17474.5px;">
<p><font papago-translate="splitted"><font papago-translate="translated">이것. </font></font><code translate="no">beginScope()</code><font papago-translate="splitted"><font papago-translate="translated"> 해당 항목이 없습니다 </font></font><code translate="no">endScope()</code><font papago-translate="splitted"><font papago-translate="translated"> 호출. 함수 본문의 끝에 도달하면 컴파일러를 완전히 종료하기 때문에 남아 있는 가장 바깥쪽 범위를 닫을 필요가 없습니다.</font></font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">지금은 매개변수에 대해 걱정하지 않겠습니다.</font><font papago-translate="translated"> 우리는 빈 괄호 쌍 뒤에 본문을 분석합니다.</font><font papago-translate="translated"> 몸은 왼쪽 곱슬머리로 시작하며, 여기서 우리는 이를 분석합니다.</font><font papago-translate="translated"> 그런 다음 기존 서비스를 호출합니다 </font></font><code translate="no">block()</code><font papago-translate="splitted"><font papago-translate="translated"> 블록의 나머지 부분을 컴파일하는 방법을 알고 있는 함수입니다.</font></font></p>
<h3><a href="https://youhogeon-meritz.github.io/calls-and-functions.html#a-stack-of-compilers" id="a-stack-of-compilers"><small><font papago-translate="translated">24 . 4 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">컴파일러 스택</font></font></a></h3>
<p><font papago-translate="translated">흥미로운 부분은 상단과 하단의 컴파일러 항목입니다.</font><font papago-translate="translated"> 컴파일러 구조는 어떤 슬롯이 어떤 로컬 변수에 의해 소유되는지, 현재 우리가 몇 개의 네스팅 블록에 있는지 등과 같은 데이터를 저장합니다.</font><font papago-translate="translated"> 이 모든 것은 단일 기능에만 해당됩니다.</font><font papago-translate="translated"> 하지만 이제 프론트엔드는<span name="nested"> 서로 중첩된</span> 여러 함수를 컴파일하는 작업을 처리해야 합니다.</font></p>
<aside name="nested" style="top: 18011.5px;">
<p><font papago-translate="translated">컴파일러는 최상위 코드를 암묵적 함수의 본문으로 취급하므로 함수 선언을 추가하자마자 중첩<em></em> 함수의 세계에 도달하게 됩니다.</font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">이를 관리하는 요령은 컴파일되는 각 함수에 대해 별도의 컴파일러를 만드는 것입니다.</font><font papago-translate="translated"> 함수 선언을 컴파일하기 시작하면 C 스택에 새 컴파일러를 생성하고 초기화합니다. </font></font><code translate="no">initCompiler()</code><font papago-translate="splitted"><font papago-translate="translated"> 컴파일러를 현재 컴파일러로 설정합니다.</font><font papago-translate="translated"> 그런 다음 본문을 컴파일할 때 바이트코드를 방출하는 모든 함수가 새 컴파일러 함수가 소유한 청크에 기록됩니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">함수의 블록 본문 끝에 도달한 후 다음과 같이 호출합니다 </font></font><code translate="no">endCompiler()</code><font papago-translate="splitted"><font papago-translate="translated">. 이를 통해 새로 컴파일된 함수 객체가 생성되며<em>,</em> 이를<em> 주변</em> 함수의 상수 테이블에 상수로 저장합니다.</font><font papago-translate="translated"> 하지만 잠깐만요, 주변 기능으로 어떻게 돌아갈 수 있을까요?</font><font papago-translate="translated"> 우리는 그것을 잃어버렸습니다 </font></font><code translate="no">initCompiler()</code><font papago-translate="splitted"><font papago-translate="translated"> 현재 컴파일러 포인터를 덮어썼습니다.</font></font></p>
<p><font papago-translate="translated">우리는 중첩된 컴파일러 구조의 집합을 스택으로 취급하여 이 문제를 해결합니다.</font><font papago-translate="translated"> VM의 Value 및 CallFrame 스택과 달리, 우리는 배열을 사용하지 않을 것입니다.</font><font papago-translate="translated"> 대신에, 우리는 연결된 목록을 사용합니다.</font><font papago-translate="translated"> 각 컴파일러는 컴파일러를 둘러싸고 있는 함수의 컴파일러를 가리키며, 최상위 코드의 루트 컴파일러를 가리키기도 합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">} FunctionType;

</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 열거<em> 함수</em> 뒤에 추가</font><font papago-translate="translated"><em>유형</em></font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no"><span class="k">typedef</span> <span class="k">struct</span> <span class="t">Compiler</span> {
  <span class="k">struct</span> <span class="t">Compiler</span>* <span class="i">enclosing</span>;
</pre><pre class="insert-after" translate="no">  ObjFunction* function;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after enum <em>FunctionType</em>, replace 1 line</div>
<p><font papago-translate="translated">컴파일러 구조 내에서는 아직 선언이 끝나지 않았기 때문에 컴파일<em>러 typedef</em>를 참조할 수 없습니다.</font><font papago-translate="translated"> 대신, 우리는 구조 자체에 이름을 붙이고 그것을 필드 유형에 사용합니다.</font><font papago-translate="translated"> C는 이상합니다.</font></p>
<p><font papago-translate="translated">새 컴파일러를 초기화할 때, 해당 포인터에 현재 컴파일러가 아닌 컴파일러를 캡처합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">static void initCompiler(Compiler* compiler, FunctionType type) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>initCompiler</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="i">compiler</span>-&gt;<span class="i">enclosing</span> = <span class="i">current</span>;
</pre><pre class="insert-after" translate="no">  compiler-&gt;function = NULL;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>initCompiler</em>()</div>
<p><font papago-translate="translated">그런 다음 컴파일러가 완료되면 이전 컴파일러를 새로운 현재 컴파일러로 복원하여 스택에서 스스로 꺼집니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#endif

</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>endCompiler</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="i">current</span> = <span class="i">current</span>-&gt;<span class="i">enclosing</span>;
</pre><pre class="insert-after" translate="no">  return function;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>endCompiler</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">컴파일러 구조를<span name="compiler"> 동적</span>으로 할당할 필요도 없습니다.</font><font papago-translate="translated"> 각각은 C 스택에 로컬 변수로 저장<span class="em"></span>됩니다 </font></font><code translate="no">compile()</code><font papago-translate="splitted"><font papago-translate="translated"> 또는 </font></font><code translate="no">function()</code><font papago-translate="splitted"><font papago-translate="translated">. C 스택을 통한 컴파일러 스레드의 연결된 목록.</font><font papago-translate="translated"> 무한히 많은 수를 얻을 수 있는 이유는 컴파일러가 재귀적 하강법을 사용하기 때문입니다 </font></font><code translate="no">function()</code><font papago-translate="splitted"><font papago-translate="translated"> 중첩 함수 선언이 있을 때 결국 스스로를 재귀적으로 호출하게 됩니다.</font></font></p>
<aside name="compiler" style="top: 19019.5px;">
<p><font papago-translate="translated">컴파일러 구조에 네이티브 스택을 사용한다는 것은 우리 컴파일러가 함수 선언이 얼마나 깊이 중첩될 수 있는지에 대한 실질적인 한계가 있다는 것을 의미합니다.</font><font papago-translate="translated"> 너무 멀리 가면 C 스택이 넘칠 수 있습니다.</font><font papago-translate="translated"> 컴파일러가 병리적이거나 심지어 악성 코드(예: JavaScript VMs와 같은 도구에 대한 실질적인 우려)에 대해 더 견고해지길 원한다면, 컴파일러가<span class="em"></span><span class="em"></span> 허용하는 함수 네스팅의 양을 인위적으로 제한하는 것이 좋을 것입니다.</font></p>
</aside>
<h3><a href="https://youhogeon-meritz.github.io/calls-and-functions.html#function-parameters" id="function-parameters"><small><font papago-translate="translated">24 . 4 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">함수 매개변수</font></font></a></h3>
<p><font papago-translate="translated">인수를 전달할 수 없다면 함수는 그다지 유용하지 않으므로 다음 매개변수를 사용해 보겠습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  consume(TOKEN_LEFT_PAREN, "Expect '(' after function name.");
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>함수</em> ()에서</font></font></div>
<pre class="insert" translate="no">  <span class="k">if</span> (!<span class="i">check</span>(<span class="a">TOKEN_RIGHT_PAREN</span>)) {
    <span class="k">do</span> {
      <span class="i">current</span>-&gt;<span class="i">function</span>-&gt;<span class="i">arity</span>++;
      <span class="k">if</span> (<span class="i">current</span>-&gt;<span class="i">function</span>-&gt;<span class="i">arity</span> &gt; <span class="n">255</span>) {
        <span class="i">errorAtCurrent</span>(<span class="s">"Can't have more than 255 parameters."</span>);
      }
      <span class="t">uint8_t</span> <span class="i">constant</span> = <span class="i">parseVariable</span>(<span class="s">"Expect parameter name."</span>);
      <span class="i">defineVariable</span>(<span class="i">constant</span>);
    } <span class="k">while</span> (<span class="i">match</span>(<span class="a">TOKEN_COMMA</span>));
  }
</pre><pre class="insert-after" translate="no">  consume(TOKEN_RIGHT_PAREN, "Expect ')' after parameters.");
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>function</em>()</div>
<p><font papago-translate="translated">의미론적으로 매개변수는 단순히 함수 본문의 가장 바깥쪽 어휘 범위에 선언된 지역 변수입니다.</font><font papago-translate="translated"> 기존 컴파일러 지원을 사용하여 명명된 로컬 변수를 선언하고 매개변수를 구문 분석 및 컴파일할 수 있습니다.</font><font papago-translate="translated"> 초기화자가 있는 로컬 변수와 달리, 여기에는 매개변수 값을 초기화할 수 있는 코드가 없습니다.</font><font papago-translate="translated"> 함수 호출에서 인수 전달을 할 때 나중에 어떻게 초기화되는지 살펴보겠습니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">우리가 그것을 하는 동안, 우리는 얼마나 많은 매개변수를 분석하는지 세어 함수의 희소성을 주목합니다.</font><font papago-translate="translated"> 함수와 함께 저장하는 또 다른 메타데이터는 함수의 이름입니다.</font><font papago-translate="translated"> 함수 선언을 컴파일할 때 다음과 같이 호출합니다 </font></font><code translate="no">initCompiler()</code><font papago-translate="splitted"><font papago-translate="translated"> 함수의 이름을 구문 분석한 직후에.</font><font papago-translate="translated"> 즉, 이전 토큰에서 바로 이름을 가져올 수 있습니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  current = compiler;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>initCompiler</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="k">if</span> (<span class="i">type</span> != <span class="a">TYPE_SCRIPT</span>) {
    <span class="i">current</span>-&gt;<span class="i">function</span>-&gt;<span class="i">name</span> = <span class="i">copyString</span>(<span class="i">parser</span>.<span class="i">previous</span>.<span class="i">start</span>,
                                         <span class="i">parser</span>.<span class="i">previous</span>.<span class="i">length</span>);
  }
</pre><pre class="insert-after" translate="no">
  Local* local = &amp;current-&gt;locals[current-&gt;localCount++];
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>initCompiler</em>()</div>
<p><font papago-translate="translated">이름 문자열의 복사본을 만드는 데 신중을 기하고 있습니다.</font><font papago-translate="translated"> 기억하세요, 어휘소는 원래 소스 코드 문자열을 직접 가리킵니다.</font><font papago-translate="translated"> 코드 컴파일이 완료되면 해당 문자열이 해제될 수 있습니다.</font><font papago-translate="translated"> 컴파일러에서 생성하는 함수 객체는 컴파일러보다 오래 지속되며 런타임까지 지속됩니다.</font><font papago-translate="translated"> 따라서 보관할 수 있는 자체 힙 할당 이름 문자열이 필요합니다.</font></p>
<p><font papago-translate="translated">Rad. 이제 함수 선언을 다음과 같이 컴파일할 수 있습니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">fun</span> <span class="i">areWeHavingItYet</span>() {
  <span class="k">print</span> <span class="s">"Yes we are!"</span>;
}

<span class="k">print</span> <span class="i">areWeHavingItYet</span>;
</pre></div>
<p><font papago-translate="translated"><span name="useful">우리</span>는 그들과<span name="useful"> 함께 유용한</span> 일을 할 수 없습니다.</font></p>
<aside name="useful" style="top: 20363.5px;">
<p><font papago-translate="translated">인쇄할 수 있습니다!</font><font papago-translate="translated"> 그건 별로 유용하지 않은 것 같아요.</font></p>
</aside>
<h2><a href="https://youhogeon-meritz.github.io/calls-and-functions.html#function-calls" id="function-calls"><small><font papago-translate="translated">24 . 5</font></small><font papago-translate="splitted"><font papago-translate="translated">함수 호출</font></font></a></h2>
<p><font papago-translate="splitted"><font papago-translate="translated">이 섹션이 끝날 때쯤이면 흥미로운 행동이 나타나기 시작할 것입니다.</font><font papago-translate="translated"> 다음 단계는 함수 호출입니다.</font><font papago-translate="translated"> 우리는 보통 이렇게 생각하지 않지만, 함수 호출 표현식은 일종의 인픽스입니다 </font></font><code translate="no">(</code><font papago-translate="splitted"><font papago-translate="translated"> 교환입니다.</font><font papago-translate="translated"> 왼쪽에는 호출되는 항목에 대한 높은 우선순위 표현이 있는데, 보통은 단일<span class="em"></span> 식별자입니다.</font><font papago-translate="translated"> 그러면 </font></font><code translate="no">(</code><font papago-translate="splitted"><font papago-translate="translated"> 중간에 쉼표로 구분된 인수 표현과 마지막 문장이 이어집니다 </font></font><code translate="no">)</code><font papago-translate="splitted"><font papago-translate="translated"> 마지막에 마무리합니다.</font></font></p>
<p><font papago-translate="translated">그 이상한 문법적 관점은 구문을 구문 분석 테이블에 연결하는 방법을 설명합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">ParseRule rules[] = {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>단항</em> () 후에 추가</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">  [<span class="a">TOKEN_LEFT_PAREN</span>]    = {<span class="i">grouping</span>, <span class="i">call</span>,   <span class="a">PREC_CALL</span>},
</pre><pre class="insert-after" translate="no">  [TOKEN_RIGHT_PAREN]   = {NULL,     NULL,   PREC_NONE},
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>unary</em>(), replace 1 line</div>
<p><font papago-translate="translated">파서가 식 뒤에 왼쪽 괄호를 만나면 새로운 파서 함수로 이동합니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>이진</em> () 후에 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">call</span>(<span class="t">bool</span> <span class="i">canAssign</span>) {
  <span class="t">uint8_t</span> <span class="i">argCount</span> = <span class="i">argumentList</span>();
  <span class="i">emitBytes</span>(<span class="a">OP_CALL</span>, <span class="i">argCount</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>binary</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">우리는 이미 </font></font><code translate="no">(</code><font papago-translate="splitted"><font papago-translate="translated"> 토큰을 사용하여 인수를 컴파일합니다 </font></font><code translate="no">argumentList()</code><font papago-translate="splitted"><font papago-translate="translated"> 도우미.</font><font papago-translate="translated"> 그 함수는 컴파일한 인수의 수를 반환합니다.</font><font papago-translate="translated"> 각 인수 표현식은 호출을 준비하기 위해 스택에 값을 남기는 코드를 생성합니다.</font><font papago-translate="translated"> 그 후, 우리는 새로운 것을 방출합니다 </font></font><code translate="no">OP_CALL</code><font papago-translate="splitted"><font papago-translate="translated"> 인수 카운트를 피연산자로 사용하여 함수를 호출하는 명령.</font></font></p>
<p><font papago-translate="translated">우리는 이 친구를 사용하여 논쟁을 정리합니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>변수 정의</em> 후에 추가하기()</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">uint8_t</span> <span class="i">argumentList</span>() {
  <span class="t">uint8_t</span> <span class="i">argCount</span> = <span class="n">0</span>;
  <span class="k">if</span> (!<span class="i">check</span>(<span class="a">TOKEN_RIGHT_PAREN</span>)) {
    <span class="k">do</span> {
      <span class="i">expression</span>();
      <span class="i">argCount</span>++;
    } <span class="k">while</span> (<span class="i">match</span>(<span class="a">TOKEN_COMMA</span>));
  }
  <span class="i">consume</span>(<span class="a">TOKEN_RIGHT_PAREN</span>, <span class="s">"Expect ')' after arguments."</span>);
  <span class="k">return</span> <span class="i">argCount</span>;
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>defineVariable</em>()</div>
<p><font papago-translate="translated">그 코드는 jlox에서 친숙하게 보일 것입니다.</font><font papago-translate="translated"> 우리는 각 표현 뒤에 쉼표를 찾기만 하면 논쟁을 계속합니다.</font><font papago-translate="translated"> 일단 다 떨어지면, 마지막 마무리 괄호를 사용하면 끝입니다.</font></p>
<p><font papago-translate="translated">거의 다 됐어요.</font><font papago-translate="translated"> Jlox로 돌아가서, 우리는 255개 이상의 인수를 호출에 전달하지 않는 컴파일 타임 체크를 추가했습니다.</font><font papago-translate="translated"> 당시 저는 클로크스도 비슷한 한계가 필요하기 때문이라고 말했습니다.</font><font papago-translate="translated"> 이제 그 이유를 알 수 있습니다—인수 카운트를 바이트 코드에 단일 바이트 피연산자로 채우기 때문에<span class="em"></span> 최대 255개까지만 가능합니다.</font><font papago-translate="translated"> 이 컴파일러에서도 이를 확인해야 합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      expression();
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>argumentList</em>()에서</font></font></div>
<pre class="insert" translate="no">      <span class="k">if</span> (<span class="i">argCount</span> == <span class="n">255</span>) {
        <span class="i">error</span>(<span class="s">"Can't have more than 255 arguments."</span>);
      }
</pre><pre class="insert-after" translate="no">      argCount++;
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>argumentList</em>()</div>
<p><font papago-translate="translated">그것이 앞쪽 끝입니다.</font><font papago-translate="translated"> 새로운 지침을 선언하기 위해 중간에 잠깐 멈추고 뒤쪽 끝으로 넘어가 보겠습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  OP_LOOP,
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">청크.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> enum O<em>pCode</em>에서</font></font></div>
<pre class="insert" translate="no">  <span class="a">OP_CALL</span>,
</pre><pre class="insert-after" translate="no">  OP_RETURN,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>
<h3><a href="https://youhogeon-meritz.github.io/calls-and-functions.html#binding-arguments-to-parameters" id="binding-arguments-to-parameters"><small><font papago-translate="translated">24 . 5 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">매개변수에 인수 바인딩</font></font></a></h3>
<p><font papago-translate="translated">구현에 도달하기 전에 호출 지점의 스택이 어떻게 생겼는지, 그리고 거기서 무엇을 해야 하는지 생각해봐야 합니다.</font><font papago-translate="translated"> 호출 명령어에 도달하면 호출 중인 함수에 대한 표현식을 이미 실행한 후 인수가 이어집니다.</font><font papago-translate="translated"> 우리 프로그램이 이렇게 생겼다고 가정해 보겠습니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">fun</span> <span class="i">sum</span>(<span class="i">a</span>, <span class="i">b</span>, <span class="i">c</span>) {
  <span class="k">return</span> <span class="i">a</span> + <span class="i">b</span> + <span class="i">c</span>;
}

<span class="k">print</span> <span class="n">4</span> + <span class="i">sum</span>(<span class="n">5</span>, <span class="n">6</span>, <span class="n">7</span>);
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">VM을 바로 일시 중지하면 </font></font><code translate="no">OP_CALL</code><font papago-translate="splitted"><font papago-translate="translated"> 해당 호출에 대한 지침 </font></font><code translate="no">sum()</code><font papago-translate="splitted"><font papago-translate="translated">, 스택은 다음과 같습니다:</font></font></p><img alt="Stack: 4, fn sum, 5, 6, 7." src="https://youhogeon-meritz.github.io/image/calls-and-functions/argument-stack.png">
<p><font papago-translate="splitted"><font papago-translate="translated">이것을 다음과 같은 관점에서 상상해 보세요 </font></font><code translate="no">sum()</code><font papago-translate="splitted"><font papago-translate="translated"> 그 자체.</font><font papago-translate="translated"> 컴파일러가 컴파일될 때 </font></font><code translate="no">sum()</code><font papago-translate="splitted"><font papago-translate="translated">, 자동으로 슬롯 0을 할당했습니다.</font><font papago-translate="translated"> 그런 다음 매개변수에 로컬 슬롯을 할당했습니다 </font></font><code translate="no">a</code><font papago-translate="splitted"><font papago-translate="translated">, </font></font><code translate="no">b</code><font papago-translate="splitted"><font papago-translate="translated">,그리고. </font></font><code translate="no">c</code><font papago-translate="splitted"><font papago-translate="translated">,유효한.</font><font papago-translate="translated"> 통화를 수행하려면 </font></font><code translate="no">sum()</code><font papago-translate="splitted"><font papago-translate="translated">, 호출되는 함수와 사용할 수 있는 스택 슬롯 영역으로 초기화된 CallFrame이 필요합니다.</font><font papago-translate="translated"> 그런 다음 함수에 전달된 인수를 수집하여 매개변수에 해당하는 슬롯에 넣어야 합니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">VM이 본문을 실행하기 시작할 때 </font></font><code translate="no">sum()</code><font papago-translate="splitted"><font papago-translate="translated">, 스택 창이 다음과 같이 보이기를 원합니다:</font></font></p><img alt="The same stack with the sum() function's call frame window surrounding fn sum, 5, 6, and 7." src="https://youhogeon-meritz.github.io/image/calls-and-functions/parameter-window.png">
<p><font papago-translate="translated">발신자가 설정하는 인수 슬롯과 발신자가 필요로 하는 매개변수 슬롯이 모두 정확한 순서로 정렬되어 있다는 것을 알 수 있습니까?</font><font papago-translate="translated"> 얼마나 편리한가!</font><font papago-translate="translated"> 이것은 우연이 아닙니다.</font><font papago-translate="translated"> 각 CallFrame이 스택에 고유한 창을 가지고 있다고 말할 때, 그 창들이<em> 분리</em>되어 있어야 한다고 말한 적이 없습니다.</font><font papago-translate="translated"> 우리가 그들과 겹치는 것을 막을 수 있는 것은 아무것도 없습니다, 예를 들어:</font></p><img alt="The same stack with the top-level call frame covering the entire stack and the sum() function's call frame window surrounding fn sum, 5, 6, and 7." src="https://youhogeon-meritz.github.io/image/calls-and-functions/overlapping-windows.png">
<p><font papago-translate="translated">호출자의 스택 상단<span name="lua">에는</span> 호출되는 함수와 순서대로 인수가 뒤따르는 함수가 포함되어<span name="lua"> 있습니다.</span></font><font papago-translate="translated"> 인수 표현을 평가할 때 필요한 임시 공간이 이미 폐기되었기 때문에 발신자가 사용 중인 슬롯 위에 다른 슬롯이 없다는 것을 알고 있습니다.</font><font papago-translate="translated"> 호출자의 스택 하단이 겹쳐서 매개변수 슬롯이 인수 값이 이미 있는 위치와 정확히 일치하도록 합니다.</font></p>
<aside name="lua" style="top: 23102px;">
<p><font papago-translate="translated">바이트코드 VM과 실제 CPU 아키텍처마다 인수 전달, 반환 주소 저장 등에 사용되는 특정 메커니즘<em>인 호출 규약</em>이 다릅니다.</font><font papago-translate="translated"> 제가 여기서 사용하는 메커니즘은 Lua의 깨끗하고 빠른 가상 머신을 기반으로 합니다.</font></p>
</aside>
<p><font papago-translate="translated">이는 우리가 "인수를 매개변수에 바인딩"하기 위해<em> 어떤</em> 작업도 할 필요가 없다는 것을 의미합니다.</font><font papago-translate="translated"> 슬롯 간 또는 환경 간에 값을 복사할 수 없습니다.</font><font papago-translate="translated"> 논쟁은 이미 정확히 필요한 위치에 있습니다.</font><font papago-translate="translated"> 성능 면에서 그것을 이기기는 어렵습니다.</font></p>
<p><font papago-translate="translated">통화 지침을 구현할 시간입니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      }
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font></div>
<pre class="insert" translate="no">      <span class="k">case</span> <span class="a">OP_CALL</span>: {
        <span class="t">int</span> <span class="i">argCount</span> = <span class="a">READ_BYTE</span>();
        <span class="k">if</span> (!<span class="i">callValue</span>(<span class="i">peek</span>(<span class="i">argCount</span>), <span class="i">argCount</span>)) {
          <span class="k">return</span> <span class="a">INTERPRET_RUNTIME_ERROR</span>;
        }
        <span class="k">break</span>;
      }
</pre><pre class="insert-after" translate="no">      case OP_RETURN: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">호출되는 함수와 그 함수에 전달된 인수의 수를 알아야 합니다.</font><font papago-translate="translated"> 우리는 후자를 명령어의 피연산자로부터 얻습니다.</font><font papago-translate="translated"> 이는 또한 스택 상단의 인수 슬롯을 지나 스택에서 함수를 찾을 수 있는 위치를 알려줍니다.</font><font papago-translate="translated"> 우리는 그 데이터를 별도로 전달합니다 </font></font><code translate="no">callValue()</code><font papago-translate="splitted"><font papago-translate="translated"> 기능.</font><font papago-translate="translated"> 만약 그것이 돌아온다면 </font></font><code translate="no">false</code><font papago-translate="splitted"><font papago-translate="translated">, 통화 중에 런타임 오류가 발생했다는 뜻입니다.</font><font papago-translate="translated"> 그런 일이 발생하면, 우리는 통역사를 중단합니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">한다면 </font></font><code translate="no">callValue()</code><font papago-translate="splitted"><font papago-translate="translated"> 성공하면 호출된 함수에 대한 새로운 프레임이 CallFrame 스택에 표시됩니다.</font><font papago-translate="translated"> 그 </font></font><code translate="no">run()</code><font papago-translate="splitted"><font papago-translate="translated"> 함수에는 현재 프레임에 대한 캐시된 포인터가 있으므로 이를 업데이트해야 합니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">          return INTERPRET_RUNTIME_ERROR;
        }
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font></div>
<pre class="insert" translate="no">        <span class="i">frame</span> = &amp;<span class="i">vm</span>.<span class="i">frames</span>[<span class="i">vm</span>.<span class="i">frameCount</span> - <span class="n">1</span>];
</pre><pre class="insert-after" translate="no">        break;
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">바이트코드 디스패치 루프는 다음과 같습니다 </font></font><code translate="no">frame</code><font papago-translate="splitted"><font papago-translate="translated"> 변수, VM이 다음 명령을 실행할 때 다음을 읽습니다 </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated"> 새로 호출된 함수의 CallFrame에서 코드로 이동합니다.</font><font papago-translate="translated"> 그 호출을 실행하는 작업은 여기서 시작됩니다:</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>엿보기</em> () 후 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">bool</span> <span class="i">callValue</span>(<span class="t">Value</span> <span class="i">callee</span>, <span class="t">int</span> <span class="i">argCount</span>) {
  <span class="k">if</span> (<span class="a">IS_OBJ</span>(<span class="i">callee</span>)) {
    <span class="k">switch</span> (<span class="a">OBJ_TYPE</span>(<span class="i">callee</span>)) {
      <span class="k">case</span> <span class="a">OBJ_FUNCTION</span>:<span name="switch"> </span>
        <span class="k">return</span> <span class="i">call</span>(<span class="a">AS_FUNCTION</span>(<span class="i">callee</span>), <span class="i">argCount</span>);
      <span class="k">default</span>:
        <span class="k">break</span>; <span class="c">// Non-callable object type.</span>
    }
  }
  <span class="i">runtimeError</span>(<span class="s">"Can only call functions and classes."</span>);
  <span class="k">return</span> <span class="k">false</span>;
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>peek</em>()</div>
<aside name="switch" style="top: 24117px;">
<p><font papago-translate="splitted"><font papago-translate="translated">사용하기 </font></font><code translate="no">switch</code><font papago-translate="splitted"><font papago-translate="translated"> 단일 유형을 확인하는 문장은 현재 오버킬 상태이지만, 다른 호출 가능한 유형을 처리하기 위해 케이스를 추가하면 이해가 됩니다.</font></font></p>
</aside>
<p><font papago-translate="translated">여기에는 단순히 새로운 CallFrame을 초기화하는 것 이상의 일이 일어나고 있습니다.</font><font papago-translate="translated"> Lox는 동적으로 입력되므로 사용자가 나쁜 코드를 작성하는 것을 막을 수 있는 방법은 없습니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="i">notAFunction</span> = <span class="n">123</span>;
<span class="i">notAFunction</span>();
</pre></div>
<p><font papago-translate="translated">그렇게 되면 런타임에서 오류를 안전하게 보고하고 중지해야 합니다.</font><font papago-translate="translated"> 그래서 우리가 가장 먼저 하는 일은 우리가 부르려는 값의 유형을 확인하는 것입니다.</font><font papago-translate="translated"> 함수가 아닌 경우 오류가 발생합니다.</font><font papago-translate="translated"> 그렇지 않으면 실제 통화는 여기서 이루어집니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>엿보기</em> () 후 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">bool</span> <span class="i">call</span>(<span class="t">ObjFunction</span>* <span class="i">function</span>, <span class="t">int</span> <span class="i">argCount</span>) {
  <span class="t">CallFrame</span>* <span class="i">frame</span> = &amp;<span class="i">vm</span>.<span class="i">frames</span>[<span class="i">vm</span>.<span class="i">frameCount</span>++];
  <span class="i">frame</span>-&gt;<span class="i">function</span> = <span class="i">function</span>;
  <span class="i">frame</span>-&gt;<span class="i">ip</span> = <span class="i">function</span>-&gt;<span class="i">chunk</span>.<span class="i">code</span>;
  <span class="i">frame</span>-&gt;<span class="i">slots</span> = <span class="i">vm</span>.<span class="i">stackTop</span> - <span class="i">argCount</span> - <span class="n">1</span>;
  <span class="k">return</span> <span class="k">true</span>;
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>peek</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">이렇게 하면 스택에서 다음 CallFrame이 초기화됩니다.</font><font papago-translate="translated"> 호출 중인 함수의 포인터를 저장하고 프레임의 </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated"> 함수의 바이트코드 시작 부분까지.</font><font papago-translate="translated"> 마침내, 그것은 </font></font><code translate="no">slots</code><font papago-translate="splitted"><font papago-translate="translated"> 포인터를 사용하여 프레임의 창을 스택에 넣습니다.</font><font papago-translate="translated"> 그곳의 산술은 스택에 이미 있는 인수들이 함수의 매개변수와 일치하도록 보장합니다:</font></font></p><img alt="The arithmetic to calculate frame-&gt;slots from stackTop and argCount." src="https://youhogeon-meritz.github.io/image/calls-and-functions/arithmetic.png">
<p><font papago-translate="splitted"><font papago-translate="translated">재미있는 작은 아이 </font></font><code translate="no">- 1</code><font papago-translate="splitted"><font papago-translate="translated"> 컴파일러가 나중에 메서드를 추가할 때 따로 설정한 스택 슬롯 0을 고려하는 것입니다.</font><font papago-translate="translated"> 매개변수는 슬롯 1에서 시작되므로 인수와 정렬하기 위해 창이 한 슬롯 더 일찍 시작되도록 합니다.</font></font></p>
<p><font papago-translate="translated">다음 단계로 넘어가기 전에, 우리의 분해기에 새로운 지침을 추가해 보겠습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      return jumpInstruction("OP_LOOP", -1, chunk, offset);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">debug.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>분해</em> 중 지침()</font></font></div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="a">OP_CALL</span>:
      <span class="k">return</span> <span class="i">byteInstruction</span>(<span class="s">"OP_CALL"</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
</pre><pre class="insert-after" translate="no">    case OP_RETURN:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>
<p><font papago-translate="translated">그리고 또 한 번의 짧은 부업.</font><font papago-translate="translated"> 이제 CallFrame을 시작하기 위한 편리한 기능이 생겼으니, 이를 사용하여 최상위 코드를 실행하기 위한 첫 번째 프레임을 설정할 수도 있습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  push(OBJ_VAL(function));
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>해석</em>상 ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 4줄 교체</font></font></div>
<pre class="insert" translate="no">  <span class="i">call</span>(<span class="i">function</span>, <span class="n">0</span>);
</pre><pre class="insert-after" translate="no">
  return run();
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>interpret</em>(), replace 4 lines</div>
<p><font papago-translate="translated">자, 이제 다시 전화로 돌아가<span class="ellipse"> 보겠습니다. . .</span></font></p>
<h3><a href="https://youhogeon-meritz.github.io/calls-and-functions.html#runtime-error-checking" id="runtime-error-checking"><small><font papago-translate="translated">24 . 5 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">런타임 오류 검사</font></font></a></h3>
<p><font papago-translate="translated">겹치는 스택 창은 호출이 함수의 각 매개변수에 대해 정확히 하나의 인수를 전달한다는 가정에 따라 작동합니다.</font><font papago-translate="translated"> 하지만 Lox가 정적으로 입력되지 않았기 때문에 어리석은 사용자는 너무 많거나 적은 수의 인수를 통과할 수 있습니다.</font><font papago-translate="translated"> Lox에서 우리는 이를 런타임 오류로 정의했으며, 이를 다음과 같이 보고합니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">static bool call(ObjFunction* function, int argCount) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>콜</em> ()에서</font></font></div>
<pre class="insert" translate="no">  <span class="k">if</span> (<span class="i">argCount</span> != <span class="i">function</span>-&gt;<span class="i">arity</span>) {
    <span class="i">runtimeError</span>(<span class="s">"Expected %d arguments but got %d."</span>,
        <span class="i">function</span>-&gt;<span class="i">arity</span>, <span class="i">argCount</span>);
    <span class="k">return</span> <span class="k">false</span>;
  }

</pre><pre class="insert-after" translate="no">  CallFrame* frame = &amp;vm.frames[vm.frameCount++];
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>call</em>()</div>
<p><font papago-translate="translated">꽤 간단합니다.</font><font papago-translate="translated"> 이것이 바로 각 함수의 희소성을 ObjFunction 내부에 저장하는 이유입니다.</font></p>
<p><font papago-translate="translated">우리가 보고해야 할 또 다른 오류가 있는데, 이는 사용자의 어리석음과 우리 자신의 어리석음과는 관련이 없습니다.</font><font papago-translate="translated"> CallFrame 배열은 고정된 크기를 가지고 있기 때문에 딥 콜 체인이 넘치지 않도록 해야 합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  }

</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>콜</em> ()에서</font></font></div>
<pre class="insert" translate="no">  <span class="k">if</span> (<span class="i">vm</span>.<span class="i">frameCount</span> == <span class="a">FRAMES_MAX</span>) {
    <span class="i">runtimeError</span>(<span class="s">"Stack overflow."</span>);
    <span class="k">return</span> <span class="k">false</span>;
  }

</pre><pre class="insert-after" translate="no">  CallFrame* frame = &amp;vm.frames[vm.frameCount++];
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>call</em>()</div>
<p><font papago-translate="translated">실제로 프로그램이 이 한계에 가까워지면 실행 중인 재귀 코드에 버그가 있을 가능성이 높습니다.</font></p>
<h3><a href="https://youhogeon-meritz.github.io/calls-and-functions.html#printing-stack-traces" id="printing-stack-traces"><small><font papago-translate="translated">24 . 5 . 3</font></small><font papago-translate="splitted"><font papago-translate="translated">스택 트레이스 인쇄</font></font></a></h3>
<p><font papago-translate="translated">런타임 오류에 대해 이야기하는 동안, 이를 더 유용하게 만드는 데 시간을 좀 더 할애해 보겠습니다.</font><font papago-translate="translated"> 런타임 오류를 중지하는 것은 VM이 잘못 정의된 방식으로 충돌하고 타는 것을 방지하는 데 중요합니다.</font><font papago-translate="translated"> 하지만 단순히 중단한다고 해서 사용자가 해당 오류<em>를 일으킨</em> 코드를 수정하는 데 도움이 되지는 않습니다.</font></p>
<p><font papago-translate="translated">런타임 실패를 디버깅하는 데 도움이 되는 고전적인 도구는<strong> 스택 트레이스</strong>입니다.<strong> 이</strong>는 프로그램이 종료되었을 때 실행 중이었고 실행이<span class="em"></span> 종료된 지점에 있던 각 함수를 출력한 것입니다.</font><font papago-translate="translated"> 이제 호출 스택이 있고 각 함수의 이름이 편리하게 저장되었으므로 런타임 오류로 인해 사용자의 존재 조화가 방해받을 때 전체 스택을 표시할 수 있습니다.</font><font papago-translate="translated"> 다음과 같이 보입니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  fputs("\n", stderr);

</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런타임</em>에<em>Error</em>()</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 4줄 교체</font></font></div>
<pre class="insert" translate="no">  <span class="k">for</span> (<span class="t">int</span> <span class="i">i</span> = <span class="i">vm</span>.<span class="i">frameCount</span> - <span class="n">1</span>; <span class="i">i</span> &gt;= <span class="n">0</span>; <span class="i">i</span>--) {
    <span class="t">CallFrame</span>* <span class="i">frame</span> = &amp;<span class="i">vm</span>.<span class="i">frames</span>[<span class="i">i</span>];
    <span class="t">ObjFunction</span>* <span class="i">function</span> = <span class="i">frame</span>-&gt;<span class="i">function</span>;
    <span class="t">size_t</span> <span class="i">instruction</span> = <span class="i">frame</span>-&gt;<span class="i">ip</span> - <span class="i">function</span>-&gt;<span class="i">chunk</span>.<span class="i">code</span> - <span class="n">1</span>;
    <span class="i">fprintf</span>(<span class="i">stderr</span>, <span class="s">"[line %d] in "</span>,<span name="minus"> </span>
            <span class="i">function</span>-&gt;<span class="i">chunk</span>.<span class="i">lines</span>[<span class="i">instruction</span>]);
    <span class="k">if</span> (<span class="i">function</span>-&gt;<span class="i">name</span> == <span class="a">NULL</span>) {
      <span class="i">fprintf</span>(<span class="i">stderr</span>, <span class="s">"script</span><span class="e">\n</span><span class="s">"</span>);
    } <span class="k">else</span> {
      <span class="i">fprintf</span>(<span class="i">stderr</span>, <span class="s">"%s()</span><span class="e">\n</span><span class="s">"</span>, <span class="i">function</span>-&gt;<span class="i">name</span>-&gt;<span class="i">chars</span>);
    }
  }

</pre><pre class="insert-after" translate="no">  resetStack();
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>runtimeError</em>(), replace 4 lines</div>
<aside name="minus" style="top: 26892.5px;">
<p><font papago-translate="splitted"><font papago-translate="translated">그 </font></font><code translate="no">- 1</code><font papago-translate="splitted"><font papago-translate="translated"> IP가 이미 다음 실행 명령어에 위치해 있지만 스택 추적이 이전에 실패한 명령어를 가리키기를 원합니다.</font></font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">오류 메시지를 직접 출력한 후, 우리는 호출 스택을<span name="top"> 위</span>에서 아래로 걸어갑니다 (가장 최근에 호출된 함수).</font><font papago-translate="translated"> 각 프레임마다 전류에 해당하는 라인 번호를 찾습니다 </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated"> 그 프레임의 기능 내부에서.</font><font papago-translate="translated"> 그런 다음 함수 이름과 함께 해당 라인 번호를 인쇄합니다.</font></font></p>
<aside name="top" style="top: 27137.5px;">
<p><font papago-translate="translated">어떤 순서의 스택 프레임을 트레이스에 표시해야 하는지에 대해 약간의 의견 차이가 있습니다.</font><font papago-translate="translated"> 대부분은 가장 안쪽 함수를 첫 번째 줄로 놓고 스택의 맨 아래쪽으로 이동합니다.</font><font papago-translate="translated"> 파이썬은 그것들을 반대 순서로 출력합니다.</font><font papago-translate="translated"> 따라서 위에서 아래로 읽으면 프로그램이 현재 위치에 도달한 방법을 알 수 있으며, 마지막 줄은 실제로 오류가 발생한 위치입니다.</font></p>
<p><font papago-translate="translated">그 스타일에는 논리가 있습니다.</font><font papago-translate="translated"> 스택 트레이스가 한 화면에 맞추기에는 너무 길어도 항상 가장 안쪽의 함수를 볼 수 있게 해줍니다.</font><font papago-translate="translated"> 반면에, 저널리즘의 "<a href="https://en.wikipedia.org/wiki/Inverted_pyramid_(journalism)">반전 피라미드"</a>는 우리에게 가장 중요한 정보를 텍스트 블록<em>에 우선</em>시해야 한다고 말합니다.</font><font papago-translate="translated"> 스택 트레이스에서는 오류가 실제로 발생한 함수입니다.</font><font papago-translate="translated"> 대부분의 다른 언어 구현은 그렇게 합니다.</font></p>
</aside>
<p><font papago-translate="translated">예를 들어, 이 고장난 프로그램을 실행하는 경우:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">fun</span> <span class="i">a</span>() { <span class="i">b</span>(); }
<span class="k">fun</span> <span class="i">b</span>() { <span class="i">c</span>(); }
<span class="k">fun</span> <span class="i">c</span>() {
  <span class="i">c</span>(<span class="s">"too"</span>, <span class="s">"many"</span>);
}

<span class="i">a</span>();
</pre></div>
<p><font papago-translate="translated">출력됩니다:</font></p>
<div class="codehilite"><pre translate="no">Expected 0 arguments but got 2.
[line 4] in c()
[line 2] in b()
[line 1] in a()
[line 7] in script
</pre></div>
<p><font papago-translate="translated">그렇게 나쁘지 않죠?</font></p>
<h3><a href="https://youhogeon-meritz.github.io/calls-and-functions.html#returning-from-functions" id="returning-from-functions"><small><font papago-translate="translated">24 . 5 . 4</font></small><font papago-translate="splitted"><font papago-translate="translated">함수에서 돌아가기</font></font></a></h3>
<p><font papago-translate="splitted"><font papago-translate="translated">가까워지고 있습니다.</font><font papago-translate="translated"> 함수를 호출하면 VM이 실행합니다.</font><font papago-translate="translated"> 하지만 아직<em> 그</em>들로부터<em> 돌아올</em> 수는 없습니다.</font><font papago-translate="translated"> 우리는 </font></font><code translate="no">OP_RETURN</code><font papago-translate="splitted"><font papago-translate="translated"> 꽤 오랫동안 교육을 받았지만, 바이트코드 루프에서 벗어나기 위해 항상 일종의 임시 코드가 걸려 있었습니다.</font><font papago-translate="translated"> 진정한 구현을 위한 시간이 도래했습니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      case OP_RETURN: {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 두 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">        <span class="t">Value</span> <span class="i">result</span> = <span class="i">pop</span>();
        <span class="i">vm</span>.<span class="i">frameCount</span>--;
        <span class="k">if</span> (<span class="i">vm</span>.<span class="i">frameCount</span> == <span class="n">0</span>) {
          <span class="i">pop</span>();
          <span class="k">return</span> <span class="a">INTERPRET_OK</span>;
        }

        <span class="i">vm</span>.<span class="i">stackTop</span> = <span class="i">frame</span>-&gt;<span class="i">slots</span>;
        <span class="i">push</span>(<span class="i">result</span>);
        <span class="i">frame</span> = &amp;<span class="i">vm</span>.<span class="i">frames</span>[<span class="i">vm</span>.<span class="i">frameCount</span> - <span class="n">1</span>];
        <span class="k">break</span>;
</pre><pre class="insert-after" translate="no">      }
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>(), replace 2 lines</div>
<p><font papago-translate="translated">함수가 값을 반환하면, 그 값은 스택 위에 있게 됩니다.</font><font papago-translate="translated"> 호출된 함수의 전체 스택 창을 폐기하려고 하는데, 그 반환 값을 터뜨리고 그대로 유지합니다.</font><font papago-translate="translated"> 그런 다음 반환 함수에 대한 콜프레임을 폐기합니다.</font><font papago-translate="translated"> 그게 바로 마지막 CallFrame이었다면, 이는 최상위 코드 실행을 마쳤다는 것을 의미합니다.</font><font papago-translate="translated"> 전체 프로그램이 완료되었으므로 스택에서 메인 스크립트 함수를 실행한 다음 인터프리터를 종료합니다.</font></p>
<p><font papago-translate="translated">그렇지 않으면, 우리는 호출자가 매개변수와 지역 변수에 사용하던 모든 슬롯을 버립니다.</font><font papago-translate="translated"> 여기에는 발신자가 인수를 전달하는 데 사용한 슬롯이 포함됩니다.</font><font papago-translate="translated"> 이제 통화가 끝났으니 발신자는 더 이상 필요하지 않습니다.</font><font papago-translate="translated"> 즉, 스택의 상단은 반환 함수의 스택 창 바로 시작 지점에 위치하게 됩니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">우리는 반환 값을 그 새로운 낮은 위치의 스택으로 다시 밀어 넣습니다.</font><font papago-translate="translated"> 그런 다음 업데이트합니다 </font></font><code translate="no">run()</code><font papago-translate="splitted"><font papago-translate="translated"> 함수의 현재 프레임에 대한 캐시된 포인터.</font><font papago-translate="translated"> 우리가 통화를 시작했을 때처럼, 바이트코드 디스패치 루프의 다음 버전에서는 VM이 다음을 읽을 것입니다 </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated"> 해당 프레임에서 실행이 종료된 직후 발신자에게 다시 전달됩니다 </font></font><code translate="no">OP_CALL</code><font papago-translate="splitted"><font papago-translate="translated"> 설명.</font></font></p><img alt="Each step of the return process: popping the return value, discarding the call frame, pushing the return value." src="https://youhogeon-meritz.github.io/image/calls-and-functions/return.png">
<p><font papago-translate="translated">여기서 우리는 함수가 실제로 값을 반환했다고 가정하지만, 함수<em></em>가 본체의 끝에 도달함으로써 암묵적으로 반환될 수 있다는 점에 유의하세요:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">fun</span> <span class="i">noReturn</span>() {
  <span class="k">print</span> <span class="s">"Do stuff"</span>;
  <span class="c">// No return here.</span>
}

<span class="k">print</span> <span class="i">noReturn</span>(); <span class="c">// ???</span>
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">우리도 그것을 올바르게 처리해야 합니다.</font><font papago-translate="translated"> 언어는 암묵적으로 반환되도록 지정됩니다 </font></font><code translate="no">nil</code><font papago-translate="splitted"><font papago-translate="translated"> 그런 경우에는.</font><font papago-translate="translated"> 이를 위해 다음과 같이 추가합니다:</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">static void emitReturn() {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>emit</em>R<em>eturn</em>()에서</font></font></div>
<pre class="insert" translate="no">  <span class="i">emitByte</span>(<span class="a">OP_NIL</span>);
</pre><pre class="insert-after" translate="no">  emitByte(OP_RETURN);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>emitReturn</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">컴파일러가 호출합니다 </font></font><code translate="no">emitReturn()</code><font papago-translate="splitted"><font papago-translate="translated"> 을 작성하기 위해 </font></font><code translate="no">OP_RETURN</code><font papago-translate="splitted"><font papago-translate="translated"> 기능 본문의 끝에 있는 지침.</font><font papago-translate="translated"> 이제 그 전에 푸시하라는 지시를 내립니다 </font></font><code translate="no">nil</code><font papago-translate="splitted"><font papago-translate="translated"> 스택에.</font><font papago-translate="translated"> 그리고 그것으로 우리는 작업 함수 호출을 할 수 있습니다!</font><font papago-translate="translated"> 그들은 심지어 매개변수를 취할 수도 있습니다!</font><font papago-translate="translated"> 우리가 여기서 무엇을 하고 있는지 거의 알고 있는 것 같습니다.</font></font></p>
<h2><a href="https://youhogeon-meritz.github.io/calls-and-functions.html#return-statements" id="return-statements"><small><font papago-translate="translated">24 . 6</font></small><font papago-translate="splitted"><font papago-translate="translated">반품 명세서</font></font></a></h2>
<p><font papago-translate="splitted"><font papago-translate="translated">암묵적인 것이 아닌 다른 것을 반환하는 함수를 원한다면 </font></font><code translate="no">nil</code><font papago-translate="splitted"><font papago-translate="translated">, 당신은 필요합니다 </font></font><code translate="no">return</code><font papago-translate="splitted"><font papago-translate="translated"> 진술.</font><font papago-translate="translated"> 제대로 해보겠습니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    ifStatement();
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>성명</em>서 ()에서</font></font></div>
<pre class="insert" translate="no">  } <span class="k">else</span> <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_RETURN</span>)) {
    <span class="i">returnStatement</span>();
</pre><pre class="insert-after" translate="no">  } else if (match(TOKEN_WHILE)) {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>statement</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">컴파일러가 다음을 볼 때 </font></font><code translate="no">return</code><font papago-translate="splitted"><font papago-translate="translated"> 키워드는 여기에 있습니다:</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>print</em>St<em>atement</em>() 후에 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">returnStatement</span>() {
  <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_SEMICOLON</span>)) {
    <span class="i">emitReturn</span>();
  } <span class="k">else</span> {
    <span class="i">expression</span>();
    <span class="i">consume</span>(<span class="a">TOKEN_SEMICOLON</span>, <span class="s">"Expect ';' after return value."</span>);
    <span class="i">emitByte</span>(<span class="a">OP_RETURN</span>);
  }
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>printStatement</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">반환 값 표현은 선택 사항이므로 파서는 값이 제공되었는지 여부를 확인하기 위해 세미콜론 토큰을 찾습니다.</font><font papago-translate="translated"> 반환 값이 없으면, 그 진술은 암묵적으로 반환됩니다 </font></font><code translate="no">nil</code><font papago-translate="splitted"><font papago-translate="translated">. 우리는 그것을 전화로 구현합니다 </font></font><code translate="no">emitReturn()</code><font papago-translate="splitted"><font papago-translate="translated">, 를 방출합니다 </font></font><code translate="no">OP_NIL</code><font papago-translate="splitted"><font papago-translate="translated"> 설명.</font><font papago-translate="translated"> 그렇지 않으면 반환 값 표현식을 컴파일하여 다음과 같이 반환합니다 </font></font><code translate="no">OP_RETURN</code><font papago-translate="splitted"><font papago-translate="translated"> 설명.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">이것은 동일합니다 </font></font><code translate="no">OP_RETURN</code><font papago-translate="splitted"><font papago-translate="translated"> 우리가 이미 구현한 명령어—새로운 런타임<span class="em"></span> 코드가 필요하지 않습니다.</font><font papago-translate="translated"> 이것은 Jlox와는 상당히 다릅니다.</font><font papago-translate="translated"> 거기서 우리는 예외를 사용하여 스택을 풀어야 했습니다 </font></font><code translate="no">return</code><font papago-translate="splitted"><font papago-translate="translated"> 문이 실행되었습니다.</font><font papago-translate="translated"> 그것은 중첩된 블록 깊숙한 곳에서 돌아올 수 있기 때문이었습니다.</font><font papago-translate="translated"> jlox가 AST를 재귀적으로 걷기 때문에 탈출해야 할 Java 메서드 호출이 많이 있었습니다.</font></font></p>
<p><font papago-translate="translated">우리 바이트코드 컴파일러는 이 모든 것을 평탄화합니다.</font><font papago-translate="translated"> 구문 분석 중에 재귀적 하강을 수행하지만, 실행 시 VM의 바이트코드 디스패치 루프는 완전히 평평합니다.</font><font papago-translate="translated"> C 레벨에서는 재귀가 전혀 일어나지 않습니다.</font><font papago-translate="translated"> 따라서 중첩된 블록 내에서도 함수의 본문 끝에서 돌아오는 것만큼이나 간단합니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">하지만 완전히 끝난 것은 아닙니다.</font><font papago-translate="translated"> 새로운 </font></font><code translate="no">return</code><font papago-translate="splitted"><font papago-translate="translated"> 문은 우리가 걱정해야 할 새로운 컴파일 오류를 제공합니다.</font><font papago-translate="translated"> 반환은 함수에서 반환할 때 유용하지만 Lox 프로그램의 최상위 레벨도 필수 코드입니다.</font><font papago-translate="translated"> 거기서<span name="worst"> 돌아올</span> 수 없어야 합니다.</font></font></p>
<div class="codehilite"><pre translate="no"><span class="k">return</span> <span class="s">"What?!"</span>;
</pre></div>
<aside name="worst" style="top: 30651.5px;">
<p><font papago-translate="splitted"><font papago-translate="translated">허용하는 </font></font><code translate="no">return</code><font papago-translate="splitted"><font papago-translate="translated"> 최고 수준에서는 최악의 아이디어가 아닙니다.</font><font papago-translate="translated"> 스크립트를 조기에 종료할 수 있는 자연스러운 방법을 제공할 것입니다.</font><font papago-translate="translated"> 반환된 숫자를 사용하여 프로세스의 종료 코드를 표시할 수도 있습니다.</font></font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">컴파일 오류를 지정했습니다 </font></font><code translate="no">return</code><font papago-translate="splitted"><font papago-translate="translated"> 함수 외부의 문장은 다음과 같이 구현됩니다:</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">static void returnStatement() {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>답례</em>문()으로</font></font></div>
<pre class="insert" translate="no">  <span class="k">if</span> (<span class="i">current</span>-&gt;<span class="i">type</span> == <span class="a">TYPE_SCRIPT</span>) {
    <span class="i">error</span>(<span class="s">"Can't return from top-level code."</span>);
  }

</pre><pre class="insert-after" translate="no">  if (match(TOKEN_SEMICOLON)) {
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>returnStatement</em>()</div>
<p><font papago-translate="translated">이것이 우리가 그 함수를 추가한 이유 중 하나입니다</font><font papago-translate="translated">컴파일러에 enum을 입력합니다.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/calls-and-functions.html#native-functions" id="native-functions"><small><font papago-translate="translated">24 . 7</font></small><font papago-translate="splitted"><font papago-translate="translated">네이티브 함수</font></font></a></h2>
<p><font papago-translate="translated">우리의 VM은 점점 더 강력해지고 있습니다.</font><font papago-translate="translated"> 함수, 호출, 매개변수, 반환이 있습니다.</font><font papago-translate="translated"> 서로를 흥미로운 방식으로 부를 수 있는 다양한 기능을 정의할 수 있습니다.</font><font papago-translate="translated"> 하지만 궁극적으로 그들은 아무것도<em> 할</em> 수 없습니다.</font><font papago-translate="translated"> Lox 프로그램이 복잡성과 상관없이 사용자가 볼 수 있는 유일한 방법은 인쇄입니다.</font><font papago-translate="translated"> 더 많은 기능을 추가하려면 사용자에게 노출시켜야 합니다.</font></p>
<p><font papago-translate="translated">프로그래밍 언어 구현은<strong> 네이티브 함수</strong>를 통해 물질 세계에 도달하고 접촉합니다.</font><font papago-translate="translated"> 시간을 확인하거나 사용자 입력을 읽거나 파일 시스템에 접근할 수 있는 프로그램을 작성하려면 Lox에서 호출할 수 있지만 C로 구현된 네이티브 기능을 추가하여 이러한<span class="em"></span><span class="em"></span> 기능을 노출해야 합니다.</font></p>
<p><font papago-translate="translated">언어 수준에서 Lox는 폐쇄, 수업, 상속 및 기타 재미<span class="em"></span>있는 기능을 갖추고 있어 상당히 완성도가 높습니다.</font><font papago-translate="translated"> 장난감 언어처럼 느껴지는 이유 중 하나는 거의 기본 기능이 없기 때문입니다.</font><font papago-translate="translated"> 긴 목록을 추가하면 실제 언어로 변환할 수 있습니다.</font></p>
<p><font papago-translate="translated">그러나 수많은 OS 작업을 꼼꼼히 살펴보는 것은 사실 그다지 교육적이지 않습니다.</font><font papago-translate="translated"> C 코드 하나를 Lox에 바인딩하는 방법을 본 후에는 아이디어가 떠오릅니다.</font><font papago-translate="translated"> 하지만<em> 하나</em>를 봐야 하고, 심지어 하나의 기본 함수라도 Lox와 C를 인터페이스하기 위한 모든 기계를 구축해야 합니다.</font><font papago-translate="translated"> 그래서 우리는 그것을 겪고 모든 힘든 일을 할 것입니다.</font><font papago-translate="translated"> 그런 다음 이 작업이 완료되면 작동한다는 것을 증명하기 위해 작은 기본 함수 하나를 추가합니다.</font></p>
<p><font papago-translate="translated">우리가 새로운 기계가 필요한 이유는 구현의 관점에서 볼 때, 네이티브 기능이 Lox 기능과 다르기 때문입니다.</font><font papago-translate="translated"> 그들이 호출될 때, 그들은 콜프레임을 푸시하지 않습니다. 왜냐하면 그 프레임이 가리키는 바이트코드 코드가 없기 때문입니다.</font><font papago-translate="translated"> 바이트코드 청크가 없습니다.</font><font papago-translate="translated"> 대신, 그들은 어떻게든 네이티브 C 코드 조각을 참조합니다.</font></p>
<p><font papago-translate="translated">우리는 네이티브 함수를 완전히 다른 객체 유형으로 정의하여 이를 clox에서 처리합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">} ObjFunction;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 구조 후 Ob<em>jFunction</em> 추가</font></font></div>
<pre class="insert" translate="no">
<span class="k">typedef</span> <span class="t">Value</span> (*<span class="t">NativeFn</span>)(<span class="t">int</span> <span class="i">argCount</span>, <span class="t">Value</span>* <span class="i">args</span>);

<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">Obj</span> <span class="i">obj</span>;
  <span class="t">NativeFn</span> <span class="i">function</span>;
} <span class="t">ObjNative</span>;
</pre><pre class="insert-after" translate="no">
struct ObjString {
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after struct <em>ObjFunction</em></div>
<p><font papago-translate="translated">표현은 ObjFunction보다 더 간단합니다. 단순히 Obj 헤더와 네이티브<span class="em"></span> 동작을 구현하는 C 함수로의 포인터일 뿐입니다.</font><font papago-translate="translated"> 네이티브 함수는 인수 개수와 스택의 첫 번째 인수에 대한 포인터를 가져옵니다.</font><font papago-translate="translated"> 그것은 그 포인터를 통해 인수에 접근합니다.</font><font papago-translate="translated"> 완료되면 결과 값을 반환합니다.</font></p>
<p><font papago-translate="translated">항상 그렇듯이, 새로운 객체 유형에는 몇 가지 부가물이 포함되어 있습니다.</font><font papago-translate="translated"> ObjNative를 만들기 위해, 우리는 생성자와 유사한 함수를 선언합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">ObjFunction* newFunction();
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>newFunction</em>() 다음에 추가</font></font></div>
<pre class="insert" translate="no"><span class="t">ObjNative</span>* <span class="i">newNative</span>(<span class="t">NativeFn</span> <span class="i">function</span>);
</pre><pre class="insert-after" translate="no">ObjString* takeString(char* chars, int length);
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after <em>newFunction</em>()</div>
<p><font papago-translate="translated">우리는 그렇게 구현합니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>newFunction</em>() 다음에 추가</font></font></div>
<pre translate="no"><span class="t">ObjNative</span>* <span class="i">newNative</span>(<span class="t">NativeFn</span> <span class="i">function</span>) {
  <span class="t">ObjNative</span>* <span class="i">native</span> = <span class="a">ALLOCATE_OBJ</span>(<span class="t">ObjNative</span>, <span class="a">OBJ_NATIVE</span>);
  <span class="i">native</span>-&gt;<span class="i">function</span> = <span class="i">function</span>;
  <span class="k">return</span> <span class="i">native</span>;
}
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, add after <em>newFunction</em>()</div>
<p><font papago-translate="translated">생성자는 C 함수 포인터를 사용하여 ObjNative를 감쌉니다.</font><font papago-translate="translated"> 객체 헤더를 설정하고 함수를 저장합니다.</font><font papago-translate="translated"> 헤더의 경우, 새로운 객체 유형이 필요합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">typedef enum {
  OBJ_FUNCTION,
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> enum Ob<em>jType</em>에서</font></font></div>
<pre class="insert" translate="no">  <span class="a">OBJ_NATIVE</span>,
</pre><pre class="insert-after" translate="no">  OBJ_STRING,
} ObjType;
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, in enum <em>ObjType</em></div>
<p><font papago-translate="translated">VM은 또한 네이티브 함수 객체의 할당을 해제하는 방법을 알아야 합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    }
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>free</em>O<em>bject</em>()에서</font></font></div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="a">OBJ_NATIVE</span>:
      <span class="a">FREE</span>(<span class="t">ObjNative</span>, <span class="i">object</span>);
      <span class="k">break</span>;
</pre><pre class="insert-after" translate="no">    case OBJ_STRING: {
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>freeObject</em>()</div>
<p><font papago-translate="translated">ObjNative는 추가 메모리가 없기 때문에 여기에는 많은 것이 없습니다.</font><font papago-translate="translated"> 모든 Lox 객체가 지원하는 다른 기능은 인쇄 중입니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      break;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>print</em>O<em>bject</em>()에서</font></font></div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="a">OBJ_NATIVE</span>:
      <span class="i">printf</span>(<span class="s">"&lt;native fn&gt;"</span>);
      <span class="k">break</span>;
</pre><pre class="insert-after" translate="no">    case OBJ_STRING:
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>printObject</em>()</div>
<p><font papago-translate="translated">동적 타이핑을 지원하기 위해 값이 네이티브 함수인지 확인할 수 있는 매크로가 있습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#define IS_FUNCTION(value)     isObjType(value, OBJ_FUNCTION)
</pre><div class="source-file"><em><font papago-translate="translated">객체.h</font></em></div>
<pre class="insert" translate="no"><span class="a">#define IS_NATIVE(value)       isObjType(value, OBJ_NATIVE)</span>
</pre><pre class="insert-after" translate="no">#define IS_STRING(value)       isObjType(value, OBJ_STRING)
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>
<p><font papago-translate="translated">참으로 반환된다고 가정하면, 이 매크로는 네이티브 함수를 나타내는 값에서 C 함수 포인터를 추출합니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#define AS_FUNCTION(value)     ((ObjFunction*)AS_OBJ(value))
</pre><div class="source-file"><em><font papago-translate="translated">객체.h</font></em></div>
<pre class="insert" translate="no"><span class="a">#define AS_NATIVE(value) \</span>
<span class="a">    (((ObjNative*)AS_OBJ(value))-&gt;function)</span>
</pre><pre class="insert-after" translate="no">#define AS_STRING(value)       ((ObjString*)AS_OBJ(value))
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>
<p><font papago-translate="translated">이 모든 짐은 VM이 다른 객체처럼 네이티브 기능을 처리할 수 있게 해줍니다.</font><font papago-translate="translated"> 변수에 저장하고, 전달하고, 생일 파티 등을 열 수 있습니다.</font><font papago-translate="translated"> 물론, 우리가 실제로 신경 쓰는 작업은 그들<em>을 호출</em>하는 것입니다. 하나는 호출<span class="em"></span> 표현에서 왼쪽 피연산자로 사용됩니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">오버 인 </font></font><code translate="no">callValue()</code><font papago-translate="splitted"><font papago-translate="translated"> 다른 유형의 케이스를 추가합니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      case OBJ_FUNCTION:<span name="switch"> </span>
        return call(AS_FUNCTION(callee), argCount);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>callValue</em>()에서</font></font></div>
<pre class="insert" translate="no">      <span class="k">case</span> <span class="a">OBJ_NATIVE</span>: {
        <span class="t">NativeFn</span> <span class="i">native</span> = <span class="a">AS_NATIVE</span>(<span class="i">callee</span>);
        <span class="t">Value</span> <span class="i">result</span> = <span class="i">native</span>(<span class="i">argCount</span>, <span class="i">vm</span>.<span class="i">stackTop</span> - <span class="i">argCount</span>);
        <span class="i">vm</span>.<span class="i">stackTop</span> -= <span class="i">argCount</span> + <span class="n">1</span>;
        <span class="i">push</span>(<span class="i">result</span>);
        <span class="k">return</span> <span class="k">true</span>;
      }
</pre><pre class="insert-after" translate="no">      default:
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>callValue</em>()</div>
<p><font papago-translate="translated">호출되는 객체가 네이티브 함수인 경우, 우리는 바로 그때 C 함수를 호출합니다.</font><font papago-translate="translated"> 콜프레임이나 다른 것을 만지작거릴 필요가 없습니다.</font><font papago-translate="translated"> 우리는 그냥 C에게 넘겨주고, 결과를 받아 스택에 다시 넣습니다.</font><font papago-translate="translated"> 이것은 네이티브 기능을 최대한 빠르게 만듭니다.</font></p>
<p><font papago-translate="translated">이를 통해 사용자는 네이티브 함수를 호출할 수 있어야 하지만 호출할 수 있는 함수가 없습니다.</font><font papago-translate="translated"> 외부 기능 인터페이스와 같은 기능이 없으면 사용자는 자신의 고유 기능을 정의할 수 없습니다.</font><font papago-translate="translated"> 그것이 바로 VM 구현자로서 우리가 해야 할 일입니다.</font><font papago-translate="translated"> 우리는 Lox 프로그램에 노출된 새로운 네이티브 함수를 정의하는 도우미부터 시작할 것입니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런타임</em> 후에 추가<em>Error</em>()</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">defineNative</span>(<span class="k">const</span> <span class="t">char</span>* <span class="i">name</span>, <span class="t">NativeFn</span> <span class="i">function</span>) {
  <span class="i">push</span>(<span class="a">OBJ_VAL</span>(<span class="i">copyString</span>(<span class="i">name</span>, (<span class="t">int</span>)<span class="i">strlen</span>(<span class="i">name</span>))));
  <span class="i">push</span>(<span class="a">OBJ_VAL</span>(<span class="i">newNative</span>(<span class="i">function</span>)));
  <span class="i">tableSet</span>(&amp;<span class="i">vm</span>.<span class="i">globals</span>, <span class="a">AS_STRING</span>(<span class="i">vm</span>.<span class="i">stack</span>[<span class="n">0</span>]), <span class="i">vm</span>.<span class="i">stack</span>[<span class="n">1</span>]);
  <span class="i">pop</span>();
  <span class="i">pop</span>();
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after <em>runtimeError</em>()</div>
<p><font papago-translate="translated">C 함수에 대한 포인터를 가져와서 Lox에서 알려진 이름을 사용합니다.</font><font papago-translate="translated"> 함수를 ObjNative에 랩핑한 다음 주어진 이름을 가진 전역 변수에 저장합니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">왜 우리가 이름과 함수를 스택에 푸시 앤 팝하는지 궁금하실 겁니다.</font><font papago-translate="translated"> 이상하게 보이지 않나요?</font><font papago-translate="translated"> <span name="worry">쓰레기</span> 수거에 관여할 때 이런 걱정을 해야 합니다.</font><font papago-translate="translated"> 둘다요. </font></font><code translate="no">copyString()</code><font papago-translate="splitted"><font papago-translate="translated"> 그리고. </font></font><code translate="no">newNative()</code><font papago-translate="splitted"><font papago-translate="translated"> 메모리를 동적으로 할당합니다.</font><font papago-translate="translated"> 즉, GC를 확보하면 잠재적으로 컬렉션을 트리거할 수 있습니다.</font><font papago-translate="translated"> 만약 그렇게 된다면, 수집가가 우리가 이름과 ObjFunction을 다 쓰지 않았다는 것을 알게 해야 합니다. 그래야 그들이 우리 밑에서 자유로워지지 않을 것입니다.</font><font papago-translate="translated"> 그것들을 가치 스택에 저장하면 그것을 달성할 수 있습니다.</font></font></p>
<aside name="worry" style="top: 34427.5px;">
<p><font papago-translate="translated">그 모든 것을 따르지 않았더라도 걱정하지 마세요.</font><font papago-translate="translated"> G<a href="https://youhogeon-meritz.github.io/garbage-collection.html">C를 도입</a>하면 훨씬 더 이해가 될 것입니다.</font></p>
</aside>
<p><font papago-translate="translated">어리석게 느껴지지만, 그 모든 작업이 끝난 후에 우리는 작은 기본 함수 하나만 추가할 것입니다.</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 변수<em> vm</em> 뒤에 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">Value</span> <span class="i">clockNative</span>(<span class="t">int</span> <span class="i">argCount</span>, <span class="t">Value</span>* <span class="i">args</span>) {
  <span class="k">return</span> <span class="a">NUMBER_VAL</span>((<span class="t">double</span>)<span class="i">clock</span>() / <span class="a">CLOCKS_PER_SEC</span>);
}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, add after variable <em>vm</em></div>
<p><font papago-translate="splitted"><font papago-translate="translated">프로그램이 실행되기 시작한 후 경과한 시간을 초 단위로 반환합니다.</font><font papago-translate="translated"> Lox 프로그램을 벤치마킹하는 데 유용합니다.</font><font papago-translate="translated"> Lox에서는 이름을 지정합니다 </font></font><code translate="no">clock()</code><font papago-translate="splitted"><font papago-translate="translated">.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  initTable(&amp;vm.strings);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>initVM</em>()에서</font></font></div>
<pre class="insert" translate="no">
  <span class="i">defineNative</span>(<span class="s">"clock"</span>, <span class="i">clockNative</span>);
</pre><pre class="insert-after" translate="no">}
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>initVM</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">C 표준 라이브러리로 이동하려면 </font></font><code translate="no">clock()</code><font papago-translate="splitted"><font papago-translate="translated"> 함수, "vm" 모듈에는 포함이 필요합니다.</font></font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#include &lt;string.h&gt;
</pre><div class="source-file"><em>vm.c</em></div>
<pre class="insert" translate="no"><span class="a">#include &lt;time.h&gt;</span>
</pre><pre class="insert-after" translate="no">
#include "common.h"
</pre></div>
<div class="source-file-narrow"><em>vm.c</em></div>
<p><font papago-translate="translated">그것은 해결해야 할 많은 자료였지만, 우리는 해냈습니다!</font><font papago-translate="translated"> 이것을 입력하고 시도해 보세요:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">fun</span> <span class="i">fib</span>(<span class="i">n</span>) {
  <span class="k">if</span> (<span class="i">n</span> &lt; <span class="n">2</span>) <span class="k">return</span> <span class="i">n</span>;
  <span class="k">return</span> <span class="i">fib</span>(<span class="i">n</span> - <span class="n">2</span>) + <span class="i">fib</span>(<span class="i">n</span> - <span class="n">1</span>);
}

<span class="k">var</span> <span class="i">start</span> = <span class="i">clock</span>();
<span class="k">print</span> <span class="i">fib</span>(<span class="n">35</span>);
<span class="k">print</span> <span class="i">clock</span>() - <span class="i">start</span>;
</pre></div>
<p><font papago-translate="translated">우리는 정말 비효율적인 재귀 피보나치 함수를 쓸 수 있습니다.</font><font papago-translate="translated"> 더 좋은 점은 그것이<span name="faster"><em> 얼마나</em></span> 비효율적인지 측정할 수 있다는 것입니다.</font><font papago-translate="translated"> 물론 이것이 피보나치 수를 계산하는 가장 현명한 방법은 아닙니다.</font><font papago-translate="translated"> 하지만 함수 호출에 대한 언어 구현의 지원을 테스트하는 것은 좋은 방법입니다.</font><font papago-translate="translated"> 제 기계에서는 이것을 clox에서 실행하는 것이 jlox에서 실행하는 것보다 약 5배 더 빠릅니다.</font><font papago-translate="translated"> 상당히 개선되었습니다.</font></p>
<aside name="faster" style="top: 35383.5px;">
<p><font papago-translate="translated">Ruby 2.4.3p205에서 실행되는 유사한 Ruby 프로그램보다 약간 느리고, Python 3.7.3에서 실행되는 프로그램보다 약 3배 빠릅니다.</font><font papago-translate="translated"> 그리고 아직 VM에서 할 수 있는 간단한 최적화가 많이 남아 있습니다.</font></p>
</aside>
<div class="challenges">
<h2><a href="https://youhogeon-meritz.github.io/calls-and-functions.html#challenges" id="challenges"><font papago-translate="translated">과제들</font></a></h2>
<ol>
<li>
<p><font papago-translate="splitted"><font papago-translate="translated">읽고 쓰기 </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated"> 필드는 바이트코드 루프 내에서 가장 빈번한 연산 중 하나입니다.</font><font papago-translate="translated"> 현재 우리는 현재 CallFrame으로 가는 포인터를 통해 그것에 접근합니다.</font><font papago-translate="translated"> 이를 위해서는 포인터의 방향 전환이 필요하며, 이는 CPU가 캐시를 우회하여 메인 메모리를 누르도록 강제할 수 있습니다.</font><font papago-translate="translated"> 그것은 진정한 성능 싱크가 될 수 있습니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">이상적으로는 다음을 유지합니다 </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated"> 네이티브 CPU 레지스터에서.</font><font papago-translate="translated"> C는 인라인 어셈블리에 들어가지 않고 이를<em> 요구</em>하지 않지만 컴파일러가 최적화하도록 코드를 구성할 수 있습니다.</font><font papago-translate="translated"> 저장하면 </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated"> C 지역 변수에 직접 표시하고 표시합니다 </font></font><code translate="no">register</code><font papago-translate="splitted"><font papago-translate="translated">, C 컴파일러가 우리의 정중한 요청을 받아들일 가능성이 높습니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">이는 로컬을 로드하고 보관하는 데 주의해야 한다는 것을 의미합니다 </font></font><code translate="no">ip</code><font papago-translate="splitted"><font papago-translate="translated"> 함수 호출을 시작하거나 종료할 때 올바른 호출 프레임으로 돌아갑니다.</font><font papago-translate="translated"> 이 최적화를 구현합니다.</font><font papago-translate="translated"> 몇 가지 벤치마크를 작성하여 성능에 어떤 영향을 미치는지 확인합니다.</font><font papago-translate="translated"> 추가 코드 복잡성이 그만한 가치가 있다고 생각하십니까?</font></font></p>
</li>
<li>
<p><font papago-translate="translated">네이티브 함수 호출은 함수가 기대하는 만큼 많은 인수를 통과하는지 검증하지 않기 때문에 부분적으로 빠릅니다.</font><font papago-translate="translated"> 우리는 정말로 해야 합니다. 또는 충분한 인수 없이 네이티브 함수를 잘못 호출하면 함수가 초기화되지 않은 메모리를 읽게 될 수 있습니다.</font><font papago-translate="translated"> 희귀도 검사를 추가합니다.</font></p>
</li>
<li>
<p><font papago-translate="splitted"><font papago-translate="translated">현재로서는 네이티브 함수가 런타임 오류를 알릴 방법이 없습니다.</font><font papago-translate="translated"> 실제 구현에서는 네이티브 함수가 정적으로 입력된 C 세계에 존재하지만 동적으로 입력된 Lox 랜드에서 호출되기 때문에 이를 지원해야 합니다.</font><font papago-translate="translated"> 사용자가 예를 들어 문자열을 전달하려고 할 때 </font></font><code translate="no">sqrt()</code><font papago-translate="splitted"><font papago-translate="translated">, 해당 네이티브 함수는 런타임 오류를 보고해야 합니다.</font></font></p>
<p><font papago-translate="translated">네이티브 기능 시스템을 확장하여 이를 지원합니다.</font><font papago-translate="translated"> 이 기능이 네이티브 통화 성능에 어떤 영향을 미치나요?</font></p>
</li>
<li>
<p><font papago-translate="translated">유용하다고 생각되는 작업을 수행하기 위해 기본 기능을 추가하세요.</font><font papago-translate="translated"> 그것들을 사용하여 몇 가지 프로그램을 작성하세요.</font><font papago-translate="translated"> 무엇을 추가하셨나요?</font><font papago-translate="translated"> 그들은 언어의 느낌과 실용성에 어떤 영향을 미치나요?</font></p>
</li>
</ol>
</div>
<footer>
<a class="next" href="https://youhogeon-meritz.github.io/closures.html"><font papago-translate="translated"> 다음 장: "폐쇄" → </font></a><font papago-translate="splitted"><font papago-translate="translated"> 로버트 니스트롬이 수작업으로 제작한 -<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE"> © 2015 ~ 2021</a></font></font>
</footer>
</article>
</div>


</body></html>