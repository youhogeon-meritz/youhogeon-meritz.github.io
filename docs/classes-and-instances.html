<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link rel="stylesheet" type="text/css" href="cid:css-90fd5890-39f1-46c1-bd66-2190db5eca3e@mhtml.blink" />

<title>Classes and Instances · Crafting Interpreters</title>
<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta content="width=device-width, initial-scale=1" name="viewport">
<link href="https://youhogeon-meritz.github.io/style.css" rel="stylesheet" type="text/css">
<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600" rel="stylesheet" type="text/css">
<link href="https://youhogeon-meritz.github.io/image/favicon.png" rel="icon" type="image/png">


<!-- Google analytics -->

</head>
<body id="top">
<!-- <div class="scrim"></div> -->
<nav class="wide">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<div class="contents">
<h3><a href="https://youhogeon-meritz.github.io/classes-and-instances.html#top"><font papago-translate="splitted"><font papago-translate="translated">클래스 및 인스턴스</font></font><small>27</small></a></h3>
<ul>
<li><a href="https://youhogeon-meritz.github.io/classes-and-instances.html#class-objects"><small>27.1</small><font papago-translate="splitted"><font papago-translate="translated"> 클래스 객체</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/classes-and-instances.html#class-declarations"><small>27.2</small><font papago-translate="splitted"><font papago-translate="translated"> 클래스 선언</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/classes-and-instances.html#instances-of-classes"><small>27.3</small><font papago-translate="splitted"><font papago-translate="translated"> 수업 사례</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/classes-and-instances.html#get-and-set-expressions"><small>27.4</small><font papago-translate="splitted"><font papago-translate="translated"> 식 가져오기 및 설정</font></font></a></li>
<li class="divider"></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/classes-and-instances.html#challenges"><font papago-translate="translated">과제들</font></a></li>
</ul>
<div class="prev-next">
<a class="left" href="https://youhogeon-meritz.github.io/garbage-collection.html" title="쓰레기 수거" papago-attr-id="1"><font papago-translate="translated">← 이전</font></a>
<a href="https://youhogeon-meritz.github.io/a-bytecode-virtual-machine.html" title="바이트코드 가상 머신" papago-attr-id="2"><font papago-translate="translated">↑ 위로</font></a>
<a class="right" href="https://youhogeon-meritz.github.io/methods-and-initializers.html" title="메서드 및 초기화" papago-attr-id="3"><font papago-translate="translated">다음 →</font></a>
</div> </div>
</nav>
<nav class="narrow">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<a class="prev" href="https://youhogeon-meritz.github.io/garbage-collection.html" title="Garbage Collection">←</a>
<a class="next" href="https://youhogeon-meritz.github.io/methods-and-initializers.html" title="Methods and Initializers">→</a>
</nav>
<div class="page">
<div class="nav-wrapper">
<nav class="floating">
<a href="https://youhogeon-meritz.github.io/"><img src="https://youhogeon-meritz.github.io/image/logotype.png" title="Crafting Interpreters"></a>
<div class="expandable">
<h3><a href="https://youhogeon-meritz.github.io/classes-and-instances.html#top"><font papago-translate="splitted"><font papago-translate="translated">클래스 및 인스턴스</font></font><small>27</small></a></h3>
<ul>
<li><a href="https://youhogeon-meritz.github.io/classes-and-instances.html#class-objects"><small>27.1</small><font papago-translate="splitted"><font papago-translate="translated"> 클래스 객체</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/classes-and-instances.html#class-declarations"><small>27.2</small><font papago-translate="splitted"><font papago-translate="translated"> 클래스 선언</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/classes-and-instances.html#instances-of-classes"><small>27.3</small><font papago-translate="splitted"><font papago-translate="translated"> 수업 사례</font></font></a></li>
<li><a href="https://youhogeon-meritz.github.io/classes-and-instances.html#get-and-set-expressions"><small>27.4</small><font papago-translate="splitted"><font papago-translate="translated"> 식 가져오기 및 설정</font></font></a></li>
<li class="divider"></li>
<li class="end-part"><a href="https://youhogeon-meritz.github.io/classes-and-instances.html#challenges">Challenges</a></li>
</ul>
<div class="prev-next">
<a class="left" href="https://youhogeon-meritz.github.io/garbage-collection.html" title="Garbage Collection">←&nbsp;Previous</a>
<a href="https://youhogeon-meritz.github.io/a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">↑&nbsp;Up</a>
<a class="right" href="https://youhogeon-meritz.github.io/methods-and-initializers.html" title="Methods and Initializers">Next&nbsp;→</a>
</div> </div>
<a id="expand-nav">≡</a>
</nav>
</div>
<article class="chapter">
<div class="number">27</div>
<h1><font papago-translate="translated">클래스 및 인스턴스</font></h1>
<blockquote>
<p><font papago-translate="translated">물건을 너무 많이 신경 쓰면 당신을 망칠 수 있습니다.</font><font papago-translate="translated"> 오직—어떤 것을 충분히 신경 쓰면, 그 자체로 삶을 살게 되죠,<span class="em"></span> 그렇지 않나요?</font><font papago-translate="translated"> 그리고 아름다운 것들이 당신을 더 큰<span class="em"></span><span class="em"></span> 아름다움과 연결해 주는 것이 핵심이 아닐까요?</font></p>
<p><cite>Donna Tartt, <em>The Goldfinch</em></cite></p>
</blockquote>
<p><font papago-translate="translated">clox에서 마지막으로 구현해야 할 영역은 객체 지향 프로그래밍입니다.</font><font papago-translate="translated"> <span name="oop">OOP</span>는 클래스, 인스턴스, 필드, 메서드, 초기화자, 상속 등 다양한 기능이 얽혀 있는 번들입니다<span name="oop">.</span></font><font papago-translate="translated" class=""> 비교적 높은 수준의 Java를 사용하여 이 모든 것을 두 장으로 나누었습니다.</font><font papago-translate="translated"> 이제 이쑤시개로 에펠탑 모형을 만드는 것 같은 느낌의 C로 코딩하고 있으니, 같은 영역을 다루는 데 세 개의 챕터를 할애하겠습니다.</font><font papago-translate="translated"> 이렇게 하면 구현 과정을 여유롭게 거닐 수 있습니다.</font><font papago-translate="translated"> <a href="https://youhogeon-meritz.github.io/closures.html">폐쇄</a>와<a href="https://youhogeon-meritz.github.io/garbage-collection.html"> 쓰레기 수거</a> 같은 힘든 장을 거친 후, 당신은 휴식을 얻었습니다.</font><font papago-translate="translated"> 사실, 이 책은 이제부터 쉽게 읽을 수 있을 것입니다.</font></p>
<aside name="oop" style="top: 448px;">
<p><font papago-translate="translated" class="">객체 지향 프로그래밍에 대해 강한 의견을 가진 사람들, 즉 "모두"를 읽는 사람들은 OOP가 매우 구체적인 언어 특징 목록을 의미한다고 생각하는 경향이 있습니다. 하지만 실제로 탐구할 수 있는 공간이 전체적으로 존재하며 각 언어에는 고유한 재료와<span class="em"></span><span class="em"></span> 레시피가 있습니다.</font></p>
<p><font papago-translate="translated">자아는 대상은 있지만 계급은 없습니다.</font><font papago-translate="translated"> CLOSS에는 메서드가 있지만 특정 클래스에 연결하지는 않습니다.</font><font papago-translate="translated" class=""> C++는 처음에는 런타임 다형성이 없었고, 가상<span class="em"></span> 메서드도 없었습니다.</font><font papago-translate="translated"> 파이썬은 여러 개의 상속을 받지만, 자바는 그렇지 않습니다.</font><font papago-translate="translated"> Ruby는 메서드를 클래스에 첨부하지만, 단일 객체에 메서드를 정의할 수도 있습니다.</font></p>
</aside>
<p><font papago-translate="translated">이 장에서는 클래스, 인스턴스, 필드의 처음 세 가지 기능을 다룹니다.</font><font papago-translate="translated"> 이것은 객체 지향의 상태적인 측면입니다.</font><font papago-translate="translated"> 그런 다음 다음 두 장에서는 이러한 객체의 동작과 코드 재사용을 중단하겠습니다.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/classes-and-instances.html#class-objects" id="class-objects"><small><font papago-translate="translated">27 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">클래스 객체</font></font></a></h2>
<p><font papago-translate="translated">수업 기반 객체 지향 언어에서는 모든 것이 수업에서 시작됩니다.</font><font papago-translate="translated"> 그들은 프로그램에 존재하는 객체의 종류와 새로운 인스턴스를 생성하는 데 사용되는 공장을 정의합니다.</font><font papago-translate="translated"> 요약하자면, 우리는 그들의 런타임 표현부터 시작해서 그것을 언어에 연결할 것입니다.</font></p>
<p><font papago-translate="translated">이 시점에서 우리는 VM에 새로운 객체 유형을 추가하는 과정에 대해 잘 알고 있습니다.</font><font papago-translate="translated"> 구조부터 시작합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">} ObjClosure;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 구조 후 Ob<em>jClosure</em> 추가</font></font></div>
<pre class="insert" translate="no">
<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">Obj</span> <span class="i">obj</span>;
  <span class="t">ObjString</span>* <span class="i">name</span>;
} <span class="t">ObjClass</span>;
</pre><pre class="insert-after" translate="no">
ObjClosure* newClosure(ObjFunction* function);
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after struct <em>ObjClosure</em></div>
<p><font papago-translate="translated">Obj 헤더 뒤에 클래스 이름을 저장합니다.</font><font papago-translate="translated"> 이것은 사용자의 프로그램에 꼭 필요한 것은 아니지만, 스택 트레이스와 같은 것들의 이름을 런타임에 표시할 수 있게 해줍니다.</font></p>
<p><font papago-translate="translated">새로운 유형은 ObjType 열거에 해당하는 대문자가 필요합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">typedef enum {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> enum Ob<em>jType</em>에서</font></font></div>
<pre class="insert" translate="no">  <span class="a">OBJ_CLASS</span>,
</pre><pre class="insert-after" translate="no">  OBJ_CLOSURE,
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, in enum <em>ObjType</em></div>
<p><font papago-translate="translated">그리고 그 유형은 해당하는 매크로 쌍을 얻습니다.</font><font papago-translate="translated"> 먼저, 객체의 유형을 테스트하기 위해:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#define OBJ_TYPE(value)        (AS_OBJ(value)-&gt;type)

</pre><div class="source-file"><em><font papago-translate="translated">객체.h</font></em></div>
<pre class="insert" translate="no"><span class="a">#define IS_CLASS(value)        isObjType(value, OBJ_CLASS)</span>
</pre><pre class="insert-after" translate="no">#define IS_CLOSURE(value)      isObjType(value, OBJ_CLOSURE)
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>
<p><font papago-translate="translated">그리고 ObjClass 포인터에 값을 할당하는 경우:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#define IS_STRING(value)       isObjType(value, OBJ_STRING)

</pre><div class="source-file"><em><font papago-translate="translated">객체.h</font></em></div>
<pre class="insert" translate="no"><span class="a">#define AS_CLASS(value)        ((ObjClass*)AS_OBJ(value))</span>
</pre><pre class="insert-after" translate="no">#define AS_CLOSURE(value)      ((ObjClosure*)AS_OBJ(value))
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>
<p><font papago-translate="translated">VM은 이 함수를 사용하여 새로운 클래스 객체를 생성합니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">} ObjClass;

</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 구조 Ob<em>jClass</em> 뒤에 추가</font></font></div>
<pre class="insert" translate="no"><span class="t">ObjClass</span>* <span class="i">newClass</span>(<span class="t">ObjString</span>* <span class="i">name</span>);
</pre><pre class="insert-after" translate="no">ObjClosure* newClosure(ObjFunction* function);
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after struct <em>ObjClass</em></div>
<p><font papago-translate="translated">구현은 여기에 있습니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>할당</em> 후 추가O<em>bject</em>()</font></font></div>
<pre translate="no"><span class="t">ObjClass</span>* <span class="i">newClass</span>(<span class="t">ObjString</span>* <span class="i">name</span>) {
  <span class="t">ObjClass</span>* <span class="i">klass</span> = <span class="a">ALLOCATE_OBJ</span>(<span class="t">ObjClass</span>, <span class="a">OBJ_CLASS</span>);
  <span class="i">klass</span>-&gt;<span class="i">name</span> = <span class="i">name</span>;<span name="klass"> </span>
  <span class="k">return</span> <span class="i">klass</span>;
}
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, add after <em>allocateObject</em>()</div>
<p><font papago-translate="translated">거의 모든 것이 보일러 플레이트입니다.</font><font papago-translate="translated"> 클래스 이름을 문자열로 가져와서 저장합니다.</font><font papago-translate="translated"> 사용자가 새 클래스를 선언할 때마다 VM은 이를 표현할 새로운 ObjClass 구조를 생성합니다.</font></p>
<aside name="klass" style="top: 2003px;"><img alt="'Klass' in a zany kidz font." src="https://youhogeon-meritz.github.io/image/classes-and-instances/klass.png">
<p><font papago-translate="translated">저는 VM에게 단순히 "Kidz Korner" 같은 느낌을 주기 위해 변수를 "class"라고 명명했습니다.</font><font papago-translate="translated"> "clox 컴파일을 C++로 얻는 것을 더 쉽게 만듭니다. 여기서 "class"는 예약된 단어입니다.</font></p>
</aside>
<p><font papago-translate="translated">VM에 더 이상 클래스가 필요하지 않을 때는 다음과 같이 자유롭게 합니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  switch (object-&gt;type) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>free</em>O<em>bject</em>()에서</font></font></div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="a">OBJ_CLASS</span>: {
      <span class="a">FREE</span>(<span class="t">ObjClass</span>, <span class="i">object</span>);
      <span class="k">break</span>;
    }<span name="braces"> </span>
</pre><pre class="insert-after" translate="no">    case OBJ_CLOSURE: {
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>freeObject</em>()</div>
<aside name="braces" style="top: 2311px;">
<p><font papago-translate="translated">여기 있는 괄호는 이제 의미가 없지만, 다음 장에서 스위치 케이스에 코드를 추가할 때 유용할 것입니다.</font></p>
</aside>
<p><font papago-translate="translated">현재 메모리 관리자가 있으므로 클래스 객체를 통한 추적도 지원해야 합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  switch (object-&gt;type) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>blacken</em>O<em>bject</em>()에서</font></font></div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="a">OBJ_CLASS</span>: {
      <span class="t">ObjClass</span>* <span class="i">klass</span> = (<span class="t">ObjClass</span>*)<span class="i">object</span>;
      <span class="i">markObject</span>((<span class="t">Obj</span>*)<span class="i">klass</span>-&gt;<span class="i">name</span>);
      <span class="k">break</span>;
    }
</pre><pre class="insert-after" translate="no">    case OBJ_CLOSURE: {
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>blackenObject</em>()</div>
<p><font papago-translate="translated">GC가 클래스 객체에 도달하면 해당 문자열을 유지하기 위해 클래스 이름도 표시합니다.</font></p>
<p><font papago-translate="translated">VM이 클래스에서 수행할 수 있는 마지막 작업은 이를 인쇄하는 것입니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  switch (OBJ_TYPE(value)) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>print</em>O<em>bject</em>()에서</font></font></div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="a">OBJ_CLASS</span>:
      <span class="i">printf</span>(<span class="s">"%s"</span>, <span class="a">AS_CLASS</span>(<span class="i">value</span>)-&gt;<span class="i">name</span>-&gt;<span class="i">chars</span>);
      <span class="k">break</span>;
</pre><pre class="insert-after" translate="no">    case OBJ_CLOSURE:
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>printObject</em>()</div>
<p><font papago-translate="translated">수업은 단순히 자신의 이름을 말합니다.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/classes-and-instances.html#class-declarations" id="class-declarations"><small><font papago-translate="translated">27 . 2</font></small><font papago-translate="splitted"><font papago-translate="translated">클래스 선언</font></font></a></h2>
<p><font papago-translate="translated">런타임 표현을 통해 언어에 수업 지원을 추가할 준비가 되었습니다.</font><font papago-translate="translated"> 다음으로 파서로 이동합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">static void declaration() {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>선언</em>문 ()에서</font></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">  <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_CLASS</span>)) {
    <span class="i">classDeclaration</span>();
  } <span class="k">else</span> <span class="k">if</span> (<span class="i">match</span>(<span class="a">TOKEN_FUN</span>)) {
</pre><pre class="insert-after" translate="no">    funDeclaration();
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, in <em>declaration</em>(), replace 1 line</div>
<p><font papago-translate="splitted"><font papago-translate="translated">클래스 선언문은 진술이며, 파서는 선두자가 하나를 인식합니다 </font></font><code translate="no">class</code><font papago-translate="splitted"><font papago-translate="translated"> 키워드.</font><font papago-translate="translated"> 나머지 컴파일은 여기에서 이루어집니다:</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>함수</em> () 후에 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">classDeclaration</span>() {
  <span class="i">consume</span>(<span class="a">TOKEN_IDENTIFIER</span>, <span class="s">"Expect class name."</span>);
  <span class="t">uint8_t</span> <span class="i">nameConstant</span> = <span class="i">identifierConstant</span>(&amp;<span class="i">parser</span>.<span class="i">previous</span>);
  <span class="i">declareVariable</span>();

  <span class="i">emitBytes</span>(<span class="a">OP_CLASS</span>, <span class="i">nameConstant</span>);
  <span class="i">defineVariable</span>(<span class="i">nameConstant</span>);

  <span class="i">consume</span>(<span class="a">TOKEN_LEFT_BRACE</span>, <span class="s">"Expect '{' before class body."</span>);
  <span class="i">consume</span>(<span class="a">TOKEN_RIGHT_BRACE</span>, <span class="s">"Expect '}' after class body."</span>);
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>function</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">직후에 </font></font><code translate="no">class</code><font papago-translate="splitted"><font papago-translate="translated"> 키워드는 클래스의 이름입니다.</font><font papago-translate="translated"> 우리는 그 식별자를 가져와서 주변 함수의 상수 테이블에 문자열로 추가합니다.</font><font papago-translate="translated"> 방금 보신 것처럼 클래스를 인쇄하면 이름이 표시되므로 컴파일러는 런타임이 찾을 수 있는 곳에 이름 문자열을 채워야 합니다.</font><font papago-translate="translated"> 상수 테이블이 그것을 하는 방법입니다.</font></font></p>
<p><font papago-translate="translated">클래스<span name="variable"> 이름</span>은 클래스 객체를 같은 이름의 변수에 바인딩하는 데에도 사용됩니다.</font><font papago-translate="translated"> 그래서 우리는 그 식별자가 있는 변수를 토큰을 소비한 직후에 선언합니다.</font></p>
<aside name="variable" style="top: 3632px;">
<p><font papago-translate="translated">클래스 선언을 문장 대신<em> 표현</em>으로 만들 수도 있었는데, 결국<span class="em"></span> 가치를 창출하는 리터럴입니다.</font><font papago-translate="translated"> 그러면 사용자는 클래스를 다음과 같은 변수에 명시적으로 바인딩해야 합니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="t">Pie</span> = <span class="k">class</span> {}
</pre></div>
<p><font papago-translate="translated">람다 함수와 비슷하지만 클래스용입니다.</font><font papago-translate="translated"> 하지만 우리는 일반적으로 어쨌든 수업 이름이 붙여지기를 원하기 때문에, 그것들을 선언문으로 취급하는 것이 합리적입니다.</font></p>
</aside>
<p><font papago-translate="translated">다음으로, 런타임 시 클래스 객체를 실제로 생성하기 위한 새로운 지침을 제시합니다.</font><font papago-translate="translated"> 이 명령어는 클래스 이름의 상수 테이블 인덱스를 피연산자로 사용합니다.</font></p>
<p><font papago-translate="translated">그 후에, 수업 본문을 작성하기 전에, 우리는 수업 이름에 대한 변수를 정의합니다.</font><font papago-translate="translated"> 변수<em>를 선언하면</em> 범위에 추가되지만, 이전<a href="https://youhogeon-meritz.github.io/local-variables.html#another-scope-edge-case"> 장</a>에서 변수<em>가 정의</em>될 때까지<em> 사용할</em> 수 없다는 점을 기억하세요<em>.</em></font><font papago-translate="translated"> 수업에서는 본문 앞에 변수를 정의합니다.</font><font papago-translate="translated"> 그렇게 하면 사용자는 자체 메서드의 본문에 포함된 클래스를 참조할 수 있습니다.</font><font papago-translate="translated"> 그것은 수업의 새로운 사례를 생성하는 공장 방법과 같은 것들에 유용합니다.</font></p>
<p><font papago-translate="translated">마침내, 우리는 본문을 편집합니다.</font><font papago-translate="translated"> 아직 방법이 없기 때문에 지금은 단순히 빈 보조기 한 쌍에 불과합니다.</font><font papago-translate="translated"> Lox는 클래스에서 필드를 선언할 필요가 없으므로 현재로서는 본문과 파<span class="em"></span><span class="em"></span>서를 모두 마쳤습니다.</font></p>
<p><font papago-translate="translated">컴파일러가 새로운 명령어를 방출하고 있으므로 이를 정의해 보겠습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  OP_RETURN,
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">청크.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> enum O<em>pCode</em>에서</font></font></div>
<pre class="insert" translate="no">  <span class="a">OP_CLASS</span>,
</pre><pre class="insert-after" translate="no">} OpCode;
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>
<p><font papago-translate="translated">그리고 분해기에 추가합니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    case OP_RETURN:
      return simpleInstruction("OP_RETURN", offset);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">debug.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>분해</em> 중 지침()</font></font></div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="a">OP_CLASS</span>:
      <span class="k">return</span> <span class="i">constantInstruction</span>(<span class="s">"OP_CLASS"</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
</pre><pre class="insert-after" translate="no">    default:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>
<p><font papago-translate="translated">이러한 대형 기능의 경우 인터프리터 지원이 최소화됩니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">        break;
      }
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font></div>
<pre class="insert" translate="no">      <span class="k">case</span> <span class="a">OP_CLASS</span>:
        <span class="i">push</span>(<span class="a">OBJ_VAL</span>(<span class="i">newClass</span>(<span class="a">READ_STRING</span>())));
        <span class="k">break</span>;
</pre><pre class="insert-after" translate="no">    }
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">우리는 상수 테이블에서 클래스 이름의 문자열을 로드하고 그것을 다음과 같이 전달합니다 </font></font><code translate="no">newClass()</code><font papago-translate="splitted"><font papago-translate="translated">. 그러면 지정된 이름을 가진 새로운 클래스 객체가 생성됩니다.</font><font papago-translate="translated"> 우리는 그것을 스택에 밀어 넣으면 괜찮습니다.</font><font papago-translate="translated"> 클래스가 전역 변수에 바인딩된 경우 컴파일러의 호출은 다음과 같습니다 </font></font><code translate="no">defineVariable()</code><font papago-translate="splitted"><font papago-translate="translated"> 스택에서 해당 객체를 글로벌 변수 테이블에 저장하기 위해 코드를 방출합니다.</font><font papago-translate="translated"> 그렇지 않으면 새로운<span name="local"> 로컬</span> 변수를 위해 스택에 있어야 하는 바로 그 위치에 있습니다.</font></font></p>
<aside name="local" style="top: 4704px;">
<p><font papago-translate="translated">"로컬" 클래스—함수나 블록의 본문 안에 선언된 클래스들은 특이<span class="em"></span>한 개념입니다.</font><font papago-translate="translated"> 많은 언어들이 그것들을 전혀 허용하지 않습니다.</font><font papago-translate="translated"> 하지만 Lox는 동적으로 타입화된 스크립팅 언어이기 때문에 프로그램의 최상위 레벨과 함수 및 블록을 균일하게 처리합니다.</font><font papago-translate="translated"> 클래스는 또 다른 종류의 선언일 뿐이며, 블록 안에서 변수와 함수를 선언할 수 있기 때문에 블록 안에서도 클래스를 선언할 수 있습니다.</font></p>
</aside>
<p><font papago-translate="translated">이제 VM이 수업을 지원합니다.</font><font papago-translate="translated"> 실행할 수 있습니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">class</span> <span class="t">Brioche</span> {}
<span class="k">print</span> <span class="t">Brioche</span>;
</pre></div>
<p><font papago-translate="translated">안타깝게도 인쇄는 수업에서 할 수<em> 있는 거의 모든 것</em>이므로 다음은 수업을 더 유용하게 만드는 것입니다.</font></p>
<h2><a href="https://youhogeon-meritz.github.io/classes-and-instances.html#instances-of-classes" id="instances-of-classes"><small><font papago-translate="translated">27 . 3</font></small><font papago-translate="splitted"><font papago-translate="translated">수업 사례</font></font></a></h2>
<p><font papago-translate="translated">수업은 언어에서 두 가지 주요 목적을 수행합니다:</font></p>
<ul>
<li>
<p><font papago-translate="splitted"><font papago-translate="translated"><strong>이것이 바로 새로운 인스턴스를 만드는 방법입니다.</strong></font><font papago-translate="translated"> 때때로 이것은 다음과 같은 것을 포함합니다 </font></font><code translate="no">new</code><font papago-translate="splitted"><font papago-translate="translated"> 키워드, 다른 경우에는 클래스 객체에 대한 메서드 호출이지만, 보통 새로운 인스턴스를 얻기 위해<em> 클래스</em>를 어떻게<em>든</em> 이름으로 언급합니다.</font></font></p>
</li>
<li>
<p><font papago-translate="translated"><strong>그들은 방법을 포함하고 있습니다.</strong></font><font papago-translate="translated"> 이것들은 클래스의 모든 인스턴스가 어떻게 작동하는지를 정의합니다.</font></p>
</li>
</ul>
<p><font papago-translate="translated">다음 장까지는 방법에 접근할 수 없으므로 지금은 첫 번째 부분만 걱정하겠습니다.</font><font papago-translate="translated"> 수업이 인스턴스를 만들기 전에, 우리는 그들을 위한 표현이 필요합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">} ObjClass;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 구조 Ob<em>jClass</em> 뒤에 추가</font></font></div>
<pre class="insert" translate="no">
<span class="k">typedef</span> <span class="k">struct</span> {
  <span class="t">Obj</span> <span class="i">obj</span>;
  <span class="t">ObjClass</span>* <span class="i">klass</span>;
  <span class="t">Table</span> <span class="i">fields</span>;<span name="fields"> </span>
} <span class="t">ObjInstance</span>;
</pre><pre class="insert-after" translate="no">
ObjClass* newClass(ObjString* name);
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after struct <em>ObjClass</em></div>
<p><font papago-translate="translated">인스턴스는 자신의 클래스를 알고 있으며, 각 인스턴스는<span class="em"></span> 자신이 인스턴스인 클래스에 대한 포인터를 가지고 있습니다.</font><font papago-translate="translated"> 이 장에서는 이 정도는 사용하지 않겠지만, 방법을 추가하면 중요해질 것입니다.</font></p>
<p><font papago-translate="translated">이 장에서 더 중요한 것은 인스턴스가 상태를 저장하는 방식입니다.</font><font papago-translate="translated"> Lox는 런타임 시 사용자가 인스턴스에 필드를 자유롭게 추가할 수 있도록 합니다.</font><font papago-translate="translated"> 이는 성장할 수 있는 저장 메커니즘이 필요하다는 것을 의미합니다.</font><font papago-translate="translated"> 동적 배열을 사용할 수도 있지만, 가능한 한 빨리 이름별 필드를 찾고 싶습니다.</font><font papago-translate="translated"> 이름별로 일련의 값에 빠르게 접근할 수 있는 완벽한 데이터 구조가 있으며, 더욱 편리하게는 이미<span class="em"></span><span class="em"></span> 구현했습니다.</font><font papago-translate="translated"> 각 인스턴스는 해시 테이블을 사용하여 필드를 저장합니다.</font></p>
<aside name="fields" style="top: 5443px;">
<p><font papago-translate="translated">런타임에 객체에 필드를 자유롭게 추가할 수 있다는 것은 대부분의 동적 언어와 정적 언어 사이에 큰 실질적인 차이가 있습니다.</font><font papago-translate="translated"> 정적으로 입력된 언어는 일반적으로 필드를 명시적으로 선언해야 합니다.</font><font papago-translate="translated"> 이렇게 하면 컴파일러는 각 인스턴스에 어떤 필드가 있는지 정확히 알 수 있습니다.</font><font papago-translate="translated"> 이를 사용하여 각 인스턴스에 필요한 정확한 메모리 양과 각 필드를 찾을 수 있는 메모리의 오프셋을 결정할 수 있습니다.</font></p>
<p><font papago-translate="translated">Lox 및 기타 동적 언어에서는 일반적으로 필드에 액세스하는 것이 해시 테이블 조회입니다.</font><font papago-translate="translated"> 일정한 시간이지만 여전히 꽤 무겁습니다.</font><font papago-translate="translated"> C++와 같은 언어에서는 필드에 접근하는 것이 포인터를 정수 상수만큼 오프셋하는 것만큼 빠릅니다.</font></p>
</aside>
<p><font papago-translate="translated">포함 항목만 추가하면 됩니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#include "chunk.h"
</pre><div class="source-file"><em><font papago-translate="translated">객체.h</font></em></div>
<pre class="insert" translate="no"><span class="a">#include "table.h"</span>
</pre><pre class="insert-after" translate="no">#include "value.h"
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>
<p><font papago-translate="translated">이 새로운 구조는 새로운 객체 유형을 얻습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  OBJ_FUNCTION,
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> enum Ob<em>jType</em>에서</font></font></div>
<pre class="insert" translate="no">  <span class="a">OBJ_INSTANCE</span>,
</pre><pre class="insert-after" translate="no">  OBJ_NATIVE,
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, in enum <em>ObjType</em></div>
<p><font papago-translate="translated">여기서 조금 천천히 하고 싶습니다. 왜냐하면 L<em>ox 언어의</em> "유형" 개념과 VM<em> 구현의</em> "유형" 개념이 혼동될 수 있는 방식으로 서로 충돌하기 때문입니다.</font><font papago-translate="translated"> 클록스를 만드는 C 코드 내부에는 여러 가지 종류의 Ob<span class="em">j</span>-ObjString, ObjClosure 등이 있습니다.</font><font papago-translate="translated"> 각각은 고유한 내적 표현과 의미를 가지고 있습니다.</font></p>
<p><font papago-translate="translated">L<em>ox 언어에서는</em> 사용자가 자신만의 클래스(예: Cake and Pie)를 정의한 다음 해당<span class="em"></span><span class="em"></span> 클래스의 인스턴스를 만들 수 있습니다.</font><font papago-translate="translated"> 사용자의 관점에서 보면, 케이크의 인스턴스는 파이의 인스턴스와는 다른 유형의 객체입니다.</font><font papago-translate="translated"> 하지만 VM의 관점에서 보면 사용자가 정의하는 모든 클래스는 단순히 ObjClass 유형의 또 다른 값일 뿐입니다.</font><font papago-translate="translated"> 마찬가지로, 사용자 프로그램의 각 인스턴스는 어떤 클래스의 인스턴스이든 상관없이 ObjInstance입니다.</font><font papago-translate="translated"> 그 하나의 VM 객체 유형은 모든 클래스의 인스턴스를 다룹니다.</font><font papago-translate="translated"> 두 세계는 서로 다음과 같은 방식으로 매핑됩니다:</font></p><img alt="A set of class declarations and instances, and the runtime representations each maps to." src="https://youhogeon-meritz.github.io/image/classes-and-instances/lox-clox.png">
<p><font papago-translate="translated">알겠어요?</font><font papago-translate="translated"> 좋아요, 다시 구현으로 돌아갑니다.</font><font papago-translate="translated"> 우리는 또한 평소의 매크로를 얻습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#define IS_FUNCTION(value)     isObjType(value, OBJ_FUNCTION)
</pre><div class="source-file"><em><font papago-translate="translated">객체.h</font></em></div>
<pre class="insert" translate="no"><span class="a">#define IS_INSTANCE(value)     isObjType(value, OBJ_INSTANCE)</span>
</pre><pre class="insert-after" translate="no">#define IS_NATIVE(value)       isObjType(value, OBJ_NATIVE)
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>
<p><font papago-translate="translated">그리고:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">#define AS_FUNCTION(value)     ((ObjFunction*)AS_OBJ(value))
</pre><div class="source-file"><em><font papago-translate="translated">객체.h</font></em></div>
<pre class="insert" translate="no"><span class="a">#define AS_INSTANCE(value)     ((ObjInstance*)AS_OBJ(value))</span>
</pre><pre class="insert-after" translate="no">#define AS_NATIVE(value) \
</pre></div>
<div class="source-file-narrow"><em>object.h</em></div>
<p><font papago-translate="translated">인스턴스가 생성된 후 필드가 추가되므로 "생성자" 함수는 클래스만 알면 됩니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">ObjFunction* newFunction();
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>newFunction</em>() 다음에 추가</font></font></div>
<pre class="insert" translate="no"><span class="t">ObjInstance</span>* <span class="i">newInstance</span>(<span class="t">ObjClass</span>* <span class="i">klass</span>);
</pre><pre class="insert-after" translate="no">ObjNative* newNative(NativeFn function);
</pre></div>
<div class="source-file-narrow"><em>object.h</em>, add after <em>newFunction</em>()</div>
<p><font papago-translate="translated">우리는 여기서 그 기능을 구현합니다:</font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>newFunction</em>() 다음에 추가</font></font></div>
<pre translate="no"><span class="t">ObjInstance</span>* <span class="i">newInstance</span>(<span class="t">ObjClass</span>* <span class="i">klass</span>) {
  <span class="t">ObjInstance</span>* <span class="i">instance</span> = <span class="a">ALLOCATE_OBJ</span>(<span class="t">ObjInstance</span>, <span class="a">OBJ_INSTANCE</span>);
  <span class="i">instance</span>-&gt;<span class="i">klass</span> = <span class="i">klass</span>;
  <span class="i">initTable</span>(&amp;<span class="i">instance</span>-&gt;<span class="i">fields</span>);
  <span class="k">return</span> <span class="i">instance</span>;
}
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, add after <em>newFunction</em>()</div>
<p><font papago-translate="translated">인스턴스의 클래스에 대한 참조를 저장합니다.</font><font papago-translate="translated"> 그런 다음 필드 테이블을 빈 해시 테이블로 초기화합니다.</font><font papago-translate="translated"> 새로운 아기 물체가 태어납니다!</font></p>
<p><font papago-translate="translated">인스턴스의 수명이 더 슬픈 끝에서 해방됩니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      FREE(ObjFunction, object);
      break;
    }
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>free</em>O<em>bject</em>()에서</font></font></div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="a">OBJ_INSTANCE</span>: {
      <span class="t">ObjInstance</span>* <span class="i">instance</span> = (<span class="t">ObjInstance</span>*)<span class="i">object</span>;
      <span class="i">freeTable</span>(&amp;<span class="i">instance</span>-&gt;<span class="i">fields</span>);
      <span class="a">FREE</span>(<span class="t">ObjInstance</span>, <span class="i">object</span>);
      <span class="k">break</span>;
    }
</pre><pre class="insert-after" translate="no">    case OBJ_NATIVE:
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>freeObject</em>()</div>
<p><font papago-translate="translated">인스턴스는 필드 테이블을 소유하고 있으므로 인스턴스를 해제할 때 테이블도 해제합니다.</font><font papago-translate="translated"> 우리는 표의 항목들을 명시적으로 자유롭게 하지 않습니다. 왜냐하면 그<em></em> 객체들에 대한 다른 참조가 있을 수 있기 때문입니다.</font><font papago-translate="translated"> 쓰레기 수거원이 우리를 위해 그것들을 처리해 줄 것입니다.</font><font papago-translate="translated"> 여기서는 테이블 자체의 항목 배열만 해제합니다.</font></p>
<p><font papago-translate="translated">쓰레기 수거기에 대해 말하자면, 사례를 추적할 수 있는 지원이 필요합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      markArray(&amp;function-&gt;chunk.constants);
      break;
    }
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">메모리.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>blacken</em>O<em>bject</em>()에서</font></font></div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="a">OBJ_INSTANCE</span>: {
      <span class="t">ObjInstance</span>* <span class="i">instance</span> = (<span class="t">ObjInstance</span>*)<span class="i">object</span>;
      <span class="i">markObject</span>((<span class="t">Obj</span>*)<span class="i">instance</span>-&gt;<span class="i">klass</span>);
      <span class="i">markTable</span>(&amp;<span class="i">instance</span>-&gt;<span class="i">fields</span>);
      <span class="k">break</span>;
    }
</pre><pre class="insert-after" translate="no">    case OBJ_UPVALUE:
</pre></div>
<div class="source-file-narrow"><em>memory.c</em>, in <em>blackenObject</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">인스턴스가 살아 있다면 클래스를 유지해야 합니다.</font><font papago-translate="translated"> 또한 인스턴스 필드에서 참조되는 모든 객체를 유지해야 합니다.</font><font papago-translate="translated"> 루트가 아닌 대부분의 살아있는 객체는 필드에 있는 객체를 참조하는 경우가 있기 때문에 도달할 수 있습니다.</font><font papago-translate="translated"> 다행히도 이미 좋은 제품이 있습니다 </font></font><code translate="no">markTable()</code><font papago-translate="splitted"><font papago-translate="translated"> 추적을 쉽게 하는 기능.</font></font></p>
<p><font papago-translate="translated">덜 중요하지만 여전히 중요한 것은 인쇄입니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      break;
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">객체.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>print</em>O<em>bject</em>()에서</font></font></div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="a">OBJ_INSTANCE</span>:
      <span class="i">printf</span>(<span class="s">"%s instance"</span>,
             <span class="a">AS_INSTANCE</span>(<span class="i">value</span>)-&gt;<span class="i">klass</span>-&gt;<span class="i">name</span>-&gt;<span class="i">chars</span>);
      <span class="k">break</span>;
</pre><pre class="insert-after" translate="no">    case OBJ_NATIVE:
</pre></div>
<div class="source-file-narrow"><em>object.c</em>, in <em>printObject</em>()</div>
<p><font papago-translate="translated">인스턴스<span name="print"></span>는 이름 뒤에 "인스턴스"를 출력합니다.</font><font papago-translate="translated"> "인스턴스" 부분은 주로 수업과 인스턴스가 동일하게 인쇄되지 않도록 하는 것입니다</font></p>
<aside name="print" style="top: 8714px;">
<p><font papago-translate="splitted"><font papago-translate="translated">대부분의 객체 지향 언어는 클래스가 다음과 같은 정의를 내릴 수 있도록 합니다 </font></font><code translate="no">toString()</code><font papago-translate="splitted"><font papago-translate="translated"> 클래스가 인스턴스를 문자열로 변환하고 인쇄하는 방법을 지정할 수 있는 메서드입니다.</font><font papago-translate="translated"> Lox가 장난감 언어가 아니었다면 저도 그것을 지지하고 싶었습니다.</font></font></p>
</aside>
<p><font papago-translate="splitted"><font papago-translate="translated">진정한 재미는 통역사를 통해 이루어집니다.</font><font papago-translate="translated"> Lox에는 특별한 것이 없습니다 </font></font><code translate="no">new</code><font papago-translate="splitted"><font papago-translate="translated"> 키워드.</font><font papago-translate="translated"> 클래스의 인스턴스를 만드는 방법은 클래스 자체를 함수처럼 호출하는 것입니다.</font><font papago-translate="translated"> 런타임은 이미 함수 호출을 지원하며, 호출되는 객체의 유형을 확인하여 사용자가 숫자나 다른 유효하지 않은 유형을 호출하려고 하지 않는지 확인합니다.</font></font></p>
<p><font papago-translate="translated">우리는 그 런타임 검사를 새로운 사례로 확장합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">    switch (OBJ_TYPE(callee)) {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>callValue</em>()에서</font></font></div>
<pre class="insert" translate="no">      <span class="k">case</span> <span class="a">OBJ_CLASS</span>: {
        <span class="t">ObjClass</span>* <span class="i">klass</span> = <span class="a">AS_CLASS</span>(<span class="i">callee</span>);
        <span class="i">vm</span>.<span class="i">stackTop</span>[-<span class="i">argCount</span> - <span class="n">1</span>] = <span class="a">OBJ_VAL</span>(<span class="i">newInstance</span>(<span class="i">klass</span>));
        <span class="k">return</span> <span class="k">true</span>;
      }
</pre><pre class="insert-after" translate="no">      case OBJ_CLOSURE:
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>callValue</em>()</div>
<p><font papago-translate="translated">호출되는 값이 클래스라면(열린 괄호의 왼쪽에 있는 표현식을 평가할 때 나타나는 객체), 이 값을 생성<span class="em"></span><span class="em"></span>자 호출로 취급합니다.</font><font papago-translate="translated"> 호출된 클래스의 새 인스턴스<span name="args">를 생성</span>하고 그 결과를 스택에 저장합니다.</font></p>
<aside name="args" style="top: 9166px;">
<p><font papago-translate="translated">현재로서는 통화에 전달된 모든 인수를 무시합니다.</font><font papago-translate="translated"> 다음<a href="https://youhogeon-meritz.github.io/methods-and-initializers.html"> 장에서</a> 이니셜라이저 지원을 추가할 때 이 코드를 다시 살펴보겠습니다.</font></p>
</aside>
<p><font papago-translate="translated">우리는 한 걸음 더 나아갔습니다.</font><font papago-translate="translated"> 이제 클래스를 정의하고 인스턴스를 만들 수 있습니다.</font></p>
<div class="codehilite"><pre translate="no"><span class="k">class</span> <span class="t">Brioche</span> {}
<span class="k">print</span> <span class="t">Brioche</span>();
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">다음 괄호를 메모합니다 </font></font><code translate="no">Brioche</code><font papago-translate="splitted"><font papago-translate="translated"> 지금 두 번째 줄에 있습니다.</font><font papago-translate="translated"> 이것은 "브리오슈 사례"를 인쇄합니다.</font></font></p>
<h2><a href="https://youhogeon-meritz.github.io/classes-and-instances.html#get-and-set-expressions" id="get-and-set-expressions"><small><font papago-translate="translated">27 . 4</font></small><font papago-translate="splitted"><font papago-translate="translated">식 가져오기 및 설정</font></font></a></h2>
<p><font papago-translate="translated">인스턴스에 대한 객체 표현은 이미 상태를 저장할 수 있으므로 남은 것은 사용자에게 해당 기능을 노출하는 것뿐입니다.</font><font papago-translate="translated"> 필드는 get 및 set 표현식을 사용하여 접근하고 수정합니다.</font><font papago-translate="translated"> 전통을 깨는 사람은 없지만, Lox는 고전적인 "점" 구문을 사용합니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="i">eclair</span>.<span class="i">filling</span> = <span class="s">"pastry creme"</span>;
<span class="k">print</span> <span class="i">eclair</span>.<span class="i">filling</span>;
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">제 영어 친구들을 위한 그 기간은 마치 infix<span name="sort"></span><span class="em"></span><span class="em"></span> 연산자처럼 작동합니다.</font><font papago-translate="translated"> 왼쪽에 먼저 평가하고 인스턴스를 생성하는 표현이 있습니다.</font><font papago-translate="translated"> 그 후에는 </font></font><code translate="no">.</code><font papago-translate="splitted"><font papago-translate="translated"> 필드 이름이 이어집니다.</font><font papago-translate="translated"> 선행 피연산자가 있으므로 이를 구문 분석 테이블에 연결하여 infix 표현식으로 사용합니다.</font></font></p>
<aside name="sort" style="top: 9702px;">
<p><font papago-translate="splitted"><font papago-translate="translated">저는 "일종의"라고 말합니다. 왜냐하면 오른쪽이 다음과 같기 때문입니다 </font></font><code translate="no">.</code><font papago-translate="splitted"><font papago-translate="translated"> 는 표현식이 아니라 의미론이 get 또는 set 표현식 자체에 의해 처리되는 단일 식별자입니다.</font><font papago-translate="translated"> 그것은 정말로 포스트픽스 표현에 더 가깝습니다.</font></font></p>
</aside>
<div class="codehilite"><pre class="insert-before" translate="no">  [TOKEN_COMMA]         = {NULL,     NULL,   PREC_NONE},
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> 한 줄 바꾸기</font></font></div>
<pre class="insert" translate="no">  [<span class="a">TOKEN_DOT</span>]           = {<span class="a">NULL</span>,     <span class="i">dot</span>,    <span class="a">PREC_CALL</span>},
</pre><pre class="insert-after" translate="no">  [TOKEN_MINUS]         = {unary,    binary, PREC_TERM},
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, replace 1 line</div>
<p><font papago-translate="splitted"><font papago-translate="translated">다른 언어들과 마찬가지로 </font></font><code translate="no">.</code><font papago-translate="splitted"><font papago-translate="translated"> 연산자는 함수 호출의 괄호만큼 높은 우선순위로 단단히 결합합니다.</font><font papago-translate="translated"> 파서가 도트 토큰을 소비한 후, 새로운 파서 함수로 이동합니다.</font></font></p>
<div class="codehilite"><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">컴파일러.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>통화</em> 후 () 추가</font></font></div>
<pre translate="no"><span class="k">static</span> <span class="t">void</span> <span class="i">dot</span>(<span class="t">bool</span> <span class="i">canAssign</span>) {
  <span class="i">consume</span>(<span class="a">TOKEN_IDENTIFIER</span>, <span class="s">"Expect property name after '.'."</span>);
  <span class="t">uint8_t</span> <span class="i">name</span> = <span class="i">identifierConstant</span>(&amp;<span class="i">parser</span>.<span class="i">previous</span>);

  <span class="k">if</span> (<span class="i">canAssign</span> &amp;&amp; <span class="i">match</span>(<span class="a">TOKEN_EQUAL</span>)) {
    <span class="i">expression</span>();
    <span class="i">emitBytes</span>(<span class="a">OP_SET_PROPERTY</span>, <span class="i">name</span>);
  } <span class="k">else</span> {
    <span class="i">emitBytes</span>(<span class="a">OP_GET_PROPERTY</span>, <span class="i">name</span>);
  }
}
</pre></div>
<div class="source-file-narrow"><em>compiler.c</em>, add after <em>call</em>()</div>
<p><font papago-translate="translated">파서는 점 직후<span name="prop">에 속성</span> 이름을 찾을 것으로 예상합니다.</font><font papago-translate="translated"> 토큰의 어휘소를 문자열로 상수 테이블에 로드하여 런타임에 이름을 사용할 수 있도록 합니다.</font></p>
<aside name="prop" style="top: 10222px;">
<p><font papago-translate="translated">컴파일러는 여기서 "필드" 대신 "속성"을 사용합니다. 왜냐하면 Lox는 점 구문을 사용하여 메서드를 호출하지 않고 접근할 수 있게 해주기 때문입니다.</font><font papago-translate="translated"> "Property"는 인스턴스에서 접근할 수 있는 모든 명명된 엔티티를 지칭하는 일반적인 용어입니다.</font><font papago-translate="translated"> 필드는 인스턴스의 상태에 의해 지원되는 속성의 하위 집합입니다.</font></p>
</aside>
<p><font papago-translate="translated">이 하나의 함수<span class="em"></span><span class="em"></span>가 처리하는 두 가지 새로운 표현 형식인 게터와 세터가 있습니다.</font><font papago-translate="translated"> 필드 이름 뒤에 등호가 표시되면 필드에 할당되는 집합 식이어야 합니다.</font><font papago-translate="translated"> 하지만 필드 뒤에 등호가<em></em> 항상 컴파일되도록 허용하는 것은 아닙니다.</font><font papago-translate="translated"> 고려:</font></p>
<div class="codehilite"><pre translate="no"><span class="i">a</span> + <span class="i">b</span>.<span class="i">c</span> = <span class="n">3</span>
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">이는 Lox의 문법에 따르면 구문적으로 유효하지 않으므로 Lox 구현은 오류를 감지하고 보고할 의무가 있습니다 </font></font><code translate="no">dot()</code><font papago-translate="splitted"><font papago-translate="translated"> 조용히 파싱했습니다 </font></font><code translate="no">= 3</code><font papago-translate="splitted"><font papago-translate="translated"> 부분적으로, 우리는 사용자가 작성한 것처럼 코드를 잘못 해석할 것입니다:</font></font></p>
<div class="codehilite"><pre translate="no"><span class="i">a</span> + (<span class="i">b</span>.<span class="i">c</span> = <span class="n">3</span>)
</pre></div>
<p><font papago-translate="splitted"><font papago-translate="translated">문제는 </font></font><code translate="no">=</code><font papago-translate="splitted"><font papago-translate="translated"> 집합 식의 측면은 다음보다 훨씬 낮은 우선순위를 갖습니다 </font></font><code translate="no">.</code><font papago-translate="splitted"><font papago-translate="translated"> 파서가 전화할 수 있습니다 </font></font><code translate="no">dot()</code><font papago-translate="splitted"><font papago-translate="translated"> 설정자가 나타나도록 허용하기에는 너무 높은 우선순위의 맥락에서.</font><font papago-translate="translated"> 이를 잘못 허용하지 않도록 다음과 같은 경우에만 동일한 부분을 구문 분석하고 컴파일합니다 </font></font><code translate="no">canAssign</code><font papago-translate="splitted"><font papago-translate="translated"> 사실입니다.</font><font papago-translate="translated"> 동등한 토큰이 나타나는 경우 </font></font><code translate="no">canAssign</code><font papago-translate="splitted"><font papago-translate="translated"> 거짓입니다, </font></font><code translate="no">dot()</code><font papago-translate="splitted"><font papago-translate="translated"> 그냥 두었다가 다시 돌아옵니다.</font><font papago-translate="translated"> 이 경우 컴파일러는 결국 다음과 같이 해제됩니다 </font></font><code translate="no">parsePrecedence()</code><font papago-translate="splitted"><font papago-translate="translated">, 예상치 못한 순간에 멈춥니다 </font></font><code translate="no">=</code><font papago-translate="splitted"><font papago-translate="translated"> 여전히 다음 토큰으로 남아 있으며 오류를 보고합니다.</font></font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">만약 우리가 </font></font><code translate="no">=</code><font papago-translate="splitted"><font papago-translate="translated"> 허용되는 맥락에서<em></em> 다음과 같은 식을 컴파일합니다.</font><font papago-translate="translated"> 그 후, 우리는 새로운<span name="set"> 지침</span>을 발표합니다.</font><font papago-translate="translated"> 이는 상수 테이블의 속성 이름 인덱스에 대한 단일 피연산자를 필요로 합니다.</font><font papago-translate="translated"> 우리가 집합 표현식을 컴파일하지 않았다면, 그것이 게터라고 가정하고 방출합니다 </font></font><code translate="no">OP_GET_PROPERTY</code><font papago-translate="splitted"><font papago-translate="translated"> 명령어는 속성 이름에 대한 피연산자도 필요로 합니다.</font></font></p>
<aside name="set" style="top: 10838px;">
<p><font papago-translate="splitted"><font papago-translate="translated">비필드 속성<em>을 설정</em>할 수 없으므로 해당 지침은 다음과 같을 수 있습니다 </font></font><code translate="no">OP_SET_FIELD</code><font papago-translate="splitted"><font papago-translate="translated">, 하지만 겟 지시에 일관되게 따르는 것이 더 보기 좋다고 생각했습니다.</font></font></p>
</aside>
<p><font papago-translate="translated">지금이 이 두 가지 새로운 지침을 정의하기에 좋은 시기입니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">  OP_SET_UPVALUE,
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">청크.h</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> enum O<em>pCode</em>에서</font></font></div>
<pre class="insert" translate="no">  <span class="a">OP_GET_PROPERTY</span>,
  <span class="a">OP_SET_PROPERTY</span>,
</pre><pre class="insert-after" translate="no">  OP_EQUAL,
</pre></div>
<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>
<p><font papago-translate="translated">그리고 분해를 위한 지지대를 추가합니다:</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      return byteInstruction("OP_SET_UPVALUE", chunk, offset);
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">debug.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>분해</em> 중 지침()</font></font></div>
<pre class="insert" translate="no">    <span class="k">case</span> <span class="a">OP_GET_PROPERTY</span>:
      <span class="k">return</span> <span class="i">constantInstruction</span>(<span class="s">"OP_GET_PROPERTY"</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
    <span class="k">case</span> <span class="a">OP_SET_PROPERTY</span>:
      <span class="k">return</span> <span class="i">constantInstruction</span>(<span class="s">"OP_SET_PROPERTY"</span>, <span class="i">chunk</span>, <span class="i">offset</span>);
</pre><pre class="insert-after" translate="no">    case OP_EQUAL:
</pre></div>
<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>
<h3><a href="https://youhogeon-meritz.github.io/classes-and-instances.html#interpreting-getter-and-setter-expressions" id="interpreting-getter-and-setter-expressions"><small><font papago-translate="translated">27 . 4 . 1</font></small><font papago-translate="splitted"><font papago-translate="translated">게터 및 세터 표현식 해석</font></font></a></h3>
<p><font papago-translate="translated">런타임으로 넘어가면, 그것들이 조금 더 간단하기 때문에 get expressions로 시작하겠습니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      }
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font></div>
<pre class="insert" translate="no">      <span class="k">case</span> <span class="a">OP_GET_PROPERTY</span>: {
        <span class="t">ObjInstance</span>* <span class="i">instance</span> = <span class="a">AS_INSTANCE</span>(<span class="i">peek</span>(<span class="n">0</span>));
        <span class="t">ObjString</span>* <span class="i">name</span> = <span class="a">READ_STRING</span>();

        <span class="t">Value</span> <span class="i">value</span>;
        <span class="k">if</span> (<span class="i">tableGet</span>(&amp;<span class="i">instance</span>-&gt;<span class="i">fields</span>, <span class="i">name</span>, &amp;<span class="i">value</span>)) {
          <span class="i">pop</span>(); <span class="c">// Instance.</span>
          <span class="i">push</span>(<span class="i">value</span>);
          <span class="k">break</span>;
        }
      }
</pre><pre class="insert-after" translate="no">      case OP_EQUAL: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p><font papago-translate="translated">인터프리터가 이 명령에 도달하면 점의 왼쪽에 있는 표현식이 이미 실행되어 결과 인스턴스가 스택 위에 있습니다.</font><font papago-translate="translated"> 상수 풀에서 필드 이름을 읽고 인스턴스의 필드 테이블에서 찾습니다.</font><font papago-translate="translated"> 해시 테이블에 해당 이름의 항목이 포함되어 있으면 인스턴스를 팝업하고 그 결과 항목의 값을 푸시합니다.</font></p>
<p><font papago-translate="translated">물론, 그 분야는 존재하지 않을 수도 있습니다.</font><font papago-translate="translated"> Lox에서는 이를 런타임 오류로 정의했습니다.</font><font papago-translate="translated"> 그래서 우리는 그것을 확인하기 위해 체크를 추가하고, 만약 그런 일이 발생하면 중단합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">          push(value);
          break;
        }
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font></div>
<pre class="insert" translate="no">
        <span class="i">runtimeError</span>(<span class="s">"Undefined property '%s'."</span>, <span class="i">name</span>-&gt;<span class="i">chars</span>);
        <span class="k">return</span> <span class="a">INTERPRET_RUNTIME_ERROR</span>;
</pre><pre class="insert-after" translate="no">      }
      case OP_EQUAL: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p><font papago-translate="translated">아마 눈치채셨을 또 다른 실패 모드가 있습니다<span name="field">.</span></font><font papago-translate="translated"> 위 코드는 점의 왼쪽에 있는 표현이 ObjInstance로 평가되었다고 가정합니다.</font><font papago-translate="translated"> 하지만 사용자가 이 글을 쓰는 것을 막을 수 있는 것은 없습니다:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">var</span> <span class="i">obj</span> = <span class="s">"not an instance"</span>;
<span class="k">print</span> <span class="i">obj</span>.<span class="i">field</span>;
</pre></div>
<p><font papago-translate="translated">사용자의 프로그램이 잘못되었지만, VM은 여전히 신중하게 처리해야 합니다.</font><font papago-translate="translated"> 지금 당장은 ObjString의 비트를 ObjInstance로 오해하고 불이 붙거나 전혀 우아하지 않은 것으로 오해할 수 있습니다.</font></p>
<p><font papago-translate="translated">Lox에서는 인스턴스에만 필드가 허용됩니다.</font><font papago-translate="translated"> 문자열이나 숫자에 필드를 채울 수 없습니다.</font><font papago-translate="translated"> 따라서 필드에 액세스하기 전에 값이 인스턴스인지 확인해야 합니다.</font></p>
<aside name="field" style="top: 12154px;">
<p><font papago-translate="translated">Lox는 다른 유형의 값에 필드를 추가하는 것을 지원<em>할 수 있습니다</em>.</font><font papago-translate="translated"> 그것은 우리의 언어이며 우리가 원하는 것을 할 수 있습니다.</font><font papago-translate="translated"> 하지만 나쁜 생각일 가능성이 높습니다.</font><font papago-translate="translated"> 성능을 저하시키는 방식으로 구현을 상당히 복잡하게 만듭니다. 예를 들어, 문자열 인터닝은 훨씬<span class="em"></span> 더 어려워집니다.</font></p>
<p><font papago-translate="splitted"><font papago-translate="translated">또한, 그것은 가치의 평등과 정체성에 관한 심오한 의미론적 질문을 제기합니다.</font><font papago-translate="translated"> 숫자에 필드를 첨부하면 </font></font><code translate="no">3</code><font papago-translate="splitted"><font papago-translate="translated">, 다음과 같은 결과를 가져옵니다 </font></font><code translate="no">1 + 2</code><font papago-translate="splitted"><font papago-translate="translated"> 그 분야도 있나요?</font><font papago-translate="translated"> 그렇다면 구현은 이를 어떻게 추적하나요?</font><font papago-translate="translated"> 그렇지 않다면, 그 결과로 나온 두 "세"는 여전히 동등한 것으로 간주됩니까?</font></font></p>
</aside>
<div class="codehilite"><pre class="insert-before" translate="no">      case OP_GET_PROPERTY: {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font></div>
<pre class="insert" translate="no">        <span class="k">if</span> (!<span class="a">IS_INSTANCE</span>(<span class="i">peek</span>(<span class="n">0</span>))) {
          <span class="i">runtimeError</span>(<span class="s">"Only instances have properties."</span>);
          <span class="k">return</span> <span class="a">INTERPRET_RUNTIME_ERROR</span>;
        }

</pre><pre class="insert-after" translate="no">        ObjInstance* instance = AS_INSTANCE(peek(0));
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p><font papago-translate="translated">스택의 값이 인스턴스가 아닌 경우 런타임 오류를 보고하고 안전하게 종료합니다.</font></p>
<p><font papago-translate="translated">물론 필드가 없는 인스턴스에서는 get 식을 사용하는 것이 그다지 유용하지 않습니다.</font><font papago-translate="translated"> 이를 위해서는 세터가 필요합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">        return INTERPRET_RUNTIME_ERROR;
      }
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font></div>
<pre class="insert" translate="no">      <span class="k">case</span> <span class="a">OP_SET_PROPERTY</span>: {
        <span class="t">ObjInstance</span>* <span class="i">instance</span> = <span class="a">AS_INSTANCE</span>(<span class="i">peek</span>(<span class="n">1</span>));
        <span class="i">tableSet</span>(&amp;<span class="i">instance</span>-&gt;<span class="i">fields</span>, <span class="a">READ_STRING</span>(), <span class="i">peek</span>(<span class="n">0</span>));
        <span class="t">Value</span> <span class="i">value</span> = <span class="i">pop</span>();
        <span class="i">pop</span>();
        <span class="i">push</span>(<span class="i">value</span>);
        <span class="k">break</span>;
      }
</pre><pre class="insert-after" translate="no">      case OP_EQUAL: {
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p><font papago-translate="splitted"><font papago-translate="translated">이것은 다음보다 조금 더 복잡합니다 </font></font><code translate="no">OP_GET_PROPERTY</code><font papago-translate="splitted"><font papago-translate="translated">. 이것이 실행될 때, 스택의 상단에는 필드가 설정되는 인스턴스와 그 위에 저장될 값이 있습니다.</font><font papago-translate="translated"> 이전과 마찬가지로, 우리는 명령어의 피연산자를 읽고 필드 이름 문자열을 찾습니다.</font><font papago-translate="translated"> 이를 사용하여 스택 상단의 값을 인스턴스의 필드 테이블에 저장합니다.</font></font></p>
<p><font papago-translate="translated">그 다음에는<span name="stack"> 작은 스택</span> 저글링이 있습니다.</font><font papago-translate="translated"> 저장된 값을 꺼내고 인스턴스를 터뜨린 다음 마지막으로 값을 다시 밀어 넣습니다.</font><font papago-translate="translated"> 즉, 상단은 그대로 두고 스택에서<em> 두 번째</em> 요소를 제거합니다.</font><font papago-translate="translated"> 세터는 그 자체로 할당된 값의 결과를 나타내는 표현이므로, 그 값을 스택에 남겨두어야 합니다.</font><font papago-translate="translated"> 제 말은 이렇습니다:</font></p>
<aside name="stack" style="top: 13178px;">
<p><font papago-translate="translated">스택 작업은 다음과 같이 진행됩니다:</font></p><img alt="Popping two values and then pushing the first value back on the stack." src="https://youhogeon-meritz.github.io/image/classes-and-instances/stack.png">
</aside>
<div class="codehilite"><pre translate="no"><span class="k">class</span> <span class="t">Toast</span> {}
<span class="k">var</span> <span class="i">toast</span> = <span class="t">Toast</span>();
<span class="k">print</span> <span class="i">toast</span>.<span class="i">jam</span> = <span class="s">"grape"</span>; <span class="c">// Prints "grape".</span>
</pre></div>
<p><font papago-translate="translated">필드를 읽을 때와 달리, 해시 테이블에 필드가 포함되지 않은 것에 대해 걱정할 필요가 없습니다.</font><font papago-translate="translated"> 필요한 경우 세터가 암묵적으로 필드를 생성합니다.</font><font papago-translate="translated"> 인스턴스가 아닌 값에 필드를 저장하려는 사용자를 잘못 처리해야 합니다.</font></p>
<div class="codehilite"><pre class="insert-before" translate="no">      case OP_SET_PROPERTY: {
</pre><div class="source-file"><font papago-translate="splitted"><em><font papago-translate="translated">vm.c</font></em></font><br><font papago-translate="splitted"><font papago-translate="translated"> <em>런</em> ()에서</font></font></div>
<pre class="insert" translate="no">        <span class="k">if</span> (!<span class="a">IS_INSTANCE</span>(<span class="i">peek</span>(<span class="n">1</span>))) {
          <span class="i">runtimeError</span>(<span class="s">"Only instances have fields."</span>);
          <span class="k">return</span> <span class="a">INTERPRET_RUNTIME_ERROR</span>;
        }

</pre><pre class="insert-after" translate="no">        ObjInstance* instance = AS_INSTANCE(peek(1));
</pre></div>
<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>
<p><font papago-translate="translated">get 식과 마찬가지로 값의 유형을 확인하고 유효하지 않은 경우 런타임 오류를 보고합니다.</font><font papago-translate="translated"> 그리고 그와 함께 객체 지향 프로그래밍에 대한 Lox의 지원은 확고한 측면을 가지고 있습니다.</font><font papago-translate="translated"> 한 번 시도해 보세요:</font></p>
<div class="codehilite"><pre translate="no"><span class="k">class</span> <span class="t">Pair</span> {}

<span class="k">var</span> <span class="i">pair</span> = <span class="t">Pair</span>();
<span class="i">pair</span>.<span class="i">first</span> = <span class="n">1</span>;
<span class="i">pair</span>.<span class="i">second</span> = <span class="n">2</span>;
<span class="k">print</span> <span class="i">pair</span>.<span class="i">first</span> + <span class="i">pair</span>.<span class="i">second</span>; <span class="c">// 3.</span>
</pre></div>
<p><font papago-translate="translated"><em>이것</em>은<em> 별로 사물</em> 지향적으로 느껴지지 않습니다.</font><font papago-translate="translated"> 그것은 물체가 느슨한 구조물 같은 데이터 묶음인 이상하고 동적으로 유형화된 C의 변형에 더 가깝습니다.</font><font papago-translate="translated"> 일종의 역동적인 절차 언어.</font><font papago-translate="translated"> 하지만 이것은 표현력의 큰 단계입니다.</font><font papago-translate="translated"> 이제 Lox 구현을 통해 사용자는 데이터를 더 큰 단위로 자유롭게 수집할 수 있습니다.</font><font papago-translate="translated"> 다음 장에서는 그 비활성 덩어리들에 생명을 불어넣을 것입니다.</font></p>
<div class="challenges">
<h2><a href="https://youhogeon-meritz.github.io/classes-and-instances.html#challenges" id="challenges"><font papago-translate="translated">과제들</font></a></h2>
<ol>
<li>
<p><font papago-translate="translated">객체에 존재하지 않는 필드에 액세스하려고 하면 전체 VM이 즉시 중단됩니다.</font><font papago-translate="translated"> 사용자는 이 런타임 오류로부터 복구할 방법이 없으며, 필드에 접근하기<em> 전에</em> 필드가 존재하는지 확인할 방법도 없습니다.</font><font papago-translate="translated"> 유효한 필드만 읽는 것은 사용자의 몫입니다.</font></p>
<p><font papago-translate="translated">다른 동적으로 입력된 언어들은 누락된 필드를 어떻게 처리하나요?</font><font papago-translate="translated"> 록스는 어떻게 해야 한다고 생각하시나요?</font><font papago-translate="translated"> 솔루션을 구현합니다.</font></p>
</li>
<li>
<p><font papago-translate="translated">필드는 런타임에<em> 문자열</em> 이름으로 액세스됩니다.</font><font papago-translate="translated"> 하지만 그 이름은 항상 소스 코드에<em> 식별자 토큰</em>으로 직접 나타나야 합니다.</font><font papago-translate="translated"> 사용자 프로그램은 문자열 값을 필수적으로 생성한 다음 이를 필드 이름으로 사용할 수 없습니다.</font><font papago-translate="translated"> 그들이 할 수 있어야 한다고 생각하시나요?</font><font papago-translate="translated"> 이를 가능하게 하는 언어 기능을 고안하고 구현합니다.</font></p>
</li>
<li>
<p><font papago-translate="splitted"><font papago-translate="translated">반대로, Lox는 인스턴스에서 필드<em>를 제거</em>할 방법을 제공하지 않습니다.</font><font papago-translate="translated"> 필드의 값을 다음과 같이 설정할 수 있습니다 </font></font><code translate="no">nil</code><font papago-translate="splitted"><font papago-translate="translated">, 하지만 해시 테이블의 항목은 여전히 존재합니다.</font><font papago-translate="translated"> 다른 언어들은 이 문제를 어떻게 처리하나요?</font><font papago-translate="translated"> Lox를 위한 전략을 선택하고 실행하세요.</font></font></p>
</li>
<li>
<p><font papago-translate="translated">필드는 런타임에 이름으로 접근하기 때문에 인스턴스 상태로 작업하는 것이 느립니다.</font><font papago-translate="translated"> 기술적으로는 해시 테이블 덕분에 상수 시간 연산이지만 상수 계수가 상대<span class="em"></span><span class="em"></span>적으로 큽니다.</font><font papago-translate="translated"> 이것이 동적 언어가 정적으로 입력된 언어보다 느린 이유의 주요 구성 요소입니다.</font></p>
<p><font papago-translate="translated">동적으로 유형화된 언어의 정교한 구현은 이를 어떻게 처리하고 최적화할 수 있습니까?</font></p>
</li>
</ol>
</div>
<footer>
<a class="next" href="https://youhogeon-meritz.github.io/methods-and-initializers.html"><font papago-translate="translated"> 다음 장: "방법과 초기화" → </font></a><font papago-translate="splitted"><font papago-translate="translated"> 로버트 니스트롬이 수작업으로 제작한 -<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE"> © 2015 ~ 2021</a></font></font>
</footer>
</article>
</div>


<div id="papagoTooltip" margin="5" style="display: none; z-index: 2147483647; left: 403.75px; top: 527px !important;">
        <h1 id="tooltipTitle">원문</h1>
        <p id="tooltipText"> Using relatively high-level Java, we packed all that into two chapters.</p>
      </div>
      </body></html>